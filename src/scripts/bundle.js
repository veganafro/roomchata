(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var firebaseApp_1 = require("./src/firebaseApp");
exports.firebase = firebaseApp_1.createFirebaseNamespace();
exports.default = exports.firebase;




}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/app/dist/cjs/index.js","/node_modules/@firebase/app/dist/cjs")

},{"./src/firebaseApp":2,"_process":162,"buffer":160}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
var contains = function (obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
};
var DEFAULT_ENTRY_NAME = '[DEFAULT]';
// An array to capture listeners before the true auth functions
// exist
var tokenListeners = [];
/**
 * Global context object for a collection of services using
 * a shared authentication state.
 */
var FirebaseAppImpl = /** @class */ (function () {
    function FirebaseAppImpl(options, name, firebase_) {
        this.firebase_ = firebase_;
        this.isDeleted_ = false;
        this.services_ = {};
        this.name_ = name;
        this.options_ = util_2.deepCopy(options);
        this.INTERNAL = {
            getUid: function () { return null; },
            getToken: function () { return Promise.resolve(null); },
            addAuthTokenListener: function (callback) {
                tokenListeners.push(callback);
                // Make sure callback is called, asynchronously, in the absence of the auth module
                setTimeout(function () { return callback(null); }, 0);
            },
            removeAuthTokenListener: function (callback) {
                tokenListeners = tokenListeners.filter(function (listener) { return listener !== callback; });
            }
        };
    }
    Object.defineProperty(FirebaseAppImpl.prototype, "name", {
        get: function () {
            this.checkDestroyed_();
            return this.name_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseAppImpl.prototype, "options", {
        get: function () {
            this.checkDestroyed_();
            return this.options_;
        },
        enumerable: true,
        configurable: true
    });
    FirebaseAppImpl.prototype.delete = function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this.checkDestroyed_();
            resolve();
        })
            .then(function () {
            _this.firebase_.INTERNAL.removeApp(_this.name_);
            var services = [];
            Object.keys(_this.services_).forEach(function (serviceKey) {
                Object.keys(_this.services_[serviceKey]).forEach(function (instanceKey) {
                    services.push(_this.services_[serviceKey][instanceKey]);
                });
            });
            return Promise.all(services.map(function (service) {
                return service.INTERNAL.delete();
            }));
        })
            .then(function () {
            _this.isDeleted_ = true;
            _this.services_ = {};
        });
    };
    /**
     * Return a service instance associated with this app (creating it
     * on demand), identified by the passed instanceIdentifier.
     *
     * NOTE: Currently storage is the only one that is leveraging this
     * functionality. They invoke it by calling:
     *
     * ```javascript
     * firebase.app().storage('STORAGE BUCKET ID')
     * ```
     *
     * The service name is passed to this already
     * @internal
     */
    FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {
        if (instanceIdentifier === void 0) { instanceIdentifier = DEFAULT_ENTRY_NAME; }
        this.checkDestroyed_();
        if (!this.services_[name]) {
            this.services_[name] = {};
        }
        if (!this.services_[name][instanceIdentifier]) {
            /**
             * If a custom instance has been defined (i.e. not '[DEFAULT]')
             * then we will pass that instance on, otherwise we pass `null`
             */
            var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME
                ? instanceIdentifier
                : undefined;
            var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);
            this.services_[name][instanceIdentifier] = service;
        }
        return this.services_[name][instanceIdentifier];
    };
    /**
     * Callback function used to extend an App instance at the time
     * of service instance creation.
     */
    FirebaseAppImpl.prototype.extendApp = function (props) {
        var _this = this;
        // Copy the object onto the FirebaseAppImpl prototype
        util_2.deepExtend(this, props);
        /**
         * If the app has overwritten the addAuthTokenListener stub, forward
         * the active token listeners on to the true fxn.
         *
         * TODO: This function is required due to our current module
         * structure. Once we are able to rely strictly upon a single module
         * implementation, this code should be refactored and Auth should
         * provide these stubs and the upgrade logic
         */
        if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {
            tokenListeners.forEach(function (listener) {
                _this.INTERNAL.addAuthTokenListener(listener);
            });
            tokenListeners = [];
        }
    };
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    FirebaseAppImpl.prototype.checkDestroyed_ = function () {
        if (this.isDeleted_) {
            error('app-deleted', { name: this.name_ });
        }
    };
    return FirebaseAppImpl;
}());
// Prevent dead-code elimination of these methods w/o invalid property
// copying.
(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||
    FirebaseAppImpl.prototype.delete ||
    console.log('dc');
/**
 * Return a firebase namespace object.
 *
 * In production, this will be called exactly once and the result
 * assigned to the 'firebase' global.  It may be called multiple times
 * in unit tests.
 */
function createFirebaseNamespace() {
    var apps_ = {};
    var factories = {};
    var appHooks = {};
    // A namespace is a plain JavaScript Object.
    var namespace = {
        // Hack to prevent Babel from modifying the object returned
        // as the firebase namespace.
        __esModule: true,
        initializeApp: initializeApp,
        app: app,
        apps: null,
        Promise: Promise,
        SDK_VERSION: '4.6.1',
        INTERNAL: {
            registerService: registerService,
            createFirebaseNamespace: createFirebaseNamespace,
            extendNamespace: extendNamespace,
            createSubscribe: util_1.createSubscribe,
            ErrorFactory: util_2.ErrorFactory,
            removeApp: removeApp,
            factories: factories,
            useAsService: useAsService,
            Promise: Promise,
            deepExtend: util_2.deepExtend
        }
    };
    // Inject a circular default export to allow Babel users who were previously
    // using:
    //
    //   import firebase from 'firebase';
    //   which becomes: var firebase = require('firebase').default;
    //
    // instead of
    //
    //   import * as firebase from 'firebase';
    //   which becomes: var firebase = require('firebase');
    util_2.patchProperty(namespace, 'default', namespace);
    // firebase.apps is a read-only getter.
    Object.defineProperty(namespace, 'apps', {
        get: getApps
    });
    /**
     * Called by App.delete() - but before any services associated with the App
     * are deleted.
     */
    function removeApp(name) {
        var app = apps_[name];
        callAppHooks(app, 'delete');
        delete apps_[name];
    }
    /**
     * Get the App object for a given name (or DEFAULT).
     */
    function app(name) {
        name = name || DEFAULT_ENTRY_NAME;
        if (!contains(apps_, name)) {
            error('no-app', { name: name });
        }
        return apps_[name];
    }
    util_2.patchProperty(app, 'App', FirebaseAppImpl);
    /**
     * Create a new App instance (name must be unique).
     */
    function initializeApp(options, name) {
        if (name === undefined) {
            name = DEFAULT_ENTRY_NAME;
        }
        else {
            if (typeof name !== 'string' || name === '') {
                error('bad-app-name', { name: name + '' });
            }
        }
        if (contains(apps_, name)) {
            error('duplicate-app', { name: name });
        }
        var app = new FirebaseAppImpl(options, name, namespace);
        apps_[name] = app;
        callAppHooks(app, 'create');
        return app;
    }
    /*
     * Return an array of all the non-deleted FirebaseApps.
     */
    function getApps() {
        // Make a copy so caller cannot mutate the apps list.
        return Object.keys(apps_).map(function (name) { return apps_[name]; });
    }
    /*
     * Register a Firebase Service.
     *
     * firebase.INTERNAL.registerService()
     *
     * TODO: Implement serviceProperties.
     */
    function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {
        // Cannot re-register a service that already exists
        if (factories[name]) {
            error('duplicate-service', { name: name });
        }
        // Capture the service factory for later service instantiation
        factories[name] = createService;
        // Capture the appHook, if passed
        if (appHook) {
            appHooks[name] = appHook;
            // Run the **new** app hook on all existing apps
            getApps().forEach(function (app) {
                appHook('create', app);
            });
        }
        // The Service namespace is an accessor function ...
        var serviceNamespace = function (appArg) {
            if (appArg === void 0) { appArg = app(); }
            if (typeof appArg[name] !== 'function') {
                // Invalid argument.
                // This happens in the following case: firebase.storage('gs:/')
                error('invalid-app-argument', { name: name });
            }
            // Forward service instance lookup to the FirebaseApp.
            return appArg[name]();
        };
        // ... and a container for service-level properties.
        if (serviceProperties !== undefined) {
            util_2.deepExtend(serviceNamespace, serviceProperties);
        }
        // Monkey-patch the serviceNamespace onto the firebase namespace
        namespace[name] = serviceNamespace;
        // Patch the FirebaseAppImpl prototype
        FirebaseAppImpl.prototype[name] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var serviceFxn = this._getService.bind(this, name);
            return serviceFxn.apply(this, allowMultipleInstances ? args : []);
        };
        return serviceNamespace;
    }
    /**
     * Patch the top-level firebase namespace with additional properties.
     *
     * firebase.INTERNAL.extendNamespace()
     */
    function extendNamespace(props) {
        util_2.deepExtend(namespace, props);
    }
    function callAppHooks(app, eventName) {
        Object.keys(factories).forEach(function (serviceName) {
            // Ignore virtual services
            var factoryName = useAsService(app, serviceName);
            if (factoryName === null) {
                return;
            }
            if (appHooks[factoryName]) {
                appHooks[factoryName](eventName, app);
            }
        });
    }
    // Map the requested service to a registered service name
    // (used to map auth to serverAuth service when needed).
    function useAsService(app, name) {
        if (name === 'serverAuth') {
            return null;
        }
        var useService = name;
        var options = app.options;
        return useService;
    }
    return namespace;
}
exports.createFirebaseNamespace = createFirebaseNamespace;
function error(code, args) {
    throw appErrors.create(code, args);
}
// TypeScript does not support non-string indexes!
// let errors: {[code: AppError: string} = {
var errors = {
    'no-app': "No Firebase App '{$name}' has been created - " +
        'call Firebase App.initializeApp()',
    'bad-app-name': "Illegal App name: '{$name}",
    'duplicate-app': "Firebase App named '{$name}' already exists",
    'app-deleted': "Firebase App named '{$name}' already deleted",
    'duplicate-service': "Firebase service named '{$name}' already registered",
    'sa-not-supported': 'Initializing the Firebase SDK with a service ' +
        'account is only allowed in a Node.js environment. On client ' +
        'devices, you should instead initialize the SDK with an api key and ' +
        'auth domain',
    'invalid-app-argument': 'firebase.{$name}() takes either no argument or a ' +
        'Firebase App instance.'
};
var appErrors = new util_2.ErrorFactory('app', 'Firebase', errors);




}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/app/dist/cjs/src/firebaseApp.js","/node_modules/@firebase/app/dist/cjs/src")

},{"@firebase/util":134,"_process":162,"buffer":160}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
(function() {
  var firebase = require('@firebase/app').default;
  var h,aa=aa||{},k=this;function m(a){return"string"==typeof a}function ba(a){return"boolean"==typeof a}function ca(){}
function da(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function ea(a){return null===a}function fa(a){return"array"==da(a)}function ha(a){var b=da(a);return"array"==b||"object"==b&&"number"==typeof a.length}function p(a){return"function"==da(a)}function q(a){var b=typeof a;return"object"==b&&null!=a||"function"==b}var ia="closure_uid_"+(1E9*Math.random()>>>0),ja=0;function ka(a,b,c){return a.call.apply(a.bind,arguments)}
function la(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function r(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?r=ka:r=la;return r.apply(null,arguments)}
function ma(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}}var na=Date.now||function(){return+new Date};function t(a,b){function c(){}c.prototype=b.prototype;a.ib=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Nc=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};function u(a){if(Error.captureStackTrace)Error.captureStackTrace(this,u);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))}t(u,Error);u.prototype.name="CustomError";function oa(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")}var pa=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")};
function qa(a){if(!ra.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(sa,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(ta,"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(ua,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(va,"&quot;"));-1!=a.indexOf("'")&&(a=a.replace(wa,"&#39;"));-1!=a.indexOf("\x00")&&(a=a.replace(xa,"&#0;"));return a}var sa=/&/g,ta=/</g,ua=/>/g,va=/"/g,wa=/'/g,xa=/\x00/g,ra=/[\x00&<>"']/;function v(a,b){return-1!=a.indexOf(b)}function ya(a,b){return a<b?-1:a>b?1:0};function za(a,b){b.unshift(a);u.call(this,oa.apply(null,b));b.shift()}t(za,u);za.prototype.name="AssertionError";function Aa(a,b){throw new za("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1));};var Ba=Array.prototype.indexOf?function(a,b,c){return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(m(a))return m(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},w=Array.prototype.forEach?function(a,b,c){Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=m(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)};
function Ca(a,b){var c=a.length,d=m(a)?a.split(""):a;for(--c;0<=c;--c)c in d&&b.call(void 0,d[c],c,a)}var Da=Array.prototype.map?function(a,b,c){return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=m(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e},Ea=Array.prototype.some?function(a,b,c){return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=m(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return!0;return!1};
function Fa(a){a:{var b=Ga;for(var c=a.length,d=m(a)?a.split(""):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1}return 0>b?null:m(a)?a.charAt(b):a[b]}function Ha(a,b){return 0<=Ba(a,b)}function Ia(a,b){b=Ba(a,b);var c;(c=0<=b)&&Array.prototype.splice.call(a,b,1);return c}function Ja(a,b){var c=0;Ca(a,function(d,e){b.call(void 0,d,e,a)&&1==Array.prototype.splice.call(a,e,1).length&&c++})}function Ka(a){return Array.prototype.concat.apply([],arguments)}
function La(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};var Ma;a:{var Na=k.navigator;if(Na){var Oa=Na.userAgent;if(Oa){Ma=Oa;break a}}Ma=""}function x(a){return v(Ma,a)};function Pa(a,b){for(var c in a)b.call(void 0,a[c],c,a)}function Qa(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function Ra(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function Sa(a){for(var b in a)return!1;return!0}function Ta(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return!1;for(c in b)if(!(c in a))return!1;return!0}function Ua(a){var b={},c;for(c in a)b[c]=a[c];return b}var Va="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Wa(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Va.length;f++)c=Va[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Xa(a){Xa[" "](a);return a}Xa[" "]=ca;function Ya(a,b){var c=Za;return Object.prototype.hasOwnProperty.call(c,a)?c[a]:c[a]=b(a)};var $a=x("Opera"),y=x("Trident")||x("MSIE"),ab=x("Edge"),bb=ab||y,cb=x("Gecko")&&!(v(Ma.toLowerCase(),"webkit")&&!x("Edge"))&&!(x("Trident")||x("MSIE"))&&!x("Edge"),db=v(Ma.toLowerCase(),"webkit")&&!x("Edge");function eb(){var a=k.document;return a?a.documentMode:void 0}var fb;
a:{var gb="",hb=function(){var a=Ma;if(cb)return/rv\:([^\);]+)(\)|;)/.exec(a);if(ab)return/Edge\/([\d\.]+)/.exec(a);if(y)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(db)return/WebKit\/(\S+)/.exec(a);if($a)return/(?:Version)[ \/]?(\S+)/.exec(a)}();hb&&(gb=hb?hb[1]:"");if(y){var ib=eb();if(null!=ib&&ib>parseFloat(gb)){fb=String(ib);break a}}fb=gb}var Za={};
function jb(a){return Ya(a,function(){for(var b=0,c=pa(String(fb)).split("."),d=pa(String(a)).split("."),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var g=c[f]||"",l=d[f]||"";do{g=/(\d*)(\D*)(.*)/.exec(g)||["","","",""];l=/(\d*)(\D*)(.*)/.exec(l)||["","","",""];if(0==g[0].length&&0==l[0].length)break;b=ya(0==g[1].length?0:parseInt(g[1],10),0==l[1].length?0:parseInt(l[1],10))||ya(0==g[2].length,0==l[2].length)||ya(g[2],l[2]);g=g[3];l=l[3]}while(0==b)}return 0<=b})}var kb;var lb=k.document;
kb=lb&&y?eb()||("CSS1Compat"==lb.compatMode?parseInt(fb,10):5):void 0;function mb(a){a.prototype.then=a.prototype.then;a.prototype.$goog_Thenable=!0}function nb(a){if(!a)return!1;try{return!!a.$goog_Thenable}catch(b){return!1}};function ob(a,b,c){this.f=c;this.c=a;this.g=b;this.b=0;this.a=null}ob.prototype.get=function(){if(0<this.b){this.b--;var a=this.a;this.a=a.next;a.next=null}else a=this.c();return a};function pb(a,b){a.g(b);a.b<a.f&&(a.b++,b.next=a.a,a.a=b)};var rb=new ob(function(){return new qb},function(a){a.reset()},100);function sb(){var a=tb,b=null;a.a&&(b=a.a,a.a=a.a.next,a.a||(a.b=null),b.next=null);return b}function qb(){this.next=this.b=this.a=null}qb.prototype.set=function(a,b){this.a=a;this.b=b;this.next=null};qb.prototype.reset=function(){this.next=this.b=this.a=null};function ub(a){k.setTimeout(function(){throw a;},0)}var wb;
function xb(){var a=k.MessageChannel;"undefined"===typeof a&&"undefined"!==typeof window&&window.postMessage&&window.addEventListener&&!x("Presto")&&(a=function(){var a=document.createElement("IFRAME");a.style.display="none";a.src="";document.documentElement.appendChild(a);var b=a.contentWindow;a=b.document;a.open();a.write("");a.close();var c="callImmediate"+Math.random(),d="file:"==b.location.protocol?"*":b.location.protocol+"//"+b.location.host;a=r(function(a){if(("*"==d||a.origin==d)&&a.data==
c)this.port1.onmessage()},this);b.addEventListener("message",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if("undefined"!==typeof a&&!x("Trident")&&!x("MSIE")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(void 0!==c.next){c=c.next;var a=c.pb;c.pb=null;a()}};return function(a){d.next={pb:a};d=d.next;b.port2.postMessage(0)}}return"undefined"!==typeof document&&"onreadystatechange"in document.createElement("SCRIPT")?function(a){var b=document.createElement("SCRIPT");
b.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){k.setTimeout(a,0)}};function yb(a,b){zb||Ab();Bb||(zb(),Bb=!0);var c=tb,d=rb.get();d.set(a,b);c.b?c.b.next=d:c.a=d;c.b=d}var zb;function Ab(){if(-1!=String(k.Promise).indexOf("[native code]")){var a=k.Promise.resolve(void 0);zb=function(){a.then(Cb)}}else zb=function(){var a=Cb;!p(k.setImmediate)||k.Window&&k.Window.prototype&&!x("Edge")&&k.Window.prototype.setImmediate==k.setImmediate?(wb||(wb=xb()),wb(a)):k.setImmediate(a)}}var Bb=!1,tb=new function(){this.b=this.a=null};
function Cb(){for(var a;a=sb();){try{a.a.call(a.b)}catch(b){ub(b)}pb(rb,a)}Bb=!1};function z(a,b){this.a=Db;this.i=void 0;this.f=this.b=this.c=null;this.g=this.h=!1;if(a!=ca)try{var c=this;a.call(b,function(a){Eb(c,Fb,a)},function(a){if(!(a instanceof Gb))try{if(a instanceof Error)throw a;throw Error("Promise rejected.");}catch(e){}Eb(c,Hb,a)})}catch(d){Eb(this,Hb,d)}}var Db=0,Fb=2,Hb=3;function Ib(){this.next=this.f=this.b=this.g=this.a=null;this.c=!1}Ib.prototype.reset=function(){this.f=this.b=this.g=this.a=null;this.c=!1};
var Jb=new ob(function(){return new Ib},function(a){a.reset()},100);function Kb(a,b,c){var d=Jb.get();d.g=a;d.b=b;d.f=c;return d}function A(a){if(a instanceof z)return a;var b=new z(ca);Eb(b,Fb,a);return b}function B(a){return new z(function(b,c){c(a)})}function Lb(a,b,c){Mb(a,b,c,null)||yb(ma(b,a))}function Nb(a){return new z(function(b,c){var d=a.length,e=[];if(d)for(var f=function(a,c){d--;e[a]=c;0==d&&b(e)},g=function(a){c(a)},l=0,n;l<a.length;l++)n=a[l],Lb(n,ma(f,l),g);else b(e)})}
function Ob(a){return new z(function(b){var c=a.length,d=[];if(c)for(var e=function(a,e,f){c--;d[a]=e?{Qb:!0,value:f}:{Qb:!1,reason:f};0==c&&b(d)},f=0,g;f<a.length;f++)g=a[f],Lb(g,ma(e,f,!0),ma(e,f,!1));else b(d)})}z.prototype.then=function(a,b,c){return Pb(this,p(a)?a:null,p(b)?b:null,c)};mb(z);function Qb(a,b){b=Kb(b,b,void 0);b.c=!0;Rb(a,b);return a}h=z.prototype;h.s=function(a,b){return Pb(this,null,a,b)};h.cancel=function(a){this.a==Db&&yb(function(){var b=new Gb(a);Sb(this,b)},this)};
function Sb(a,b){if(a.a==Db)if(a.c){var c=a.c;if(c.b){for(var d=0,e=null,f=null,g=c.b;g&&(g.c||(d++,g.a==a&&(e=g),!(e&&1<d)));g=g.next)e||(f=g);e&&(c.a==Db&&1==d?Sb(c,b):(f?(d=f,d.next==c.f&&(c.f=d),d.next=d.next.next):Tb(c),Ub(c,e,Hb,b)))}a.c=null}else Eb(a,Hb,b)}function Rb(a,b){a.b||a.a!=Fb&&a.a!=Hb||Vb(a);a.f?a.f.next=b:a.b=b;a.f=b}
function Pb(a,b,c,d){var e=Kb(null,null,null);e.a=new z(function(a,g){e.g=b?function(c){try{var e=b.call(d,c);a(e)}catch(D){g(D)}}:a;e.b=c?function(b){try{var e=c.call(d,b);void 0===e&&b instanceof Gb?g(b):a(e)}catch(D){g(D)}}:g});e.a.c=a;Rb(a,e);return e.a}h.wc=function(a){this.a=Db;Eb(this,Fb,a)};h.xc=function(a){this.a=Db;Eb(this,Hb,a)};
function Eb(a,b,c){a.a==Db&&(a===c&&(b=Hb,c=new TypeError("Promise cannot resolve to itself")),a.a=1,Mb(c,a.wc,a.xc,a)||(a.i=c,a.a=b,a.c=null,Vb(a),b!=Hb||c instanceof Gb||Wb(a,c)))}function Mb(a,b,c,d){if(a instanceof z)return Rb(a,Kb(b||ca,c||null,d)),!0;if(nb(a))return a.then(b,c,d),!0;if(q(a))try{var e=a.then;if(p(e))return Xb(a,e,b,c,d),!0}catch(f){return c.call(d,f),!0}return!1}
function Xb(a,b,c,d,e){function f(a){l||(l=!0,d.call(e,a))}function g(a){l||(l=!0,c.call(e,a))}var l=!1;try{b.call(a,g,f)}catch(n){f(n)}}function Vb(a){a.h||(a.h=!0,yb(a.Mb,a))}function Tb(a){var b=null;a.b&&(b=a.b,a.b=b.next,b.next=null);a.b||(a.f=null);return b}h.Mb=function(){for(var a;a=Tb(this);)Ub(this,a,this.a,this.i);this.h=!1};
function Ub(a,b,c,d){if(c==Hb&&b.b&&!b.c)for(;a&&a.g;a=a.c)a.g=!1;if(b.a)b.a.c=null,Yb(b,c,d);else try{b.c?b.g.call(b.f):Yb(b,c,d)}catch(e){Zb.call(null,e)}pb(Jb,b)}function Yb(a,b,c){b==Fb?a.g.call(a.f,c):a.b&&a.b.call(a.f,c)}function Wb(a,b){a.g=!0;yb(function(){a.g&&Zb.call(null,b)})}var Zb=ub;function Gb(a){u.call(this,a)}t(Gb,u);Gb.prototype.name="cancel";var $b=!y||9<=Number(kb);function ac(){this.a="";this.b=bc}ac.prototype.la=!0;ac.prototype.ja=function(){return this.a};ac.prototype.toString=function(){return"Const{"+this.a+"}"};function cc(a){if(a instanceof ac&&a.constructor===ac&&a.b===bc)return a.a;Aa("expected object of type Const, got '"+a+"'");return"type_error:Const"}var bc={};function dc(a){var b=new ac;b.a=a;return b}dc("");function ec(){this.a="";this.b=fc}ec.prototype.la=!0;ec.prototype.ja=function(){return this.a};ec.prototype.toString=function(){return"TrustedResourceUrl{"+this.a+"}"};function gc(a){if(a instanceof ec&&a.constructor===ec&&a.b===fc)return a.a;Aa("expected object of type TrustedResourceUrl, got '"+a+"' of type "+da(a));return"type_error:TrustedResourceUrl"}function hc(a,b){a=ic(a,b);b=new ec;b.a=a;return b}
function ic(a,b){var c=cc(a);if(!jc.test(c))throw Error("Invalid TrustedResourceUrl format: "+c);return c.replace(kc,function(a,e){if(!Object.prototype.hasOwnProperty.call(b,e))throw Error('Found marker, "'+e+'", in format string, "'+c+'", but no valid label mapping found in args: '+JSON.stringify(b));a=b[e];return a instanceof ac?cc(a):encodeURIComponent(String(a))})}var kc=/%{(\w+)}/g,jc=/^(?:https:)?\/\/[0-9a-z.:[\]-]+\/|^\/[^\/\\]|^about:blank(#|$)/i,fc={};function lc(){this.a="";this.b=mc}lc.prototype.la=!0;lc.prototype.ja=function(){return this.a};lc.prototype.toString=function(){return"SafeUrl{"+this.a+"}"};function nc(a){if(a instanceof lc&&a.constructor===lc&&a.b===mc)return a.a;Aa("expected object of type SafeUrl, got '"+a+"' of type "+da(a));return"type_error:SafeUrl"}var oc=/^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;
function pc(a){if(a instanceof lc)return a;a=a.la?a.ja():String(a);oc.test(a)||(a="about:invalid#zClosurez");return qc(a)}var mc={};function qc(a){var b=new lc;b.a=a;return b}qc("about:blank");function rc(){this.a="";this.b=sc}rc.prototype.la=!0;rc.prototype.ja=function(){return this.a};rc.prototype.toString=function(){return"SafeHtml{"+this.a+"}"};function uc(a){if(a instanceof rc&&a.constructor===rc&&a.b===sc)return a.a;Aa("expected object of type SafeHtml, got '"+a+"' of type "+da(a));return"type_error:SafeHtml"}var sc={};function vc(a){var b=new rc;b.a=a;return b}vc("<!DOCTYPE html>");vc("");vc("<br>");function wc(a){var b=document;return m(a)?b.getElementById(a):a}function xc(a,b){Pa(b,function(b,d){b&&b.la&&(b=b.ja());"style"==d?a.style.cssText=b:"class"==d?a.className=b:"for"==d?a.htmlFor=b:yc.hasOwnProperty(d)?a.setAttribute(yc[d],b):0==d.lastIndexOf("aria-",0)||0==d.lastIndexOf("data-",0)?a.setAttribute(d,b):a[d]=b})}
var yc={cellpadding:"cellPadding",cellspacing:"cellSpacing",colspan:"colSpan",frameborder:"frameBorder",height:"height",maxlength:"maxLength",nonce:"nonce",role:"role",rowspan:"rowSpan",type:"type",usemap:"useMap",valign:"vAlign",width:"width"};
function zc(a,b,c){var d=arguments,e=document,f=String(d[0]),g=d[1];if(!$b&&g&&(g.name||g.type)){f=["<",f];g.name&&f.push(' name="',qa(g.name),'"');if(g.type){f.push(' type="',qa(g.type),'"');var l={};Wa(l,g);delete l.type;g=l}f.push(">");f=f.join("")}f=e.createElement(f);g&&(m(g)?f.className=g:fa(g)?f.className=g.join(" "):xc(f,g));2<d.length&&Ac(e,f,d);return f}
function Ac(a,b,c){function d(c){c&&b.appendChild(m(c)?a.createTextNode(c):c)}for(var e=2;e<c.length;e++){var f=c[e];!ha(f)||q(f)&&0<f.nodeType?d(f):w(Bc(f)?La(f):f,d)}}function Bc(a){if(a&&"number"==typeof a.length){if(q(a))return"function"==typeof a.item||"string"==typeof a.item;if(p(a))return"function"==typeof a.item}return!1};function Cc(a){var b=[];Dc(new Ec,a,b);return b.join("")}function Ec(){}
function Dc(a,b,c){if(null==b)c.push("null");else{if("object"==typeof b){if(fa(b)){var d=b;b=d.length;c.push("[");for(var e="",f=0;f<b;f++)c.push(e),Dc(a,d[f],c),e=",";c.push("]");return}if(b instanceof String||b instanceof Number||b instanceof Boolean)b=b.valueOf();else{c.push("{");e="";for(d in b)Object.prototype.hasOwnProperty.call(b,d)&&(f=b[d],"function"!=typeof f&&(c.push(e),Fc(d,c),c.push(":"),Dc(a,f,c),e=","));c.push("}");return}}switch(typeof b){case "string":Fc(b,c);break;case "number":c.push(isFinite(b)&&
!isNaN(b)?String(b):"null");break;case "boolean":c.push(String(b));break;case "function":c.push("null");break;default:throw Error("Unknown type: "+typeof b);}}}var Gc={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},Hc=/\uffff/.test("\uffff")?/[\\\"\x00-\x1f\x7f-\uffff]/g:/[\\\"\x00-\x1f\x7f-\xff]/g;
function Fc(a,b){b.push('"',a.replace(Hc,function(a){var b=Gc[a];b||(b="\\u"+(a.charCodeAt(0)|65536).toString(16).substr(1),Gc[a]=b);return b}),'"')};function Ic(){0!=Jc&&(Kc[this[ia]||(this[ia]=++ja)]=this);this.oa=this.oa;this.Fa=this.Fa}var Jc=0,Kc={};Ic.prototype.oa=!1;function Lc(a){a.oa||(a.oa=!0,a.ta(),0!=Jc&&(a=a[ia]||(a[ia]=++ja),delete Kc[a]))}Ic.prototype.ta=function(){if(this.Fa)for(;this.Fa.length;)this.Fa.shift()()};var Mc=Object.freeze||function(a){return a};var Nc=!y||9<=Number(kb),Oc=y&&!jb("9"),Pc=function(){if(!k.addEventListener||!Object.defineProperty)return!1;var a=!1,b=Object.defineProperty({},"passive",{get:function(){a=!0}});k.addEventListener("test",ca,b);k.removeEventListener("test",ca,b);return a}();function C(a,b){this.type=a;this.b=this.target=b;this.Ab=!0}C.prototype.c=function(){this.Ab=!1};function Qc(a,b){C.call(this,a?a.type:"");this.relatedTarget=this.b=this.target=null;this.button=this.screenY=this.screenX=this.clientY=this.clientX=0;this.key="";this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.pointerId=0;this.pointerType="";this.a=null;if(a){var c=this.type=a.type,d=a.changedTouches?a.changedTouches[0]:null;this.target=a.target||a.srcElement;this.b=b;if(b=a.relatedTarget){if(cb){a:{try{Xa(b.nodeName);var e=!0;break a}catch(f){}e=!1}e||(b=null)}}else"mouseover"==c?b=
a.fromElement:"mouseout"==c&&(b=a.toElement);this.relatedTarget=b;null===d?(this.clientX=void 0!==a.clientX?a.clientX:a.pageX,this.clientY=void 0!==a.clientY?a.clientY:a.pageY,this.screenX=a.screenX||0,this.screenY=a.screenY||0):(this.clientX=void 0!==d.clientX?d.clientX:d.pageX,this.clientY=void 0!==d.clientY?d.clientY:d.pageY,this.screenX=d.screenX||0,this.screenY=d.screenY||0);this.button=a.button;this.key=a.key||"";this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;this.metaKey=
a.metaKey;this.pointerId=a.pointerId||0;this.pointerType=m(a.pointerType)?a.pointerType:Rc[a.pointerType]||"";this.a=a;a.defaultPrevented&&this.c()}}t(Qc,C);var Rc=Mc({2:"touch",3:"pen",4:"mouse"});Qc.prototype.c=function(){Qc.ib.c.call(this);var a=this.a;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,Oc)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};Qc.prototype.g=function(){return this.a};var Sc="closure_listenable_"+(1E6*Math.random()|0),Tc=0;function Uc(a,b,c,d,e){this.listener=a;this.a=null;this.src=b;this.type=c;this.capture=!!d;this.La=e;this.key=++Tc;this.ma=this.Ha=!1}function Vc(a){a.ma=!0;a.listener=null;a.a=null;a.src=null;a.La=null};function Wc(a){this.src=a;this.a={};this.b=0}function Xc(a,b,c,d,e,f){var g=b.toString();b=a.a[g];b||(b=a.a[g]=[],a.b++);var l=Yc(b,c,e,f);-1<l?(a=b[l],d||(a.Ha=!1)):(a=new Uc(c,a.src,g,!!e,f),a.Ha=d,b.push(a));return a}function Zc(a,b){var c=b.type;c in a.a&&Ia(a.a[c],b)&&(Vc(b),0==a.a[c].length&&(delete a.a[c],a.b--))}function Yc(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.ma&&f.listener==b&&f.capture==!!c&&f.La==d)return e}return-1};var $c="closure_lm_"+(1E6*Math.random()|0),ad={},bd=0;function cd(a,b,c,d,e){if(d&&d.once)dd(a,b,c,d,e);else if(fa(b))for(var f=0;f<b.length;f++)cd(a,b[f],c,d,e);else c=ed(c),a&&a[Sc]?fd(a,b,c,q(d)?!!d.capture:!!d,e):gd(a,b,c,!1,d,e)}
function gd(a,b,c,d,e,f){if(!b)throw Error("Invalid event type");var g=q(e)?!!e.capture:!!e,l=hd(a);l||(a[$c]=l=new Wc(a));c=Xc(l,b,c,d,g,f);if(!c.a){d=id();c.a=d;d.src=a;d.listener=c;if(a.addEventListener)Pc||(e=g),void 0===e&&(e=!1),a.addEventListener(b.toString(),d,e);else if(a.attachEvent)a.attachEvent(jd(b.toString()),d);else throw Error("addEventListener and attachEvent are unavailable.");bd++}}
function id(){var a=kd,b=Nc?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b}function dd(a,b,c,d,e){if(fa(b))for(var f=0;f<b.length;f++)dd(a,b[f],c,d,e);else c=ed(c),a&&a[Sc]?ld(a,b,c,q(d)?!!d.capture:!!d,e):gd(a,b,c,!0,d,e)}
function E(a,b,c,d,e){if(fa(b))for(var f=0;f<b.length;f++)E(a,b[f],c,d,e);else(d=q(d)?!!d.capture:!!d,c=ed(c),a&&a[Sc])?(a=a.u,b=String(b).toString(),b in a.a&&(f=a.a[b],c=Yc(f,c,d,e),-1<c&&(Vc(f[c]),Array.prototype.splice.call(f,c,1),0==f.length&&(delete a.a[b],a.b--)))):a&&(a=hd(a))&&(b=a.a[b.toString()],a=-1,b&&(a=Yc(b,c,d,e)),(c=-1<a?b[a]:null)&&md(c))}
function md(a){if("number"!=typeof a&&a&&!a.ma){var b=a.src;if(b&&b[Sc])Zc(b.u,a);else{var c=a.type,d=a.a;b.removeEventListener?b.removeEventListener(c,d,a.capture):b.detachEvent&&b.detachEvent(jd(c),d);bd--;(c=hd(b))?(Zc(c,a),0==c.b&&(c.src=null,b[$c]=null)):Vc(a)}}}function jd(a){return a in ad?ad[a]:ad[a]="on"+a}function nd(a,b,c,d){var e=!0;if(a=hd(a))if(b=a.a[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.capture==c&&!f.ma&&(f=od(f,d),e=e&&!1!==f)}return e}
function od(a,b){var c=a.listener,d=a.La||a.src;a.Ha&&md(a);return c.call(d,b)}
function kd(a,b){if(a.ma)return!0;if(!Nc){if(!b)a:{b=["window","event"];for(var c=k,d=0;d<b.length;d++)if(c=c[b[d]],null==c){b=null;break a}b=c}d=b;b=new Qc(d,this);c=!0;if(!(0>d.keyCode||void 0!=d.returnValue)){a:{var e=!1;if(0==d.keyCode)try{d.keyCode=-1;break a}catch(g){e=!0}if(e||void 0==d.returnValue)d.returnValue=!0}d=[];for(e=b.b;e;e=e.parentNode)d.push(e);a=a.type;for(e=d.length-1;0<=e;e--){b.b=d[e];var f=nd(d[e],a,!0,b);c=c&&f}for(e=0;e<d.length;e++)b.b=d[e],f=nd(d[e],a,!1,b),c=c&&f}return c}return od(a,
new Qc(b,this))}function hd(a){a=a[$c];return a instanceof Wc?a:null}var pd="__closure_events_fn_"+(1E9*Math.random()>>>0);function ed(a){if(p(a))return a;a[pd]||(a[pd]=function(b){return a.handleEvent(b)});return a[pd]};function F(){Ic.call(this);this.u=new Wc(this);this.Eb=this;this.Ra=null}t(F,Ic);F.prototype[Sc]=!0;F.prototype.removeEventListener=function(a,b,c,d){E(this,a,b,c,d)};
function G(a,b){var c,d=a.Ra;if(d)for(c=[];d;d=d.Ra)c.push(d);a=a.Eb;d=b.type||b;if(m(b))b=new C(b,a);else if(b instanceof C)b.target=b.target||a;else{var e=b;b=new C(d,a);Wa(b,e)}e=!0;if(c)for(var f=c.length-1;0<=f;f--){var g=b.b=c[f];e=qd(g,d,!0,b)&&e}g=b.b=a;e=qd(g,d,!0,b)&&e;e=qd(g,d,!1,b)&&e;if(c)for(f=0;f<c.length;f++)g=b.b=c[f],e=qd(g,d,!1,b)&&e}
F.prototype.ta=function(){F.ib.ta.call(this);if(this.u){var a=this.u,b=0,c;for(c in a.a){for(var d=a.a[c],e=0;e<d.length;e++)++b,Vc(d[e]);delete a.a[c];a.b--}}this.Ra=null};function fd(a,b,c,d,e){Xc(a.u,String(b),c,!1,d,e)}function ld(a,b,c,d,e){Xc(a.u,String(b),c,!0,d,e)}function qd(a,b,c,d){b=a.u.a[String(b)];if(!b)return!0;b=b.concat();for(var e=!0,f=0;f<b.length;++f){var g=b[f];if(g&&!g.ma&&g.capture==c){var l=g.listener,n=g.La||g.src;g.Ha&&Zc(a.u,g);e=!1!==l.call(n,d)&&e}}return e&&0!=d.Ab};function rd(a,b,c){if(p(a))c&&(a=r(a,c));else if(a&&"function"==typeof a.handleEvent)a=r(a.handleEvent,a);else throw Error("Invalid listener argument");return 2147483647<Number(b)?-1:k.setTimeout(a,b||0)}function sd(a){var b=null;return(new z(function(c,d){b=rd(function(){c(void 0)},a);-1==b&&d(Error("Failed to schedule timer."))})).s(function(a){k.clearTimeout(b);throw a;})};function td(a,b,c,d,e){this.reset(a,b,c,d,e)}td.prototype.a=null;var ud=0;td.prototype.reset=function(a,b,c,d,e){"number"==typeof e||ud++;d||na();this.b=b;delete this.a};function vd(a){this.f=a;this.b=this.c=this.a=null}function wd(a,b){this.name=a;this.value=b}wd.prototype.toString=function(){return this.name};var xd=new wd("SEVERE",1E3),yd=new wd("CONFIG",700),zd=new wd("FINE",500);function Ad(a){if(a.c)return a.c;if(a.a)return Ad(a.a);Aa("Root logger has no level set.");return null}
vd.prototype.log=function(a,b,c){if(a.value>=Ad(this).value)for(p(b)&&(b=b()),a=new td(a,String(b),this.f),c&&(a.a=c),c="log:"+a.b,(a=k.console)&&a.timeStamp&&a.timeStamp(c),(a=k.msWriteProfilerMark)&&a(c),c=this;c;)c=c.a};var Bd={},Cd=null;function Dd(a){Cd||(Cd=new vd(""),Bd[""]=Cd,Cd.c=yd);var b;if(!(b=Bd[a])){b=new vd(a);var c=a.lastIndexOf("."),d=a.substr(c+1);c=Dd(a.substr(0,c));c.b||(c.b={});c.b[d]=b;b.a=c;Bd[a]=b}return b};function Ed(a,b){this.b={};this.a=[];this.c=0;var c=arguments.length;if(1<c){if(c%2)throw Error("Uneven number of arguments");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1])}else if(a){a instanceof Ed?(c=a.S(),d=a.P()):(c=Ra(a),d=Qa(a));for(var e=0;e<c.length;e++)this.set(c[e],d[e])}}h=Ed.prototype;h.P=function(){Fd(this);for(var a=[],b=0;b<this.a.length;b++)a.push(this.b[this.a[b]]);return a};h.S=function(){Fd(this);return this.a.concat()};
h.clear=function(){this.b={};this.c=this.a.length=0};function Fd(a){if(a.c!=a.a.length){for(var b=0,c=0;b<a.a.length;){var d=a.a[b];Gd(a.b,d)&&(a.a[c++]=d);b++}a.a.length=c}if(a.c!=a.a.length){var e={};for(c=b=0;b<a.a.length;)d=a.a[b],Gd(e,d)||(a.a[c++]=d,e[d]=1),b++;a.a.length=c}}h.get=function(a,b){return Gd(this.b,a)?this.b[a]:b};h.set=function(a,b){Gd(this.b,a)||(this.c++,this.a.push(a));this.b[a]=b};
h.forEach=function(a,b){for(var c=this.S(),d=0;d<c.length;d++){var e=c[d],f=this.get(e);a.call(b,f,e,this)}};function Gd(a,b){return Object.prototype.hasOwnProperty.call(a,b)};function H(a,b){a&&a.log(zd,b,void 0)};function Hd(a){return Da(a,function(a){a=a.toString(16);return 1<a.length?a:"0"+a}).join("")};var Id=null,Jd=null;function Kd(a){var b="";Ld(a,function(a){b+=String.fromCharCode(a)});return b}function Ld(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=Jd[c];if(null!=e)return e;if(!/^[\s\xa0]*$/.test(c))throw Error("Unknown base64 encoding at char: "+c);}return b}Md();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),l=c(64);if(64===l&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=l&&b(g<<6&192|l))}}
function Md(){if(!Id){Id={};Jd={};for(var a=0;65>a;a++)Id[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),Jd[Id[a]]=a,62<=a&&(Jd["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a)]=a)}};/*
 Portions of this code are from MochiKit, received by
 The Closure Authors under the MIT license. All other code is Copyright
 2005-2009 The Closure Authors. All Rights Reserved.
*/
function Nd(a,b){this.g=[];this.v=a;this.o=b||null;this.f=this.a=!1;this.c=void 0;this.u=this.w=this.i=!1;this.h=0;this.b=null;this.l=0}Nd.prototype.cancel=function(a){if(this.a)this.c instanceof Nd&&this.c.cancel();else{if(this.b){var b=this.b;delete this.b;a?b.cancel(a):(b.l--,0>=b.l&&b.cancel())}this.v?this.v.call(this.o,this):this.u=!0;this.a||(a=new Od,Pd(this),Qd(this,!1,a))}};Nd.prototype.m=function(a,b){this.i=!1;Qd(this,a,b)};function Qd(a,b,c){a.a=!0;a.c=c;a.f=!b;Rd(a)}
function Pd(a){if(a.a){if(!a.u)throw new Sd;a.u=!1}}Nd.prototype.A=function(a){Pd(this);Qd(this,!0,a)};function Td(a,b){Ud(a,null,b,void 0)}function Ud(a,b,c,d){a.g.push([b,c,d]);a.a&&Rd(a)}Nd.prototype.then=function(a,b,c){var d,e,f=new z(function(a,b){d=a;e=b});Ud(this,d,function(a){a instanceof Od?f.cancel():e(a)});return f.then(a,b,c)};mb(Nd);function Vd(a){return Ea(a.g,function(a){return p(a[1])})}
function Rd(a){if(a.h&&a.a&&Vd(a)){var b=a.h,c=Wd[b];c&&(k.clearTimeout(c.a),delete Wd[b]);a.h=0}a.b&&(a.b.l--,delete a.b);b=a.c;for(var d=c=!1;a.g.length&&!a.i;){var e=a.g.shift(),f=e[0],g=e[1];e=e[2];if(f=a.f?g:f)try{var l=f.call(e||a.o,b);void 0!==l&&(a.f=a.f&&(l==b||l instanceof Error),a.c=b=l);if(nb(b)||"function"===typeof k.Promise&&b instanceof k.Promise)d=!0,a.i=!0}catch(n){b=n,a.f=!0,Vd(a)||(c=!0)}}a.c=b;d&&(l=r(a.m,a,!0),d=r(a.m,a,!1),b instanceof Nd?(Ud(b,l,d),b.w=!0):b.then(l,d));c&&(b=
new Xd(b),Wd[b.a]=b,a.h=b.a)}function Sd(){u.call(this)}t(Sd,u);Sd.prototype.message="Deferred has already fired";Sd.prototype.name="AlreadyCalledError";function Od(){u.call(this)}t(Od,u);Od.prototype.message="Deferred was canceled";Od.prototype.name="CanceledError";function Xd(a){this.a=k.setTimeout(r(this.c,this),0);this.b=a}Xd.prototype.c=function(){delete Wd[this.a];throw this.b;};var Wd={};function Yd(){this.b=-1};function Zd(a,b){this.b=-1;this.b=$d;this.f=k.Uint8Array?new Uint8Array(this.b):Array(this.b);this.g=this.c=0;this.a=[];this.i=a;this.h=b;this.l=k.Int32Array?new Int32Array(64):Array(64);ae||(k.Int32Array?ae=new Int32Array(be):ae=be);this.reset()}var ae;t(Zd,Yd);for(var $d=64,ce=$d-1,de=[],ee=0;ee<ce;ee++)de[ee]=0;var fe=Ka(128,de);Zd.prototype.reset=function(){this.g=this.c=0;this.a=k.Int32Array?new Int32Array(this.h):La(this.h)};
function ge(a){for(var b=a.f,c=a.l,d=0,e=0;e<b.length;)c[d++]=b[e]<<24|b[e+1]<<16|b[e+2]<<8|b[e+3],e=4*d;for(b=16;64>b;b++){e=c[b-15]|0;d=c[b-2]|0;var f=(c[b-16]|0)+((e>>>7|e<<25)^(e>>>18|e<<14)^e>>>3)|0,g=(c[b-7]|0)+((d>>>17|d<<15)^(d>>>19|d<<13)^d>>>10)|0;c[b]=f+g|0}d=a.a[0]|0;e=a.a[1]|0;var l=a.a[2]|0,n=a.a[3]|0,D=a.a[4]|0,vb=a.a[5]|0,tc=a.a[6]|0;f=a.a[7]|0;for(b=0;64>b;b++){var Bj=((d>>>2|d<<30)^(d>>>13|d<<19)^(d>>>22|d<<10))+(d&e^d&l^e&l)|0;g=D&vb^~D&tc;f=f+((D>>>6|D<<26)^(D>>>11|D<<21)^(D>>>
25|D<<7))|0;g=g+(ae[b]|0)|0;g=f+(g+(c[b]|0)|0)|0;f=tc;tc=vb;vb=D;D=n+g|0;n=l;l=e;e=d;d=g+Bj|0}a.a[0]=a.a[0]+d|0;a.a[1]=a.a[1]+e|0;a.a[2]=a.a[2]+l|0;a.a[3]=a.a[3]+n|0;a.a[4]=a.a[4]+D|0;a.a[5]=a.a[5]+vb|0;a.a[6]=a.a[6]+tc|0;a.a[7]=a.a[7]+f|0}
function he(a,b,c){void 0===c&&(c=b.length);var d=0,e=a.c;if(m(b))for(;d<c;)a.f[e++]=b.charCodeAt(d++),e==a.b&&(ge(a),e=0);else if(ha(b))for(;d<c;){var f=b[d++];if(!("number"==typeof f&&0<=f&&255>=f&&f==(f|0)))throw Error("message must be a byte array");a.f[e++]=f;e==a.b&&(ge(a),e=0)}else throw Error("message must be string or array");a.c=e;a.g+=c}
var be=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,
4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function ie(){Zd.call(this,8,je)}t(ie,Zd);var je=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];function ke(a){if(a.P&&"function"==typeof a.P)return a.P();if(m(a))return a.split("");if(ha(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}return Qa(a)}function le(a){if(a.S&&"function"==typeof a.S)return a.S();if(!a.P||"function"!=typeof a.P){if(ha(a)||m(a)){var b=[];a=a.length;for(var c=0;c<a;c++)b.push(c);return b}return Ra(a)}}
function me(a,b){if(a.forEach&&"function"==typeof a.forEach)a.forEach(b,void 0);else if(ha(a)||m(a))w(a,b,void 0);else for(var c=le(a),d=ke(a),e=d.length,f=0;f<e;f++)b.call(void 0,d[f],c&&c[f],a)};var ne=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;function oe(a,b){if(a){a=a.split("&");for(var c=0;c<a.length;c++){var d=a[c].indexOf("="),e=null;if(0<=d){var f=a[c].substring(0,d);e=a[c].substring(d+1)}else f=a[c];b(f,e?decodeURIComponent(e.replace(/\+/g," ")):"")}}};function pe(a,b){this.b=this.l=this.c="";this.i=null;this.h=this.g="";this.f=!1;if(a instanceof pe){this.f=void 0!==b?b:a.f;qe(this,a.c);this.l=a.l;this.b=a.b;re(this,a.i);this.g=a.g;b=a.a;var c=new se;c.c=b.c;b.a&&(c.a=new Ed(b.a),c.b=b.b);te(this,c);this.h=a.h}else a&&(c=String(a).match(ne))?(this.f=!!b,qe(this,c[1]||"",!0),this.l=ue(c[2]||""),this.b=ue(c[3]||"",!0),re(this,c[4]),this.g=ue(c[5]||"",!0),te(this,c[6]||"",!0),this.h=ue(c[7]||"")):(this.f=!!b,this.a=new se(null,0,this.f))}
pe.prototype.toString=function(){var a=[],b=this.c;b&&a.push(ve(b,we,!0),":");var c=this.b;if(c||"file"==b)a.push("//"),(b=this.l)&&a.push(ve(b,we,!0),"@"),a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),c=this.i,null!=c&&a.push(":",String(c));if(c=this.g)this.b&&"/"!=c.charAt(0)&&a.push("/"),a.push(ve(c,"/"==c.charAt(0)?xe:ye,!0));(c=this.a.toString())&&a.push("?",c);(c=this.h)&&a.push("#",ve(c,ze));return a.join("")};
function qe(a,b,c){a.c=c?ue(b,!0):b;a.c&&(a.c=a.c.replace(/:$/,""))}function re(a,b){if(b){b=Number(b);if(isNaN(b)||0>b)throw Error("Bad port number "+b);a.i=b}else a.i=null}function te(a,b,c){b instanceof se?(a.a=b,Ae(a.a,a.f)):(c||(b=ve(b,Be)),a.a=new se(b,0,a.f))}function I(a,b,c){a.a.set(b,c)}function Ce(a,b){return a.a.get(b)}function De(a){return a instanceof pe?new pe(a):new pe(a,void 0)}function Ee(a,b){var c=new pe(null,void 0);qe(c,"https");a&&(c.b=a);b&&(c.g=b);return c}
function ue(a,b){return a?b?decodeURI(a.replace(/%25/g,"%2525")):decodeURIComponent(a):""}function ve(a,b,c){return m(a)?(a=encodeURI(a).replace(b,Fe),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),a):null}function Fe(a){a=a.charCodeAt(0);return"%"+(a>>4&15).toString(16)+(a&15).toString(16)}var we=/[#\/\?@]/g,ye=/[\#\?:]/g,xe=/[\#\?]/g,Be=/[\#\?@]/g,ze=/#/g;function se(a,b,c){this.b=this.a=null;this.c=a||null;this.f=!!c}
function Ge(a){a.a||(a.a=new Ed,a.b=0,a.c&&oe(a.c,function(b,c){He(a,decodeURIComponent(b.replace(/\+/g," ")),c)}))}function Ie(a){var b=le(a);if("undefined"==typeof b)throw Error("Keys are undefined");var c=new se(null,0,void 0);a=ke(a);for(var d=0;d<b.length;d++){var e=b[d],f=a[d];fa(f)?Je(c,e,f):He(c,e,f)}return c}function He(a,b,c){Ge(a);a.c=null;b=Ke(a,b);var d=a.a.get(b);d||a.a.set(b,d=[]);d.push(c);a.b+=1}
function Le(a,b){Ge(a);b=Ke(a,b);Gd(a.a.b,b)&&(a.c=null,a.b-=a.a.get(b).length,a=a.a,Gd(a.b,b)&&(delete a.b[b],a.c--,a.a.length>2*a.c&&Fd(a)))}h=se.prototype;h.clear=function(){this.a=this.c=null;this.b=0};function Me(a,b){Ge(a);b=Ke(a,b);return Gd(a.a.b,b)}h.forEach=function(a,b){Ge(this);this.a.forEach(function(c,d){w(c,function(c){a.call(b,c,d,this)},this)},this)};h.S=function(){Ge(this);for(var a=this.a.P(),b=this.a.S(),c=[],d=0;d<b.length;d++)for(var e=a[d],f=0;f<e.length;f++)c.push(b[d]);return c};
h.P=function(a){Ge(this);var b=[];if(m(a))Me(this,a)&&(b=Ka(b,this.a.get(Ke(this,a))));else{a=this.a.P();for(var c=0;c<a.length;c++)b=Ka(b,a[c])}return b};h.set=function(a,b){Ge(this);this.c=null;a=Ke(this,a);Me(this,a)&&(this.b-=this.a.get(a).length);this.a.set(a,[b]);this.b+=1;return this};h.get=function(a,b){a=a?this.P(a):[];return 0<a.length?String(a[0]):b};function Je(a,b,c){Le(a,b);0<c.length&&(a.c=null,a.a.set(Ke(a,b),La(c)),a.b+=c.length)}
h.toString=function(){if(this.c)return this.c;if(!this.a)return"";for(var a=[],b=this.a.S(),c=0;c<b.length;c++){var d=b[c],e=encodeURIComponent(String(d));d=this.P(d);for(var f=0;f<d.length;f++){var g=e;""!==d[f]&&(g+="="+encodeURIComponent(String(d[f])));a.push(g)}}return this.c=a.join("&")};function Ke(a,b){b=String(b);a.f&&(b=b.toLowerCase());return b}function Ae(a,b){b&&!a.f&&(Ge(a),a.c=null,a.a.forEach(function(a,b){var c=b.toLowerCase();b!=c&&(Le(this,b),Je(this,c,a))},a));a.f=b};function Ne(){}Ne.prototype.c=null;function Oe(a){return a.c||(a.c=a.b())};var Pe;function Qe(){}t(Qe,Ne);Qe.prototype.a=function(){var a=Re(this);return a?new ActiveXObject(a):new XMLHttpRequest};Qe.prototype.b=function(){var a={};Re(this)&&(a[0]=!0,a[1]=!0);return a};
function Re(a){if(!a.f&&"undefined"==typeof XMLHttpRequest&&"undefined"!=typeof ActiveXObject){for(var b=["MSXML2.XMLHTTP.6.0","MSXML2.XMLHTTP.3.0","MSXML2.XMLHTTP","Microsoft.XMLHTTP"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.f=d}catch(e){}}throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");}return a.f}Pe=new Qe;function Se(a){F.call(this);this.headers=new Ed;this.w=a||null;this.b=!1;this.v=this.a=null;this.g=this.I=this.i="";this.c=this.G=this.h=this.A=!1;this.f=0;this.m=null;this.l=Te;this.o=this.N=!1}t(Se,F);var Te="",Ue=Se.prototype,Ve=Dd("goog.net.XhrIo");Ue.J=Ve;var We=/^https?$/i,Xe=["POST","PUT"];
function Ye(a,b,c,d,e){if(a.a)throw Error("[goog.net.XhrIo] Object is active with another request="+a.i+"; newUri="+b);c=c?c.toUpperCase():"GET";a.i=b;a.g="";a.I=c;a.A=!1;a.b=!0;a.a=a.w?a.w.a():Pe.a();a.v=a.w?Oe(a.w):Oe(Pe);a.a.onreadystatechange=r(a.zb,a);try{H(a.J,Ze(a,"Opening Xhr")),a.G=!0,a.a.open(c,String(b),!0),a.G=!1}catch(g){H(a.J,Ze(a,"Error opening Xhr: "+g.message));$e(a,g);return}b=d||"";var f=new Ed(a.headers);e&&me(e,function(a,b){f.set(b,a)});e=Fa(f.S());d=k.FormData&&b instanceof
k.FormData;!Ha(Xe,c)||e||d||f.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");f.forEach(function(a,b){this.a.setRequestHeader(b,a)},a);a.l&&(a.a.responseType=a.l);"withCredentials"in a.a&&a.a.withCredentials!==a.N&&(a.a.withCredentials=a.N);try{af(a),0<a.f&&(a.o=bf(a.a),H(a.J,Ze(a,"Will abort after "+a.f+"ms if incomplete, xhr2 "+a.o)),a.o?(a.a.timeout=a.f,a.a.ontimeout=r(a.Ea,a)):a.m=rd(a.Ea,a.f,a)),H(a.J,Ze(a,"Sending request")),a.h=!0,a.a.send(b),a.h=!1}catch(g){H(a.J,Ze(a,
"Send error: "+g.message)),$e(a,g)}}function bf(a){return y&&jb(9)&&"number"==typeof a.timeout&&void 0!==a.ontimeout}function Ga(a){return"content-type"==a.toLowerCase()}h=Se.prototype;h.Ea=function(){"undefined"!=typeof aa&&this.a&&(this.g="Timed out after "+this.f+"ms, aborting",H(this.J,Ze(this,this.g)),G(this,"timeout"),this.abort(8))};function $e(a,b){a.b=!1;a.a&&(a.c=!0,a.a.abort(),a.c=!1);a.g=b;cf(a);df(a)}function cf(a){a.A||(a.A=!0,G(a,"complete"),G(a,"error"))}
h.abort=function(){this.a&&this.b&&(H(this.J,Ze(this,"Aborting")),this.b=!1,this.c=!0,this.a.abort(),this.c=!1,G(this,"complete"),G(this,"abort"),df(this))};h.ta=function(){this.a&&(this.b&&(this.b=!1,this.c=!0,this.a.abort(),this.c=!1),df(this,!0));Se.ib.ta.call(this)};h.zb=function(){this.oa||(this.G||this.h||this.c?ef(this):this.fc())};h.fc=function(){ef(this)};
function ef(a){if(a.b&&"undefined"!=typeof aa)if(a.v[1]&&4==ff(a)&&2==gf(a))H(a.J,Ze(a,"Local request error detected and ignored"));else if(a.h&&4==ff(a))rd(a.zb,0,a);else if(G(a,"readystatechange"),4==ff(a)){H(a.J,Ze(a,"Request complete"));a.b=!1;try{var b=gf(a);a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var c=!0;break a;default:c=!1}var d;if(!(d=c)){var e;if(e=0===b){var f=String(a.i).match(ne)[1]||null;if(!f&&k.self&&k.self.location){var g=k.self.location.protocol;
f=g.substr(0,g.length-1)}e=!We.test(f?f.toLowerCase():"")}d=e}if(d)G(a,"complete"),G(a,"success");else{try{var l=2<ff(a)?a.a.statusText:""}catch(n){H(a.J,"Can not get status: "+n.message),l=""}a.g=l+" ["+gf(a)+"]";cf(a)}}finally{df(a)}}}function df(a,b){if(a.a){af(a);var c=a.a,d=a.v[0]?ca:null;a.a=null;a.v=null;b||G(a,"ready");try{c.onreadystatechange=d}catch(e){(a=a.J)&&a.log(xd,"Problem encountered resetting onreadystatechange: "+e.message,void 0)}}}
function af(a){a.a&&a.o&&(a.a.ontimeout=null);"number"==typeof a.m&&(k.clearTimeout(a.m),a.m=null)}function ff(a){return a.a?a.a.readyState:0}function gf(a){try{return 2<ff(a)?a.a.status:-1}catch(b){return-1}}function hf(a){try{return a.a?a.a.responseText:""}catch(b){return H(a.J,"Can not get responseText: "+b.message),""}}
h.getResponse=function(){try{if(!this.a)return null;if("response"in this.a)return this.a.response;switch(this.l){case Te:case "text":return this.a.responseText;case "arraybuffer":if("mozResponseArrayBuffer"in this.a)return this.a.mozResponseArrayBuffer}var a=this.J;a&&a.log(xd,"Response type "+this.l+" is not supported on this browser",void 0);return null}catch(b){return H(this.J,"Can not get response: "+b.message),null}};function Ze(a,b){return b+" ["+a.I+" "+a.i+" "+gf(a)+"]"};var jf=/^[+a-zA-Z0-9_.!#$%&'*\/=?^`{|}~-]+@([a-zA-Z0-9-]+\.)+[a-zA-Z0-9]{2,63}$/;function kf(a){var b={},c=b.document||document,d=gc(a),e=document.createElement("SCRIPT"),f={Bb:e,Ea:void 0},g=new Nd(lf,f),l=null,n=null!=b.timeout?b.timeout:5E3;0<n&&(l=window.setTimeout(function(){mf(e,!0);var a=new nf(of,"Timeout reached for loading script "+d);Pd(g);Qd(g,!1,a)},n),f.Ea=l);e.onload=e.onreadystatechange=function(){e.readyState&&"loaded"!=e.readyState&&"complete"!=e.readyState||(mf(e,b.Oc||!1,l),g.A(null))};e.onerror=function(){mf(e,!0,l);var a=new nf(pf,"Error while loading script "+
d);Pd(g);Qd(g,!1,a)};f=b.attributes||{};Wa(f,{type:"text/javascript",charset:"UTF-8"});xc(e,f);e.src=gc(a);qf(c).appendChild(e);return g}function qf(a){var b;return(b=(a||document).getElementsByTagName("HEAD"))&&0!=b.length?b[0]:a.documentElement}function lf(){if(this&&this.Bb){var a=this.Bb;a&&"SCRIPT"==a.tagName&&mf(a,!0,this.Ea)}}
function mf(a,b,c){null!=c&&k.clearTimeout(c);a.onload=ca;a.onerror=ca;a.onreadystatechange=ca;b&&window.setTimeout(function(){a&&a.parentNode&&a.parentNode.removeChild(a)},0)}var pf=0,of=1;function nf(a,b){var c="Jsloader error (code #"+a+")";b&&(c+=": "+b);u.call(this,c);this.code=a}t(nf,u);function rf(){}t(rf,Ne);rf.prototype.a=function(){var a=new XMLHttpRequest;if("withCredentials"in a)return a;if("undefined"!=typeof XDomainRequest)return new sf;throw Error("Unsupported browser");};rf.prototype.b=function(){return{}};
function sf(){this.a=new XDomainRequest;this.readyState=0;this.onreadystatechange=null;this.responseText="";this.status=-1;this.statusText=this.responseXML=null;this.a.onload=r(this.Sb,this);this.a.onerror=r(this.wb,this);this.a.onprogress=r(this.Tb,this);this.a.ontimeout=r(this.Ub,this)}h=sf.prototype;h.open=function(a,b,c){if(null!=c&&!c)throw Error("Only async requests are supported.");this.a.open(a,b)};
h.send=function(a){if(a)if("string"==typeof a)this.a.send(a);else throw Error("Only string data is supported");else this.a.send()};h.abort=function(){this.a.abort()};h.setRequestHeader=function(){};h.getResponseHeader=function(a){return"content-type"==a.toLowerCase()?this.a.contentType:""};h.Sb=function(){this.status=200;this.responseText=this.a.responseText;tf(this,4)};h.wb=function(){this.status=500;this.responseText="";tf(this,4)};h.Ub=function(){this.wb()};
h.Tb=function(){this.status=200;tf(this,1)};function tf(a,b){a.readyState=b;if(a.onreadystatechange)a.onreadystatechange()}h.getAllResponseHeaders=function(){return"content-type: "+this.a.contentType};function uf(){var a=J();return y&&!!kb&&11==kb||/Edge\/\d+/.test(a)}function vf(){return k.window&&k.window.location.href||""}function wf(a,b){b=b||k.window;var c="about:blank";a&&(c=nc(pc(a)));b.location.href=c}function xf(a,b){var c=[],d;for(d in a)d in b?typeof a[d]!=typeof b[d]?c.push(d):fa(a[d])?Ta(a[d],b[d])||c.push(d):"object"==typeof a[d]&&null!=a[d]&&null!=b[d]?0<xf(a[d],b[d]).length&&c.push(d):a[d]!==b[d]&&c.push(d):c.push(d);for(d in b)d in a||c.push(d);return c}
function yf(){var a=J();a=zf(a)!=Af?null:(a=a.match(/\sChrome\/(\d+)/i))&&2==a.length?parseInt(a[1],10):null;return a&&30>a?!1:!y||!kb||9<kb}function Bf(a){a=(a||J()).toLowerCase();return a.match(/android/)||a.match(/webos/)||a.match(/iphone|ipad|ipod/)||a.match(/blackberry/)||a.match(/windows phone/)||a.match(/iemobile/)?!0:!1}function Cf(a){a=a||k.window;try{a.close()}catch(b){}}
function Df(a,b,c){var d=Math.floor(1E9*Math.random()).toString();b=b||500;c=c||600;var e=(window.screen.availHeight-c)/2,f=(window.screen.availWidth-b)/2;b={width:b,height:c,top:0<e?e:0,left:0<f?f:0,location:!0,resizable:!0,statusbar:!0,toolbar:!1};c=J().toLowerCase();d&&(b.target=d,v(c,"crios/")&&(b.target="_blank"));zf(J())==Ef&&(a=a||"http://localhost",b.scrollbars=!0);c=a||"";(d=b)||(d={});a=window;b=c instanceof lc?c:pc("undefined"!=typeof c.href?c.href:String(c));c=d.target||c.target;e=[];
for(g in d)switch(g){case "width":case "height":case "top":case "left":e.push(g+"="+d[g]);break;case "target":case "noreferrer":break;default:e.push(g+"="+(d[g]?1:0))}var g=e.join(",");(x("iPhone")&&!x("iPod")&&!x("iPad")||x("iPad")||x("iPod"))&&a.navigator&&a.navigator.standalone&&c&&"_self"!=c?(g=a.document.createElement("A"),b instanceof lc||b instanceof lc||(b=b.la?b.ja():String(b),oc.test(b)||(b="about:invalid#zClosurez"),b=qc(b)),g.href=nc(b),g.setAttribute("target",c),d.noreferrer&&g.setAttribute("rel",
"noreferrer"),d=document.createEvent("MouseEvent"),d.initMouseEvent("click",!0,!0,a,1),g.dispatchEvent(d),g={}):d.noreferrer?(g=a.open("",c,g),a=nc(b),g&&(bb&&v(a,";")&&(a="'"+a.replace(/'/g,"%27")+"'"),g.opener=null,dc("b/12014412, meta tag with sanitized URL"),a='<META HTTP-EQUIV="refresh" content="0; url='+qa(a)+'">',a=vc(a),g.document.write(uc(a)),g.document.close())):g=a.open(nc(b),c,g);if(g)try{g.focus()}catch(l){}return g}
function Ff(a){return new z(function(b){function c(){sd(2E3).then(function(){if(!a||a.closed)b();else return c()})}return c()})}var Gf=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;function Hf(){var a=null;return(new z(function(b){"complete"==k.document.readyState?b():(a=function(){b()},dd(window,"load",a))})).s(function(b){E(window,"load",a);throw b;})}
function If(){return Jf(void 0)?Hf().then(function(){return new z(function(a,b){var c=k.document,d=setTimeout(function(){b(Error("Cordova framework is not ready."))},1E3);c.addEventListener("deviceready",function(){clearTimeout(d);a()},!1)})}):B(Error("Cordova must run in an Android or iOS file scheme."))}function Jf(a){a=a||J();return!("file:"!==Kf()||!a.toLowerCase().match(/iphone|ipad|ipod|android/))}function Lf(){var a=k.window;try{return!(!a||a==a.top)}catch(b){return!1}}
function K(){return firebase.INTERNAL.hasOwnProperty("reactNative")?"ReactNative":firebase.INTERNAL.hasOwnProperty("node")?"Node":"Browser"}function Mf(){var a=K();return"ReactNative"===a||"Node"===a}var Ef="Firefox",Af="Chrome";
function zf(a){var b=a.toLowerCase();if(v(b,"opera/")||v(b,"opr/")||v(b,"opios/"))return"Opera";if(v(b,"iemobile"))return"IEMobile";if(v(b,"msie")||v(b,"trident/"))return"IE";if(v(b,"edge/"))return"Edge";if(v(b,"firefox/"))return Ef;if(v(b,"silk/"))return"Silk";if(v(b,"blackberry"))return"Blackberry";if(v(b,"webos"))return"Webos";if(!v(b,"safari/")||v(b,"chrome/")||v(b,"crios/")||v(b,"android"))if(!v(b,"chrome/")&&!v(b,"crios/")||v(b,"edge/")){if(v(b,"android"))return"Android";if((a=a.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/))&&
2==a.length)return a[1]}else return Af;else return"Safari";return"Other"}var Nf={Cc:"FirebaseCore-web",Ec:"FirebaseUI-web"};function Of(a,b){b=b||[];var c=[],d={},e;for(e in Nf)d[Nf[e]]=!0;for(e=0;e<b.length;e++)"undefined"!==typeof d[b[e]]&&(delete d[b[e]],c.push(b[e]));c.sort();b=c;b.length||(b=["FirebaseCore-web"]);c=K();d="";"Browser"===c?d=zf(J()):d=c;return d+"/JsCore/"+a+"/"+b.join(",")}function J(){return k.navigator&&k.navigator.userAgent||""}
function L(a,b){a=a.split(".");b=b||k;for(var c=0;c<a.length&&"object"==typeof b&&null!=b;c++)b=b[a[c]];c!=a.length&&(b=void 0);return b}function Pf(){try{var a=k.localStorage,b=Qf();if(a)return a.setItem(b,"1"),a.removeItem(b),uf()?!!k.indexedDB:!0}catch(c){}return!1}function Rf(){return(Sf()||"chrome-extension:"===Kf()||Jf())&&!Mf()&&Pf()}function Sf(){return"http:"===Kf()||"https:"===Kf()}function Kf(){return k.location&&k.location.protocol||null}
function Tf(a){a=a||J();return Bf(a)||zf(a)==Ef?!1:!0}function Uf(a){return"undefined"===typeof a?null:Cc(a)}function Vf(a){var b={},c;for(c in a)a.hasOwnProperty(c)&&null!==a[c]&&void 0!==a[c]&&(b[c]=a[c]);return b}function Wf(a){if(null!==a)return JSON.parse(a)}function Qf(a){return a?a:""+Math.floor(1E9*Math.random()).toString()}function Xf(a){a=a||J();return"Safari"==zf(a)||a.toLowerCase().match(/iphone|ipad|ipod/)?!1:!0}
function Yf(){var a=k.___jsl;if(a&&a.H)for(var b in a.H)if(a.H[b].r=a.H[b].r||[],a.H[b].L=a.H[b].L||[],a.H[b].r=a.H[b].L.concat(),a.CP)for(var c=0;c<a.CP.length;c++)a.CP[c]=null}function Zf(){var a=k.navigator;return a&&"boolean"===typeof a.onLine&&(Sf()||"chrome-extension:"===Kf()||"undefined"!==typeof a.connection)?a.onLine:!0}function $f(a,b,c,d){if(a>b)throw Error("Short delay should be less than long delay!");this.c=a;this.b=b;a=c||J();d=d||K();this.a=Bf(a)||"ReactNative"===d}
$f.prototype.get=function(){return this.a?this.b:this.c};function ag(){var a=k.document;return a&&"undefined"!==typeof a.visibilityState?"visible"==a.visibilityState:!0}function bg(){var a=k.document,b=null;return ag()||!a?A():(new z(function(c){b=function(){ag()&&(a.removeEventListener("visibilitychange",b,!1),c())};a.addEventListener("visibilitychange",b,!1)})).s(function(c){a.removeEventListener("visibilitychange",b,!1);throw c;})}
function cg(a){try{var b=new Date(parseInt(a,10));if(!isNaN(b.getTime())&&!/[^0-9]/.test(a))return b.toUTCString()}catch(c){}return null};var dg={};var eg;try{var fg={};Object.defineProperty(fg,"abcd",{configurable:!0,enumerable:!0,value:1});Object.defineProperty(fg,"abcd",{configurable:!0,enumerable:!0,value:2});eg=2==fg.abcd}catch(a){eg=!1}function M(a,b,c){eg?Object.defineProperty(a,b,{configurable:!0,enumerable:!0,value:c}):a[b]=c}function gg(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&M(a,c,b[c])}function hg(a){var b={};gg(b,a);return b}function ig(a){var b={},c;for(c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);return b}
function jg(a,b){if(!b||!b.length)return!0;if(!a)return!1;for(var c=0;c<b.length;c++){var d=a[b[c]];if(void 0===d||null===d||""===d)return!1}return!0}function kg(a){var b=a;if("object"==typeof a&&null!=a){b="length"in a?[]:{};for(var c in a)M(b,c,kg(a[c]))}return b};function lg(a){var b={},c=a[mg],d=a[ng];a=a[og];if(!c||!a)throw Error("Invalid provider user info!");b[pg]=d||null;b[qg]=c;M(this,rg,a);M(this,sg,kg(b))}var mg="email",ng="newEmail",og="requestType",qg="email",pg="fromEmail",sg="data",rg="operation";function N(a,b){this.code=tg+a;this.message=b||ug[a]||""}t(N,Error);N.prototype.B=function(){return{code:this.code,message:this.message}};N.prototype.toJSON=function(){return this.B()};function vg(a){var b=a&&a.code;return b?new N(b.substring(tg.length),a.message):null}
var tg="auth/",ug={"argument-error":"","app-not-authorized":"This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.","app-not-installed":"The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.","captcha-check-failed":"The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",
"code-expired":"The SMS code has expired. Please re-send the verification code to try again.","cordova-not-ready":"Cordova framework is not ready.","cors-unsupported":"This browser is not supported.","credential-already-in-use":"This credential is already associated with a different user account.","custom-token-mismatch":"The custom token corresponds to a different audience.","requires-recent-login":"This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
"dynamic-link-not-activated":"Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.","email-already-in-use":"The email address is already in use by another account.","expired-action-code":"The action code has expired. ","cancelled-popup-request":"This operation has been cancelled due to another conflicting popup being opened.","internal-error":"An internal error has occurred.","invalid-app-credential":"The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
"invalid-app-id":"The mobile app identifier is not registed for the current project.","invalid-user-token":"The user's credential is no longer valid. The user must sign in again.","invalid-auth-event":"An internal error has occurred.","invalid-verification-code":"The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure use the verification code provided by the user.","invalid-continue-uri":"The continue URL provided in the request is invalid.",
"invalid-cordova-configuration":"The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.","invalid-custom-token":"The custom token format is incorrect. Please check the documentation.","invalid-email":"The email address is badly formatted.","invalid-api-key":"Your API key is invalid, please check you have copied it correctly.","invalid-cert-hash":"The SHA-1 certificate hash provided is invalid.",
"invalid-credential":"The supplied auth credential is malformed or has expired.","invalid-persistence-type":"The specified persistence type is invalid. It can only be local, session or none.","invalid-message-payload":"The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.","invalid-oauth-provider":"EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.",
"invalid-oauth-client-id":"The OAuth client ID provided is either invalid or does not match the specified API key.","unauthorized-domain":"This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.","invalid-action-code":"The action code is invalid. This can happen if the code is malformed, expired, or has already been used.","wrong-password":"The password is invalid or the user does not have a password.","invalid-phone-number":"The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
"invalid-recipient-email":"The email corresponding to this action failed to send as the provided recipient email address is invalid.","invalid-sender":"The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.","invalid-verification-id":"The verification ID used to create the phone auth credential is invalid.","missing-android-pkg-name":"An Android Package Name must be provided if the Android App is required to be installed.",
"auth-domain-config-required":"Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.","missing-app-credential":"The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.","missing-verification-code":"The phone auth credential was created with an empty SMS verification code.","missing-continue-uri":"A continue URL must be provided in the request.","missing-iframe-start":"An internal error has occurred.",
"missing-ios-bundle-id":"An iOS Bundle ID must be provided if an App Store ID is provided.","missing-phone-number":"To send verification codes, provide a phone number for the recipient.","missing-verification-id":"The phone auth credential was created with an empty verification ID.","app-deleted":"This instance of FirebaseApp has been deleted.","account-exists-with-different-credential":"An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
"network-request-failed":"A network error (such as timeout, interrupted connection or unreachable host) has occurred.","no-auth-event":"An internal error has occurred.","no-such-provider":"User was not linked to an account with the given provider.","operation-not-allowed":"The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.","operation-not-supported-in-this-environment":'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
"popup-blocked":"Unable to establish a connection with the popup. It may have been blocked by the browser.","popup-closed-by-user":"The popup has been closed by the user before finalizing the operation.","provider-already-linked":"User can only be linked to one identity for the given provider.","quota-exceeded":"The project's quota for this operation has been exceeded.","redirect-cancelled-by-user":"The redirect operation has been cancelled by the user before finalizing.","redirect-operation-pending":"A redirect sign-in operation is already pending.",
timeout:"The operation has timed out.","user-token-expired":"The user's credential is no longer valid. The user must sign in again.","too-many-requests":"We have blocked all requests from this device due to unusual activity. Try again later.","unauthorized-continue-uri":"The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.","unsupported-persistence-type":"The current environment does not support the specified persistence type.","user-cancelled":"User did not grant your application the permissions it requested.",
"user-not-found":"There is no user record corresponding to this identifier. The user may have been deleted.","user-disabled":"The user account has been disabled by an administrator.","user-mismatch":"The supplied credentials do not correspond to the previously signed in user.","user-signed-out":"","weak-password":"The password must be 6 characters long or more.","web-storage-unsupported":"This browser is not supported or 3rd party cookies and data may be disabled."};function wg(a){var b=a[xg];if("undefined"===typeof b)throw new N("missing-continue-uri");if("string"!==typeof b||"string"===typeof b&&!b.length)throw new N("invalid-continue-uri");this.h=b;this.c=this.a=null;this.g=!1;var c=a[yg];if(c&&"object"===typeof c){b=c[zg];var d=c[Ag];c=c[Bg];if("string"===typeof b&&b.length){this.a=b;if("undefined"!==typeof d&&"boolean"!==typeof d)throw new N("argument-error",Ag+" property must be a boolean when specified.");this.g=!!d;if("undefined"!==typeof c&&("string"!==
typeof c||"string"===typeof c&&!c.length))throw new N("argument-error",Bg+" property must be a non empty string when specified.");this.c=c||null}else{if("undefined"!==typeof b)throw new N("argument-error",zg+" property must be a non empty string when specified.");if("undefined"!==typeof d||"undefined"!==typeof c)throw new N("missing-android-pkg-name");}}else if("undefined"!==typeof c)throw new N("argument-error",yg+" property must be a non null object when specified.");this.b=null;if((b=a[Cg])&&"object"===
typeof b)if(b=b[Dg],"string"===typeof b&&b.length)this.b=b;else{if("undefined"!==typeof b)throw new N("argument-error",Dg+" property must be a non empty string when specified.");}else if("undefined"!==typeof b)throw new N("argument-error",Cg+" property must be a non null object when specified.");a=a[Eg];if("undefined"!==typeof a&&"boolean"!==typeof a)throw new N("argument-error",Eg+" property must be a boolean when specified.");if((this.f=!!a)&&!this.b&&!this.a)throw new N("argument-error",Eg+" property can't be true when no mobile application is provided.");
}var yg="android",Eg="handleCodeInApp",Cg="iOS",xg="url",Ag="installApp",Bg="minimumVersion",zg="packageName",Dg="bundleId";function Fg(a){var b={};b.continueUrl=a.h;b.canHandleCodeInApp=a.f;if(b.androidPackageName=a.a)b.androidMinimumVersion=a.c,b.androidInstallApp=a.g;b.iOSBundleId=a.b;for(var c in b)null===b[c]&&delete b[c];return b};function Gg(a){this.b=a.sub;na();this.a=a.provider_id||a.firebase&&a.firebase.sign_in_provider||null}function Hg(a){a=a.split(".");if(3!=a.length)return null;a=a[1];for(var b=(4-a.length%4)%4,c=0;c<b;c++)a+=".";try{var d=JSON.parse(Kd(a));if(d.sub&&d.iss&&d.aud&&d.exp)return new Gg(d)}catch(e){}return null};var Ig="oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version".split(" "),Jg=["client_id","response_type","scope","redirect_uri","state"],Kg={Dc:{Ma:"locale",za:500,ya:600,Na:"facebook.com",$a:Jg},Fc:{Ma:null,za:500,ya:620,Na:"github.com",$a:Jg},Gc:{Ma:"hl",za:515,ya:680,Na:"google.com",$a:Jg},Mc:{Ma:"lang",za:485,ya:705,Na:"twitter.com",$a:Ig}};function Lg(a){for(var b in Kg)if(Kg[b].Na==a)return Kg[b];return null};function Mg(a){var b={};b["facebook.com"]=Ng;b["google.com"]=Og;b["github.com"]=Pg;b["twitter.com"]=Qg;var c=a&&a[Rg];try{if(c)return b[c]?new b[c](a):new Sg(a);if("undefined"!==typeof a[Tg])return new Ug(a)}catch(d){}return null}var Tg="idToken",Rg="providerId";function Ug(a){var b=a[Rg];if(!b&&a[Tg]){var c=Hg(a[Tg]);c&&c.a&&(b=c.a)}if(!b)throw Error("Invalid additional user info!");a=!!a.isNewUser;M(this,"providerId",b);M(this,"isNewUser",a)}
function Sg(a){Ug.call(this,a);a=Wf(a.rawUserInfo||"{}");M(this,"profile",kg(a||{}))}t(Sg,Ug);function Ng(a){Sg.call(this,a);if("facebook.com"!=this.providerId)throw Error("Invalid provider ID!");}t(Ng,Sg);function Pg(a){Sg.call(this,a);if("github.com"!=this.providerId)throw Error("Invalid provider ID!");M(this,"username",this.profile&&this.profile.login||null)}t(Pg,Sg);function Og(a){Sg.call(this,a);if("google.com"!=this.providerId)throw Error("Invalid provider ID!");}t(Og,Sg);
function Qg(a){Sg.call(this,a);if("twitter.com"!=this.providerId)throw Error("Invalid provider ID!");M(this,"username",a.screenName||null)}t(Qg,Sg);function Vg(a,b){return a.then(function(a){if(a[O]){var c=Hg(a[O]);if(!c||b!=c.b)throw new N("user-mismatch");return a}throw new N("user-mismatch");}).s(function(a){throw a&&a.code&&a.code==tg+"user-not-found"?new N("user-mismatch"):a;})}
function Wg(a,b){if(b.idToken||b.accessToken)b.idToken&&M(this,"idToken",b.idToken),b.accessToken&&M(this,"accessToken",b.accessToken);else if(b.oauthToken&&b.oauthTokenSecret)M(this,"accessToken",b.oauthToken),M(this,"secret",b.oauthTokenSecret);else throw new N("internal-error","failed to construct a credential");M(this,"providerId",a)}Wg.prototype.wa=function(a){return Xg(a,Yg(this))};Wg.prototype.b=function(a,b){var c=Yg(this);c.idToken=b;return Zg(a,c)};
Wg.prototype.c=function(a,b){var c=Yg(this);return Vg($g(a,c),b)};function Yg(a){var b={};a.idToken&&(b.id_token=a.idToken);a.accessToken&&(b.access_token=a.accessToken);a.secret&&(b.oauth_token_secret=a.secret);b.providerId=a.providerId;return{postBody:Ie(b).toString(),requestUri:"http://localhost"}}
Wg.prototype.B=function(){var a={providerId:this.providerId};this.idToken&&(a.oauthIdToken=this.idToken);this.accessToken&&(a.oauthAccessToken=this.accessToken);this.secret&&(a.oauthTokenSecret=this.secret);return a};function ah(a,b){this.nc=b||[];gg(this,{providerId:a,isOAuthProvider:!0});this.qb={};this.Wa=(Lg(a)||{}).Ma||null;this.Ua=null}ah.prototype.Ba=function(a){this.qb=Ua(a);return this};function P(a){ah.call(this,a,Jg);this.a=[]}t(P,ah);
P.prototype.sa=function(a){Ha(this.a,a)||this.a.push(a);return this};P.prototype.vb=function(){return La(this.a)};P.prototype.credential=function(a,b){if(!a&&!b)throw new N("argument-error","credential failed: must provide the ID token and/or the access token.");return new Wg(this.providerId,{idToken:a||null,accessToken:b||null})};function bh(){P.call(this,"facebook.com")}t(bh,P);M(bh,"PROVIDER_ID","facebook.com");
function ch(a){if(!a)throw new N("argument-error","credential failed: expected 1 argument (the OAuth access token).");var b=a;q(a)&&(b=a.accessToken);return(new bh).credential(null,b)}function dh(){P.call(this,"github.com")}t(dh,P);M(dh,"PROVIDER_ID","github.com");function eh(a){if(!a)throw new N("argument-error","credential failed: expected 1 argument (the OAuth access token).");var b=a;q(a)&&(b=a.accessToken);return(new dh).credential(null,b)}
function fh(){P.call(this,"google.com");this.sa("profile")}t(fh,P);M(fh,"PROVIDER_ID","google.com");function gh(a,b){var c=a;q(a)&&(c=a.idToken,b=a.accessToken);return(new fh).credential(c,b)}function hh(){ah.call(this,"twitter.com",Ig)}t(hh,ah);M(hh,"PROVIDER_ID","twitter.com");
function ih(a,b){var c=a;q(c)||(c={oauthToken:a,oauthTokenSecret:b});if(!c.oauthToken||!c.oauthTokenSecret)throw new N("argument-error","credential failed: expected 2 arguments (the OAuth access token and secret).");return new Wg("twitter.com",c)}function jh(a,b){this.a=a;this.f=b;M(this,"providerId","password")}jh.prototype.wa=function(a){return Q(a,kh,{email:this.a,password:this.f})};jh.prototype.b=function(a,b){return Q(a,lh,{idToken:b,email:this.a,password:this.f})};
jh.prototype.c=function(a,b){return Vg(this.wa(a),b)};jh.prototype.B=function(){return{email:this.a,password:this.f}};function mh(){gg(this,{providerId:"password",isOAuthProvider:!1})}gg(mh,{PROVIDER_ID:"password"});function nh(a){if(!(a.Pa&&a.Oa||a.Da&&a.Y))throw new N("internal-error");this.a=a;M(this,"providerId","phone")}nh.prototype.wa=function(a){return a.Qa(oh(this))};nh.prototype.b=function(a,b){var c=oh(this);c.idToken=b;return Q(a,ph,c)};
nh.prototype.c=function(a,b){var c=oh(this);c.operation="REAUTH";a=Q(a,qh,c);return Vg(a,b)};nh.prototype.B=function(){var a={providerId:"phone"};this.a.Pa&&(a.verificationId=this.a.Pa);this.a.Oa&&(a.verificationCode=this.a.Oa);this.a.Da&&(a.temporaryProof=this.a.Da);this.a.Y&&(a.phoneNumber=this.a.Y);return a};function oh(a){return a.a.Da&&a.a.Y?{temporaryProof:a.a.Da,phoneNumber:a.a.Y}:{sessionInfo:a.a.Pa,code:a.a.Oa}}
function rh(a){try{this.a=a||firebase.auth()}catch(b){throw new N("argument-error","Either an instance of firebase.auth.Auth must be passed as an argument to the firebase.auth.PhoneAuthProvider constructor, or the default firebase App instance must be initialized via firebase.initializeApp().");}gg(this,{providerId:"phone",isOAuthProvider:!1})}
rh.prototype.Qa=function(a,b){var c=this.a.c;return A(b.verify()).then(function(d){if(!m(d))throw new N("argument-error","An implementation of firebase.auth.ApplicationVerifier.prototype.verify() must return a firebase.Promise that resolves with a string.");switch(b.type){case "recaptcha":return sh(c,{phoneNumber:a,recaptchaToken:d}).then(function(a){"function"===typeof b.reset&&b.reset();return a},function(a){"function"===typeof b.reset&&b.reset();throw a;});default:throw new N("argument-error",
'Only firebase.auth.ApplicationVerifiers with type="recaptcha" are currently supported.');}})};function th(a,b){if(!a)throw new N("missing-verification-id");if(!b)throw new N("missing-verification-code");return new nh({Pa:a,Oa:b})}gg(rh,{PROVIDER_ID:"phone"});
function uh(a){if(a.temporaryProof&&a.phoneNumber)return new nh({Da:a.temporaryProof,Y:a.phoneNumber});var b=a&&a.providerId;if(!b||"password"===b)return null;var c=a&&a.oauthAccessToken,d=a&&a.oauthTokenSecret;a=a&&a.oauthIdToken;try{switch(b){case "google.com":return gh(a,c);case "facebook.com":return ch(c);case "github.com":return eh(c);case "twitter.com":return ih(c,d);default:return(new P(b)).credential(a,c)}}catch(e){return null}}
function vh(a){if(!a.isOAuthProvider)throw new N("invalid-oauth-provider");};function wh(a,b,c,d,e){this.b=a;this.c=b||null;this.f=c||null;this.g=d||null;this.a=e||null;if(this.f||this.a){if(this.f&&this.a)throw new N("invalid-auth-event");if(this.f&&!this.g)throw new N("invalid-auth-event");}else throw new N("invalid-auth-event");}wh.prototype.B=function(){return{type:this.b,eventId:this.c,urlResponse:this.f,sessionId:this.g,error:this.a&&this.a.B()}};function xh(a){a=a||{};return a.type?new wh(a.type,a.eventId,a.urlResponse,a.sessionId,a.error&&vg(a.error)):null};function yh(a){var b="unauthorized-domain",c=void 0,d=De(a);a=d.b;d=d.c;"chrome-extension"==d?c=oa("This chrome extension ID (chrome-extension://%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.",a):"http"==d||"https"==d?c=oa("This domain (%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.",a):b="operation-not-supported-in-this-environment";
N.call(this,b,c)}t(yh,N);function zh(a,b,c){N.call(this,a,c);a=b||{};a.rb&&M(this,"email",a.rb);a.Y&&M(this,"phoneNumber",a.Y);a.credential&&M(this,"credential",a.credential)}t(zh,N);zh.prototype.B=function(){var a={code:this.code,message:this.message};this.email&&(a.email=this.email);this.phoneNumber&&(a.phoneNumber=this.phoneNumber);var b=this.credential&&this.credential.B();b&&Wa(a,b);return a};zh.prototype.toJSON=function(){return this.B()};
function Ah(a){if(a.code){var b=a.code||"";0==b.indexOf(tg)&&(b=b.substring(tg.length));var c={credential:uh(a)};if(a.email)c.rb=a.email;else if(a.phoneNumber)c.Y=a.phoneNumber;else return new N(b,a.message||void 0);return new zh(b,c,a.message)}return null};function Bh(a){this.f=a}t(Bh,Ne);Bh.prototype.a=function(){return new this.f};Bh.prototype.b=function(){return{}};
function Ch(a,b,c){var d="Node"==K();d=k.XMLHttpRequest||d&&firebase.INTERNAL.node&&firebase.INTERNAL.node.XMLHttpRequest;if(!d)throw new N("internal-error","The XMLHttpRequest compatibility library was not found.");this.b=a;a=b||{};this.i=a.secureTokenEndpoint||"https://securetoken.googleapis.com/v1/token";this.l=a.secureTokenTimeout||Dh;this.c=Ua(a.secureTokenHeaders||Eh);this.g=a.firebaseEndpoint||"https://www.googleapis.com/identitytoolkit/v3/relyingparty/";this.h=a.firebaseTimeout||Fh;this.a=
Ua(a.firebaseHeaders||Gh);c&&(this.a["X-Client-Version"]=c,this.c["X-Client-Version"]=c);this.f=new rf;this.o=new Bh(d)}var Hh,O="idToken",Dh=new $f(3E4,6E4),Eh={"Content-Type":"application/x-www-form-urlencoded"},Fh=new $f(3E4,6E4),Gh={"Content-Type":"application/json"};function Ih(a,b){b?a.a["X-Firebase-Locale"]=b:delete a.a["X-Firebase-Locale"]}function Jh(a,b){b?(a.a["X-Client-Version"]=b,a.c["X-Client-Version"]=b):(delete a.a["X-Client-Version"],delete a.c["X-Client-Version"])}
function Kh(a,b,c,d,e,f,g){Zf()?(yf()?a=r(a.m,a):(Hh||(Hh=new z(function(a,b){Lh(a,b)})),a=r(a.u,a)),a(b,c,d,e,f,g)):c&&c(null)}
Ch.prototype.m=function(a,b,c,d,e,f){var g="Node"==K(),l=Mf()?g?new Se(this.o):new Se:new Se(this.f);if(f){l.f=Math.max(0,f);var n=setTimeout(function(){G(l,"timeout")},f)}fd(l,"complete",function(){n&&clearTimeout(n);var a=null;try{a=JSON.parse(hf(this))||null}catch(vb){a=null}b&&b(a)});ld(l,"ready",function(){n&&clearTimeout(n);Lc(this)});ld(l,"timeout",function(){n&&clearTimeout(n);Lc(this);b&&b(null)});Ye(l,a,c,d,e)};
var Mh=dc("https://apis.google.com/js/client.js?onload=%{onload}"),Nh="__fcb"+Math.floor(1E6*Math.random()).toString();function Lh(a,b){if(((window.gapi||{}).client||{}).request)a();else{k[Nh]=function(){((window.gapi||{}).client||{}).request?a():b(Error("CORS_UNSUPPORTED"))};var c=hc(Mh,{onload:Nh});Td(kf(c),function(){b(Error("CORS_UNSUPPORTED"))})}}
Ch.prototype.u=function(a,b,c,d,e){var f=this;Hh.then(function(){window.gapi.client.setApiKey(f.b);var g=window.gapi.auth.getToken();window.gapi.auth.setToken(null);window.gapi.client.request({path:a,method:c,body:d,headers:e,authType:"none",callback:function(a){window.gapi.auth.setToken(g);b&&b(a)}})}).s(function(a){b&&b({error:{message:a&&a.message||"CORS_UNSUPPORTED"}})})};
function Oh(a,b){return new z(function(c,d){"refresh_token"==b.grant_type&&b.refresh_token||"authorization_code"==b.grant_type&&b.code?Kh(a,a.i+"?key="+encodeURIComponent(a.b),function(a){a?a.error?d(Ph(a)):a.access_token&&a.refresh_token?c(a):d(new N("internal-error")):d(new N("network-request-failed"))},"POST",Ie(b).toString(),a.c,a.l.get()):d(new N("internal-error"))})}
function Qh(a,b,c,d,e,f){var g=De(a.g+b);I(g,"key",a.b);f&&I(g,"cb",na().toString());var l="GET"==c;if(l)for(var n in d)d.hasOwnProperty(n)&&I(g,n,d[n]);return new z(function(b,f){Kh(a,g.toString(),function(a){a?a.error?f(Ph(a,e||{})):b(a):f(new N("network-request-failed"))},c,l?void 0:Cc(Vf(d)),a.a,a.h.get())})}function Rh(a){if(!jf.test(a.email))throw new N("invalid-email");}function Sh(a){"email"in a&&Rh(a)}
function Th(a,b){return Q(a,Uh,{identifier:b,continueUri:Sf()?vf():"http://localhost"}).then(function(a){return a.allProviders||[]})}function Vh(a){return Q(a,Wh,{}).then(function(a){return a.authorizedDomains||[]})}function Xh(a){if(!a[O])throw new N("internal-error");}
function Yh(a){if(a.phoneNumber||a.temporaryProof){if(!a.phoneNumber||!a.temporaryProof)throw new N("internal-error");}else{if(!a.sessionInfo)throw new N("missing-verification-id");if(!a.code)throw new N("missing-verification-code");}}Ch.prototype.gb=function(){return Q(this,Zh,{})};Ch.prototype.kb=function(a,b){return Q(this,$h,{idToken:a,email:b})};Ch.prototype.lb=function(a,b){return Q(this,lh,{idToken:a,password:b})};var ai={displayName:"DISPLAY_NAME",photoUrl:"PHOTO_URL"};h=Ch.prototype;
h.mb=function(a,b){var c={idToken:a},d=[];Pa(ai,function(a,f){var e=b[f];null===e?d.push(a):f in b&&(c[f]=e)});d.length&&(c.deleteAttribute=d);return Q(this,$h,c)};h.cb=function(a,b){a={requestType:"PASSWORD_RESET",email:a};Wa(a,b);return Q(this,bi,a)};h.bb=function(a,b){a={requestType:"VERIFY_EMAIL",idToken:a};Wa(a,b);return Q(this,ci,a)};function sh(a,b){return Q(a,di,b)}h.Qa=function(a){return Q(this,ei,a)};function fi(a,b,c){return Q(a,gi,{idToken:b,deleteProvider:c})}
function hi(a){if(!a.requestUri||!a.sessionId&&!a.postBody)throw new N("internal-error");}function ii(a){var b=null;a.needConfirmation?(a.code="account-exists-with-different-credential",b=Ah(a)):"FEDERATED_USER_ID_ALREADY_LINKED"==a.errorMessage?(a.code="credential-already-in-use",b=Ah(a)):"EMAIL_EXISTS"==a.errorMessage?(a.code="email-already-in-use",b=Ah(a)):a.errorMessage&&(b=ji(a.errorMessage));if(b)throw b;if(!a[O])throw new N("internal-error");}
function Xg(a,b){b.returnIdpCredential=!0;return Q(a,ki,b)}function Zg(a,b){b.returnIdpCredential=!0;return Q(a,li,b)}function $g(a,b){b.returnIdpCredential=!0;b.autoCreate=!1;return Q(a,mi,b)}function ni(a){if(!a.oobCode)throw new N("invalid-action-code");}h.Ta=function(a,b){return Q(this,oi,{oobCode:a,newPassword:b})};h.Ia=function(a){return Q(this,pi,{oobCode:a})};h.Sa=function(a){return Q(this,qi,{oobCode:a})};
var qi={endpoint:"setAccountInfo",D:ni,ga:"email"},pi={endpoint:"resetPassword",D:ni,O:function(a){if(!a.email||!a.requestType)throw new N("internal-error");}},ri={endpoint:"signupNewUser",D:function(a){Rh(a);if(!a.password)throw new N("weak-password");},O:Xh,T:!0},Uh={endpoint:"createAuthUri"},si={endpoint:"deleteAccount",ea:["idToken"]},gi={endpoint:"setAccountInfo",ea:["idToken","deleteProvider"],D:function(a){if(!fa(a.deleteProvider))throw new N("internal-error");}},ti={endpoint:"getAccountInfo"},
ci={endpoint:"getOobConfirmationCode",ea:["idToken","requestType"],D:function(a){if("VERIFY_EMAIL"!=a.requestType)throw new N("internal-error");},ga:"email"},bi={endpoint:"getOobConfirmationCode",ea:["requestType"],D:function(a){if("PASSWORD_RESET"!=a.requestType)throw new N("internal-error");Rh(a)},ga:"email"},Wh={nb:!0,endpoint:"getProjectConfig",yb:"GET"},ui={nb:!0,endpoint:"getRecaptchaParam",yb:"GET",O:function(a){if(!a.recaptchaSiteKey)throw new N("internal-error");}},oi={endpoint:"resetPassword",
D:ni,ga:"email"},di={endpoint:"sendVerificationCode",ea:["phoneNumber","recaptchaToken"],ga:"sessionInfo"},$h={endpoint:"setAccountInfo",ea:["idToken"],D:Sh,T:!0},lh={endpoint:"setAccountInfo",ea:["idToken"],D:function(a){Sh(a);if(!a.password)throw new N("weak-password");},O:Xh,T:!0},Zh={endpoint:"signupNewUser",O:Xh,T:!0},ki={endpoint:"verifyAssertion",D:hi,O:ii,T:!0},mi={endpoint:"verifyAssertion",D:hi,O:function(a){if(a.errorMessage&&"USER_NOT_FOUND"==a.errorMessage)throw new N("user-not-found");
if(a.errorMessage)throw ji(a.errorMessage);if(!a[O])throw new N("internal-error");},T:!0},li={endpoint:"verifyAssertion",D:function(a){hi(a);if(!a.idToken)throw new N("internal-error");},O:ii,T:!0},vi={endpoint:"verifyCustomToken",D:function(a){if(!a.token)throw new N("invalid-custom-token");},O:Xh,T:!0},kh={endpoint:"verifyPassword",D:function(a){Rh(a);if(!a.password)throw new N("wrong-password");},O:Xh,T:!0},ei={endpoint:"verifyPhoneNumber",D:Yh,O:Xh},ph={endpoint:"verifyPhoneNumber",D:function(a){if(!a.idToken)throw new N("internal-error");
Yh(a)},O:function(a){if(a.temporaryProof)throw a.code="credential-already-in-use",Ah(a);Xh(a)}},qh={Lb:{USER_NOT_FOUND:"user-not-found"},endpoint:"verifyPhoneNumber",D:Yh,O:Xh};
function Q(a,b,c){if(!jg(c,b.ea))return B(new N("internal-error"));var d=b.yb||"POST",e;return A(c).then(b.D).then(function(){b.T&&(c.returnSecureToken=!0);return Qh(a,b.endpoint,d,c,b.Lb,b.nb||!1)}).then(function(a){return e=a}).then(b.O).then(function(){if(!b.ga)return e;if(!(b.ga in e))throw new N("internal-error");return e[b.ga]})}function ji(a){return Ph({error:{errors:[{message:a}],code:400,message:a}})}
function Ph(a,b){var c=(a.error&&a.error.errors&&a.error.errors[0]||{}).reason||"";var d={keyInvalid:"invalid-api-key",ipRefererBlocked:"app-not-authorized"};if(c=d[c]?new N(d[c]):null)return c;c=a.error&&a.error.message||"";d={INVALID_CUSTOM_TOKEN:"invalid-custom-token",CREDENTIAL_MISMATCH:"custom-token-mismatch",MISSING_CUSTOM_TOKEN:"internal-error",INVALID_IDENTIFIER:"invalid-email",MISSING_CONTINUE_URI:"internal-error",INVALID_EMAIL:"invalid-email",INVALID_PASSWORD:"wrong-password",USER_DISABLED:"user-disabled",
MISSING_PASSWORD:"internal-error",EMAIL_EXISTS:"email-already-in-use",PASSWORD_LOGIN_DISABLED:"operation-not-allowed",INVALID_IDP_RESPONSE:"invalid-credential",FEDERATED_USER_ID_ALREADY_LINKED:"credential-already-in-use",INVALID_MESSAGE_PAYLOAD:"invalid-message-payload",INVALID_RECIPIENT_EMAIL:"invalid-recipient-email",INVALID_SENDER:"invalid-sender",EMAIL_NOT_FOUND:"user-not-found",EXPIRED_OOB_CODE:"expired-action-code",INVALID_OOB_CODE:"invalid-action-code",MISSING_OOB_CODE:"internal-error",CREDENTIAL_TOO_OLD_LOGIN_AGAIN:"requires-recent-login",
INVALID_ID_TOKEN:"invalid-user-token",TOKEN_EXPIRED:"user-token-expired",USER_NOT_FOUND:"user-token-expired",CORS_UNSUPPORTED:"cors-unsupported",DYNAMIC_LINK_NOT_ACTIVATED:"dynamic-link-not-activated",INVALID_APP_ID:"invalid-app-id",TOO_MANY_ATTEMPTS_TRY_LATER:"too-many-requests",WEAK_PASSWORD:"weak-password",OPERATION_NOT_ALLOWED:"operation-not-allowed",USER_CANCELLED:"user-cancelled",CAPTCHA_CHECK_FAILED:"captcha-check-failed",INVALID_APP_CREDENTIAL:"invalid-app-credential",INVALID_CODE:"invalid-verification-code",
INVALID_PHONE_NUMBER:"invalid-phone-number",INVALID_SESSION_INFO:"invalid-verification-id",INVALID_TEMPORARY_PROOF:"invalid-credential",MISSING_APP_CREDENTIAL:"missing-app-credential",MISSING_CODE:"missing-verification-code",MISSING_PHONE_NUMBER:"missing-phone-number",MISSING_SESSION_INFO:"missing-verification-id",QUOTA_EXCEEDED:"quota-exceeded",SESSION_EXPIRED:"code-expired",INVALID_CONTINUE_URI:"invalid-continue-uri",MISSING_ANDROID_PACKAGE_NAME:"missing-android-pkg-name",MISSING_IOS_BUNDLE_ID:"missing-ios-bundle-id",
UNAUTHORIZED_DOMAIN:"unauthorized-continue-uri",INVALID_OAUTH_CLIENT_ID:"invalid-oauth-client-id",INVALID_CERT_HASH:"invalid-cert-hash"};Wa(d,b||{});b=(b=c.match(/^[^\s]+\s*:\s*(.*)$/))&&1<b.length?b[1]:void 0;for(var e in d)if(0===c.indexOf(e))return new N(d[e],b);!b&&a&&(b=Uf(a));return new N("internal-error",b)};var wi={Ic:{Va:"https://www.googleapis.com/identitytoolkit/v3/relyingparty/",ab:"https://securetoken.googleapis.com/v1/token",id:"p"},Kc:{Va:"https://staging-www.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/",ab:"https://staging-securetoken.sandbox.googleapis.com/v1/token",id:"s"},Lc:{Va:"https://www-googleapis-test.sandbox.google.com/identitytoolkit/v3/relyingparty/",ab:"https://test-securetoken.sandbox.googleapis.com/v1/token",id:"t"}};
function xi(a){for(var b in wi)if(wi[b].id===a)return a=wi[b],{firebaseEndpoint:a.Va,secureTokenEndpoint:a.ab};return null}var yi;yi=xi("__EID__")?"__EID__":void 0;function zi(a){this.b=a;this.a=null;this.Ya=Ai(this)}
function Ai(a){return Bi().then(function(){return new z(function(b,c){L("gapi.iframes.getContext")().open({where:document.body,url:a.b,messageHandlersFilter:L("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"),attributes:{style:{position:"absolute",top:"-100px",width:"1px",height:"1px"}},dontclear:!0},function(d){function e(){clearTimeout(f);b()}a.a=d;a.a.restyle({setHideOnLeave:!1});var f=setTimeout(function(){c(Error("Network Error"))},Ci.get());d.ping(e).then(e,function(){c(Error("Network Error"))})})})})}
function Di(a,b){return a.Ya.then(function(){return new z(function(c){a.a.send(b.type,b,c,L("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"))})})}function Ei(a,b){a.Ya.then(function(){a.a.register("authEvent",b,L("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"))})}var Fi=dc("https://apis.google.com/js/api.js?onload=%{onload}"),Gi=new $f(3E4,6E4),Ci=new $f(5E3,15E3),Hi=null;
function Bi(){return Hi?Hi:Hi=(new z(function(a,b){if(Zf()){var c=function(){Yf();L("gapi.load")("gapi.iframes",{callback:a,ontimeout:function(){Yf();b(Error("Network Error"))},timeout:Gi.get()})};if(L("gapi.iframes.Iframe"))a();else if(L("gapi.load"))c();else{var d="__iframefcb"+Math.floor(1E6*Math.random()).toString();k[d]=function(){L("gapi.load")?c():b(Error("Network Error"))};d=hc(Fi,{onload:d});A(kf(d)).s(function(){b(Error("Network Error"))})}}else b(Error("Network Error"))})).s(function(a){Hi=
null;throw a;})};function Ii(a,b,c){this.i=a;this.g=b;this.h=c;this.f=null;this.a=Ee(this.i,"/__/auth/iframe");I(this.a,"apiKey",this.g);I(this.a,"appName",this.h);this.b=null;this.c=[]}Ii.prototype.toString=function(){this.f?I(this.a,"v",this.f):Le(this.a.a,"v");this.b?I(this.a,"eid",this.b):Le(this.a.a,"eid");this.c.length?I(this.a,"fw",this.c.join(",")):Le(this.a.a,"fw");return this.a.toString()};function Ji(a,b,c,d,e){this.m=a;this.u=b;this.c=c;this.l=d;this.i=this.g=this.h=null;this.a=e;this.f=null}
Ji.prototype.toString=function(){var a=Ee(this.m,"/__/auth/handler");I(a,"apiKey",this.u);I(a,"appName",this.c);I(a,"authType",this.l);if(this.a.isOAuthProvider){var b=this.a;try{var c=firebase.app(this.c).auth().$()}catch(l){c=null}b.Ua=c;I(a,"providerId",this.a.providerId);b=this.a;c=Vf(b.qb);for(var d in c)c[d]=c[d].toString();d=b.nc;c=Ua(c);for(var e=0;e<d.length;e++){var f=d[e];f in c&&delete c[f]}b.Wa&&b.Ua&&!c[b.Wa]&&(c[b.Wa]=b.Ua);Sa(c)||I(a,"customParameters",Uf(c))}"function"===typeof this.a.vb&&
(b=this.a.vb(),b.length&&I(a,"scopes",b.join(",")));this.h?I(a,"redirectUrl",this.h):Le(a.a,"redirectUrl");this.g?I(a,"eventId",this.g):Le(a.a,"eventId");this.i?I(a,"v",this.i):Le(a.a,"v");if(this.b)for(var g in this.b)this.b.hasOwnProperty(g)&&!Ce(a,g)&&I(a,g,this.b[g]);this.f?I(a,"eid",this.f):Le(a.a,"eid");g=Ki(this.c);g.length&&I(a,"fw",g.join(","));return a.toString()};function Ki(a){try{return firebase.app(a).auth().Ka()}catch(b){return[]}}
function Li(a,b,c,d,e){this.u=a;this.f=b;this.b=c;this.c=d||null;this.h=e||null;this.m=this.o=this.v=null;this.g=[];this.l=this.a=null}
function Mi(a){var b=vf();return Vh(a).then(function(a){a:{var c=De(b),e=c.c;c=c.b;for(var f=0;f<a.length;f++){var g=a[f];var l=c;var n=e;0==g.indexOf("chrome-extension://")?l=De(g).b==l&&"chrome-extension"==n:"http"!=n&&"https"!=n?l=!1:Gf.test(g)?l=l==g:(g=g.split(".").join("\\."),l=(new RegExp("^(.+\\."+g+"|"+g+")$","i")).test(l));if(l){a=!0;break a}}a=!1}if(!a)throw new yh(vf());})}
function Ni(a){if(a.l)return a.l;a.l=Hf().then(function(){if(!a.o){var b=a.c,c=a.h,d=Ki(a.b),e=new Ii(a.u,a.f,a.b);e.f=b;e.b=c;e.c=La(d||[]);a.o=e.toString()}a.i=new zi(a.o);Oi(a)});return a.l}h=Li.prototype;h.Ca=function(a,b,c){var d=new N("popup-closed-by-user"),e=new N("web-storage-unsupported"),f=this,g=!1;return this.ba().then(function(){Pi(f).then(function(c){c||(a&&Cf(a),b(e),g=!0)})}).s(function(){}).then(function(){if(!g)return Ff(a)}).then(function(){if(!g)return sd(c).then(function(){b(d)})})};
h.Cb=function(){var a=J();return!Tf(a)&&!Xf(a)};h.xb=function(){return!1};
h.ub=function(a,b,c,d,e,f,g){if(!a)return B(new N("popup-blocked"));if(g&&!Tf())return this.ba().s(function(b){Cf(a);e(b)}),d(),A();this.a||(this.a=Mi(Qi(this)));var l=this;return this.a.then(function(){var b=l.ba().s(function(b){Cf(a);e(b);throw b;});d();return b}).then(function(){vh(c);if(!g){var d=Ri(l.u,l.f,l.b,b,c,null,f,l.c,void 0,l.h);wf(d,a)}}).s(function(a){"auth/network-request-failed"==a.code&&(l.a=null);throw a;})};
function Qi(a){a.m||(a.v=a.c?Of(a.c,Ki(a.b)):null,a.m=new Ch(a.f,xi(a.h),a.v));return a.m}h.Aa=function(a,b,c){this.a||(this.a=Mi(Qi(this)));var d=this;return this.a.then(function(){vh(b);var e=Ri(d.u,d.f,d.b,a,b,vf(),c,d.c,void 0,d.h);wf(e)}).s(function(a){"auth/network-request-failed"==a.code&&(d.a=null);throw a;})};h.ba=function(){var a=this;return Ni(this).then(function(){return a.i.Ya}).s(function(){a.a=null;throw new N("network-request-failed");})};h.Db=function(){return!0};
function Ri(a,b,c,d,e,f,g,l,n,D){a=new Ji(a,b,c,d,e);a.h=f;a.g=g;a.i=l;a.b=Ua(n||null);a.f=D;return a.toString()}function Oi(a){if(!a.i)throw Error("IfcHandler must be initialized!");Ei(a.i,function(b){var c={};if(b&&b.authEvent){var d=!1;b=xh(b.authEvent);for(c=0;c<a.g.length;c++)d=a.g[c](b)||d;c={};c.status=d?"ACK":"ERROR";return A(c)}c.status="ERROR";return A(c)})}
function Pi(a){var b={type:"webStorageSupport"};return Ni(a).then(function(){return Di(a.i,b)}).then(function(a){if(a&&a.length&&"undefined"!==typeof a[0].webStorageSupport)return a[0].webStorageSupport;throw Error();})}h.ua=function(a){this.g.push(a)};h.Ja=function(a){Ja(this.g,function(b){return b==a})};function Si(a){this.a=a||firebase.INTERNAL.reactNative&&firebase.INTERNAL.reactNative.AsyncStorage;if(!this.a)throw new N("internal-error","The React Native compatibility library was not found.");}h=Si.prototype;h.get=function(a){return A(this.a.getItem(a)).then(function(a){return a&&Wf(a)})};h.set=function(a,b){return A(this.a.setItem(a,Uf(b)))};h.X=function(a){return A(this.a.removeItem(a))};h.ia=function(){};h.da=function(){};function Ti(){this.a={}}h=Ti.prototype;h.get=function(a){return A(this.a[a])};h.set=function(a,b){this.a[a]=b;return A()};h.X=function(a){delete this.a[a];return A()};h.ia=function(){};h.da=function(){};function Ui(a,b,c,d,e,f){try{var g=!!k.indexedDB}catch(l){g=!1}if(!g)throw new N("web-storage-unsupported");this.u=a;this.h=b;this.g=c;this.l=d;this.m=e;this.f={};this.c=[];this.a=0;this.o=f||k.indexedDB}var Vi;function Wi(a){return new z(function(b,c){var d=a.o.open(a.u,a.m);d.onerror=function(a){c(Error(a.target.errorCode))};d.onupgradeneeded=function(b){b=b.target.result;try{b.createObjectStore(a.h,{keyPath:a.g})}catch(f){c(f)}};d.onsuccess=function(a){b(a.target.result)}})}
function Xi(a){a.i||(a.i=Wi(a));return a.i}function Yi(a,b){return b.objectStore(a.h)}function Zi(a,b,c){return b.transaction([a.h],c?"readwrite":"readonly")}function $i(a){return new z(function(b,c){a.onsuccess=function(a){a&&a.target?b(a.target.result):b()};a.onerror=function(a){c(Error(a.target.errorCode))}})}h=Ui.prototype;
h.set=function(a,b){var c=!1,d,e=this;return Qb(Xi(this).then(function(b){d=b;b=Yi(e,Zi(e,d,!0));return $i(b.get(a))}).then(function(f){var g=Yi(e,Zi(e,d,!0));if(f)return f.value=b,$i(g.put(f));e.a++;c=!0;f={};f[e.g]=a;f[e.l]=b;return $i(g.add(f))}).then(function(){e.f[a]=b}),function(){c&&e.a--})};h.get=function(a){var b=this;return Xi(this).then(function(c){return $i(Yi(b,Zi(b,c,!1)).get(a))}).then(function(a){return a&&a.value})};
h.X=function(a){var b=!1,c=this;return Qb(Xi(this).then(function(d){b=!0;c.a++;return $i(Yi(c,Zi(c,d,!0))["delete"](a))}).then(function(){delete c.f[a]}),function(){b&&c.a--})};
h.vc=function(){var a=this;return Xi(this).then(function(b){var c=Yi(a,Zi(a,b,!1));return c.getAll?$i(c.getAll()):new z(function(a,b){var d=[],e=c.openCursor();e.onsuccess=function(b){(b=b.target.result)?(d.push(b.value),b["continue"]()):a(d)};e.onerror=function(a){b(Error(a.target.errorCode))}})}).then(function(b){var c={},d=[];if(0==a.a){for(d=0;d<b.length;d++)c[b[d][a.g]]=b[d][a.l];d=xf(a.f,c);a.f=c}return d})};h.ia=function(a){0==this.c.length&&aj(this);this.c.push(a)};
h.da=function(a){Ja(this.c,function(b){return b==a});0==this.c.length&&this.b&&this.b.cancel("STOP_EVENT")};function aj(a){function b(){a.b=sd(800).then(r(a.vc,a)).then(function(b){0<b.length&&w(a.c,function(a){a(b)})}).then(b).s(function(a){"STOP_EVENT"!=a.message&&b()});return a.b}a.b&&a.b.cancel("STOP_EVENT");b()};function bj(){if(!cj()){if("Node"==K())throw new N("internal-error","The LocalStorage compatibility library was not found.");throw new N("web-storage-unsupported");}this.a=dj()||firebase.INTERNAL.node.localStorage}function dj(){try{var a=k.localStorage,b=Qf();a&&(a.setItem(b,"1"),a.removeItem(b));return a}catch(c){return null}}
function cj(){var a="Node"==K();a=dj()||a&&firebase.INTERNAL.node&&firebase.INTERNAL.node.localStorage;if(!a)return!1;try{return a.setItem("__sak","1"),a.removeItem("__sak"),!0}catch(b){return!1}}h=bj.prototype;h.get=function(a){var b=this;return A().then(function(){var c=b.a.getItem(a);return Wf(c)})};h.set=function(a,b){var c=this;return A().then(function(){var d=Uf(b);null===d?c.X(a):c.a.setItem(a,d)})};h.X=function(a){var b=this;return A().then(function(){b.a.removeItem(a)})};
h.ia=function(a){k.window&&cd(k.window,"storage",a)};h.da=function(a){k.window&&E(k.window,"storage",a)};function ej(){}h=ej.prototype;h.get=function(){return A(null)};h.set=function(){return A()};h.X=function(){return A()};h.ia=function(){};h.da=function(){};function fj(){if(!gj()){if("Node"==K())throw new N("internal-error","The SessionStorage compatibility library was not found.");throw new N("web-storage-unsupported");}this.a=hj()||firebase.INTERNAL.node.sessionStorage}function hj(){try{var a=k.sessionStorage,b=Qf();a&&(a.setItem(b,"1"),a.removeItem(b));return a}catch(c){return null}}
function gj(){var a="Node"==K();a=hj()||a&&firebase.INTERNAL.node&&firebase.INTERNAL.node.sessionStorage;if(!a)return!1;try{return a.setItem("__sak","1"),a.removeItem("__sak"),!0}catch(b){return!1}}h=fj.prototype;h.get=function(a){var b=this;return A().then(function(){var c=b.a.getItem(a);return Wf(c)})};h.set=function(a,b){var c=this;return A().then(function(){var d=Uf(b);null===d?c.X(a):c.a.setItem(a,d)})};h.X=function(a){var b=this;return A().then(function(){b.a.removeItem(a)})};h.ia=function(){};
h.da=function(){};function ij(){var a={};a.Browser=jj;a.Node=kj;a.ReactNative=lj;this.a=a[K()]}var mj,jj={C:bj,jb:fj},kj={C:bj,jb:fj},lj={C:Si,jb:ej};var nj={Hc:"local",NONE:"none",Jc:"session"};function oj(a){var b=new N("invalid-persistence-type"),c=new N("unsupported-persistence-type");a:{for(d in nj)if(nj[d]==a){var d=!0;break a}d=!1}if(!d||"string"!==typeof a)throw b;switch(K()){case "ReactNative":if("session"===a)throw c;break;case "Node":if("none"!==a)throw c;break;default:if(!Pf()&&"none"!==a)throw c;}}
function pj(a,b,c,d,e){this.i=a;this.g=b;this.A=c;this.u=d;this.v=e;this.a={};mj||(mj=new ij);a=mj;try{if(uf()){Vi||(Vi=new Ui("firebaseLocalStorageDb","firebaseLocalStorage","fbase_key","value",1));var f=Vi}else f=new a.a.C;this.l=f}catch(g){this.l=new Ti,this.u=!0}try{this.o=new a.a.jb}catch(g){this.o=new Ti}this.w=new Ti;this.h=r(this.m,this);this.b={}}var qj;function rj(){qj||(qj=new pj("firebase",":",!Xf(J())&&Lf()?!0:!1,Tf(),Pf()));return qj}
function sj(a,b){switch(b){case "session":return a.o;case "none":return a.w;default:return a.l}}function tj(a,b,c){return a.i+a.g+b.name+(c?a.g+c:"")}pj.prototype.get=function(a,b){return sj(this,a.C).get(tj(this,a,b))};function uj(a,b,c){c=tj(a,b,c);"local"==b.C&&(a.b[c]=null);return sj(a,b.C).X(c)}pj.prototype.set=function(a,b,c){var d=tj(this,a,c),e=this,f=sj(this,a.C);return f.set(d,b).then(function(){return f.get(d)}).then(function(b){"local"==a.C&&(e.b[d]=b)})};
function vj(a,b,c,d){b=tj(a,b,c);a.v&&(a.b[b]=k.localStorage.getItem(b));Sa(a.a)&&(sj(a,"local").ia(a.h),a.u||uf()||!a.v||wj(a));a.a[b]||(a.a[b]=[]);a.a[b].push(d)}function xj(a,b,c){b=tj(a,yj("local"),b);a.a[b]&&(Ja(a.a[b],function(a){return a==c}),0==a.a[b].length&&delete a.a[b]);Sa(a.a)&&zj(a)}
function wj(a){Aj(a);a.f=setInterval(function(){for(var b in a.a){var c=k.localStorage.getItem(b),d=a.b[b];c!=d&&(a.b[b]=c,c=new Qc({type:"storage",key:b,target:window,oldValue:d,newValue:c,a:!0}),a.m(c))}},1E3)}function Aj(a){a.f&&(clearInterval(a.f),a.f=null)}function zj(a){sj(a,"local").da(a.h);Aj(a)}
pj.prototype.m=function(a){if(a&&a.g){var b=a.a.key;if(null==b)for(var c in this.a){var d=this.b[c];"undefined"===typeof d&&(d=null);var e=k.localStorage.getItem(c);e!==d&&(this.b[c]=e,this.c(c))}else if(0==b.indexOf(this.i+this.g)&&this.a[b]){"undefined"!==typeof a.a.a?sj(this,"local").da(this.h):Aj(this);if(this.A)if(c=k.localStorage.getItem(b),d=a.a.newValue,d!==c)null!==d?k.localStorage.setItem(b,d):k.localStorage.removeItem(b);else if(this.b[b]===d&&"undefined"===typeof a.a.a)return;var f=this;
c=function(){if("undefined"!==typeof a.a.a||f.b[b]!==k.localStorage.getItem(b))f.b[b]=k.localStorage.getItem(b),f.c(b)};y&&kb&&10==kb&&k.localStorage.getItem(b)!==a.a.newValue&&a.a.newValue!==a.a.oldValue?setTimeout(c,10):c()}}else w(a,r(this.c,this))};pj.prototype.c=function(a){this.a[a]&&w(this.a[a],function(a){a()})};function Cj(a){this.a=a;this.b=rj()}var Dj={name:"authEvent",C:"local"};function Ej(a){return a.b.get(Dj,a.a).then(function(a){return xh(a)})};function Fj(){this.a=rj()};function Gj(a,b,c,d,e,f,g){this.u=a;this.i=b;this.l=c;this.m=d||null;this.o=g||null;this.h=b+":"+c;this.A=new Fj;this.g=new Cj(this.h);this.f=null;this.b=[];this.v=e||500;this.w=f||2E3;this.a=this.c=null}function Hj(a){return new N("invalid-cordova-configuration",a)}h=Gj.prototype;
h.ba=function(){return this.xa?this.xa:this.xa=If().then(function(){if("function"!==typeof L("universalLinks.subscribe",k))throw Hj("cordova-universal-links-plugin is not installed");if("undefined"===typeof L("BuildInfo.packageName",k))throw Hj("cordova-plugin-buildinfo is not installed");if("function"!==typeof L("cordova.plugins.browsertab.openUrl",k))throw Hj("cordova-plugin-browsertab is not installed");if("function"!==typeof L("cordova.InAppBrowser.open",k))throw Hj("cordova-plugin-inappbrowser is not installed");
},function(){throw new N("cordova-not-ready");})};function Ij(){for(var a=20,b=[];0<a;)b.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62*Math.random()))),a--;return b.join("")}function Jj(a){var b=new ie;he(b,a);a=[];var c=8*b.g;56>b.c?he(b,fe,56-b.c):he(b,fe,b.b-(b.c-56));for(var d=63;56<=d;d--)b.f[d]=c&255,c/=256;ge(b);for(d=c=0;d<b.i;d++)for(var e=24;0<=e;e-=8)a[c++]=b.a[d]>>e&255;return Hd(a)}
h.Ca=function(a,b){b(new N("operation-not-supported-in-this-environment"));return A()};h.ub=function(){return B(new N("operation-not-supported-in-this-environment"))};h.Db=function(){return!1};h.Cb=function(){return!0};h.xb=function(){return!0};
h.Aa=function(a,b,c){if(this.c)return B(new N("redirect-operation-pending"));var d=this,e=k.document,f=null,g=null,l=null,n=null;return this.c=Qb(A().then(function(){vh(b);return Kj(d)}).then(function(){return Lj(d,a,b,c)}).then(function(){return(new z(function(a,b){g=function(){var b=L("cordova.plugins.browsertab.close",k);a();"function"===typeof b&&b();d.a&&"function"===typeof d.a.close&&(d.a.close(),d.a=null);return!1};d.ua(g);l=function(){f||(f=sd(d.w).then(function(){b(new N("redirect-cancelled-by-user"))}))};
n=function(){ag()&&l()};e.addEventListener("resume",l,!1);J().toLowerCase().match(/android/)||e.addEventListener("visibilitychange",n,!1)})).s(function(a){return Mj(d).then(function(){throw a;})})}),function(){l&&e.removeEventListener("resume",l,!1);n&&e.removeEventListener("visibilitychange",n,!1);f&&f.cancel();g&&d.Ja(g);d.c=null})};
function Lj(a,b,c,d){var e=Ij(),f=new wh(b,d,null,e,new N("no-auth-event")),g=L("BuildInfo.packageName",k);if("string"!==typeof g)throw new N("invalid-cordova-configuration");var l=L("BuildInfo.displayName",k),n={};if(J().toLowerCase().match(/iphone|ipad|ipod/))n.ibi=g;else if(J().toLowerCase().match(/android/))n.apn=g;else return B(new N("operation-not-supported-in-this-environment"));l&&(n.appDisplayName=l);e=Jj(e);n.sessionId=e;var D=Ri(a.u,a.i,a.l,b,c,null,d,a.m,n,a.o);return a.ba().then(function(){var b=
a.h;return a.A.a.set(Dj,f.B(),b)}).then(function(){var b=L("cordova.plugins.browsertab.isAvailable",k);if("function"!==typeof b)throw new N("invalid-cordova-configuration");var c=null;b(function(b){if(b){c=L("cordova.plugins.browsertab.openUrl",k);if("function"!==typeof c)throw new N("invalid-cordova-configuration");c(D)}else{c=L("cordova.InAppBrowser.open",k);if("function"!==typeof c)throw new N("invalid-cordova-configuration");b=J();b=!(!b.match(/(iPad|iPhone|iPod).*OS 7_\d/i)&&!b.match(/(iPad|iPhone|iPod).*OS 8_\d/i));
a.a=c(D,b?"_blank":"_system","location=yes")}})})}function Nj(a,b){for(var c=0;c<a.b.length;c++)try{a.b[c](b)}catch(d){}}function Kj(a){a.f||(a.f=a.ba().then(function(){return new z(function(b){function c(d){b(d);a.Ja(c);return!1}a.ua(c);Oj(a)})}));return a.f}function Mj(a){var b=null;return Ej(a.g).then(function(c){b=c;c=a.g;return uj(c.b,Dj,c.a)}).then(function(){return b})}
function Oj(a){function b(b){e=!0;f&&f.cancel();Mj(a).then(function(c){var e=d;if(c&&b&&b.url){e=null;var f=b.url;var g=De(f),l=Ce(g,"link"),n=Ce(De(l),"link");g=Ce(g,"deep_link_id");f=Ce(De(g),"link")||g||n||l||f;-1!=f.indexOf("/__/auth/callback")&&(e=De(f),e=Wf(Ce(e,"firebaseError")||null),e=(e="object"===typeof e?vg(e):null)?new wh(c.b,c.c,null,null,e):new wh(c.b,c.c,f,c.g));e=e||d}Nj(a,e)})}var c=L("universalLinks.subscribe",k);if("function"!==typeof c)throw new N("invalid-cordova-configuration");
var d=new wh("unknown",null,null,null,new N("no-auth-event")),e=!1,f=sd(a.v).then(function(){return Mj(a).then(function(){e||Nj(a,d)})}),g=k.handleOpenURL;k.handleOpenURL=function(a){0==a.toLowerCase().indexOf(L("BuildInfo.packageName",k).toLowerCase()+"://")&&b({url:a});if("function"===typeof g)try{g(a)}catch(n){console.error(n)}};c(null,b)}
h.ua=function(a){this.b.push(a);Kj(this).s(function(b){"auth/invalid-cordova-configuration"===b.code&&(b=new wh("unknown",null,null,null,new N("no-auth-event")),a(b))})};h.Ja=function(a){Ja(this.b,function(b){return b==a})};function Pj(a){this.a=a;this.b=rj()}var Qj={name:"pendingRedirect",C:"session"};function Rj(a){return a.b.set(Qj,"pending",a.a)}function Sj(a){return uj(a.b,Qj,a.a)}function Tj(a){return a.b.get(Qj,a.a).then(function(a){return"pending"==a})};function Uj(a,b,c){this.v=a;this.l=b;this.u=c;this.h=[];this.f=!1;this.i=r(this.m,this);this.c=new Vj;this.o=new Wj;this.g=new Pj(this.l+":"+this.u);this.b={};this.b.unknown=this.c;this.b.signInViaRedirect=this.c;this.b.linkViaRedirect=this.c;this.b.reauthViaRedirect=this.c;this.b.signInViaPopup=this.o;this.b.linkViaPopup=this.o;this.b.reauthViaPopup=this.o;this.a=Xj(this.v,this.l,this.u,yi)}
function Xj(a,b,c,d){var e=firebase.SDK_VERSION||null;return Jf()?new Gj(a,b,c,e,void 0,void 0,d):new Li(a,b,c,e,d)}Uj.prototype.reset=function(){this.f=!1;this.a.Ja(this.i);this.a=Xj(this.v,this.l,this.u)};function Yj(a){a.f||(a.f=!0,a.a.ua(a.i));var b=a.a;return a.a.ba().s(function(c){a.a==b&&a.reset();throw c;})}function Zj(a){a.a.Cb()&&Yj(a).s(function(b){var c=new wh("unknown",null,null,null,new N("operation-not-supported-in-this-environment"));ak(b)&&a.m(c)});a.a.xb()||bk(a.c)}
Uj.prototype.subscribe=function(a){Ha(this.h,a)||this.h.push(a);if(!this.f){var b=this;Tj(this.g).then(function(a){a?Sj(b.g).then(function(){Yj(b).s(function(a){var c=new wh("unknown",null,null,null,new N("operation-not-supported-in-this-environment"));ak(a)&&b.m(c)})}):Zj(b)}).s(function(){Zj(b)})}};Uj.prototype.unsubscribe=function(a){Ja(this.h,function(b){return b==a})};
Uj.prototype.m=function(a){if(!a)throw new N("invalid-auth-event");for(var b=!1,c=0;c<this.h.length;c++){var d=this.h[c];if(d.ob(a.b,a.c)){(b=this.b[a.b])&&b.h(a,d);b=!0;break}}bk(this.c);return b};var ck=new $f(2E3,1E4),dk=new $f(3E4,6E4);Uj.prototype.aa=function(){return this.c.aa()};function ek(a,b,c,d,e,f){return a.a.ub(b,c,d,function(){a.f||(a.f=!0,a.a.ua(a.i))},function(){a.reset()},e,f)}function ak(a){return a&&"auth/cordova-not-ready"==a.code?!0:!1}
Uj.prototype.Aa=function(a,b,c){var d=this,e;return Rj(this.g).then(function(){return d.a.Aa(a,b,c).s(function(a){if(ak(a))throw new N("operation-not-supported-in-this-environment");e=a;return Sj(d.g).then(function(){throw e;})}).then(function(){return d.a.Db()?new z(function(){}):Sj(d.g).then(function(){return d.aa()}).then(function(){}).s(function(){})})})};Uj.prototype.Ca=function(a,b,c,d){return this.a.Ca(c,function(c){a.fa(b,null,c,d)},ck.get())};var fk={};
function gk(a,b,c){var d=b+":"+c;fk[d]||(fk[d]=new Uj(a,b,c));return fk[d]}function Vj(){this.b=null;this.f=[];this.c=[];this.a=null;this.g=!1}Vj.prototype.reset=function(){this.b=null;this.a&&(this.a.cancel(),this.a=null)};
Vj.prototype.h=function(a,b){if(!a)return B(new N("invalid-auth-event"));this.reset();this.g=!0;var c=a.b,d=a.c,e=a.a&&"auth/web-storage-unsupported"==a.a.code,f=a.a&&"auth/operation-not-supported-in-this-environment"==a.a.code;"unknown"!=c||e||f?a.a?(hk(this,!0,null,a.a),a=A()):a=b.va(c,d)?ik(this,a,b):B(new N("invalid-auth-event")):(hk(this,!1,null,null),a=A());return a};function bk(a){a.g||(a.g=!0,hk(a,!1,null,null))}
function ik(a,b,c){c=c.va(b.b,b.c);var d=b.f,e=b.g,f=!!b.b.match(/Redirect$/);return c(d,e).then(function(b){hk(a,f,b,null)}).s(function(b){hk(a,f,null,b)})}function jk(a,b){a.b=function(){return B(b)};if(a.c.length)for(var c=0;c<a.c.length;c++)a.c[c](b)}function kk(a,b){a.b=function(){return A(b)};if(a.f.length)for(var c=0;c<a.f.length;c++)a.f[c](b)}function hk(a,b,c,d){b?d?jk(a,d):kk(a,c):kk(a,{user:null});a.f=[];a.c=[]}
Vj.prototype.aa=function(){var a=this;return new z(function(b,c){a.b?a.b().then(b,c):(a.f.push(b),a.c.push(c),lk(a))})};function lk(a){var b=new N("timeout");a.a&&a.a.cancel();a.a=sd(dk.get()).then(function(){a.b||hk(a,!0,null,b)})}function Wj(){}Wj.prototype.h=function(a,b){if(!a)return B(new N("invalid-auth-event"));var c=a.b,d=a.c;a.a?(b.fa(a.b,null,a.a,a.c),a=A()):a=b.va(c,d)?mk(a,b):B(new N("invalid-auth-event"));return a};
function mk(a,b){var c=a.c,d=a.b;return b.va(d,c)(a.f,a.g).then(function(a){b.fa(d,a,null,c)}).s(function(a){b.fa(d,null,a,c)})};function nk(a,b){this.a=b;M(this,"verificationId",a)}nk.prototype.confirm=function(a){a=th(this.verificationId,a);return this.a(a)};function ok(a,b,c,d){return(new rh(a)).Qa(b,c).then(function(a){return new nk(a,d)})};function pk(a,b,c,d,e,f){this.h=a;this.i=b;this.g=c;this.c=d;this.f=e;this.l=!!f;this.b=null;this.a=this.c;if(this.f<this.c)throw Error("Proactive refresh lower bound greater than upper bound!");}pk.prototype.start=function(){this.a=this.c;qk(this,!0)};function rk(a,b){if(b)return a.a=a.c,a.g();b=a.a;a.a*=2;a.a>a.f&&(a.a=a.f);return b}
function qk(a,b){sk(a);a.b=sd(rk(a,b)).then(function(){return a.l?A():bg()}).then(function(){return a.h()}).then(function(){qk(a,!0)}).s(function(b){a.i(b)&&qk(a,!1)})}function sk(a){a.b&&(a.b.cancel(),a.b=null)};function tk(a){this.f=a;this.b=this.a=null;this.c=0}tk.prototype.B=function(){return{apiKey:this.f.b,refreshToken:this.a,accessToken:this.b,expirationTime:this.c}};function uk(a,b){var c=b[O],d=b.refreshToken;b=vk(b.expiresIn);a.b=c;a.c=b;a.a=d}function vk(a){return na()+1E3*parseInt(a,10)}
function wk(a,b){return Oh(a.f,b).then(function(b){a.b=b.access_token;a.c=vk(b.expires_in);a.a=b.refresh_token;return{accessToken:a.b,expirationTime:a.c,refreshToken:a.a}}).s(function(b){"auth/user-token-expired"==b.code&&(a.a=null);throw b;})}tk.prototype.getToken=function(a){a=!!a;return this.b&&!this.a?B(new N("user-token-expired")):a||!this.b||na()>this.c-3E4?this.a?wk(this,{grant_type:"refresh_token",refresh_token:this.a}):A(null):A({accessToken:this.b,expirationTime:this.c,refreshToken:this.a})};function xk(a,b){this.a=a||null;this.b=b||null;gg(this,{lastSignInTime:cg(b||null),creationTime:cg(a||null)})}function yk(a){return new xk(a.a,a.b)}xk.prototype.B=function(){return{lastLoginAt:this.b,createdAt:this.a}};function zk(a,b,c,d,e,f){gg(this,{uid:a,displayName:d||null,photoURL:e||null,email:c||null,phoneNumber:f||null,providerId:b})}function Ak(a,b){C.call(this,a);for(var c in b)this[c]=b[c]}t(Ak,C);
function Bk(a,b,c){this.A=[];this.G=a.apiKey;this.o=a.appName;this.w=a.authDomain||null;a=firebase.SDK_VERSION?Of(firebase.SDK_VERSION):null;this.c=new Ch(this.G,xi(yi),a);this.h=new tk(this.c);Ck(this,b[O]);uk(this.h,b);M(this,"refreshToken",this.h.a);Dk(this,c||{});F.call(this);this.I=!1;this.w&&Rf()&&(this.a=gk(this.w,this.G,this.o));this.N=[];this.i=null;this.l=Ek(this);this.U=r(this.Ga,this);var d=this;this.ha=null;this.ra=function(a){d.na(a.h)};this.W=null;this.R=[];this.qa=function(a){Fk(d,
a.f)};this.V=null}t(Bk,F);Bk.prototype.na=function(a){this.ha=a;Ih(this.c,a)};Bk.prototype.$=function(){return this.ha};function Gk(a,b){a.W&&E(a.W,"languageCodeChanged",a.ra);(a.W=b)&&cd(b,"languageCodeChanged",a.ra)}function Fk(a,b){a.R=b;Jh(a.c,firebase.SDK_VERSION?Of(firebase.SDK_VERSION,a.R):null)}Bk.prototype.Ka=function(){return La(this.R)};function Hk(a,b){a.V&&E(a.V,"frameworkChanged",a.qa);(a.V=b)&&cd(b,"frameworkChanged",a.qa)}Bk.prototype.Ga=function(){this.l.b&&(sk(this.l),this.l.start())};
function Ik(a){try{return firebase.app(a.o).auth()}catch(b){throw new N("internal-error","No firebase.auth.Auth instance is available for the Firebase App '"+a.o+"'!");}}function Ek(a){return new pk(function(){return a.F(!0)},function(a){return a&&"auth/network-request-failed"==a.code?!0:!1},function(){var b=a.h.c-na()-3E5;return 0<b?b:0},3E4,96E4,!1)}function Jk(a){a.m||a.l.b||(a.l.start(),E(a,"tokenChanged",a.U),cd(a,"tokenChanged",a.U))}function Kk(a){E(a,"tokenChanged",a.U);sk(a.l)}
function Ck(a,b){a.pa=b;M(a,"_lat",b)}function Lk(a,b){Ja(a.N,function(a){return a==b})}function Mk(a){for(var b=[],c=0;c<a.N.length;c++)b.push(a.N[c](a));return Ob(b).then(function(){return a})}function Nk(a){a.a&&!a.I&&(a.I=!0,a.a.subscribe(a))}
function Dk(a,b){gg(a,{uid:b.uid,displayName:b.displayName||null,photoURL:b.photoURL||null,email:b.email||null,emailVerified:b.emailVerified||!1,phoneNumber:b.phoneNumber||null,isAnonymous:b.isAnonymous||!1,metadata:new xk(b.createdAt,b.lastLoginAt),providerData:[]})}M(Bk.prototype,"providerId","firebase");function Ok(){}function Pk(a){return A().then(function(){if(a.m)throw new N("app-deleted");})}function Qk(a){return Da(a.providerData,function(a){return a.providerId})}
function Rk(a,b){b&&(Sk(a,b.providerId),a.providerData.push(b))}function Sk(a,b){Ja(a.providerData,function(a){return a.providerId==b})}function Tk(a,b,c){("uid"!=b||c)&&a.hasOwnProperty(b)&&M(a,b,c)}
function Uk(a,b){a!=b&&(gg(a,{uid:b.uid,displayName:b.displayName,photoURL:b.photoURL,email:b.email,emailVerified:b.emailVerified,phoneNumber:b.phoneNumber,isAnonymous:b.isAnonymous,providerData:[]}),b.metadata?M(a,"metadata",yk(b.metadata)):M(a,"metadata",new xk),w(b.providerData,function(b){Rk(a,b)}),a.h=b.h,M(a,"refreshToken",a.h.a))}h=Bk.prototype;h.reload=function(){var a=this;return R(this,Pk(this).then(function(){return Vk(a).then(function(){return Mk(a)}).then(Ok)}))};
function Vk(a){return a.F().then(function(b){var c=a.isAnonymous;return Wk(a,b).then(function(){c||Tk(a,"isAnonymous",!1);return b})})}h.F=function(a){var b=this;return R(this,Pk(this).then(function(){return b.h.getToken(a)}).then(function(a){if(!a)throw new N("internal-error");a.accessToken!=b.pa&&(Ck(b,a.accessToken),G(b,new Ak("tokenChanged")));Tk(b,"refreshToken",a.refreshToken);return a.accessToken}))};
h.getToken=function(a){dg["firebase.User.prototype.getToken is deprecated. Please use firebase.User.prototype.getIdToken instead."]||(dg["firebase.User.prototype.getToken is deprecated. Please use firebase.User.prototype.getIdToken instead."]=!0,"undefined"!==typeof console&&"function"===typeof console.warn&&console.warn("firebase.User.prototype.getToken is deprecated. Please use firebase.User.prototype.getIdToken instead."));return this.F(a)};
function Xk(a,b){b[O]&&a.pa!=b[O]&&(uk(a.h,b),G(a,new Ak("tokenChanged")),Ck(a,b[O]),Tk(a,"refreshToken",a.h.a))}function Wk(a,b){return Q(a.c,ti,{idToken:b}).then(r(a.gc,a))}
h.gc=function(a){a=a.users;if(!a||!a.length)throw new N("internal-error");a=a[0];Dk(this,{uid:a.localId,displayName:a.displayName,photoURL:a.photoUrl,email:a.email,emailVerified:!!a.emailVerified,phoneNumber:a.phoneNumber,lastLoginAt:a.lastLoginAt,createdAt:a.createdAt});for(var b=Yk(a),c=0;c<b.length;c++)Rk(this,b[c]);Tk(this,"isAnonymous",!(this.email&&a.passwordHash)&&!(this.providerData&&this.providerData.length))};
function Yk(a){return(a=a.providerUserInfo)&&a.length?Da(a,function(a){return new zk(a.rawId,a.providerId,a.email,a.displayName,a.photoUrl,a.phoneNumber)}):[]}h.Za=function(a){var b=this,c=null;return R(this,a.c(this.c,this.uid).then(function(a){Xk(b,a);c=Zk(b,a,"reauthenticate");b.i=null;return b.reload()}).then(function(){return c}),!0)};h.hc=function(a){return this.Za(a).then(function(){})};
function $k(a,b){return Vk(a).then(function(){if(Ha(Qk(a),b))return Mk(a).then(function(){throw new N("provider-already-linked");})})}h.Xa=function(a){var b=this,c=null;return R(this,$k(this,a.providerId).then(function(){return b.F()}).then(function(c){return a.b(b.c,c)}).then(function(a){c=Zk(b,a,"link");return al(b,a)}).then(function(){return c}))};h.Zb=function(a){return this.Xa(a).then(function(a){return a.user})};
h.$b=function(a,b){var c=this;return R(this,$k(this,"phone").then(function(){return ok(Ik(c),a,b,r(c.Xa,c))}))};h.ic=function(a,b){var c=this;return R(this,A().then(function(){return ok(Ik(c),a,b,r(c.Za,c))}),!0)};function Zk(a,b,c){var d=uh(b);b=Mg(b);return hg({user:a,credential:d,additionalUserInfo:b,operationType:c})}function al(a,b){Xk(a,b);return a.reload().then(function(){return a})}
h.kb=function(a){var b=this;return R(this,this.F().then(function(c){return b.c.kb(c,a)}).then(function(a){Xk(b,a);return b.reload()}))};h.zc=function(a){var b=this;return R(this,this.F().then(function(c){return a.b(b.c,c)}).then(function(a){Xk(b,a);return b.reload()}))};h.lb=function(a){var b=this;return R(this,this.F().then(function(c){return b.c.lb(c,a)}).then(function(a){Xk(b,a);return b.reload()}))};
h.mb=function(a){if(void 0===a.displayName&&void 0===a.photoURL)return Pk(this);var b=this;return R(this,this.F().then(function(c){return b.c.mb(c,{displayName:a.displayName,photoUrl:a.photoURL})}).then(function(a){Xk(b,a);Tk(b,"displayName",a.displayName||null);Tk(b,"photoURL",a.photoUrl||null);w(b.providerData,function(a){"password"===a.providerId&&(M(a,"displayName",b.displayName),M(a,"photoURL",b.photoURL))});return Mk(b)}).then(Ok))};
h.yc=function(a){var b=this;return R(this,Vk(this).then(function(c){return Ha(Qk(b),a)?fi(b.c,c,[a]).then(function(a){var c={};w(a.providerUserInfo||[],function(a){c[a.providerId]=!0});w(Qk(b),function(a){c[a]||Sk(b,a)});c[rh.PROVIDER_ID]||M(b,"phoneNumber",null);return Mk(b)}):Mk(b).then(function(){throw new N("no-such-provider");})}))};
h.delete=function(){var a=this;return R(this,this.F().then(function(b){return Q(a.c,si,{idToken:b})}).then(function(){G(a,new Ak("userDeleted"))})).then(function(){for(var b=0;b<a.A.length;b++)a.A[b].cancel("app-deleted");Gk(a,null);Hk(a,null);a.A=[];a.m=!0;Kk(a);M(a,"refreshToken",null);a.a&&a.a.unsubscribe(a)})};
h.ob=function(a,b){return"linkViaPopup"==a&&(this.g||null)==b&&this.f||"reauthViaPopup"==a&&(this.g||null)==b&&this.f||"linkViaRedirect"==a&&(this.Z||null)==b||"reauthViaRedirect"==a&&(this.Z||null)==b?!0:!1};h.fa=function(a,b,c,d){"linkViaPopup"!=a&&"reauthViaPopup"!=a||d!=(this.g||null)||(c&&this.v?this.v(c):b&&!c&&this.f&&this.f(b),this.b&&(this.b.cancel(),this.b=null),delete this.f,delete this.v)};
h.va=function(a,b){return"linkViaPopup"==a&&b==(this.g||null)?r(this.sb,this):"reauthViaPopup"==a&&b==(this.g||null)?r(this.tb,this):"linkViaRedirect"==a&&(this.Z||null)==b?r(this.sb,this):"reauthViaRedirect"==a&&(this.Z||null)==b?r(this.tb,this):null};h.ac=function(a){var b=this;return bl(this,"linkViaPopup",a,function(){return $k(b,a.providerId).then(function(){return Mk(b)})},!1)};h.jc=function(a){return bl(this,"reauthViaPopup",a,function(){return A()},!0)};
function bl(a,b,c,d,e){if(!Rf())return B(new N("operation-not-supported-in-this-environment"));if(a.i&&!e)return B(a.i);var f=Lg(c.providerId),g=Qf(a.uid+":::"),l=null;(!Tf()||Lf())&&a.w&&c.isOAuthProvider&&(l=Ri(a.w,a.G,a.o,b,c,null,g,firebase.SDK_VERSION||null));var n=Df(l,f&&f.za,f&&f.ya);d=d().then(function(){cl(a);if(!e)return a.F().then(function(){})}).then(function(){return ek(a.a,n,b,c,g,!!l)}).then(function(){return new z(function(c,d){a.fa(b,null,new N("cancelled-popup-request"),a.g||null);
a.f=c;a.v=d;a.g=g;a.b=a.a.Ca(a,b,n,g)})}).then(function(a){n&&Cf(n);return a?hg(a):null}).s(function(a){n&&Cf(n);throw a;});return R(a,d,e)}h.bc=function(a){var b=this;return dl(this,"linkViaRedirect",a,function(){return $k(b,a.providerId)},!1)};h.kc=function(a){return dl(this,"reauthViaRedirect",a,function(){return A()},!0)};
function dl(a,b,c,d,e){if(!Rf())return B(new N("operation-not-supported-in-this-environment"));if(a.i&&!e)return B(a.i);var f=null,g=Qf(a.uid+":::");d=d().then(function(){cl(a);if(!e)return a.F().then(function(){})}).then(function(){a.Z=g;return Mk(a)}).then(function(b){a.ca&&(b=a.ca,b=b.b.set(el,a.B(),b.a));return b}).then(function(){return a.a.Aa(b,c,g)}).s(function(b){f=b;if(a.ca)return fl(a.ca);throw f;}).then(function(){if(f)throw f;});return R(a,d,e)}
function cl(a){if(!a.a||!a.I){if(a.a&&!a.I)throw new N("internal-error");throw new N("auth-domain-config-required");}}h.sb=function(a,b){var c=this;this.b&&(this.b.cancel(),this.b=null);var d=null,e=this.F().then(function(d){return Zg(c.c,{requestUri:a,sessionId:b,idToken:d})}).then(function(a){d=Zk(c,a,"link");return al(c,a)}).then(function(){return d});return R(this,e)};
h.tb=function(a,b){var c=this;this.b&&(this.b.cancel(),this.b=null);var d=null,e=A().then(function(){return Vg($g(c.c,{requestUri:a,sessionId:b}),c.uid)}).then(function(a){d=Zk(c,a,"reauthenticate");Xk(c,a);c.i=null;return c.reload()}).then(function(){return d});return R(this,e,!0)};h.bb=function(a){var b=this,c=null;return R(this,this.F().then(function(b){c=b;return"undefined"===typeof a||Sa(a)?{}:Fg(new wg(a))}).then(function(a){return b.c.bb(c,a)}).then(function(a){if(b.email!=a)return b.reload()}).then(function(){}))};
function R(a,b,c){var d=gl(a,b,c);a.A.push(d);Qb(d,function(){Ia(a.A,d)});return d}function gl(a,b,c){return a.i&&!c?(b.cancel(),B(a.i)):b.s(function(b){!b||"auth/user-disabled"!=b.code&&"auth/user-token-expired"!=b.code||(a.i||G(a,new Ak("userInvalidated")),a.i=b);throw b;})}h.toJSON=function(){return this.B()};
h.B=function(){var a={uid:this.uid,displayName:this.displayName,photoURL:this.photoURL,email:this.email,emailVerified:this.emailVerified,phoneNumber:this.phoneNumber,isAnonymous:this.isAnonymous,providerData:[],apiKey:this.G,appName:this.o,authDomain:this.w,stsTokenManager:this.h.B(),redirectEventId:this.Z||null};this.metadata&&Wa(a,this.metadata.B());w(this.providerData,function(b){a.providerData.push(ig(b))});return a};
function hl(a){if(!a.apiKey)return null;var b={apiKey:a.apiKey,authDomain:a.authDomain,appName:a.appName},c={};if(a.stsTokenManager&&a.stsTokenManager.accessToken&&a.stsTokenManager.expirationTime)c[O]=a.stsTokenManager.accessToken,c.refreshToken=a.stsTokenManager.refreshToken||null,c.expiresIn=(a.stsTokenManager.expirationTime-na())/1E3;else return null;var d=new Bk(b,c,a);a.providerData&&w(a.providerData,function(a){a&&Rk(d,hg(a))});a.redirectEventId&&(d.Z=a.redirectEventId);return d}
function il(a,b,c,d){var e=new Bk(a,b);c&&(e.ca=c);d&&Fk(e,d);return e.reload().then(function(){return e})};function jl(a){this.a=a;this.b=rj()}var el={name:"redirectUser",C:"session"};function fl(a){return uj(a.b,el,a.a)}function kl(a,b){return a.b.get(el,a.a).then(function(a){a&&b&&(a.authDomain=b);return hl(a||{})})};function ll(a,b){this.a=a;this.b=b||rj();this.c=null;this.f=ml(this);vj(this.b,yj("local"),this.a,r(this.g,this))}ll.prototype.g=function(){var a=this,b=yj("local");nl(this,function(){return A().then(function(){return a.c&&"local"!=a.c.C?a.b.get(b,a.a):null}).then(function(c){if(c)return ol(a,"local").then(function(){a.c=b})})})};function ol(a,b){var c=[],d;for(d in nj)nj[d]!==b&&c.push(uj(a.b,yj(nj[d]),a.a));c.push(uj(a.b,pl,a.a));return Nb(c)}
function ml(a){var b=yj("local"),c=yj("session"),d=yj("none");return a.b.get(c,a.a).then(function(e){return e?c:a.b.get(d,a.a).then(function(c){return c?d:a.b.get(b,a.a).then(function(c){return c?b:a.b.get(pl,a.a).then(function(a){return a?yj(a):b})})})}).then(function(b){a.c=b;return ol(a,b.C)}).s(function(){a.c||(a.c=b)})}var pl={name:"persistence",C:"session"};function yj(a){return{name:"authUser",C:a}}
ll.prototype.eb=function(a){var b=null,c=this;oj(a);return nl(this,function(){return a!=c.c.C?c.b.get(c.c,c.a).then(function(d){b=d;return ol(c,a)}).then(function(){c.c=yj(a);if(b)return c.b.set(c.c,b,c.a)}):A()})};function ql(a){return nl(a,function(){return a.b.set(pl,a.c.C,a.a)})}function rl(a,b){return nl(a,function(){return a.b.set(a.c,b.B(),a.a)})}function sl(a){return nl(a,function(){return uj(a.b,a.c,a.a)})}
function tl(a,b){return nl(a,function(){return a.b.get(a.c,a.a).then(function(a){a&&b&&(a.authDomain=b);return hl(a||{})})})}function nl(a,b){a.f=a.f.then(b,b);return a.f};function ul(a){this.l=!1;M(this,"app",a);if(S(this).options&&S(this).options.apiKey)a=firebase.SDK_VERSION?Of(firebase.SDK_VERSION):null,this.c=new Ch(S(this).options&&S(this).options.apiKey,xi(yi),a);else throw new N("invalid-api-key");this.N=[];this.m=[];this.I=[];this.Gb=firebase.INTERNAL.createSubscribe(r(this.Xb,this));this.R=void 0;this.Hb=firebase.INTERNAL.createSubscribe(r(this.Yb,this));vl(this,null);this.h=new ll(S(this).options.apiKey+":"+S(this).name);this.G=new jl(S(this).options.apiKey+
":"+S(this).name);this.U=T(this,wl(this));this.i=T(this,xl(this));this.W=!1;this.ha=r(this.uc,this);this.Ga=r(this.ka,this);this.pa=r(this.Pb,this);this.qa=r(this.Vb,this);this.ra=r(this.Wb,this);yl(this);this.INTERNAL={};this.INTERNAL["delete"]=r(this.delete,this);this.INTERNAL.logFramework=r(this.cc,this);this.o=0;F.call(this);zl(this);this.A=[]}t(ul,F);function Al(a){C.call(this,"languageCodeChanged");this.h=a}t(Al,C);function Bl(a){C.call(this,"frameworkChanged");this.f=a}t(Bl,C);h=ul.prototype;
h.eb=function(a){a=this.h.eb(a);return T(this,a)};h.na=function(a){this.V===a||this.l||(this.V=a,Ih(this.c,this.V),G(this,new Al(this.$())))};h.$=function(){return this.V};h.Ac=function(){var a=k.navigator;this.na(a?a.languages&&a.languages[0]||a.language||a.userLanguage||null:null)};h.cc=function(a){this.A.push(a);Jh(this.c,firebase.SDK_VERSION?Of(firebase.SDK_VERSION,this.A):null);G(this,new Bl(this.A))};h.Ka=function(){return La(this.A)};
function zl(a){Object.defineProperty(a,"lc",{get:function(){return this.$()},set:function(a){this.na(a)},enumerable:!1});a.V=null}h.toJSON=function(){return{apiKey:S(this).options.apiKey,authDomain:S(this).options.authDomain,appName:S(this).name,currentUser:U(this)&&U(this).B()}};function Cl(a){return a.Fb||B(new N("auth-domain-config-required"))}
function yl(a){var b=S(a).options.authDomain,c=S(a).options.apiKey;b&&Rf()&&(a.Fb=a.U.then(function(){if(!a.l){a.a=gk(b,c,S(a).name);a.a.subscribe(a);U(a)&&Nk(U(a));if(a.w){Nk(a.w);var d=a.w;d.na(a.$());Gk(d,a);d=a.w;Fk(d,a.A);Hk(d,a);a.w=null}return a.a}}))}h.ob=function(a,b){switch(a){case "unknown":case "signInViaRedirect":return!0;case "signInViaPopup":return this.g==b&&!!this.f;default:return!1}};
h.fa=function(a,b,c,d){"signInViaPopup"==a&&this.g==d&&(c&&this.v?this.v(c):b&&!c&&this.f&&this.f(b),this.b&&(this.b.cancel(),this.b=null),delete this.f,delete this.v)};h.va=function(a,b){return"signInViaRedirect"==a||"signInViaPopup"==a&&this.g==b&&this.f?r(this.Ob,this):null};
h.Ob=function(a,b){var c=this;a={requestUri:a,sessionId:b};this.b&&(this.b.cancel(),this.b=null);var d=null,e=null,f=Xg(c.c,a).then(function(a){d=uh(a);e=Mg(a);return a});a=c.U.then(function(){return f}).then(function(a){return Dl(c,a)}).then(function(){return hg({user:U(c),credential:d,additionalUserInfo:e,operationType:"signIn"})});return T(this,a)};
h.sc=function(a){if(!Rf())return B(new N("operation-not-supported-in-this-environment"));var b=this,c=Lg(a.providerId),d=Qf(),e=null;(!Tf()||Lf())&&S(this).options.authDomain&&a.isOAuthProvider&&(e=Ri(S(this).options.authDomain,S(this).options.apiKey,S(this).name,"signInViaPopup",a,null,d,firebase.SDK_VERSION||null));var f=Df(e,c&&c.za,c&&c.ya);c=Cl(this).then(function(b){return ek(b,f,"signInViaPopup",a,d,!!e)}).then(function(){return new z(function(a,c){b.fa("signInViaPopup",null,new N("cancelled-popup-request"),
b.g);b.f=a;b.v=c;b.g=d;b.b=b.a.Ca(b,"signInViaPopup",f,d)})}).then(function(a){f&&Cf(f);return a?hg(a):null}).s(function(a){f&&Cf(f);throw a;});return T(this,c)};h.tc=function(a){if(!Rf())return B(new N("operation-not-supported-in-this-environment"));var b=this,c=Cl(this).then(function(){return ql(b.h)}).then(function(){return b.a.Aa("signInViaRedirect",a)});return T(this,c)};
h.aa=function(){if(!Rf())return B(new N("operation-not-supported-in-this-environment"));var a=this,b=Cl(this).then(function(){return a.a.aa()}).then(function(a){return a?hg(a):null});return T(this,b)};function Dl(a,b){var c={};c.apiKey=S(a).options.apiKey;c.authDomain=S(a).options.authDomain;c.appName=S(a).name;return a.U.then(function(){return il(c,b,a.G,a.Ka())}).then(function(b){if(U(a)&&b.uid==U(a).uid)return Uk(U(a),b),a.ka(b);vl(a,b);Nk(b);return a.ka(b)}).then(function(){El(a)})}
function vl(a,b){U(a)&&(Lk(U(a),a.Ga),E(U(a),"tokenChanged",a.pa),E(U(a),"userDeleted",a.qa),E(U(a),"userInvalidated",a.ra),Kk(U(a)));b&&(b.N.push(a.Ga),cd(b,"tokenChanged",a.pa),cd(b,"userDeleted",a.qa),cd(b,"userInvalidated",a.ra),0<a.o&&Jk(b));M(a,"currentUser",b);b&&(b.na(a.$()),Gk(b,a),Fk(b,a.A),Hk(b,a))}h.hb=function(){var a=this,b=this.i.then(function(){if(!U(a))return A();vl(a,null);return sl(a.h).then(function(){El(a)})});return T(this,b)};
function Fl(a){var b=kl(a.G,S(a).options.authDomain).then(function(b){if(a.w=b)b.ca=a.G;return fl(a.G)});return T(a,b)}function wl(a){var b=S(a).options.authDomain,c=Fl(a).then(function(){return tl(a.h,b)}).then(function(b){return b?(b.ca=a.G,a.w&&(a.w.Z||null)==(b.Z||null)?b:b.reload().then(function(){return rl(a.h,b).then(function(){return b})}).s(function(c){return"auth/network-request-failed"==c.code?b:sl(a.h)})):null}).then(function(b){vl(a,b||null)});return T(a,c)}
function xl(a){return a.U.then(function(){return a.aa()}).s(function(){}).then(function(){if(!a.l)return a.ha()}).s(function(){}).then(function(){if(!a.l){a.W=!0;var b=a.h;vj(b.b,yj("local"),b.a,a.ha)}})}
h.uc=function(){var a=this;return tl(this.h,S(this).options.authDomain).then(function(b){if(!a.l){var c;if(c=U(a)&&b){c=U(a).uid;var d=b.uid;c=void 0===c||null===c||""===c||void 0===d||null===d||""===d?!1:c==d}if(c)return Uk(U(a),b),U(a).F();if(U(a)||b)vl(a,b),b&&(Nk(b),b.ca=a.G),a.a&&a.a.subscribe(a),El(a)}})};h.ka=function(a){return rl(this.h,a)};h.Pb=function(){El(this);this.ka(U(this))};h.Vb=function(){this.hb()};h.Wb=function(){this.hb()};
function Gl(a,b){var c=null,d=null;return T(a,b.then(function(b){c=uh(b);d=Mg(b);return Dl(a,b)}).then(function(){return hg({user:U(a),credential:c,additionalUserInfo:d,operationType:"signIn"})}))}h.Xb=function(a){var b=this;this.addAuthTokenListener(function(){a.next(U(b))})};h.Yb=function(a){var b=this;Hl(this,function(){a.next(U(b))})};h.ec=function(a,b,c){var d=this;this.W&&firebase.Promise.resolve().then(function(){p(a)?a(U(d)):p(a.next)&&a.next(U(d))});return this.Gb(a,b,c)};
h.dc=function(a,b,c){var d=this;this.W&&firebase.Promise.resolve().then(function(){d.R=d.getUid();p(a)?a(U(d)):p(a.next)&&a.next(U(d))});return this.Hb(a,b,c)};h.Rb=function(a){var b=this,c=this.i.then(function(){return U(b)?U(b).F(a).then(function(a){return{accessToken:a}}):null});return T(this,c)};h.pc=function(a){var b=this;return this.i.then(function(){return Gl(b,Q(b.c,vi,{token:a}))}).then(function(a){a=a.user;Tk(a,"isAnonymous",!1);return b.ka(a)}).then(function(){return U(b)})};
h.qc=function(a,b){var c=this;return this.i.then(function(){return Gl(c,Q(c.c,kh,{email:a,password:b}))}).then(function(a){return a.user})};h.Kb=function(a,b){var c=this;return this.i.then(function(){return Gl(c,Q(c.c,ri,{email:a,password:b}))}).then(function(a){return a.user})};h.oc=function(a){return this.fb(a).then(function(a){return a.user})};h.fb=function(a){var b=this;return this.i.then(function(){return Gl(b,a.wa(b.c))})};
h.gb=function(){var a=this;return this.i.then(function(){var b=U(a);return b&&b.isAnonymous?b:Gl(a,a.c.gb()).then(function(b){b=b.user;Tk(b,"isAnonymous",!0);return a.ka(b)}).then(function(){return U(a)})})};function S(a){return a.app}function U(a){return a.currentUser}h.getUid=function(){return U(this)&&U(this).uid||null};function Il(a){return U(a)&&U(a)._lat||null}
function El(a){if(a.W){for(var b=0;b<a.m.length;b++)if(a.m[b])a.m[b](Il(a));if(a.R!==a.getUid()&&a.I.length)for(a.R=a.getUid(),b=0;b<a.I.length;b++)if(a.I[b])a.I[b](Il(a))}}h.Ib=function(a){this.addAuthTokenListener(a);this.o++;0<this.o&&U(this)&&Jk(U(this))};h.mc=function(a){var b=this;w(this.m,function(c){c==a&&b.o--});0>this.o&&(this.o=0);0==this.o&&U(this)&&Kk(U(this));this.removeAuthTokenListener(a)};
h.addAuthTokenListener=function(a){var b=this;this.m.push(a);T(this,this.i.then(function(){b.l||Ha(b.m,a)&&a(Il(b))}))};h.removeAuthTokenListener=function(a){Ja(this.m,function(b){return b==a})};function Hl(a,b){a.I.push(b);T(a,a.i.then(function(){!a.l&&Ha(a.I,b)&&a.R!==a.getUid()&&(a.R=a.getUid(),b(Il(a)))}))}h.delete=function(){this.l=!0;for(var a=0;a<this.N.length;a++)this.N[a].cancel("app-deleted");this.N=[];this.h&&(a=this.h,xj(a.b,a.a,this.ha));this.a&&this.a.unsubscribe(this);return firebase.Promise.resolve()};
function T(a,b){a.N.push(b);Qb(b,function(){Ia(a.N,b)});return b}h.Nb=function(a){return T(this,Th(this.c,a))};h.Bc=function(a){return this.Ia(a).then(function(a){return a.data.email})};h.Ta=function(a,b){return T(this,this.c.Ta(a,b).then(function(){}))};h.Ia=function(a){return T(this,this.c.Ia(a).then(function(a){return new lg(a)}))};h.Sa=function(a){return T(this,this.c.Sa(a).then(function(){}))};
h.cb=function(a,b){var c=this;return T(this,A().then(function(){return"undefined"===typeof b||Sa(b)?{}:Fg(new wg(b))}).then(function(b){return c.c.cb(a,b)}).then(function(){}))};h.rc=function(a,b){return T(this,ok(this,a,b,r(this.fb,this)))};function Jl(a,b,c,d){a:{c=Array.prototype.slice.call(c);var e=0;for(var f=!1,g=0;g<b.length;g++)if(b[g].optional)f=!0;else{if(f)throw new N("internal-error","Argument validator encountered a required argument after an optional argument.");e++}f=b.length;if(c.length<e||f<c.length)d="Expected "+(e==f?1==e?"1 argument":e+" arguments":e+"-"+f+" arguments")+" but got "+c.length+".";else{for(e=0;e<c.length;e++)if(f=b[e].optional&&void 0===c[e],!b[e].M(c[e])&&!f){b=b[e];if(0>e||e>=Kl.length)throw new N("internal-error",
"Argument validator received an unsupported number of arguments.");c=Kl[e];d=(d?"":c+" argument ")+(b.name?'"'+b.name+'" ':"")+"must be "+b.K+".";break a}d=null}}if(d)throw new N("argument-error",a+" failed: "+d);}var Kl="First Second Third Fourth Fifth Sixth Seventh Eighth Ninth".split(" ");function V(a,b){return{name:a||"",K:"a valid string",optional:!!b,M:m}}function Ll(){return{name:"opt_forceRefresh",K:"a boolean",optional:!0,M:ba}}
function W(a,b){return{name:a||"",K:"a valid object",optional:!!b,M:q}}function Ml(a,b){return{name:a||"",K:"a function",optional:!!b,M:p}}function Nl(a,b){return{name:a||"",K:"null",optional:!!b,M:ea}}function Ol(){return{name:"",K:"an HTML element",optional:!1,M:function(a){return!!(a&&a instanceof Element)}}}function Pl(){return{name:"auth",K:"an instance of Firebase Auth",optional:!0,M:function(a){return!!(a&&a instanceof ul)}}}
function Ql(){return{name:"app",K:"an instance of Firebase App",optional:!0,M:function(a){return!!(a&&a instanceof firebase.app.App)}}}function Rl(a){return{name:a?a+"Credential":"credential",K:a?"a valid "+a+" credential":"a valid credential",optional:!1,M:function(b){if(!b)return!1;var c=!a||b.providerId===a;return!(!b.wa||!c)}}}
function Sl(){return{name:"authProvider",K:"a valid Auth provider",optional:!1,M:function(a){return!!(a&&a.providerId&&a.hasOwnProperty&&a.hasOwnProperty("isOAuthProvider"))}}}function Tl(){return{name:"applicationVerifier",K:"an implementation of firebase.auth.ApplicationVerifier",optional:!1,M:function(a){return!!(a&&m(a.type)&&p(a.verify))}}}function X(a,b,c,d){return{name:c||"",K:a.K+" or "+b.K,optional:!!d,M:function(c){return a.M(c)||b.M(c)}}};function Ul(a,b,c,d,e,f){M(this,"type","recaptcha");this.b=this.c=null;this.m=!1;this.l=b;this.a=c||{theme:"light",type:"image"};this.g=[];if(this.a[Vl])throw new N("argument-error","sitekey should not be provided for reCAPTCHA as one is automatically provisioned for the current project.");this.h="invisible"===this.a[Wl];if(!wc(b)||!this.h&&wc(b).hasChildNodes())throw new N("argument-error","reCAPTCHA container is either not found or already contains inner elements!");this.u=new Ch(a,f||null,e||null);
this.o=d||function(){return null};var g=this;this.i=[];var l=this.a[Xl];this.a[Xl]=function(a){Yl(g,a);if("function"===typeof l)l(a);else if("string"===typeof l){var b=L(l,k);"function"===typeof b&&b(a)}};var n=this.a[Zl];this.a[Zl]=function(){Yl(g,null);if("function"===typeof n)n();else if("string"===typeof n){var a=L(n,k);"function"===typeof a&&a()}}}var Xl="callback",Zl="expired-callback",Vl="sitekey",Wl="size";function Yl(a,b){for(var c=0;c<a.i.length;c++)try{a.i[c](b)}catch(d){}}
function $l(a,b){Ja(a.i,function(a){return a==b})}function am(a,b){a.g.push(b);Qb(b,function(){Ia(a.g,b)});return b}h=Ul.prototype;
h.xa=function(){var a=this;return this.c?this.c:this.c=am(this,A().then(function(){if(Sf())return Hf();throw new N("operation-not-supported-in-this-environment","RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment.");}).then(function(){return bm(cm(),a.o())}).then(function(){return Q(a.u,ui,{})}).then(function(b){a.a[Vl]=b.recaptchaSiteKey}).s(function(b){a.c=null;throw b;}))};
h.render=function(){dm(this);var a=this;return am(this,this.xa().then(function(){if(null===a.b){var b=a.l;if(!a.h){var c=wc(b);b=zc("DIV");c.appendChild(b)}a.b=grecaptcha.render(b,a.a)}return a.b}))};h.verify=function(){dm(this);var a=this;return am(this,this.render().then(function(b){return new z(function(c){var d=grecaptcha.getResponse(b);if(d)c(d);else{var e=function(b){b&&($l(a,e),c(b))};a.i.push(e);a.h&&grecaptcha.execute(a.b)}})}))};h.reset=function(){dm(this);null!==this.b&&grecaptcha.reset(this.b)};
function dm(a){if(a.m)throw new N("internal-error","RecaptchaVerifier instance has been destroyed.");}h.clear=function(){dm(this);this.m=!0;cm().b--;for(var a=0;a<this.g.length;a++)this.g[a].cancel("RecaptchaVerifier instance has been destroyed.");if(!this.h){a=wc(this.l);for(var b;b=a.firstChild;)a.removeChild(b)}};var em=dc("https://www.google.com/recaptcha/api.js?onload=%{onload}&render=explicit&hl=%{hl}");
function fm(){this.b=k.grecaptcha?Infinity:0;this.c=null;this.a="__rcb"+Math.floor(1E6*Math.random()).toString()}
function bm(a,b){return new z(function(c,d){if(Zf())if(!k.grecaptcha||b!==a.c&&!a.b){k[a.a]=function(){if(k.grecaptcha){a.c=b;var e=k.grecaptcha.render;k.grecaptcha.render=function(b,c){b=e(b,c);a.b++;return b};c()}else d(new N("internal-error"));delete k[a.a]};var e=hc(em,{onload:a.a,hl:b||""});A(kf(e)).s(function(){d(new N("internal-error","Unable to load external reCAPTCHA dependencies!"))})}else c();else d(new N("network-request-failed"))})}var gm=null;
function cm(){gm||(gm=new fm);return gm}function hm(a,b,c){try{this.f=c||firebase.app()}catch(f){throw new N("argument-error","No firebase.app.App instance is currently initialized.");}if(this.f.options&&this.f.options.apiKey)c=this.f.options.apiKey;else throw new N("invalid-api-key");var d=this,e=null;try{e=this.f.auth().Ka()}catch(f){}e=firebase.SDK_VERSION?Of(firebase.SDK_VERSION,e):null;Ul.call(this,c,a,b,function(){try{var a=d.f.auth().$()}catch(g){a=null}return a},e,xi(yi))}t(hm,Ul);function Y(a,b){for(var c in b){var d=b[c].name;a[d]=im(d,a[c],b[c].j)}}function Z(a,b,c,d){a[b]=im(b,c,d)}function im(a,b,c){function d(){var a=Array.prototype.slice.call(arguments);Jl(e,c,a);return b.apply(this,a)}if(!c)return b;var e=jm(a),f;for(f in b)d[f]=b[f];for(f in b.prototype)d.prototype[f]=b.prototype[f];return d}function jm(a){a=a.split(".");return a[a.length-1]};Y(ul.prototype,{Sa:{name:"applyActionCode",j:[V("code")]},Ia:{name:"checkActionCode",j:[V("code")]},Ta:{name:"confirmPasswordReset",j:[V("code"),V("newPassword")]},Kb:{name:"createUserWithEmailAndPassword",j:[V("email"),V("password")]},Nb:{name:"fetchProvidersForEmail",j:[V("email")]},aa:{name:"getRedirectResult",j:[]},dc:{name:"onAuthStateChanged",j:[X(W(),Ml(),"nextOrObserver"),Ml("opt_error",!0),Ml("opt_completed",!0)]},ec:{name:"onIdTokenChanged",j:[X(W(),Ml(),"nextOrObserver"),Ml("opt_error",
!0),Ml("opt_completed",!0)]},cb:{name:"sendPasswordResetEmail",j:[V("email"),X(W("opt_actionCodeSettings",!0),Nl(null,!0),"opt_actionCodeSettings",!0)]},eb:{name:"setPersistence",j:[V("persistence")]},fb:{name:"signInAndRetrieveDataWithCredential",j:[Rl()]},gb:{name:"signInAnonymously",j:[]},oc:{name:"signInWithCredential",j:[Rl()]},pc:{name:"signInWithCustomToken",j:[V("token")]},qc:{name:"signInWithEmailAndPassword",j:[V("email"),V("password")]},rc:{name:"signInWithPhoneNumber",j:[V("phoneNumber"),
Tl()]},sc:{name:"signInWithPopup",j:[Sl()]},tc:{name:"signInWithRedirect",j:[Sl()]},hb:{name:"signOut",j:[]},toJSON:{name:"toJSON",j:[V(null,!0)]},Ac:{name:"useDeviceLanguage",j:[]},Bc:{name:"verifyPasswordResetCode",j:[V("code")]}});(function(a,b){for(var c in b){var d=b[c].name;if(d!==c){var e=b[c].Jb;Object.defineProperty(a,d,{get:function(){return this[c]},set:function(a){Jl(d,[e],[a],!0);this[c]=a},enumerable:!0})}}})(ul.prototype,{lc:{name:"languageCode",Jb:X(V(),Nl(),"languageCode")}});
ul.Persistence=nj;ul.Persistence.LOCAL="local";ul.Persistence.SESSION="session";ul.Persistence.NONE="none";
Y(Bk.prototype,{"delete":{name:"delete",j:[]},F:{name:"getIdToken",j:[Ll()]},getToken:{name:"getToken",j:[Ll()]},Xa:{name:"linkAndRetrieveDataWithCredential",j:[Rl()]},Zb:{name:"linkWithCredential",j:[Rl()]},$b:{name:"linkWithPhoneNumber",j:[V("phoneNumber"),Tl()]},ac:{name:"linkWithPopup",j:[Sl()]},bc:{name:"linkWithRedirect",j:[Sl()]},Za:{name:"reauthenticateAndRetrieveDataWithCredential",j:[Rl()]},hc:{name:"reauthenticateWithCredential",j:[Rl()]},ic:{name:"reauthenticateWithPhoneNumber",j:[V("phoneNumber"),
Tl()]},jc:{name:"reauthenticateWithPopup",j:[Sl()]},kc:{name:"reauthenticateWithRedirect",j:[Sl()]},reload:{name:"reload",j:[]},bb:{name:"sendEmailVerification",j:[X(W("opt_actionCodeSettings",!0),Nl(null,!0),"opt_actionCodeSettings",!0)]},toJSON:{name:"toJSON",j:[V(null,!0)]},yc:{name:"unlink",j:[V("provider")]},kb:{name:"updateEmail",j:[V("email")]},lb:{name:"updatePassword",j:[V("password")]},zc:{name:"updatePhoneNumber",j:[Rl("phone")]},mb:{name:"updateProfile",j:[W("profile")]}});
Y(z.prototype,{s:{name:"catch"},then:{name:"then"}});Y(nk.prototype,{confirm:{name:"confirm",j:[V("verificationCode")]}});Z(mh,"credential",function(a,b){return new jh(a,b)},[V("email"),V("password")]);Y(bh.prototype,{sa:{name:"addScope",j:[V("scope")]},Ba:{name:"setCustomParameters",j:[W("customOAuthParameters")]}});Z(bh,"credential",ch,[X(V(),W(),"token")]);Y(dh.prototype,{sa:{name:"addScope",j:[V("scope")]},Ba:{name:"setCustomParameters",j:[W("customOAuthParameters")]}});
Z(dh,"credential",eh,[X(V(),W(),"token")]);Y(fh.prototype,{sa:{name:"addScope",j:[V("scope")]},Ba:{name:"setCustomParameters",j:[W("customOAuthParameters")]}});Z(fh,"credential",gh,[X(V(),X(W(),Nl()),"idToken"),X(V(),Nl(),"accessToken",!0)]);Y(hh.prototype,{Ba:{name:"setCustomParameters",j:[W("customOAuthParameters")]}});Z(hh,"credential",ih,[X(V(),W(),"token"),V("secret",!0)]);
Y(P.prototype,{sa:{name:"addScope",j:[V("scope")]},credential:{name:"credential",j:[X(V(),Nl(),"idToken",!0),X(V(),Nl(),"accessToken",!0)]},Ba:{name:"setCustomParameters",j:[W("customOAuthParameters")]}});Z(rh,"credential",th,[V("verificationId"),V("verificationCode")]);Y(rh.prototype,{Qa:{name:"verifyPhoneNumber",j:[V("phoneNumber"),Tl()]}});Y(N.prototype,{toJSON:{name:"toJSON",j:[V(null,!0)]}});Y(zh.prototype,{toJSON:{name:"toJSON",j:[V(null,!0)]}});
Y(yh.prototype,{toJSON:{name:"toJSON",j:[V(null,!0)]}});Y(hm.prototype,{clear:{name:"clear",j:[]},render:{name:"render",j:[]},verify:{name:"verify",j:[]}});
(function(){if("undefined"!==typeof firebase&&firebase.INTERNAL&&firebase.INTERNAL.registerService){var a={Auth:ul,Error:N};Z(a,"EmailAuthProvider",mh,[]);Z(a,"FacebookAuthProvider",bh,[]);Z(a,"GithubAuthProvider",dh,[]);Z(a,"GoogleAuthProvider",fh,[]);Z(a,"TwitterAuthProvider",hh,[]);Z(a,"OAuthProvider",P,[V("providerId")]);Z(a,"PhoneAuthProvider",rh,[Pl()]);Z(a,"RecaptchaVerifier",hm,[X(V(),Ol(),"recaptchaContainer"),W("recaptchaParameters",!0),Ql()]);firebase.INTERNAL.registerService("auth",function(a,
c){a=new ul(a);c({INTERNAL:{getUid:r(a.getUid,a),getToken:r(a.Rb,a),addAuthTokenListener:r(a.Ib,a),removeAuthTokenListener:r(a.mc,a)}});return a},a,function(a,c){if("create"===a)try{c.auth()}catch(d){}});firebase.INTERNAL.extendNamespace({User:Bk})}else throw Error("Cannot find the firebase namespace; be sure to include firebase-app.js before this library.");})();
}).call(typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/auth/dist/auth.js","/node_modules/@firebase/auth/dist")

},{"@firebase/app":1,"_process":162,"buffer":160}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var app_1 = require("@firebase/app");
var Database_1 = require("./src/api/Database");
exports.Database = Database_1.Database;
var Query_1 = require("./src/api/Query");
exports.Query = Query_1.Query;
var Reference_1 = require("./src/api/Reference");
exports.Reference = Reference_1.Reference;
var util_1 = require("./src/core/util/util");
exports.enableLogging = util_1.enableLogging;
var RepoManager_1 = require("./src/core/RepoManager");
var INTERNAL = require("./src/api/internal");
var TEST_ACCESS = require("./src/api/test_access");
var util_2 = require("@firebase/util");
var ServerValue = Database_1.Database.ServerValue;
exports.ServerValue = ServerValue;
function registerDatabase(instance) {
    // Register the Database Service with the 'firebase' namespace.
    var namespace = instance.INTERNAL.registerService('database', function (app, unused, url) { return RepoManager_1.RepoManager.getInstance().databaseFromApp(app, url); }, 
    // firebase.database namespace properties
    {
        Reference: Reference_1.Reference,
        Query: Query_1.Query,
        Database: Database_1.Database,
        enableLogging: util_1.enableLogging,
        INTERNAL: INTERNAL,
        ServerValue: ServerValue,
        TEST_ACCESS: TEST_ACCESS
    }, null, true);
    if (util_2.isNodeSdk()) {
        module.exports = namespace;
    }
}
exports.registerDatabase = registerDatabase;
registerDatabase(app_1.default);
var DataSnapshot_1 = require("./src/api/DataSnapshot");
exports.DataSnapshot = DataSnapshot_1.DataSnapshot;
var onDisconnect_1 = require("./src/api/onDisconnect");
exports.OnDisconnect = onDisconnect_1.OnDisconnect;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/index.js","/node_modules/@firebase/database/dist/cjs")

},{"./src/api/DataSnapshot":5,"./src/api/Database":6,"./src/api/Query":7,"./src/api/Reference":8,"./src/api/internal":10,"./src/api/onDisconnect":11,"./src/api/test_access":12,"./src/core/RepoManager":19,"./src/core/util/util":63,"@firebase/app":1,"@firebase/util":134,"_process":162,"buffer":160}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var validation_1 = require("../core/util/validation");
var Path_1 = require("../core/util/Path");
var PriorityIndex_1 = require("../core/snap/indexes/PriorityIndex");
/**
 * Class representing a firebase data snapshot.  It wraps a SnapshotNode and
 * surfaces the public methods (val, forEach, etc.) we want to expose.
 */
var DataSnapshot = /** @class */ (function () {
    /**
     * @param {!Node} node_ A SnapshotNode to wrap.
     * @param {!Reference} ref_ The ref of the location this snapshot came from.
     * @param {!Index} index_ The iteration order for this snapshot
     */
    function DataSnapshot(node_, ref_, index_) {
        this.node_ = node_;
        this.ref_ = ref_;
        this.index_ = index_;
    }
    /**
     * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is
     * empty.
     *
     * @return {*} JSON representation of the DataSnapshot contents, or null if empty.
     */
    DataSnapshot.prototype.val = function () {
        util_1.validateArgCount('DataSnapshot.val', 0, 0, arguments.length);
        return this.node_.val();
    };
    /**
     * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting
     * the entire node contents.
     * @return {*} JSON representation of the DataSnapshot contents, or null if empty.
     */
    DataSnapshot.prototype.exportVal = function () {
        util_1.validateArgCount('DataSnapshot.exportVal', 0, 0, arguments.length);
        return this.node_.val(true);
    };
    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
    // for end-users
    DataSnapshot.prototype.toJSON = function () {
        // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content
        util_1.validateArgCount('DataSnapshot.toJSON', 0, 1, arguments.length);
        return this.exportVal();
    };
    /**
     * Returns whether the snapshot contains a non-null value.
     *
     * @return {boolean} Whether the snapshot contains a non-null value, or is empty.
     */
    DataSnapshot.prototype.exists = function () {
        util_1.validateArgCount('DataSnapshot.exists', 0, 0, arguments.length);
        return !this.node_.isEmpty();
    };
    /**
     * Returns a DataSnapshot of the specified child node's contents.
     *
     * @param {!string} childPathString Path to a child.
     * @return {!DataSnapshot} DataSnapshot for child node.
     */
    DataSnapshot.prototype.child = function (childPathString) {
        util_1.validateArgCount('DataSnapshot.child', 0, 1, arguments.length);
        // Ensure the childPath is a string (can be a number)
        childPathString = String(childPathString);
        validation_1.validatePathString('DataSnapshot.child', 1, childPathString, false);
        var childPath = new Path_1.Path(childPathString);
        var childRef = this.ref_.child(childPath);
        return new DataSnapshot(this.node_.getChild(childPath), childRef, PriorityIndex_1.PRIORITY_INDEX);
    };
    /**
     * Returns whether the snapshot contains a child at the specified path.
     *
     * @param {!string} childPathString Path to a child.
     * @return {boolean} Whether the child exists.
     */
    DataSnapshot.prototype.hasChild = function (childPathString) {
        util_1.validateArgCount('DataSnapshot.hasChild', 1, 1, arguments.length);
        validation_1.validatePathString('DataSnapshot.hasChild', 1, childPathString, false);
        var childPath = new Path_1.Path(childPathString);
        return !this.node_.getChild(childPath).isEmpty();
    };
    /**
     * Returns the priority of the object, or null if no priority was set.
     *
     * @return {string|number|null} The priority.
     */
    DataSnapshot.prototype.getPriority = function () {
        util_1.validateArgCount('DataSnapshot.getPriority', 0, 0, arguments.length);
        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)
        return this.node_.getPriority().val();
    };
    /**
     * Iterates through child nodes and calls the specified action for each one.
     *
     * @param {function(!DataSnapshot)} action Callback function to be called
     * for each child.
     * @return {boolean} True if forEach was canceled by action returning true for
     * one of the child nodes.
     */
    DataSnapshot.prototype.forEach = function (action) {
        var _this = this;
        util_1.validateArgCount('DataSnapshot.forEach', 1, 1, arguments.length);
        util_1.validateCallback('DataSnapshot.forEach', 1, action, false);
        if (this.node_.isLeafNode())
            return false;
        var childrenNode = this.node_;
        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...
        return !!childrenNode.forEachChild(this.index_, function (key, node) {
            return action(new DataSnapshot(node, _this.ref_.child(key), PriorityIndex_1.PRIORITY_INDEX));
        });
    };
    /**
     * Returns whether this DataSnapshot has children.
     * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.
     */
    DataSnapshot.prototype.hasChildren = function () {
        util_1.validateArgCount('DataSnapshot.hasChildren', 0, 0, arguments.length);
        if (this.node_.isLeafNode())
            return false;
        else
            return !this.node_.isEmpty();
    };
    Object.defineProperty(DataSnapshot.prototype, "key", {
        get: function () {
            return this.ref_.getKey();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the number of children for this DataSnapshot.
     * @return {number} The number of children that this DataSnapshot contains.
     */
    DataSnapshot.prototype.numChildren = function () {
        util_1.validateArgCount('DataSnapshot.numChildren', 0, 0, arguments.length);
        return this.node_.numChildren();
    };
    /**
     * @return {Reference} The Firebase reference for the location this snapshot's data came from.
     */
    DataSnapshot.prototype.getRef = function () {
        util_1.validateArgCount('DataSnapshot.ref', 0, 0, arguments.length);
        return this.ref_;
    };
    Object.defineProperty(DataSnapshot.prototype, "ref", {
        get: function () {
            return this.getRef();
        },
        enumerable: true,
        configurable: true
    });
    return DataSnapshot;
}());
exports.DataSnapshot = DataSnapshot;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/api/DataSnapshot.js","/node_modules/@firebase/database/dist/cjs/src/api")

},{"../core/snap/indexes/PriorityIndex":41,"../core/util/Path":57,"../core/util/validation":64,"@firebase/util":134,"_process":162,"buffer":160}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../core/util/util");
var parser_1 = require("../core/util/libs/parser");
var Path_1 = require("../core/util/Path");
var Reference_1 = require("./Reference");
var Repo_1 = require("../core/Repo");
var RepoManager_1 = require("../core/RepoManager");
var util_2 = require("@firebase/util");
var validation_1 = require("../core/util/validation");
/**
 * Class representing a firebase database.
 * @implements {FirebaseService}
 */
var Database = /** @class */ (function () {
    /**
     * The constructor should not be called by users of our public API.
     * @param {!Repo} repo_
     */
    function Database(repo_) {
        this.repo_ = repo_;
        if (!(repo_ instanceof Repo_1.Repo)) {
            util_1.fatal("Don't call new Database() directly - please use firebase.database().");
        }
        /** @type {Reference} */
        this.root_ = new Reference_1.Reference(repo_, Path_1.Path.Empty);
        this.INTERNAL = new DatabaseInternals(this);
    }
    Object.defineProperty(Database.prototype, "app", {
        get: function () {
            return this.repo_.app;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a reference to the root or the path specified in opt_pathString.
     * @param {string=} pathString
     * @return {!Reference} Firebase reference.
     */
    Database.prototype.ref = function (pathString) {
        this.checkDeleted_('ref');
        util_2.validateArgCount('database.ref', 0, 1, arguments.length);
        return pathString !== undefined ? this.root_.child(pathString) : this.root_;
    };
    /**
     * Returns a reference to the root or the path specified in url.
     * We throw a exception if the url is not in the same domain as the
     * current repo.
     * @param {string} url
     * @return {!Reference} Firebase reference.
     */
    Database.prototype.refFromURL = function (url) {
        /** @const {string} */
        var apiName = 'database.refFromURL';
        this.checkDeleted_(apiName);
        util_2.validateArgCount(apiName, 1, 1, arguments.length);
        var parsedURL = parser_1.parseRepoInfo(url);
        validation_1.validateUrl(apiName, 1, parsedURL);
        var repoInfo = parsedURL.repoInfo;
        if (repoInfo.host !== this.repo_.repoInfo_.host) {
            util_1.fatal(apiName +
                ': Host name does not match the current database: ' +
                '(found ' +
                repoInfo.host +
                ' but expected ' +
                this.repo_.repoInfo_.host +
                ')');
        }
        return this.ref(parsedURL.path.toString());
    };
    /**
     * @param {string} apiName
     */
    Database.prototype.checkDeleted_ = function (apiName) {
        if (this.repo_ === null) {
            util_1.fatal('Cannot call ' + apiName + ' on a deleted database.');
        }
    };
    // Make individual repo go offline.
    Database.prototype.goOffline = function () {
        util_2.validateArgCount('database.goOffline', 0, 0, arguments.length);
        this.checkDeleted_('goOffline');
        this.repo_.interrupt();
    };
    Database.prototype.goOnline = function () {
        util_2.validateArgCount('database.goOnline', 0, 0, arguments.length);
        this.checkDeleted_('goOnline');
        this.repo_.resume();
    };
    Database.ServerValue = {
        TIMESTAMP: {
            '.sv': 'timestamp'
        }
    };
    return Database;
}());
exports.Database = Database;
var DatabaseInternals = /** @class */ (function () {
    /** @param {!Database} database */
    function DatabaseInternals(database) {
        this.database = database;
    }
    /** @return {Promise<void>} */
    DatabaseInternals.prototype.delete = function () {
        this.database.checkDeleted_('delete');
        RepoManager_1.RepoManager.getInstance().deleteRepo(this.database.repo_);
        this.database.repo_ = null;
        this.database.root_ = null;
        this.database.INTERNAL = null;
        this.database = null;
        return Promise.resolve();
    };
    return DatabaseInternals;
}());
exports.DatabaseInternals = DatabaseInternals;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/api/Database.js","/node_modules/@firebase/database/dist/cjs/src/api")

},{"../core/Repo":17,"../core/RepoManager":19,"../core/util/Path":57,"../core/util/libs/parser":62,"../core/util/util":63,"../core/util/validation":64,"./Reference":8,"@firebase/util":134,"_process":162,"buffer":160}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var KeyIndex_1 = require("../core/snap/indexes/KeyIndex");
var PriorityIndex_1 = require("../core/snap/indexes/PriorityIndex");
var ValueIndex_1 = require("../core/snap/indexes/ValueIndex");
var PathIndex_1 = require("../core/snap/indexes/PathIndex");
var util_2 = require("../core/util/util");
var Path_1 = require("../core/util/Path");
var validation_1 = require("../core/util/validation");
var util_3 = require("@firebase/util");
var EventRegistration_1 = require("../core/view/EventRegistration");
var util_4 = require("@firebase/util");
var __referenceConstructor;
/**
 * A Query represents a filter to be applied to a firebase location.  This object purely represents the
 * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.
 *
 * Since every Firebase reference is a query, Firebase inherits from this object.
 */
var Query = /** @class */ (function () {
    function Query(repo, path, queryParams_, orderByCalled_) {
        this.repo = repo;
        this.path = path;
        this.queryParams_ = queryParams_;
        this.orderByCalled_ = orderByCalled_;
    }
    Object.defineProperty(Query, "__referenceConstructor", {
        get: function () {
            util_1.assert(__referenceConstructor, 'Reference.ts has not been loaded');
            return __referenceConstructor;
        },
        set: function (val) {
            __referenceConstructor = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Validates start/end values for queries.
     * @param {!QueryParams} params
     * @private
     */
    Query.validateQueryEndpoints_ = function (params) {
        var startNode = null;
        var endNode = null;
        if (params.hasStart()) {
            startNode = params.getIndexStartValue();
        }
        if (params.hasEnd()) {
            endNode = params.getIndexEndValue();
        }
        if (params.getIndex() === KeyIndex_1.KEY_INDEX) {
            var tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +
                'startAt(), endAt(), or equalTo().';
            var wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), endAt(),' +
                'or equalTo() must be a string.';
            if (params.hasStart()) {
                var startName = params.getIndexStartName();
                if (startName != util_2.MIN_NAME) {
                    throw new Error(tooManyArgsError);
                }
                else if (typeof startNode !== 'string') {
                    throw new Error(wrongArgTypeError);
                }
            }
            if (params.hasEnd()) {
                var endName = params.getIndexEndName();
                if (endName != util_2.MAX_NAME) {
                    throw new Error(tooManyArgsError);
                }
                else if (typeof endNode !== 'string') {
                    throw new Error(wrongArgTypeError);
                }
            }
        }
        else if (params.getIndex() === PriorityIndex_1.PRIORITY_INDEX) {
            if ((startNode != null && !validation_1.isValidPriority(startNode)) ||
                (endNode != null && !validation_1.isValidPriority(endNode))) {
                throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +
                    'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');
            }
        }
        else {
            util_1.assert(params.getIndex() instanceof PathIndex_1.PathIndex ||
                params.getIndex() === ValueIndex_1.VALUE_INDEX, 'unknown index type.');
            if ((startNode != null && typeof startNode === 'object') ||
                (endNode != null && typeof endNode === 'object')) {
                throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +
                    'an object.');
            }
        }
    };
    /**
     * Validates that limit* has been called with the correct combination of parameters
     * @param {!QueryParams} params
     * @private
     */
    Query.validateLimit_ = function (params) {
        if (params.hasStart() &&
            params.hasEnd() &&
            params.hasLimit() &&
            !params.hasAnchoredLimit()) {
            throw new Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");
        }
    };
    /**
     * Validates that no other order by call has been made
     * @param {!string} fnName
     * @private
     */
    Query.prototype.validateNoPreviousOrderByCall_ = function (fnName) {
        if (this.orderByCalled_ === true) {
            throw new Error(fnName + ": You can't combine multiple orderBy calls.");
        }
    };
    /**
     * @return {!QueryParams}
     */
    Query.prototype.getQueryParams = function () {
        return this.queryParams_;
    };
    /**
     * @return {!Reference}
     */
    Query.prototype.getRef = function () {
        util_3.validateArgCount('Query.ref', 0, 0, arguments.length);
        // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.
        // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this
        // method gets called.
        return new Query.__referenceConstructor(this.repo, this.path);
    };
    /**
     * @param {!string} eventType
     * @param {!function(DataSnapshot, string=)} callback
     * @param {(function(Error)|Object)=} cancelCallbackOrContext
     * @param {Object=} context
     * @return {!function(DataSnapshot, string=)}
     */
    Query.prototype.on = function (eventType, callback, cancelCallbackOrContext, context) {
        util_3.validateArgCount('Query.on', 2, 4, arguments.length);
        validation_1.validateEventType('Query.on', 1, eventType, false);
        util_3.validateCallback('Query.on', 2, callback, false);
        var ret = Query.getCancelAndContextArgs_('Query.on', cancelCallbackOrContext, context);
        if (eventType === 'value') {
            this.onValueEvent(callback, ret.cancel, ret.context);
        }
        else {
            var callbacks = {};
            callbacks[eventType] = callback;
            this.onChildEvent(callbacks, ret.cancel, ret.context);
        }
        return callback;
    };
    /**
     * @param {!function(!DataSnapshot)} callback
     * @param {?function(Error)} cancelCallback
     * @param {?Object} context
     * @protected
     */
    Query.prototype.onValueEvent = function (callback, cancelCallback, context) {
        var container = new EventRegistration_1.ValueEventRegistration(callback, cancelCallback || null, context || null);
        this.repo.addEventCallbackForQuery(this, container);
    };
    /**
     * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks
     * @param {?function(Error)} cancelCallback
     * @param {?Object} context
     * @protected
     */
    Query.prototype.onChildEvent = function (callbacks, cancelCallback, context) {
        var container = new EventRegistration_1.ChildEventRegistration(callbacks, cancelCallback, context);
        this.repo.addEventCallbackForQuery(this, container);
    };
    /**
     * @param {string=} eventType
     * @param {(function(!DataSnapshot, ?string=))=} callback
     * @param {Object=} context
     */
    Query.prototype.off = function (eventType, callback, context) {
        util_3.validateArgCount('Query.off', 0, 3, arguments.length);
        validation_1.validateEventType('Query.off', 1, eventType, true);
        util_3.validateCallback('Query.off', 2, callback, true);
        util_3.validateContextObject('Query.off', 3, context, true);
        var container = null;
        var callbacks = null;
        if (eventType === 'value') {
            var valueCallback = callback || null;
            container = new EventRegistration_1.ValueEventRegistration(valueCallback, null, context || null);
        }
        else if (eventType) {
            if (callback) {
                callbacks = {};
                callbacks[eventType] = callback;
            }
            container = new EventRegistration_1.ChildEventRegistration(callbacks, null, context || null);
        }
        this.repo.removeEventCallbackForQuery(this, container);
    };
    /**
     * Attaches a listener, waits for the first event, and then removes the listener
     * @param {!string} eventType
     * @param {!function(!DataSnapshot, string=)} userCallback
     * @param cancelOrContext
     * @param context
     * @return {!firebase.Promise}
     */
    Query.prototype.once = function (eventType, userCallback, cancelOrContext, context) {
        var _this = this;
        util_3.validateArgCount('Query.once', 1, 4, arguments.length);
        validation_1.validateEventType('Query.once', 1, eventType, false);
        util_3.validateCallback('Query.once', 2, userCallback, true);
        var ret = Query.getCancelAndContextArgs_('Query.once', cancelOrContext, context);
        // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)
        // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change
        // because the API currently expects callbacks will be called synchronously if the data is cached, but this is
        // against the Promise specification.
        var firstCall = true;
        var deferred = new util_4.Deferred();
        // A dummy error handler in case a user wasn't expecting promises
        deferred.promise.catch(function () { });
        var onceCallback = function (snapshot) {
            // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)
            // triggers multiple events (e.g. child_added or child_changed).
            if (firstCall) {
                firstCall = false;
                _this.off(eventType, onceCallback);
                if (userCallback) {
                    userCallback.bind(ret.context)(snapshot);
                }
                deferred.resolve(snapshot);
            }
        };
        this.on(eventType, onceCallback, 
        /*cancel=*/ function (err) {
            _this.off(eventType, onceCallback);
            if (ret.cancel)
                ret.cancel.bind(ret.context)(err);
            deferred.reject(err);
        });
        return deferred.promise;
    };
    /**
     * Set a limit and anchor it to the start of the window.
     * @param {!number} limit
     * @return {!Query}
     */
    Query.prototype.limitToFirst = function (limit) {
        util_3.validateArgCount('Query.limitToFirst', 1, 1, arguments.length);
        if (typeof limit !== 'number' ||
            Math.floor(limit) !== limit ||
            limit <= 0) {
            throw new Error('Query.limitToFirst: First argument must be a positive integer.');
        }
        if (this.queryParams_.hasLimit()) {
            throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, ' +
                'limitToFirst, or limitToLast).');
        }
        return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);
    };
    /**
     * Set a limit and anchor it to the end of the window.
     * @param {!number} limit
     * @return {!Query}
     */
    Query.prototype.limitToLast = function (limit) {
        util_3.validateArgCount('Query.limitToLast', 1, 1, arguments.length);
        if (typeof limit !== 'number' ||
            Math.floor(limit) !== limit ||
            limit <= 0) {
            throw new Error('Query.limitToLast: First argument must be a positive integer.');
        }
        if (this.queryParams_.hasLimit()) {
            throw new Error('Query.limitToLast: Limit was already set (by another call to limit, ' +
                'limitToFirst, or limitToLast).');
        }
        return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit), this.orderByCalled_);
    };
    /**
     * Given a child path, return a new query ordered by the specified grandchild path.
     * @param {!string} path
     * @return {!Query}
     */
    Query.prototype.orderByChild = function (path) {
        util_3.validateArgCount('Query.orderByChild', 1, 1, arguments.length);
        if (path === '$key') {
            throw new Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');
        }
        else if (path === '$priority') {
            throw new Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');
        }
        else if (path === '$value') {
            throw new Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');
        }
        validation_1.validatePathString('Query.orderByChild', 1, path, false);
        this.validateNoPreviousOrderByCall_('Query.orderByChild');
        var parsedPath = new Path_1.Path(path);
        if (parsedPath.isEmpty()) {
            throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');
        }
        var index = new PathIndex_1.PathIndex(parsedPath);
        var newParams = this.queryParams_.orderBy(index);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * Return a new query ordered by the KeyIndex
     * @return {!Query}
     */
    Query.prototype.orderByKey = function () {
        util_3.validateArgCount('Query.orderByKey', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByKey');
        var newParams = this.queryParams_.orderBy(KeyIndex_1.KEY_INDEX);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * Return a new query ordered by the PriorityIndex
     * @return {!Query}
     */
    Query.prototype.orderByPriority = function () {
        util_3.validateArgCount('Query.orderByPriority', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByPriority');
        var newParams = this.queryParams_.orderBy(PriorityIndex_1.PRIORITY_INDEX);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * Return a new query ordered by the ValueIndex
     * @return {!Query}
     */
    Query.prototype.orderByValue = function () {
        util_3.validateArgCount('Query.orderByValue', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByValue');
        var newParams = this.queryParams_.orderBy(ValueIndex_1.VALUE_INDEX);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * @param {number|string|boolean|null} value
     * @param {?string=} name
     * @return {!Query}
     */
    Query.prototype.startAt = function (value, name) {
        if (value === void 0) { value = null; }
        util_3.validateArgCount('Query.startAt', 0, 2, arguments.length);
        validation_1.validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);
        validation_1.validateKey('Query.startAt', 2, name, true);
        var newParams = this.queryParams_.startAt(value, name);
        Query.validateLimit_(newParams);
        Query.validateQueryEndpoints_(newParams);
        if (this.queryParams_.hasStart()) {
            throw new Error('Query.startAt: Starting point was already set (by another call to startAt ' +
                'or equalTo).');
        }
        // Calling with no params tells us to start at the beginning.
        if (value === undefined) {
            value = null;
            name = null;
        }
        return new Query(this.repo, this.path, newParams, this.orderByCalled_);
    };
    /**
     * @param {number|string|boolean|null} value
     * @param {?string=} name
     * @return {!Query}
     */
    Query.prototype.endAt = function (value, name) {
        if (value === void 0) { value = null; }
        util_3.validateArgCount('Query.endAt', 0, 2, arguments.length);
        validation_1.validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);
        validation_1.validateKey('Query.endAt', 2, name, true);
        var newParams = this.queryParams_.endAt(value, name);
        Query.validateLimit_(newParams);
        Query.validateQueryEndpoints_(newParams);
        if (this.queryParams_.hasEnd()) {
            throw new Error('Query.endAt: Ending point was already set (by another call to endAt or ' +
                'equalTo).');
        }
        return new Query(this.repo, this.path, newParams, this.orderByCalled_);
    };
    /**
     * Load the selection of children with exactly the specified value, and, optionally,
     * the specified name.
     * @param {number|string|boolean|null} value
     * @param {string=} name
     * @return {!Query}
     */
    Query.prototype.equalTo = function (value, name) {
        util_3.validateArgCount('Query.equalTo', 1, 2, arguments.length);
        validation_1.validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);
        validation_1.validateKey('Query.equalTo', 2, name, true);
        if (this.queryParams_.hasStart()) {
            throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or ' +
                'equalTo).');
        }
        if (this.queryParams_.hasEnd()) {
            throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or ' +
                'equalTo).');
        }
        return this.startAt(value, name).endAt(value, name);
    };
    /**
     * @return {!string} URL for this location.
     */
    Query.prototype.toString = function () {
        util_3.validateArgCount('Query.toString', 0, 0, arguments.length);
        return this.repo.toString() + this.path.toUrlEncodedString();
    };
    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
    // for end-users.
    Query.prototype.toJSON = function () {
        // An optional spacer argument is unnecessary for a string.
        util_3.validateArgCount('Query.toJSON', 0, 1, arguments.length);
        return this.toString();
    };
    /**
     * An object representation of the query parameters used by this Query.
     * @return {!Object}
     */
    Query.prototype.queryObject = function () {
        return this.queryParams_.getQueryObject();
    };
    /**
     * @return {!string}
     */
    Query.prototype.queryIdentifier = function () {
        var obj = this.queryObject();
        var id = util_2.ObjectToUniqueKey(obj);
        return id === '{}' ? 'default' : id;
    };
    /**
     * Return true if this query and the provided query are equivalent; otherwise, return false.
     * @param {Query} other
     * @return {boolean}
     */
    Query.prototype.isEqual = function (other) {
        util_3.validateArgCount('Query.isEqual', 1, 1, arguments.length);
        if (!(other instanceof Query)) {
            var error = 'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';
            throw new Error(error);
        }
        var sameRepo = this.repo === other.repo;
        var samePath = this.path.equals(other.path);
        var sameQueryIdentifier = this.queryIdentifier() === other.queryIdentifier();
        return sameRepo && samePath && sameQueryIdentifier;
    };
    /**
     * Helper used by .on and .once to extract the context and or cancel arguments.
     * @param {!string} fnName The function name (on or once)
     * @param {(function(Error)|Object)=} cancelOrContext
     * @param {Object=} context
     * @return {{cancel: ?function(Error), context: ?Object}}
     * @private
     */
    Query.getCancelAndContextArgs_ = function (fnName, cancelOrContext, context) {
        var ret = { cancel: null, context: null };
        if (cancelOrContext && context) {
            ret.cancel = cancelOrContext;
            util_3.validateCallback(fnName, 3, ret.cancel, true);
            ret.context = context;
            util_3.validateContextObject(fnName, 4, ret.context, true);
        }
        else if (cancelOrContext) {
            // we have either a cancel callback or a context.
            if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {
                // it's a context!
                ret.context = cancelOrContext;
            }
            else if (typeof cancelOrContext === 'function') {
                ret.cancel = cancelOrContext;
            }
            else {
                throw new Error(util_3.errorPrefix(fnName, 3, true) +
                    ' must either be a cancel callback or a context object.');
            }
        }
        return ret;
    };
    Object.defineProperty(Query.prototype, "ref", {
        get: function () {
            return this.getRef();
        },
        enumerable: true,
        configurable: true
    });
    return Query;
}());
exports.Query = Query;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/api/Query.js","/node_modules/@firebase/database/dist/cjs/src/api")

},{"../core/snap/indexes/KeyIndex":39,"../core/snap/indexes/PathIndex":40,"../core/snap/indexes/PriorityIndex":41,"../core/snap/indexes/ValueIndex":42,"../core/util/Path":57,"../core/util/util":63,"../core/util/validation":64,"../core/view/EventRegistration":72,"@firebase/util":134,"_process":162,"buffer":160}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var onDisconnect_1 = require("./onDisconnect");
var TransactionResult_1 = require("./TransactionResult");
var util_1 = require("../core/util/util");
var NextPushId_1 = require("../core/util/NextPushId");
var Query_1 = require("./Query");
var Repo_1 = require("../core/Repo");
var Path_1 = require("../core/util/Path");
var QueryParams_1 = require("../core/view/QueryParams");
var validation_1 = require("../core/util/validation");
var util_2 = require("@firebase/util");
var util_3 = require("@firebase/util");
var SyncPoint_1 = require("../core/SyncPoint");
var Reference = /** @class */ (function (_super) {
    __extends(Reference, _super);
    /**
     * Call options:
     *   new Reference(Repo, Path) or
     *   new Reference(url: string, string|RepoManager)
     *
     * Externally - this is the firebase.database.Reference type.
     *
     * @param {!Repo} repo
     * @param {(!Path)} path
     * @extends {Query}
     */
    function Reference(repo, path) {
        var _this = this;
        if (!(repo instanceof Repo_1.Repo)) {
            throw new Error('new Reference() no longer supported - use app.database().');
        }
        // call Query's constructor, passing in the repo and path.
        _this = _super.call(this, repo, path, QueryParams_1.QueryParams.DEFAULT, false) || this;
        return _this;
    }
    /** @return {?string} */
    Reference.prototype.getKey = function () {
        util_2.validateArgCount('Reference.key', 0, 0, arguments.length);
        if (this.path.isEmpty())
            return null;
        else
            return this.path.getBack();
    };
    /**
     * @param {!(string|Path)} pathString
     * @return {!Reference}
     */
    Reference.prototype.child = function (pathString) {
        util_2.validateArgCount('Reference.child', 1, 1, arguments.length);
        if (typeof pathString === 'number') {
            pathString = String(pathString);
        }
        else if (!(pathString instanceof Path_1.Path)) {
            if (this.path.getFront() === null)
                validation_1.validateRootPathString('Reference.child', 1, pathString, false);
            else
                validation_1.validatePathString('Reference.child', 1, pathString, false);
        }
        return new Reference(this.repo, this.path.child(pathString));
    };
    /** @return {?Reference} */
    Reference.prototype.getParent = function () {
        util_2.validateArgCount('Reference.parent', 0, 0, arguments.length);
        var parentPath = this.path.parent();
        return parentPath === null ? null : new Reference(this.repo, parentPath);
    };
    /** @return {!Reference} */
    Reference.prototype.getRoot = function () {
        util_2.validateArgCount('Reference.root', 0, 0, arguments.length);
        var ref = this;
        while (ref.getParent() !== null) {
            ref = ref.getParent();
        }
        return ref;
    };
    /** @return {!Database} */
    Reference.prototype.databaseProp = function () {
        return this.repo.database;
    };
    /**
     * @param {*} newVal
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.set = function (newVal, onComplete) {
        util_2.validateArgCount('Reference.set', 1, 2, arguments.length);
        validation_1.validateWritablePath('Reference.set', this.path);
        validation_1.validateFirebaseDataArg('Reference.set', 1, newVal, this.path, false);
        util_2.validateCallback('Reference.set', 2, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo.setWithPriority(this.path, newVal, 
        /*priority=*/ null, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {!Object} objectToMerge
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.update = function (objectToMerge, onComplete) {
        util_2.validateArgCount('Reference.update', 1, 2, arguments.length);
        validation_1.validateWritablePath('Reference.update', this.path);
        if (Array.isArray(objectToMerge)) {
            var newObjectToMerge = {};
            for (var i = 0; i < objectToMerge.length; ++i) {
                newObjectToMerge['' + i] = objectToMerge[i];
            }
            objectToMerge = newObjectToMerge;
            util_1.warn('Passing an Array to Firebase.update() is deprecated. ' +
                'Use set() if you want to overwrite the existing data, or ' +
                'an Object with integer keys if you really do want to ' +
                'only update some of the children.');
        }
        validation_1.validateFirebaseMergeDataArg('Reference.update', 1, objectToMerge, this.path, false);
        util_2.validateCallback('Reference.update', 2, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo.update(this.path, objectToMerge, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*} newVal
     * @param {string|number|null} newPriority
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.setWithPriority = function (newVal, newPriority, onComplete) {
        util_2.validateArgCount('Reference.setWithPriority', 2, 3, arguments.length);
        validation_1.validateWritablePath('Reference.setWithPriority', this.path);
        validation_1.validateFirebaseDataArg('Reference.setWithPriority', 1, newVal, this.path, false);
        validation_1.validatePriority('Reference.setWithPriority', 2, newPriority, false);
        util_2.validateCallback('Reference.setWithPriority', 3, onComplete, true);
        if (this.getKey() === '.length' || this.getKey() === '.keys')
            throw 'Reference.setWithPriority failed: ' +
                this.getKey() +
                ' is a read-only object.';
        var deferred = new util_3.Deferred();
        this.repo.setWithPriority(this.path, newVal, newPriority, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.remove = function (onComplete) {
        util_2.validateArgCount('Reference.remove', 0, 1, arguments.length);
        validation_1.validateWritablePath('Reference.remove', this.path);
        util_2.validateCallback('Reference.remove', 1, onComplete, true);
        return this.set(null, onComplete);
    };
    /**
     * @param {function(*):*} transactionUpdate
     * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete
     * @param {boolean=} applyLocally
     * @return {!Promise}
     */
    Reference.prototype.transaction = function (transactionUpdate, onComplete, applyLocally) {
        util_2.validateArgCount('Reference.transaction', 1, 3, arguments.length);
        validation_1.validateWritablePath('Reference.transaction', this.path);
        util_2.validateCallback('Reference.transaction', 1, transactionUpdate, false);
        util_2.validateCallback('Reference.transaction', 2, onComplete, true);
        // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how
        // to expose it.
        validation_1.validateBoolean('Reference.transaction', 3, applyLocally, true);
        if (this.getKey() === '.length' || this.getKey() === '.keys')
            throw 'Reference.transaction failed: ' +
                this.getKey() +
                ' is a read-only object.';
        if (applyLocally === undefined)
            applyLocally = true;
        var deferred = new util_3.Deferred();
        if (typeof onComplete === 'function') {
            deferred.promise.catch(function () { });
        }
        var promiseComplete = function (error, committed, snapshot) {
            if (error) {
                deferred.reject(error);
            }
            else {
                deferred.resolve(new TransactionResult_1.TransactionResult(committed, snapshot));
            }
            if (typeof onComplete === 'function') {
                onComplete(error, committed, snapshot);
            }
        };
        this.repo.startTransaction(this.path, transactionUpdate, promiseComplete, applyLocally);
        return deferred.promise;
    };
    /**
     * @param {string|number|null} priority
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.setPriority = function (priority, onComplete) {
        util_2.validateArgCount('Reference.setPriority', 1, 2, arguments.length);
        validation_1.validateWritablePath('Reference.setPriority', this.path);
        validation_1.validatePriority('Reference.setPriority', 1, priority, false);
        util_2.validateCallback('Reference.setPriority', 2, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo.setWithPriority(this.path.child('.priority'), priority, null, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*=} value
     * @param {function(?Error)=} onComplete
     * @return {!Reference}
     */
    Reference.prototype.push = function (value, onComplete) {
        util_2.validateArgCount('Reference.push', 0, 2, arguments.length);
        validation_1.validateWritablePath('Reference.push', this.path);
        validation_1.validateFirebaseDataArg('Reference.push', 1, value, this.path, true);
        util_2.validateCallback('Reference.push', 2, onComplete, true);
        var now = this.repo.serverTime();
        var name = NextPushId_1.nextPushId(now);
        // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.
        // We use child() to create handles to two different references. The first is turned into a
        // ThennableReference below by adding then() and catch() methods and is used as the
        // return value of push(). The second remains a regular Reference and is used as the fulfilled
        // value of the first ThennableReference.
        var thennablePushRef = this.child(name);
        var pushRef = this.child(name);
        var promise;
        if (value != null) {
            promise = thennablePushRef.set(value, onComplete).then(function () { return pushRef; });
        }
        else {
            promise = Promise.resolve(pushRef);
        }
        thennablePushRef.then = promise.then.bind(promise);
        thennablePushRef.catch = promise.then.bind(promise, undefined);
        if (typeof onComplete === 'function') {
            promise.catch(function () { });
        }
        return thennablePushRef;
    };
    /**
     * @return {!OnDisconnect}
     */
    Reference.prototype.onDisconnect = function () {
        validation_1.validateWritablePath('Reference.onDisconnect', this.path);
        return new onDisconnect_1.OnDisconnect(this.repo, this.path);
    };
    Object.defineProperty(Reference.prototype, "database", {
        get: function () {
            return this.databaseProp();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "key", {
        get: function () {
            return this.getKey();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "parent", {
        get: function () {
            return this.getParent();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "root", {
        get: function () {
            return this.getRoot();
        },
        enumerable: true,
        configurable: true
    });
    return Reference;
}(Query_1.Query));
exports.Reference = Reference;
/**
 * Define reference constructor in various modules
 *
 * We are doing this here to avoid several circular
 * dependency issues
 */
Query_1.Query.__referenceConstructor = Reference;
SyncPoint_1.SyncPoint.__referenceConstructor = Reference;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/api/Reference.js","/node_modules/@firebase/database/dist/cjs/src/api")

},{"../core/Repo":17,"../core/SyncPoint":24,"../core/util/NextPushId":55,"../core/util/Path":57,"../core/util/util":63,"../core/util/validation":64,"../core/view/QueryParams":73,"./Query":7,"./TransactionResult":9,"./onDisconnect":11,"@firebase/util":134,"_process":162,"buffer":160}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var TransactionResult = /** @class */ (function () {
    /**
     * A type for the resolve value of Firebase.transaction.
     * @constructor
     * @dict
     * @param {boolean} committed
     * @param {DataSnapshot} snapshot
     */
    function TransactionResult(committed, snapshot) {
        this.committed = committed;
        this.snapshot = snapshot;
    }
    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
    // for end-users
    TransactionResult.prototype.toJSON = function () {
        util_1.validateArgCount('TransactionResult.toJSON', 0, 1, arguments.length);
        return { committed: this.committed, snapshot: this.snapshot.toJSON() };
    };
    return TransactionResult;
}());
exports.TransactionResult = TransactionResult;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/api/TransactionResult.js","/node_modules/@firebase/database/dist/cjs/src/api")

},{"@firebase/util":134,"_process":162,"buffer":160}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var WebSocketConnection_1 = require("../realtime/WebSocketConnection");
var BrowserPollConnection_1 = require("../realtime/BrowserPollConnection");
/**
 * INTERNAL methods for internal-use only (tests, etc.).
 *
 * Customers shouldn't use these or else should be aware that they could break at any time.
 *
 * @const
 */
exports.forceLongPolling = function () {
    WebSocketConnection_1.WebSocketConnection.forceDisallow();
    BrowserPollConnection_1.BrowserPollConnection.forceAllow();
};
exports.forceWebSockets = function () {
    BrowserPollConnection_1.BrowserPollConnection.forceDisallow();
};
/* Used by App Manager */
exports.isWebSocketsAvailable = function () {
    return WebSocketConnection_1.WebSocketConnection['isAvailable']();
};
exports.setSecurityDebugCallback = function (ref, callback) {
    ref.repo.persistentConnection_.securityDebugCallback_ = callback;
};
exports.stats = function (ref, showDelta) {
    ref.repo.stats(showDelta);
};
exports.statsIncrementCounter = function (ref, metric) {
    ref.repo.statsIncrementCounter(metric);
};
exports.dataUpdateCount = function (ref) {
    return ref.repo.dataUpdateCount;
};
exports.interceptServerData = function (ref, callback) {
    return ref.repo.interceptServerData_(callback);
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/api/internal.js","/node_modules/@firebase/database/dist/cjs/src/api")

},{"../realtime/BrowserPollConnection":80,"../realtime/WebSocketConnection":84,"_process":162,"buffer":160}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var validation_1 = require("../core/util/validation");
var util_2 = require("../core/util/util");
var util_3 = require("@firebase/util");
/**
 * @constructor
 */
var OnDisconnect = /** @class */ (function () {
    /**
     * @param {!Repo} repo_
     * @param {!Path} path_
     */
    function OnDisconnect(repo_, path_) {
        this.repo_ = repo_;
        this.path_ = path_;
    }
    /**
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.cancel = function (onComplete) {
        util_1.validateArgCount('OnDisconnect.cancel', 0, 1, arguments.length);
        util_1.validateCallback('OnDisconnect.cancel', 1, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo_.onDisconnectCancel(this.path_, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.remove = function (onComplete) {
        util_1.validateArgCount('OnDisconnect.remove', 0, 1, arguments.length);
        validation_1.validateWritablePath('OnDisconnect.remove', this.path_);
        util_1.validateCallback('OnDisconnect.remove', 1, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo_.onDisconnectSet(this.path_, null, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*} value
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.set = function (value, onComplete) {
        util_1.validateArgCount('OnDisconnect.set', 1, 2, arguments.length);
        validation_1.validateWritablePath('OnDisconnect.set', this.path_);
        validation_1.validateFirebaseDataArg('OnDisconnect.set', 1, value, this.path_, false);
        util_1.validateCallback('OnDisconnect.set', 2, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo_.onDisconnectSet(this.path_, value, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*} value
     * @param {number|string|null} priority
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.setWithPriority = function (value, priority, onComplete) {
        util_1.validateArgCount('OnDisconnect.setWithPriority', 2, 3, arguments.length);
        validation_1.validateWritablePath('OnDisconnect.setWithPriority', this.path_);
        validation_1.validateFirebaseDataArg('OnDisconnect.setWithPriority', 1, value, this.path_, false);
        validation_1.validatePriority('OnDisconnect.setWithPriority', 2, priority, false);
        util_1.validateCallback('OnDisconnect.setWithPriority', 3, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo_.onDisconnectSetWithPriority(this.path_, value, priority, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {!Object} objectToMerge
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.update = function (objectToMerge, onComplete) {
        util_1.validateArgCount('OnDisconnect.update', 1, 2, arguments.length);
        validation_1.validateWritablePath('OnDisconnect.update', this.path_);
        if (Array.isArray(objectToMerge)) {
            var newObjectToMerge = {};
            for (var i = 0; i < objectToMerge.length; ++i) {
                newObjectToMerge['' + i] = objectToMerge[i];
            }
            objectToMerge = newObjectToMerge;
            util_2.warn('Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the ' +
                'existing data, or an Object with integer keys if you really do want to only update some of the children.');
        }
        validation_1.validateFirebaseMergeDataArg('OnDisconnect.update', 1, objectToMerge, this.path_, false);
        util_1.validateCallback('OnDisconnect.update', 2, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo_.onDisconnectUpdate(this.path_, objectToMerge, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    return OnDisconnect;
}());
exports.OnDisconnect = OnDisconnect;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/api/onDisconnect.js","/node_modules/@firebase/database/dist/cjs/src/api")

},{"../core/util/util":63,"../core/util/validation":64,"@firebase/util":134,"_process":162,"buffer":160}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var RepoInfo_1 = require("../core/RepoInfo");
var PersistentConnection_1 = require("../core/PersistentConnection");
var RepoManager_1 = require("../core/RepoManager");
var Connection_1 = require("../realtime/Connection");
exports.DataConnection = PersistentConnection_1.PersistentConnection;
/**
 * @param {!string} pathString
 * @param {function(*)} onComplete
 */
PersistentConnection_1.PersistentConnection.prototype.simpleListen = function (pathString, onComplete) {
    this.sendRequest('q', { p: pathString }, onComplete);
};
/**
 * @param {*} data
 * @param {function(*)} onEcho
 */
PersistentConnection_1.PersistentConnection.prototype.echo = function (data, onEcho) {
    this.sendRequest('echo', { d: data }, onEcho);
};
// RealTimeConnection properties that we use in tests.
exports.RealTimeConnection = Connection_1.Connection;
/**
 * @param {function(): string} newHash
 * @return {function()}
 */
exports.hijackHash = function (newHash) {
    var oldPut = PersistentConnection_1.PersistentConnection.prototype.put;
    PersistentConnection_1.PersistentConnection.prototype.put = function (pathString, data, opt_onComplete, opt_hash) {
        if (opt_hash !== undefined) {
            opt_hash = newHash();
        }
        oldPut.call(this, pathString, data, opt_onComplete, opt_hash);
    };
    return function () {
        PersistentConnection_1.PersistentConnection.prototype.put = oldPut;
    };
};
/**
 * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}
 */
exports.ConnectionTarget = RepoInfo_1.RepoInfo;
/**
 * @param {!Query} query
 * @return {!string}
 */
exports.queryIdentifier = function (query) {
    return query.queryIdentifier();
};
/**
 * @param {!Query} firebaseRef
 * @return {!Object}
 */
exports.listens = function (firebaseRef) {
    return firebaseRef.repo.persistentConnection_.listens_;
};
/**
 * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.
 *
 * @param {boolean} forceRestClient
 */
exports.forceRestClient = function (forceRestClient) {
    RepoManager_1.RepoManager.getInstance().forceRestClient(forceRestClient);
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/api/test_access.js","/node_modules/@firebase/database/dist/cjs/src/api")

},{"../core/PersistentConnection":15,"../core/RepoInfo":18,"../core/RepoManager":19,"../realtime/Connection":81,"_process":162,"buffer":160}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util/util");
/**
 * Abstraction around FirebaseApp's token fetching capabilities.
 */
var AuthTokenProvider = /** @class */ (function () {
    /**
     * @param {!FirebaseApp} app_
     */
    function AuthTokenProvider(app_) {
        this.app_ = app_;
    }
    /**
     * @param {boolean} forceRefresh
     * @return {!Promise<FirebaseAuthTokenData>}
     */
    AuthTokenProvider.prototype.getToken = function (forceRefresh) {
        return this.app_['INTERNAL']['getToken'](forceRefresh).then(null, 
        // .catch
        function (error) {
            // TODO: Need to figure out all the cases this is raised and whether
            // this makes sense.
            if (error && error.code === 'auth/token-not-initialized') {
                util_1.log('Got auth/token-not-initialized error.  Treating as null token.');
                return null;
            }
            else {
                return Promise.reject(error);
            }
        });
    };
    AuthTokenProvider.prototype.addTokenChangeListener = function (listener) {
        // TODO: We might want to wrap the listener and call it with no args to
        // avoid a leaky abstraction, but that makes removing the listener harder.
        this.app_['INTERNAL']['addAuthTokenListener'](listener);
    };
    AuthTokenProvider.prototype.removeTokenChangeListener = function (listener) {
        this.app_['INTERNAL']['removeAuthTokenListener'](listener);
    };
    AuthTokenProvider.prototype.notifyForInvalidToken = function () {
        var errorMessage = 'Provided authentication credentials for the app named "' +
            this.app_.name +
            '" are invalid. This usually indicates your app was not ' +
            'initialized correctly. ';
        if ('credential' in this.app_.options) {
            errorMessage +=
                'Make sure the "credential" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
        }
        else if ('serviceAccount' in this.app_.options) {
            errorMessage +=
                'Make sure the "serviceAccount" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
        }
        else {
            errorMessage +=
                'Make sure the "apiKey" and "databaseURL" properties provided to ' +
                    'initializeApp() match the values provided for your app at ' +
                    'https://console.firebase.google.com/.';
        }
        util_1.warn(errorMessage);
    };
    return AuthTokenProvider;
}());
exports.AuthTokenProvider = AuthTokenProvider;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/AuthTokenProvider.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"./util/util":63,"_process":162,"buffer":160}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ImmutableTree_1 = require("./util/ImmutableTree");
var Path_1 = require("./util/Path");
var util_1 = require("@firebase/util");
var Node_1 = require("./snap/Node");
var PriorityIndex_1 = require("./snap/indexes/PriorityIndex");
var util_2 = require("@firebase/util");
/**
 * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with
 * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write
 * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write
 * to reflect the write added.
 *
 * @constructor
 * @param {!ImmutableTree.<!Node>} writeTree
 */
var CompoundWrite = /** @class */ (function () {
    function CompoundWrite(writeTree_) {
        this.writeTree_ = writeTree_;
    }
    /**
     * @param {!Path} path
     * @param {!Node} node
     * @return {!CompoundWrite}
     */
    CompoundWrite.prototype.addWrite = function (path, node) {
        if (path.isEmpty()) {
            return new CompoundWrite(new ImmutableTree_1.ImmutableTree(node));
        }
        else {
            var rootmost = this.writeTree_.findRootMostValueAndPath(path);
            if (rootmost != null) {
                var rootMostPath = rootmost.path;
                var value = rootmost.value;
                var relativePath = Path_1.Path.relativePath(rootMostPath, path);
                value = value.updateChild(relativePath, node);
                return new CompoundWrite(this.writeTree_.set(rootMostPath, value));
            }
            else {
                var subtree = new ImmutableTree_1.ImmutableTree(node);
                var newWriteTree = this.writeTree_.setTree(path, subtree);
                return new CompoundWrite(newWriteTree);
            }
        }
    };
    /**
     * @param {!Path} path
     * @param {!Object.<string, !Node>} updates
     * @return {!CompoundWrite}
     */
    CompoundWrite.prototype.addWrites = function (path, updates) {
        var newWrite = this;
        util_1.forEach(updates, function (childKey, node) {
            newWrite = newWrite.addWrite(path.child(childKey), node);
        });
        return newWrite;
    };
    /**
     * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher
     * location, which must be removed by calling this method with that path.
     *
     * @param {!Path} path The path at which a write and all deeper writes should be removed
     * @return {!CompoundWrite} The new CompoundWrite with the removed path
     */
    CompoundWrite.prototype.removeWrite = function (path) {
        if (path.isEmpty()) {
            return CompoundWrite.Empty;
        }
        else {
            var newWriteTree = this.writeTree_.setTree(path, ImmutableTree_1.ImmutableTree.Empty);
            return new CompoundWrite(newWriteTree);
        }
    };
    /**
     * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be
     * considered "complete".
     *
     * @param {!Path} path The path to check for
     * @return {boolean} Whether there is a complete write at that path
     */
    CompoundWrite.prototype.hasCompleteWrite = function (path) {
        return this.getCompleteNode(path) != null;
    };
    /**
     * Returns a node for a path if and only if the node is a "complete" overwrite at that path. This will not aggregate
     * writes from deeper paths, but will return child nodes from a more shallow path.
     *
     * @param {!Path} path The path to get a complete write
     * @return {?Node} The node if complete at that path, or null otherwise.
     */
    CompoundWrite.prototype.getCompleteNode = function (path) {
        var rootmost = this.writeTree_.findRootMostValueAndPath(path);
        if (rootmost != null) {
            return this.writeTree_
                .get(rootmost.path)
                .getChild(Path_1.Path.relativePath(rootmost.path, path));
        }
        else {
            return null;
        }
    };
    /**
     * Returns all children that are guaranteed to be a complete overwrite.
     *
     * @return {!Array.<NamedNode>} A list of all complete children.
     */
    CompoundWrite.prototype.getCompleteChildren = function () {
        var children = [];
        var node = this.writeTree_.value;
        if (node != null) {
            // If it's a leaf node, it has no children; so nothing to do.
            if (!node.isLeafNode()) {
                node.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {
                    children.push(new Node_1.NamedNode(childName, childNode));
                });
            }
        }
        else {
            this.writeTree_.children.inorderTraversal(function (childName, childTree) {
                if (childTree.value != null) {
                    children.push(new Node_1.NamedNode(childName, childTree.value));
                }
            });
        }
        return children;
    };
    /**
     * @param {!Path} path
     * @return {!CompoundWrite}
     */
    CompoundWrite.prototype.childCompoundWrite = function (path) {
        if (path.isEmpty()) {
            return this;
        }
        else {
            var shadowingNode = this.getCompleteNode(path);
            if (shadowingNode != null) {
                return new CompoundWrite(new ImmutableTree_1.ImmutableTree(shadowingNode));
            }
            else {
                return new CompoundWrite(this.writeTree_.subtree(path));
            }
        }
    };
    /**
     * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.
     * @return {boolean} Whether this CompoundWrite is empty
     */
    CompoundWrite.prototype.isEmpty = function () {
        return this.writeTree_.isEmpty();
    };
    /**
     * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the
     * node
     * @param {!Node} node The node to apply this CompoundWrite to
     * @return {!Node} The node with all writes applied
     */
    CompoundWrite.prototype.apply = function (node) {
        return CompoundWrite.applySubtreeWrite_(Path_1.Path.Empty, this.writeTree_, node);
    };
    /**
     * @type {!CompoundWrite}
     */
    CompoundWrite.Empty = new CompoundWrite(new ImmutableTree_1.ImmutableTree(null));
    /**
     * @param {!Path} relativePath
     * @param {!ImmutableTree.<!Node>} writeTree
     * @param {!Node} node
     * @return {!Node}
     * @private
     */
    CompoundWrite.applySubtreeWrite_ = function (relativePath, writeTree, node) {
        if (writeTree.value != null) {
            // Since there a write is always a leaf, we're done here
            return node.updateChild(relativePath, writeTree.value);
        }
        else {
            var priorityWrite_1 = null;
            writeTree.children.inorderTraversal(function (childKey, childTree) {
                if (childKey === '.priority') {
                    // Apply priorities at the end so we don't update priorities for either empty nodes or forget
                    // to apply priorities to empty nodes that are later filled
                    util_2.assert(childTree.value !== null, 'Priority writes must always be leaf nodes');
                    priorityWrite_1 = childTree.value;
                }
                else {
                    node = CompoundWrite.applySubtreeWrite_(relativePath.child(childKey), childTree, node);
                }
            });
            // If there was a priority write, we only apply it if the node is not empty
            if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {
                node = node.updateChild(relativePath.child('.priority'), priorityWrite_1);
            }
            return node;
        }
    };
    return CompoundWrite;
}());
exports.CompoundWrite = CompoundWrite;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/CompoundWrite.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"./snap/Node":35,"./snap/indexes/PriorityIndex":41,"./util/ImmutableTree":54,"./util/Path":57,"@firebase/util":134,"_process":162,"buffer":160}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var app_1 = require("@firebase/app");
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
var util_3 = require("@firebase/util");
var util_4 = require("./util/util");
var Path_1 = require("./util/Path");
var VisibilityMonitor_1 = require("./util/VisibilityMonitor");
var OnlineMonitor_1 = require("./util/OnlineMonitor");
var util_5 = require("@firebase/util");
var Connection_1 = require("../realtime/Connection");
var util_6 = require("@firebase/util");
var util_7 = require("@firebase/util");
var ServerActions_1 = require("./ServerActions");
var RECONNECT_MIN_DELAY = 1000;
var RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)
var RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)
var RECONNECT_DELAY_MULTIPLIER = 1.3;
var RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.
var SERVER_KILL_INTERRUPT_REASON = 'server_kill';
// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.
var INVALID_AUTH_TOKEN_THRESHOLD = 3;
/**
 * Firebase connection.  Abstracts wire protocol and handles reconnecting.
 *
 * NOTE: All JSON objects sent to the realtime connection must have property names enclosed
 * in quotes to make sure the closure compiler does not minify them.
 */
var PersistentConnection = /** @class */ (function (_super) {
    __extends(PersistentConnection, _super);
    /**
     * @implements {ServerActions}
     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to
     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server
     * @param onConnectStatus_
     * @param onServerInfoUpdate_
     * @param authTokenProvider_
     * @param authOverride_
     */
    function PersistentConnection(repoInfo_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, authOverride_) {
        var _this = _super.call(this) || this;
        _this.repoInfo_ = repoInfo_;
        _this.onDataUpdate_ = onDataUpdate_;
        _this.onConnectStatus_ = onConnectStatus_;
        _this.onServerInfoUpdate_ = onServerInfoUpdate_;
        _this.authTokenProvider_ = authTokenProvider_;
        _this.authOverride_ = authOverride_;
        // Used for diagnostic logging.
        _this.id = PersistentConnection.nextPersistentConnectionId_++;
        _this.log_ = util_4.logWrapper('p:' + _this.id + ':');
        /** @private {Object} */
        _this.interruptReasons_ = {};
        _this.listens_ = {};
        _this.outstandingPuts_ = [];
        _this.outstandingPutCount_ = 0;
        _this.onDisconnectRequestQueue_ = [];
        _this.connected_ = false;
        _this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
        _this.securityDebugCallback_ = null;
        _this.lastSessionId = null;
        /** @private {number|null} */
        _this.establishConnectionTimer_ = null;
        /** @private {boolean} */
        _this.visible_ = false;
        // Before we get connected, we keep a queue of pending messages to send.
        _this.requestCBHash_ = {};
        _this.requestNumber_ = 0;
        /** @private {?{
         *   sendRequest(Object),
         *   close()
         * }} */
        _this.realtime_ = null;
        /** @private {string|null} */
        _this.authToken_ = null;
        _this.forceTokenRefresh_ = false;
        _this.invalidAuthTokenCount_ = 0;
        _this.firstConnection_ = true;
        _this.lastConnectionAttemptTime_ = null;
        _this.lastConnectionEstablishedTime_ = null;
        if (authOverride_ && !util_7.isNodeSdk()) {
            throw new Error('Auth override specified in options, but not supported on non Node.js platforms');
        }
        _this.scheduleConnect_(0);
        VisibilityMonitor_1.VisibilityMonitor.getInstance().on('visible', _this.onVisible_, _this);
        if (repoInfo_.host.indexOf('fblocal') === -1) {
            OnlineMonitor_1.OnlineMonitor.getInstance().on('online', _this.onOnline_, _this);
        }
        return _this;
    }
    /**
     * @param {!string} action
     * @param {*} body
     * @param {function(*)=} onResponse
     * @protected
     */
    PersistentConnection.prototype.sendRequest = function (action, body, onResponse) {
        var curReqNum = ++this.requestNumber_;
        var msg = { r: curReqNum, a: action, b: body };
        this.log_(util_2.stringify(msg));
        util_3.assert(this.connected_, "sendRequest call when we're not connected not allowed.");
        this.realtime_.sendRequest(msg);
        if (onResponse) {
            this.requestCBHash_[curReqNum] = onResponse;
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.listen = function (query, currentHashFn, tag, onComplete) {
        var queryId = query.queryIdentifier();
        var pathString = query.path.toString();
        this.log_('Listen called for ' + pathString + ' ' + queryId);
        this.listens_[pathString] = this.listens_[pathString] || {};
        util_3.assert(query.getQueryParams().isDefault() ||
            !query.getQueryParams().loadsAllData(), 'listen() called for non-default but complete query');
        util_3.assert(!this.listens_[pathString][queryId], 'listen() called twice for same path/queryId.');
        var listenSpec = {
            onComplete: onComplete,
            hashFn: currentHashFn,
            query: query,
            tag: tag
        };
        this.listens_[pathString][queryId] = listenSpec;
        if (this.connected_) {
            this.sendListen_(listenSpec);
        }
    };
    /**
     * @param {!{onComplete(),
     *           hashFn():!string,
     *           query: !Query,
     *           tag: ?number}} listenSpec
     * @private
     */
    PersistentConnection.prototype.sendListen_ = function (listenSpec) {
        var _this = this;
        var query = listenSpec.query;
        var pathString = query.path.toString();
        var queryId = query.queryIdentifier();
        this.log_('Listen on ' + pathString + ' for ' + queryId);
        var req = { /*path*/ p: pathString };
        var action = 'q';
        // Only bother to send query if it's non-default.
        if (listenSpec.tag) {
            req['q'] = query.queryObject();
            req['t'] = listenSpec.tag;
        }
        req['h'] = listenSpec.hashFn();
        this.sendRequest(action, req, function (message) {
            var payload = message['d'];
            var status = message['s'];
            // print warnings in any case...
            PersistentConnection.warnOnListenWarnings_(payload, query);
            var currentListenSpec = _this.listens_[pathString] && _this.listens_[pathString][queryId];
            // only trigger actions if the listen hasn't been removed and readded
            if (currentListenSpec === listenSpec) {
                _this.log_('listen response', message);
                if (status !== 'ok') {
                    _this.removeListen_(pathString, queryId);
                }
                if (listenSpec.onComplete) {
                    listenSpec.onComplete(status, payload);
                }
            }
        });
    };
    /**
     * @param {*} payload
     * @param {!Query} query
     * @private
     */
    PersistentConnection.warnOnListenWarnings_ = function (payload, query) {
        if (payload && typeof payload === 'object' && util_1.contains(payload, 'w')) {
            var warnings = util_1.safeGet(payload, 'w');
            if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {
                var indexSpec = '".indexOn": "' +
                    query
                        .getQueryParams()
                        .getIndex()
                        .toString() +
                    '"';
                var indexPath = query.path.toString();
                util_4.warn("Using an unspecified index. Your data will be downloaded and " +
                    ("filtered on the client. Consider adding " + indexSpec + " at ") +
                    (indexPath + " to your security rules for better performance."));
            }
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.refreshAuthToken = function (token) {
        this.authToken_ = token;
        this.log_('Auth token refreshed');
        if (this.authToken_) {
            this.tryAuth();
        }
        else {
            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete
            //the credential so we dont become authenticated next time we connect.
            if (this.connected_) {
                this.sendRequest('unauth', {}, function () { });
            }
        }
        this.reduceReconnectDelayIfAdminCredential_(token);
    };
    /**
     * @param {!string} credential
     * @private
     */
    PersistentConnection.prototype.reduceReconnectDelayIfAdminCredential_ = function (credential) {
        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).
        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.
        var isFirebaseSecret = credential && credential.length === 40;
        if (isFirebaseSecret || util_5.isAdmin(credential)) {
            this.log_('Admin auth credential detected.  Reducing max reconnect time.');
            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
        }
    };
    /**
     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like
     * a auth revoked (the connection is closed).
     */
    PersistentConnection.prototype.tryAuth = function () {
        var _this = this;
        if (this.connected_ && this.authToken_) {
            var token_1 = this.authToken_;
            var authMethod = util_5.isValidFormat(token_1) ? 'auth' : 'gauth';
            var requestData = { cred: token_1 };
            if (this.authOverride_ === null) {
                requestData['noauth'] = true;
            }
            else if (typeof this.authOverride_ === 'object') {
                requestData['authvar'] = this.authOverride_;
            }
            this.sendRequest(authMethod, requestData, function (res) {
                var status = res['s'];
                var data = res['d'] || 'error';
                if (_this.authToken_ === token_1) {
                    if (status === 'ok') {
                        _this.invalidAuthTokenCount_ = 0;
                    }
                    else {
                        // Triggers reconnect and force refresh for auth token
                        _this.onAuthRevoked_(status, data);
                    }
                }
            });
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.unlisten = function (query, tag) {
        var pathString = query.path.toString();
        var queryId = query.queryIdentifier();
        this.log_('Unlisten called for ' + pathString + ' ' + queryId);
        util_3.assert(query.getQueryParams().isDefault() ||
            !query.getQueryParams().loadsAllData(), 'unlisten() called for non-default but complete query');
        var listen = this.removeListen_(pathString, queryId);
        if (listen && this.connected_) {
            this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);
        }
    };
    PersistentConnection.prototype.sendUnlisten_ = function (pathString, queryId, queryObj, tag) {
        this.log_('Unlisten on ' + pathString + ' for ' + queryId);
        var req = { /*path*/ p: pathString };
        var action = 'n';
        // Only bother sending queryId if it's non-default.
        if (tag) {
            req['q'] = queryObj;
            req['t'] = tag;
        }
        this.sendRequest(action, req);
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.onDisconnectPut = function (pathString, data, onComplete) {
        if (this.connected_) {
            this.sendOnDisconnect_('o', pathString, data, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString: pathString,
                action: 'o',
                data: data,
                onComplete: onComplete
            });
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.onDisconnectMerge = function (pathString, data, onComplete) {
        if (this.connected_) {
            this.sendOnDisconnect_('om', pathString, data, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString: pathString,
                action: 'om',
                data: data,
                onComplete: onComplete
            });
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.onDisconnectCancel = function (pathString, onComplete) {
        if (this.connected_) {
            this.sendOnDisconnect_('oc', pathString, null, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString: pathString,
                action: 'oc',
                data: null,
                onComplete: onComplete
            });
        }
    };
    PersistentConnection.prototype.sendOnDisconnect_ = function (action, pathString, data, onComplete) {
        var request = { /*path*/ p: pathString, /*data*/ d: data };
        this.log_('onDisconnect ' + action, request);
        this.sendRequest(action, request, function (response) {
            if (onComplete) {
                setTimeout(function () {
                    onComplete(response['s'], response['d']);
                }, Math.floor(0));
            }
        });
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {
        this.putInternal('p', pathString, data, onComplete, hash);
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.merge = function (pathString, data, onComplete, hash) {
        this.putInternal('m', pathString, data, onComplete, hash);
    };
    PersistentConnection.prototype.putInternal = function (action, pathString, data, onComplete, hash) {
        var request = {
            /*path*/ p: pathString,
            /*data*/ d: data
        };
        if (hash !== undefined)
            request['h'] = hash;
        // TODO: Only keep track of the most recent put for a given path?
        this.outstandingPuts_.push({
            action: action,
            request: request,
            onComplete: onComplete
        });
        this.outstandingPutCount_++;
        var index = this.outstandingPuts_.length - 1;
        if (this.connected_) {
            this.sendPut_(index);
        }
        else {
            this.log_('Buffering put: ' + pathString);
        }
    };
    PersistentConnection.prototype.sendPut_ = function (index) {
        var _this = this;
        var action = this.outstandingPuts_[index].action;
        var request = this.outstandingPuts_[index].request;
        var onComplete = this.outstandingPuts_[index].onComplete;
        this.outstandingPuts_[index].queued = this.connected_;
        this.sendRequest(action, request, function (message) {
            _this.log_(action + ' response', message);
            delete _this.outstandingPuts_[index];
            _this.outstandingPutCount_--;
            // Clean up array occasionally.
            if (_this.outstandingPutCount_ === 0) {
                _this.outstandingPuts_ = [];
            }
            if (onComplete)
                onComplete(message['s'], message['d']);
        });
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.reportStats = function (stats) {
        var _this = this;
        // If we're not connected, we just drop the stats.
        if (this.connected_) {
            var request = { /*counters*/ c: stats };
            this.log_('reportStats', request);
            this.sendRequest(/*stats*/ 's', request, function (result) {
                var status = result['s'];
                if (status !== 'ok') {
                    var errorReason = result['d'];
                    _this.log_('reportStats', 'Error sending stats: ' + errorReason);
                }
            });
        }
    };
    /**
     * @param {*} message
     * @private
     */
    PersistentConnection.prototype.onDataMessage_ = function (message) {
        if ('r' in message) {
            // this is a response
            this.log_('from server: ' + util_2.stringify(message));
            var reqNum = message['r'];
            var onResponse = this.requestCBHash_[reqNum];
            if (onResponse) {
                delete this.requestCBHash_[reqNum];
                onResponse(message['b']);
            }
        }
        else if ('error' in message) {
            throw 'A server-side error has occurred: ' + message['error'];
        }
        else if ('a' in message) {
            // a and b are action and body, respectively
            this.onDataPush_(message['a'], message['b']);
        }
    };
    PersistentConnection.prototype.onDataPush_ = function (action, body) {
        this.log_('handleServerMessage', action, body);
        if (action === 'd')
            this.onDataUpdate_(body['p'], body['d'], 
            /*isMerge*/ false, body['t']);
        else if (action === 'm')
            this.onDataUpdate_(body['p'], body['d'], 
            /*isMerge=*/ true, body['t']);
        else if (action === 'c')
            this.onListenRevoked_(body['p'], body['q']);
        else if (action === 'ac')
            this.onAuthRevoked_(body['s'], body['d']);
        else if (action === 'sd')
            this.onSecurityDebugPacket_(body);
        else
            util_4.error('Unrecognized action received from server: ' +
                util_2.stringify(action) +
                '\nAre you using the latest client?');
    };
    PersistentConnection.prototype.onReady_ = function (timestamp, sessionId) {
        this.log_('connection ready');
        this.connected_ = true;
        this.lastConnectionEstablishedTime_ = new Date().getTime();
        this.handleTimestamp_(timestamp);
        this.lastSessionId = sessionId;
        if (this.firstConnection_) {
            this.sendConnectStats_();
        }
        this.restoreState_();
        this.firstConnection_ = false;
        this.onConnectStatus_(true);
    };
    PersistentConnection.prototype.scheduleConnect_ = function (timeout) {
        var _this = this;
        util_3.assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
        if (this.establishConnectionTimer_) {
            clearTimeout(this.establishConnectionTimer_);
        }
        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating "Security Error" in
        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).
        this.establishConnectionTimer_ = setTimeout(function () {
            _this.establishConnectionTimer_ = null;
            _this.establishConnection_();
        }, Math.floor(timeout));
    };
    /**
     * @param {boolean} visible
     * @private
     */
    PersistentConnection.prototype.onVisible_ = function (visible) {
        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.
        if (visible &&
            !this.visible_ &&
            this.reconnectDelay_ === this.maxReconnectDelay_) {
            this.log_('Window became visible.  Reducing delay.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
        this.visible_ = visible;
    };
    PersistentConnection.prototype.onOnline_ = function (online) {
        if (online) {
            this.log_('Browser went online.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
        else {
            this.log_('Browser went offline.  Killing connection.');
            if (this.realtime_) {
                this.realtime_.close();
            }
        }
    };
    PersistentConnection.prototype.onRealtimeDisconnect_ = function () {
        this.log_('data client disconnected');
        this.connected_ = false;
        this.realtime_ = null;
        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.
        this.cancelSentTransactions_();
        // Clear out the pending requests.
        this.requestCBHash_ = {};
        if (this.shouldReconnect_()) {
            if (!this.visible_) {
                this.log_("Window isn't visible.  Delaying reconnect.");
                this.reconnectDelay_ = this.maxReconnectDelay_;
                this.lastConnectionAttemptTime_ = new Date().getTime();
            }
            else if (this.lastConnectionEstablishedTime_) {
                // If we've been connected long enough, reset reconnect delay to minimum.
                var timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;
                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT)
                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;
                this.lastConnectionEstablishedTime_ = null;
            }
            var timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;
            var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
            reconnectDelay = Math.random() * reconnectDelay;
            this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');
            this.scheduleConnect_(reconnectDelay);
            // Adjust reconnect delay for next time.
            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
        }
        this.onConnectStatus_(false);
    };
    PersistentConnection.prototype.establishConnection_ = function () {
        if (this.shouldReconnect_()) {
            this.log_('Making a connection attempt');
            this.lastConnectionAttemptTime_ = new Date().getTime();
            this.lastConnectionEstablishedTime_ = null;
            var onDataMessage_1 = this.onDataMessage_.bind(this);
            var onReady_1 = this.onReady_.bind(this);
            var onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);
            var connId_1 = this.id + ':' + PersistentConnection.nextConnectionId_++;
            var self_1 = this;
            var lastSessionId_1 = this.lastSessionId;
            var canceled_1 = false;
            var connection_1 = null;
            var closeFn_1 = function () {
                if (connection_1) {
                    connection_1.close();
                }
                else {
                    canceled_1 = true;
                    onDisconnect_1();
                }
            };
            var sendRequestFn = function (msg) {
                util_3.assert(connection_1, "sendRequest call when we're not connected not allowed.");
                connection_1.sendRequest(msg);
            };
            this.realtime_ = {
                close: closeFn_1,
                sendRequest: sendRequestFn
            };
            var forceRefresh = this.forceTokenRefresh_;
            this.forceTokenRefresh_ = false;
            // First fetch auth token, and establish connection after fetching the token was successful
            this.authTokenProvider_
                .getToken(forceRefresh)
                .then(function (result) {
                if (!canceled_1) {
                    util_4.log('getToken() completed. Creating connection.');
                    self_1.authToken_ = result && result.accessToken;
                    connection_1 = new Connection_1.Connection(connId_1, self_1.repoInfo_, onDataMessage_1, onReady_1, onDisconnect_1, 
                    /* onKill= */ function (reason) {
                        util_4.warn(reason + ' (' + self_1.repoInfo_.toString() + ')');
                        self_1.interrupt(SERVER_KILL_INTERRUPT_REASON);
                    }, lastSessionId_1);
                }
                else {
                    util_4.log('getToken() completed but was canceled');
                }
            })
                .then(null, function (error) {
                self_1.log_('Failed to get token: ' + error);
                if (!canceled_1) {
                    if (util_6.CONSTANTS.NODE_ADMIN) {
                        // This may be a critical error for the Admin Node.js SDK, so log a warning.
                        // But getToken() may also just have temporarily failed, so we still want to
                        // continue retrying.
                        util_4.warn(error);
                    }
                    closeFn_1();
                }
            });
        }
    };
    /**
     * @param {string} reason
     */
    PersistentConnection.prototype.interrupt = function (reason) {
        util_4.log('Interrupting connection for reason: ' + reason);
        this.interruptReasons_[reason] = true;
        if (this.realtime_) {
            this.realtime_.close();
        }
        else {
            if (this.establishConnectionTimer_) {
                clearTimeout(this.establishConnectionTimer_);
                this.establishConnectionTimer_ = null;
            }
            if (this.connected_) {
                this.onRealtimeDisconnect_();
            }
        }
    };
    /**
     * @param {string} reason
     */
    PersistentConnection.prototype.resume = function (reason) {
        util_4.log('Resuming connection for reason: ' + reason);
        delete this.interruptReasons_[reason];
        if (util_1.isEmpty(this.interruptReasons_)) {
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
    };
    PersistentConnection.prototype.handleTimestamp_ = function (timestamp) {
        var delta = timestamp - new Date().getTime();
        this.onServerInfoUpdate_({ serverTimeOffset: delta });
    };
    PersistentConnection.prototype.cancelSentTransactions_ = function () {
        for (var i = 0; i < this.outstandingPuts_.length; i++) {
            var put = this.outstandingPuts_[i];
            if (put && /*hash*/ 'h' in put.request && put.queued) {
                if (put.onComplete)
                    put.onComplete('disconnect');
                delete this.outstandingPuts_[i];
                this.outstandingPutCount_--;
            }
        }
        // Clean up array occasionally.
        if (this.outstandingPutCount_ === 0)
            this.outstandingPuts_ = [];
    };
    /**
     * @param {!string} pathString
     * @param {Array.<*>=} query
     * @private
     */
    PersistentConnection.prototype.onListenRevoked_ = function (pathString, query) {
        // Remove the listen and manufacture a "permission_denied" error for the failed listen.
        var queryId;
        if (!query) {
            queryId = 'default';
        }
        else {
            queryId = query.map(function (q) { return util_4.ObjectToUniqueKey(q); }).join('$');
        }
        var listen = this.removeListen_(pathString, queryId);
        if (listen && listen.onComplete)
            listen.onComplete('permission_denied');
    };
    /**
     * @param {!string} pathString
     * @param {!string} queryId
     * @return {{queries:Array.<Query>, onComplete:function(string)}}
     * @private
     */
    PersistentConnection.prototype.removeListen_ = function (pathString, queryId) {
        var normalizedPathString = new Path_1.Path(pathString).toString(); // normalize path.
        var listen;
        if (this.listens_[normalizedPathString] !== undefined) {
            listen = this.listens_[normalizedPathString][queryId];
            delete this.listens_[normalizedPathString][queryId];
            if (util_1.getCount(this.listens_[normalizedPathString]) === 0) {
                delete this.listens_[normalizedPathString];
            }
        }
        else {
            // all listens for this path has already been removed
            listen = undefined;
        }
        return listen;
    };
    PersistentConnection.prototype.onAuthRevoked_ = function (statusCode, explanation) {
        util_4.log('Auth token revoked: ' + statusCode + '/' + explanation);
        this.authToken_ = null;
        this.forceTokenRefresh_ = true;
        this.realtime_.close();
        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {
            // We'll wait a couple times before logging the warning / increasing the
            // retry period since oauth tokens will report as "invalid" if they're
            // just expired. Plus there may be transient issues that resolve themselves.
            this.invalidAuthTokenCount_++;
            if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {
                // Set a long reconnect delay because recovery is unlikely
                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
                // Notify the auth token provider that the token is invalid, which will log
                // a warning
                this.authTokenProvider_.notifyForInvalidToken();
            }
        }
    };
    PersistentConnection.prototype.onSecurityDebugPacket_ = function (body) {
        if (this.securityDebugCallback_) {
            this.securityDebugCallback_(body);
        }
        else {
            if ('msg' in body && typeof console !== 'undefined') {
                console.log('FIREBASE: ' + body['msg'].replace('\n', '\nFIREBASE: '));
            }
        }
    };
    PersistentConnection.prototype.restoreState_ = function () {
        var _this = this;
        //Re-authenticate ourselves if we have a credential stored.
        this.tryAuth();
        // Puts depend on having received the corresponding data update from the server before they complete, so we must
        // make sure to send listens before puts.
        util_1.forEach(this.listens_, function (pathString, queries) {
            util_1.forEach(queries, function (key, listenSpec) {
                _this.sendListen_(listenSpec);
            });
        });
        for (var i = 0; i < this.outstandingPuts_.length; i++) {
            if (this.outstandingPuts_[i])
                this.sendPut_(i);
        }
        while (this.onDisconnectRequestQueue_.length) {
            var request = this.onDisconnectRequestQueue_.shift();
            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
        }
    };
    /**
     * Sends client stats for first connection
     * @private
     */
    PersistentConnection.prototype.sendConnectStats_ = function () {
        var stats = {};
        var clientName = 'js';
        if (util_6.CONSTANTS.NODE_ADMIN) {
            clientName = 'admin_node';
        }
        else if (util_6.CONSTANTS.NODE_CLIENT) {
            clientName = 'node';
        }
        stats['sdk.' + clientName + '.' + app_1.default.SDK_VERSION.replace(/\./g, '-')] = 1;
        if (util_7.isMobileCordova()) {
            stats['framework.cordova'] = 1;
        }
        else if (util_7.isReactNative()) {
            stats['framework.reactnative'] = 1;
        }
        this.reportStats(stats);
    };
    /**
     * @return {boolean}
     * @private
     */
    PersistentConnection.prototype.shouldReconnect_ = function () {
        var online = OnlineMonitor_1.OnlineMonitor.getInstance().currentlyOnline();
        return util_1.isEmpty(this.interruptReasons_) && online;
    };
    /**
     * @private
     */
    PersistentConnection.nextPersistentConnectionId_ = 0;
    /**
     * Counter for number of connections created. Mainly used for tagging in the logs
     * @type {number}
     * @private
     */
    PersistentConnection.nextConnectionId_ = 0;
    return PersistentConnection;
}(ServerActions_1.ServerActions));
exports.PersistentConnection = PersistentConnection;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/PersistentConnection.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"../realtime/Connection":81,"./ServerActions":21,"./util/OnlineMonitor":56,"./util/Path":57,"./util/VisibilityMonitor":61,"./util/util":63,"@firebase/app":1,"@firebase/util":134,"_process":162,"buffer":160}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("./util/util");
var util_3 = require("@firebase/util");
var util_4 = require("@firebase/util");
var util_5 = require("@firebase/util");
var ServerActions_1 = require("./ServerActions");
/**
 * An implementation of ServerActions that communicates with the server via REST requests.
 * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full
 * persistent connection (using WebSockets or long-polling)
 */
var ReadonlyRestClient = /** @class */ (function (_super) {
    __extends(ReadonlyRestClient, _super);
    /**
     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to
     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server
     * @param {AuthTokenProvider} authTokenProvider_
     * @implements {ServerActions}
     */
    function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_) {
        var _this = _super.call(this) || this;
        _this.repoInfo_ = repoInfo_;
        _this.onDataUpdate_ = onDataUpdate_;
        _this.authTokenProvider_ = authTokenProvider_;
        /** @private {function(...[*])} */
        _this.log_ = util_2.logWrapper('p:rest:');
        /**
         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen
         * that's been removed. :-/
         *
         * @private {!Object.<string, !Object>}
         */
        _this.listens_ = {};
        return _this;
    }
    ReadonlyRestClient.prototype.reportStats = function (stats) {
        throw new Error('Method not implemented.');
    };
    /**
     * @param {!Query} query
     * @param {?number=} tag
     * @return {string}
     * @private
     */
    ReadonlyRestClient.getListenId_ = function (query, tag) {
        if (tag !== undefined) {
            return 'tag$' + tag;
        }
        else {
            util_1.assert(query.getQueryParams().isDefault(), "should have a tag if it's not a default query.");
            return query.path.toString();
        }
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.listen = function (query, currentHashFn, tag, onComplete) {
        var _this = this;
        var pathString = query.path.toString();
        this.log_('Listen called for ' + pathString + ' ' + query.queryIdentifier());
        // Mark this listener so we can tell if it's removed.
        var listenId = ReadonlyRestClient.getListenId_(query, tag);
        var thisListen = {};
        this.listens_[listenId] = thisListen;
        var queryStringParamaters = query
            .getQueryParams()
            .toRestQueryStringParameters();
        this.restRequest_(pathString + '.json', queryStringParamaters, function (error, result) {
            var data = result;
            if (error === 404) {
                data = null;
                error = null;
            }
            if (error === null) {
                _this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);
            }
            if (util_4.safeGet(_this.listens_, listenId) === thisListen) {
                var status_1;
                if (!error) {
                    status_1 = 'ok';
                }
                else if (error == 401) {
                    status_1 = 'permission_denied';
                }
                else {
                    status_1 = 'rest_error:' + error;
                }
                onComplete(status_1, null);
            }
        });
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.unlisten = function (query, tag) {
        var listenId = ReadonlyRestClient.getListenId_(query, tag);
        delete this.listens_[listenId];
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.refreshAuthToken = function (token) {
        // no-op since we just always call getToken.
    };
    /**
     * Performs a REST request to the given path, with the provided query string parameters,
     * and any auth credentials we have.
     *
     * @param {!string} pathString
     * @param {!Object.<string, *>} queryStringParameters
     * @param {?function(?number, *=)} callback
     * @private
     */
    ReadonlyRestClient.prototype.restRequest_ = function (pathString, queryStringParameters, callback) {
        var _this = this;
        if (queryStringParameters === void 0) { queryStringParameters = {}; }
        queryStringParameters['format'] = 'export';
        this.authTokenProvider_
            .getToken(/*forceRefresh=*/ false)
            .then(function (authTokenData) {
            var authToken = authTokenData && authTokenData.accessToken;
            if (authToken) {
                queryStringParameters['auth'] = authToken;
            }
            var url = (_this.repoInfo_.secure ? 'https://' : 'http://') +
                _this.repoInfo_.host +
                pathString +
                '?' +
                util_5.querystring(queryStringParameters);
            _this.log_('Sending REST request for ' + url);
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (callback && xhr.readyState === 4) {
                    _this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);
                    var res = null;
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            res = util_3.jsonEval(xhr.responseText);
                        }
                        catch (e) {
                            util_2.warn('Failed to parse JSON response for ' +
                                url +
                                ': ' +
                                xhr.responseText);
                        }
                        callback(null, res);
                    }
                    else {
                        // 401 and 404 are expected.
                        if (xhr.status !== 401 && xhr.status !== 404) {
                            util_2.warn('Got unsuccessful REST response for ' +
                                url +
                                ' Status: ' +
                                xhr.status);
                        }
                        callback(xhr.status);
                    }
                    callback = null;
                }
            };
            xhr.open('GET', url, /*asynchronous=*/ true);
            xhr.send();
        });
    };
    return ReadonlyRestClient;
}(ServerActions_1.ServerActions));
exports.ReadonlyRestClient = ReadonlyRestClient;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/ReadonlyRestClient.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"./ServerActions":21,"./util/util":63,"@firebase/util":134,"_process":162,"buffer":160}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ServerValues_1 = require("./util/ServerValues");
var nodeFromJSON_1 = require("./snap/nodeFromJSON");
var Path_1 = require("./util/Path");
var SparseSnapshotTree_1 = require("./SparseSnapshotTree");
var SyncTree_1 = require("./SyncTree");
var SnapshotHolder_1 = require("./SnapshotHolder");
var util_1 = require("@firebase/util");
var util_2 = require("./util/util");
var util_3 = require("@firebase/util");
var AuthTokenProvider_1 = require("./AuthTokenProvider");
var StatsManager_1 = require("./stats/StatsManager");
var StatsReporter_1 = require("./stats/StatsReporter");
var StatsListener_1 = require("./stats/StatsListener");
var EventQueue_1 = require("./view/EventQueue");
var PersistentConnection_1 = require("./PersistentConnection");
var ReadonlyRestClient_1 = require("./ReadonlyRestClient");
var Database_1 = require("../api/Database");
var INTERRUPT_REASON = 'repo_interrupt';
/**
 * A connection to a single data repository.
 */
var Repo = /** @class */ (function () {
    /**
     * @param {!RepoInfo} repoInfo_
     * @param {boolean} forceRestClient
     * @param {!FirebaseApp} app
     */
    function Repo(repoInfo_, forceRestClient, app) {
        var _this = this;
        this.repoInfo_ = repoInfo_;
        this.app = app;
        this.dataUpdateCount = 0;
        this.statsListener_ = null;
        this.eventQueue_ = new EventQueue_1.EventQueue();
        this.nextWriteId_ = 1;
        this.interceptServerDataCallback_ = null;
        // A list of data pieces and paths to be set when this client disconnects.
        this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();
        /**
         * TODO: This should be @private but it's used by test_access.js and internal.js
         * @type {?PersistentConnection}
         */
        this.persistentConnection_ = null;
        /** @type {!AuthTokenProvider} */
        var authTokenProvider = new AuthTokenProvider_1.AuthTokenProvider(app);
        this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo_);
        if (forceRestClient || util_2.beingCrawled()) {
            this.server_ = new ReadonlyRestClient_1.ReadonlyRestClient(this.repoInfo_, this.onDataUpdate_.bind(this), authTokenProvider);
            // Minor hack: Fire onConnect immediately, since there's no actual connection.
            setTimeout(this.onConnectStatus_.bind(this, true), 0);
        }
        else {
            var authOverride = app.options['databaseAuthVariableOverride'];
            // Validate authOverride
            if (typeof authOverride !== 'undefined' && authOverride !== null) {
                if (typeof authOverride !== 'object') {
                    throw new Error('Only objects are supported for option databaseAuthVariableOverride');
                }
                try {
                    util_1.stringify(authOverride);
                }
                catch (e) {
                    throw new Error('Invalid authOverride provided: ' + e);
                }
            }
            this.persistentConnection_ = new PersistentConnection_1.PersistentConnection(this.repoInfo_, this.onDataUpdate_.bind(this), this.onConnectStatus_.bind(this), this.onServerInfoUpdate_.bind(this), authTokenProvider, authOverride);
            this.server_ = this.persistentConnection_;
        }
        authTokenProvider.addTokenChangeListener(function (token) {
            _this.server_.refreshAuthToken(token);
        });
        // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),
        // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.
        this.statsReporter_ = StatsManager_1.StatsManager.getOrCreateReporter(repoInfo_, function () { return new StatsReporter_1.StatsReporter(_this.stats_, _this.server_); });
        this.transactions_init_();
        // Used for .info.
        this.infoData_ = new SnapshotHolder_1.SnapshotHolder();
        this.infoSyncTree_ = new SyncTree_1.SyncTree({
            startListening: function (query, tag, currentHashFn, onComplete) {
                var infoEvents = [];
                var node = _this.infoData_.getNode(query.path);
                // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events
                // on initial data...
                if (!node.isEmpty()) {
                    infoEvents = _this.infoSyncTree_.applyServerOverwrite(query.path, node);
                    setTimeout(function () {
                        onComplete('ok');
                    }, 0);
                }
                return infoEvents;
            },
            stopListening: function () { }
        });
        this.updateInfo_('connected', false);
        this.serverSyncTree_ = new SyncTree_1.SyncTree({
            startListening: function (query, tag, currentHashFn, onComplete) {
                _this.server_.listen(query, currentHashFn, tag, function (status, data) {
                    var events = onComplete(status, data);
                    _this.eventQueue_.raiseEventsForChangedPath(query.path, events);
                });
                // No synchronous events for network-backed sync trees
                return [];
            },
            stopListening: function (query, tag) {
                _this.server_.unlisten(query, tag);
            }
        });
    }
    /**
     * @return {string}  The URL corresponding to the root of this Firebase.
     */
    Repo.prototype.toString = function () {
        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);
    };
    /**
     * @return {!string} The namespace represented by the repo.
     */
    Repo.prototype.name = function () {
        return this.repoInfo_.namespace;
    };
    /**
     * @return {!number} The time in milliseconds, taking the server offset into account if we have one.
     */
    Repo.prototype.serverTime = function () {
        var offsetNode = this.infoData_.getNode(new Path_1.Path('.info/serverTimeOffset'));
        var offset = offsetNode.val() || 0;
        return new Date().getTime() + offset;
    };
    /**
     * Generate ServerValues using some variables from the repo object.
     * @return {!Object}
     */
    Repo.prototype.generateServerValues = function () {
        return ServerValues_1.generateWithValues({
            timestamp: this.serverTime()
        });
    };
    /**
     * Called by realtime when we get new messages from the server.
     *
     * @private
     * @param {string} pathString
     * @param {*} data
     * @param {boolean} isMerge
     * @param {?number} tag
     */
    Repo.prototype.onDataUpdate_ = function (pathString, data, isMerge, tag) {
        // For testing.
        this.dataUpdateCount++;
        var path = new Path_1.Path(pathString);
        data = this.interceptServerDataCallback_
            ? this.interceptServerDataCallback_(pathString, data)
            : data;
        var events = [];
        if (tag) {
            if (isMerge) {
                var taggedChildren = util_3.map(data, function (raw) {
                    return nodeFromJSON_1.nodeFromJSON(raw);
                });
                events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);
            }
            else {
                var taggedSnap = nodeFromJSON_1.nodeFromJSON(data);
                events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);
            }
        }
        else if (isMerge) {
            var changedChildren = util_3.map(data, function (raw) {
                return nodeFromJSON_1.nodeFromJSON(raw);
            });
            events = this.serverSyncTree_.applyServerMerge(path, changedChildren);
        }
        else {
            var snap = nodeFromJSON_1.nodeFromJSON(data);
            events = this.serverSyncTree_.applyServerOverwrite(path, snap);
        }
        var affectedPath = path;
        if (events.length > 0) {
            // Since we have a listener outstanding for each transaction, receiving any events
            // is a proxy for some change having occurred.
            affectedPath = this.rerunTransactions_(path);
        }
        this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);
    };
    /**
     * TODO: This should be @private but it's used by test_access.js and internal.js
     * @param {?function(!string, *):*} callback
     * @private
     */
    Repo.prototype.interceptServerData_ = function (callback) {
        this.interceptServerDataCallback_ = callback;
    };
    /**
     * @param {!boolean} connectStatus
     * @private
     */
    Repo.prototype.onConnectStatus_ = function (connectStatus) {
        this.updateInfo_('connected', connectStatus);
        if (connectStatus === false) {
            this.runOnDisconnectEvents_();
        }
    };
    /**
     * @param {!Object} updates
     * @private
     */
    Repo.prototype.onServerInfoUpdate_ = function (updates) {
        var _this = this;
        util_2.each(updates, function (value, key) {
            _this.updateInfo_(key, value);
        });
    };
    /**
     *
     * @param {!string} pathString
     * @param {*} value
     * @private
     */
    Repo.prototype.updateInfo_ = function (pathString, value) {
        var path = new Path_1.Path('/.info/' + pathString);
        var newNode = nodeFromJSON_1.nodeFromJSON(value);
        this.infoData_.updateSnapshot(path, newNode);
        var events = this.infoSyncTree_.applyServerOverwrite(path, newNode);
        this.eventQueue_.raiseEventsForChangedPath(path, events);
    };
    /**
     * @return {!number}
     * @private
     */
    Repo.prototype.getNextWriteId_ = function () {
        return this.nextWriteId_++;
    };
    /**
     * @param {!Path} path
     * @param {*} newVal
     * @param {number|string|null} newPriority
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.setWithPriority = function (path, newVal, newPriority, onComplete) {
        var _this = this;
        this.log_('set', {
            path: path.toString(),
            value: newVal,
            priority: newPriority
        });
        // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or
        // (b) store unresolved paths on JSON parse
        var serverValues = this.generateServerValues();
        var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, newPriority);
        var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);
        var writeId = this.getNextWriteId_();
        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);
        this.eventQueue_.queueEvents(events);
        this.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), function (status, errorReason) {
            var success = status === 'ok';
            if (!success) {
                util_2.warn('set at ' + path + ' failed: ' + status);
            }
            var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId, !success);
            _this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
        var affectedPath = this.abortTransactions_(path);
        this.rerunTransactions_(affectedPath);
        // We queued the events above, so just flush the queue here
        this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);
    };
    /**
     * @param {!Path} path
     * @param {!Object} childrenToMerge
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.update = function (path, childrenToMerge, onComplete) {
        var _this = this;
        this.log_('update', { path: path.toString(), value: childrenToMerge });
        // Start with our existing data and merge each child into it.
        var empty = true;
        var serverValues = this.generateServerValues();
        var changedChildren = {};
        util_3.forEach(childrenToMerge, function (changedKey, changedValue) {
            empty = false;
            var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(changedValue);
            changedChildren[changedKey] = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);
        });
        if (!empty) {
            var writeId_1 = this.getNextWriteId_();
            var events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId_1);
            this.eventQueue_.queueEvents(events);
            this.server_.merge(path.toString(), childrenToMerge, function (status, errorReason) {
                var success = status === 'ok';
                if (!success) {
                    util_2.warn('update at ' + path + ' failed: ' + status);
                }
                var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId_1, !success);
                var affectedPath = clearEvents.length > 0 ? _this.rerunTransactions_(path) : path;
                _this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);
                _this.callOnCompleteCallback(onComplete, status, errorReason);
            });
            util_3.forEach(childrenToMerge, function (changedPath) {
                var affectedPath = _this.abortTransactions_(path.child(changedPath));
                _this.rerunTransactions_(affectedPath);
            });
            // We queued the events above, so just flush the queue here
            this.eventQueue_.raiseEventsForChangedPath(path, []);
        }
        else {
            util_2.log("update() called with empty data.  Don't do anything.");
            this.callOnCompleteCallback(onComplete, 'ok');
        }
    };
    /**
     * Applies all of the changes stored up in the onDisconnect_ tree.
     * @private
     */
    Repo.prototype.runOnDisconnectEvents_ = function () {
        var _this = this;
        this.log_('onDisconnectEvents');
        var serverValues = this.generateServerValues();
        var resolvedOnDisconnectTree = ServerValues_1.resolveDeferredValueTree(this.onDisconnect_, serverValues);
        var events = [];
        resolvedOnDisconnectTree.forEachTree(Path_1.Path.Empty, function (path, snap) {
            events = events.concat(_this.serverSyncTree_.applyServerOverwrite(path, snap));
            var affectedPath = _this.abortTransactions_(path);
            _this.rerunTransactions_(affectedPath);
        });
        this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();
        this.eventQueue_.raiseEventsForChangedPath(Path_1.Path.Empty, events);
    };
    /**
     * @param {!Path} path
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectCancel = function (path, onComplete) {
        var _this = this;
        this.server_.onDisconnectCancel(path.toString(), function (status, errorReason) {
            if (status === 'ok') {
                _this.onDisconnect_.forget(path);
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Path} path
     * @param {*} value
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectSet = function (path, value, onComplete) {
        var _this = this;
        var newNode = nodeFromJSON_1.nodeFromJSON(value);
        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {
            if (status === 'ok') {
                _this.onDisconnect_.remember(path, newNode);
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Path} path
     * @param {*} value
     * @param {*} priority
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectSetWithPriority = function (path, value, priority, onComplete) {
        var _this = this;
        var newNode = nodeFromJSON_1.nodeFromJSON(value, priority);
        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {
            if (status === 'ok') {
                _this.onDisconnect_.remember(path, newNode);
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Path} path
     * @param {*} childrenToMerge
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectUpdate = function (path, childrenToMerge, onComplete) {
        var _this = this;
        if (util_3.isEmpty(childrenToMerge)) {
            util_2.log("onDisconnect().update() called with empty data.  Don't do anything.");
            this.callOnCompleteCallback(onComplete, 'ok');
            return;
        }
        this.server_.onDisconnectMerge(path.toString(), childrenToMerge, function (status, errorReason) {
            if (status === 'ok') {
                util_3.forEach(childrenToMerge, function (childName, childNode) {
                    var newChildNode = nodeFromJSON_1.nodeFromJSON(childNode);
                    _this.onDisconnect_.remember(path.child(childName), newChildNode);
                });
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     */
    Repo.prototype.addEventCallbackForQuery = function (query, eventRegistration) {
        var events;
        if (query.path.getFront() === '.info') {
            events = this.infoSyncTree_.addEventRegistration(query, eventRegistration);
        }
        else {
            events = this.serverSyncTree_.addEventRegistration(query, eventRegistration);
        }
        this.eventQueue_.raiseEventsAtPath(query.path, events);
    };
    /**
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration
     */
    Repo.prototype.removeEventCallbackForQuery = function (query, eventRegistration) {
        // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof
        // a little bit by handling the return values anyways.
        var events;
        if (query.path.getFront() === '.info') {
            events = this.infoSyncTree_.removeEventRegistration(query, eventRegistration);
        }
        else {
            events = this.serverSyncTree_.removeEventRegistration(query, eventRegistration);
        }
        this.eventQueue_.raiseEventsAtPath(query.path, events);
    };
    Repo.prototype.interrupt = function () {
        if (this.persistentConnection_) {
            this.persistentConnection_.interrupt(INTERRUPT_REASON);
        }
    };
    Repo.prototype.resume = function () {
        if (this.persistentConnection_) {
            this.persistentConnection_.resume(INTERRUPT_REASON);
        }
    };
    Repo.prototype.stats = function (showDelta) {
        if (showDelta === void 0) { showDelta = false; }
        if (typeof console === 'undefined')
            return;
        var stats;
        if (showDelta) {
            if (!this.statsListener_)
                this.statsListener_ = new StatsListener_1.StatsListener(this.stats_);
            stats = this.statsListener_.get();
        }
        else {
            stats = this.stats_.get();
        }
        var longestName = Object.keys(stats).reduce(function (previousValue, currentValue) {
            return Math.max(currentValue.length, previousValue);
        }, 0);
        util_3.forEach(stats, function (stat, value) {
            // pad stat names to be the same length (plus 2 extra spaces).
            for (var i = stat.length; i < longestName + 2; i++)
                stat += ' ';
            console.log(stat + value);
        });
    };
    Repo.prototype.statsIncrementCounter = function (metric) {
        this.stats_.incrementCounter(metric);
        this.statsReporter_.includeStat(metric);
    };
    /**
     * @param {...*} var_args
     * @private
     */
    Repo.prototype.log_ = function () {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            var_args[_i] = arguments[_i];
        }
        var prefix = '';
        if (this.persistentConnection_) {
            prefix = this.persistentConnection_.id + ':';
        }
        util_2.log.apply(void 0, [prefix].concat(var_args));
    };
    /**
     * @param {?function(?Error, *=)} callback
     * @param {!string} status
     * @param {?string=} errorReason
     */
    Repo.prototype.callOnCompleteCallback = function (callback, status, errorReason) {
        if (callback) {
            util_2.exceptionGuard(function () {
                if (status == 'ok') {
                    callback(null);
                }
                else {
                    var code = (status || 'error').toUpperCase();
                    var message = code;
                    if (errorReason)
                        message += ': ' + errorReason;
                    var error = new Error(message);
                    error.code = code;
                    callback(error);
                }
            });
        }
    };
    Object.defineProperty(Repo.prototype, "database", {
        get: function () {
            return this.__database || (this.__database = new Database_1.Database(this));
        },
        enumerable: true,
        configurable: true
    });
    return Repo;
}());
exports.Repo = Repo;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/Repo.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"../api/Database":6,"./AuthTokenProvider":13,"./PersistentConnection":15,"./ReadonlyRestClient":16,"./SnapshotHolder":22,"./SparseSnapshotTree":23,"./SyncTree":25,"./snap/nodeFromJSON":43,"./stats/StatsListener":46,"./stats/StatsManager":47,"./stats/StatsReporter":48,"./util/Path":57,"./util/ServerValues":58,"./util/util":63,"./view/EventQueue":71,"@firebase/util":134,"_process":162,"buffer":160}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
var storage_1 = require("./storage/storage");
var Constants_1 = require("../realtime/Constants");
/**
 * A class that holds metadata about a Repo object
 *
 * @constructor
 */
var RepoInfo = /** @class */ (function () {
    /**
     * @param {string} host Hostname portion of the url for the repo
     * @param {boolean} secure Whether or not this repo is accessed over ssl
     * @param {string} namespace The namespace represented by the repo
     * @param {boolean} webSocketOnly Whether to prefer websockets over all other transports (used by Nest).
     * @param {string=} persistenceKey Override the default session persistence storage key
     */
    function RepoInfo(host, secure, namespace, webSocketOnly, persistenceKey) {
        if (persistenceKey === void 0) { persistenceKey = ''; }
        this.secure = secure;
        this.namespace = namespace;
        this.webSocketOnly = webSocketOnly;
        this.persistenceKey = persistenceKey;
        this.host = host.toLowerCase();
        this.domain = this.host.substr(this.host.indexOf('.') + 1);
        this.internalHost = storage_1.PersistentStorage.get('host:' + host) || this.host;
    }
    RepoInfo.prototype.needsQueryParam = function () {
        return this.host !== this.internalHost;
    };
    RepoInfo.prototype.isCacheableHost = function () {
        return this.internalHost.substr(0, 2) === 's-';
    };
    RepoInfo.prototype.isDemoHost = function () {
        return this.domain === 'firebaseio-demo.com';
    };
    RepoInfo.prototype.isCustomHost = function () {
        return (this.domain !== 'firebaseio.com' && this.domain !== 'firebaseio-demo.com');
    };
    RepoInfo.prototype.updateHost = function (newHost) {
        if (newHost !== this.internalHost) {
            this.internalHost = newHost;
            if (this.isCacheableHost()) {
                storage_1.PersistentStorage.set('host:' + this.host, this.internalHost);
            }
        }
    };
    /**
     * Returns the websocket URL for this repo
     * @param {string} type of connection
     * @param {Object} params list
     * @return {string} The URL for this repo
     */
    RepoInfo.prototype.connectionURL = function (type, params) {
        util_1.assert(typeof type === 'string', 'typeof type must == string');
        util_1.assert(typeof params === 'object', 'typeof params must == object');
        var connURL;
        if (type === Constants_1.WEBSOCKET) {
            connURL =
                (this.secure ? 'wss://' : 'ws://') + this.internalHost + '/.ws?';
        }
        else if (type === Constants_1.LONG_POLLING) {
            connURL =
                (this.secure ? 'https://' : 'http://') + this.internalHost + '/.lp?';
        }
        else {
            throw new Error('Unknown connection type: ' + type);
        }
        if (this.needsQueryParam()) {
            params['ns'] = this.namespace;
        }
        var pairs = [];
        util_2.forEach(params, function (key, value) {
            pairs.push(key + '=' + value);
        });
        return connURL + pairs.join('&');
    };
    /** @return {string} */
    RepoInfo.prototype.toString = function () {
        var str = this.toURLString();
        if (this.persistenceKey) {
            str += '<' + this.persistenceKey + '>';
        }
        return str;
    };
    /** @return {string} */
    RepoInfo.prototype.toURLString = function () {
        return (this.secure ? 'https://' : 'http://') + this.host;
    };
    return RepoInfo;
}());
exports.RepoInfo = RepoInfo;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/RepoInfo.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"../realtime/Constants":82,"./storage/storage":51,"@firebase/util":134,"_process":162,"buffer":160}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var Repo_1 = require("./Repo");
var util_2 = require("./util/util");
var parser_1 = require("./util/libs/parser");
var validation_1 = require("./util/validation");
require("./Repo_transaction");
/** @const {string} */
var DATABASE_URL_OPTION = 'databaseURL';
var _staticInstance;
/**
 * Creates and caches Repo instances.
 */
var RepoManager = /** @class */ (function () {
    function RepoManager() {
        /**
         * @private {!Object.<string, Object<string, !fb.core.Repo>>}
         */
        this.repos_ = {};
        /**
         * If true, new Repos will be created to use ReadonlyRestClient (for testing purposes).
         * @private {boolean}
         */
        this.useRestClient_ = false;
    }
    RepoManager.getInstance = function () {
        if (!_staticInstance) {
            _staticInstance = new RepoManager();
        }
        return _staticInstance;
    };
    // TODO(koss): Remove these functions unless used in tests?
    RepoManager.prototype.interrupt = function () {
        for (var appName in this.repos_) {
            for (var dbUrl in this.repos_[appName]) {
                this.repos_[appName][dbUrl].interrupt();
            }
        }
    };
    RepoManager.prototype.resume = function () {
        for (var appName in this.repos_) {
            for (var dbUrl in this.repos_[appName]) {
                this.repos_[appName][dbUrl].resume();
            }
        }
    };
    /**
     * This function should only ever be called to CREATE a new database instance.
     *
     * @param {!FirebaseApp} app
     * @return {!Database}
     */
    RepoManager.prototype.databaseFromApp = function (app, url) {
        var dbUrl = url || app.options[DATABASE_URL_OPTION];
        if (dbUrl === undefined) {
            util_2.fatal("Can't determine Firebase Database URL.  Be sure to include " +
                DATABASE_URL_OPTION +
                ' option when calling firebase.intializeApp().');
        }
        var parsedUrl = parser_1.parseRepoInfo(dbUrl);
        var repoInfo = parsedUrl.repoInfo;
        validation_1.validateUrl('Invalid Firebase Database URL', 1, parsedUrl);
        if (!parsedUrl.path.isEmpty()) {
            util_2.fatal('Database URL must point to the root of a Firebase Database ' +
                '(not including a child path).');
        }
        var repo = this.createRepo(repoInfo, app);
        return repo.database;
    };
    /**
     * Remove the repo and make sure it is disconnected.
     *
     * @param {!Repo} repo
     */
    RepoManager.prototype.deleteRepo = function (repo) {
        var appRepos = util_1.safeGet(this.repos_, repo.app.name);
        // This should never happen...
        if (!appRepos || util_1.safeGet(appRepos, repo.repoInfo_.toURLString()) !== repo) {
            util_2.fatal("Database " + repo.app.name + "(" + repo.repoInfo_ + ") has already been deleted.");
        }
        repo.interrupt();
        delete appRepos[repo.repoInfo_.toURLString()];
    };
    /**
     * Ensures a repo doesn't already exist and then creates one using the
     * provided app.
     *
     * @param {!RepoInfo} repoInfo The metadata about the Repo
     * @param {!FirebaseApp} app
     * @return {!Repo} The Repo object for the specified server / repoName.
     */
    RepoManager.prototype.createRepo = function (repoInfo, app) {
        var appRepos = util_1.safeGet(this.repos_, app.name);
        if (!appRepos) {
            appRepos = {};
            this.repos_[app.name] = appRepos;
        }
        var repo = util_1.safeGet(appRepos, repoInfo.toURLString());
        if (repo) {
            util_2.fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');
        }
        repo = new Repo_1.Repo(repoInfo, this.useRestClient_, app);
        appRepos[repoInfo.toURLString()] = repo;
        return repo;
    };
    /**
     * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.
     * @param {boolean} forceRestClient
     */
    RepoManager.prototype.forceRestClient = function (forceRestClient) {
        this.useRestClient_ = forceRestClient;
    };
    return RepoManager;
}());
exports.RepoManager = RepoManager;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/RepoManager.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"./Repo":17,"./Repo_transaction":20,"./util/libs/parser":62,"./util/util":63,"./util/validation":64,"@firebase/util":134,"_process":162,"buffer":160}],20:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var Reference_1 = require("../api/Reference");
var DataSnapshot_1 = require("../api/DataSnapshot");
var Path_1 = require("./util/Path");
var Tree_1 = require("./util/Tree");
var PriorityIndex_1 = require("./snap/indexes/PriorityIndex");
var util_2 = require("./util/util");
var ServerValues_1 = require("./util/ServerValues");
var validation_1 = require("./util/validation");
var util_3 = require("@firebase/util");
var nodeFromJSON_1 = require("./snap/nodeFromJSON");
var ChildrenNode_1 = require("./snap/ChildrenNode");
var Repo_1 = require("./Repo");
// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific
// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well
// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.
// For now it's part of Repo, but in its own file.
/**
 * @enum {number}
 */
var TransactionStatus;
(function (TransactionStatus) {
    // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the
    // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to
    // mismatched hash.
    TransactionStatus[TransactionStatus["RUN"] = 0] = "RUN";
    // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted
    // or rejected yet).
    TransactionStatus[TransactionStatus["SENT"] = 1] = "SENT";
    // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be
    // removed when we get a chance to prune completed ones.
    TransactionStatus[TransactionStatus["COMPLETED"] = 2] = "COMPLETED";
    // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).
    // If it comes back as unsuccessful, we'll abort it.
    TransactionStatus[TransactionStatus["SENT_NEEDS_ABORT"] = 3] = "SENT_NEEDS_ABORT";
    // Temporary state used to mark transactions that need to be aborted.
    TransactionStatus[TransactionStatus["NEEDS_ABORT"] = 4] = "NEEDS_ABORT";
})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
/**
 * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's
 * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.
 * @type {number}
 * @const
 * @private
 */
Repo_1.Repo.MAX_TRANSACTION_RETRIES_ = 25;
/**
 * Setup the transaction data structures
 * @private
 */
Repo_1.Repo.prototype.transactions_init_ = function () {
    /**
     * Stores queues of outstanding transactions for Firebase locations.
     *
     * @type {!Tree.<Array.<!Transaction>>}
     * @private
     */
    this.transactionQueueTree_ = new Tree_1.Tree();
};
/**
 * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.
 *
 * @param {!Path} path Path at which to do transaction.
 * @param {function(*):*} transactionUpdate Update callback.
 * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.
 * @param {boolean} applyLocally Whether or not to make intermediate results visible
 */
Repo_1.Repo.prototype.startTransaction = function (path, transactionUpdate, onComplete, applyLocally) {
    this.log_('transaction on ' + path);
    // Add a watch to make sure we get server updates.
    var valueCallback = function () { };
    var watchRef = new Reference_1.Reference(this, path);
    watchRef.on('value', valueCallback);
    var unwatcher = function () {
        watchRef.off('value', valueCallback);
    };
    // Initialize transaction.
    var transaction = {
        path: path,
        update: transactionUpdate,
        onComplete: onComplete,
        // One of TransactionStatus enums.
        status: null,
        // Used when combining transactions at different locations to figure out which one goes first.
        order: util_2.LUIDGenerator(),
        // Whether to raise local events for this transaction.
        applyLocally: applyLocally,
        // Count of how many times we've retried the transaction.
        retryCount: 0,
        // Function to call to clean up our .on() listener.
        unwatcher: unwatcher,
        // Stores why a transaction was aborted.
        abortReason: null,
        currentWriteId: null,
        currentInputSnapshot: null,
        currentOutputSnapshotRaw: null,
        currentOutputSnapshotResolved: null
    };
    // Run transaction initially.
    var currentState = this.getLatestState_(path);
    transaction.currentInputSnapshot = currentState;
    var newVal = transaction.update(currentState.val());
    if (newVal === undefined) {
        // Abort transaction.
        transaction.unwatcher();
        transaction.currentOutputSnapshotRaw = null;
        transaction.currentOutputSnapshotResolved = null;
        if (transaction.onComplete) {
            // We just set the input snapshot, so this cast should be safe
            var snapshot = new DataSnapshot_1.DataSnapshot(transaction.currentInputSnapshot, new Reference_1.Reference(this, transaction.path), PriorityIndex_1.PRIORITY_INDEX);
            transaction.onComplete(null, false, snapshot);
        }
    }
    else {
        validation_1.validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path);
        // Mark as run and add to our queue.
        transaction.status = TransactionStatus.RUN;
        var queueNode = this.transactionQueueTree_.subTree(path);
        var nodeQueue = queueNode.getValue() || [];
        nodeQueue.push(transaction);
        queueNode.setValue(nodeQueue);
        // Update visibleData and raise events
        // Note: We intentionally raise events after updating all of our transaction state, since the user could
        // start new transactions from the event callbacks.
        var priorityForNode = void 0;
        if (typeof newVal === 'object' &&
            newVal !== null &&
            util_3.contains(newVal, '.priority')) {
            priorityForNode = util_3.safeGet(newVal, '.priority');
            util_1.assert(validation_1.isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' +
                'Priority must be a valid string, finite number, server value, or null.');
        }
        else {
            var currentNode = this.serverSyncTree_.calcCompleteEventCache(path) ||
                ChildrenNode_1.ChildrenNode.EMPTY_NODE;
            priorityForNode = currentNode.getPriority().val();
        }
        priorityForNode /** @type {null|number|string} */ = priorityForNode;
        var serverValues = this.generateServerValues();
        var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, priorityForNode);
        var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);
        transaction.currentOutputSnapshotRaw = newNodeUnresolved;
        transaction.currentOutputSnapshotResolved = newNode;
        transaction.currentWriteId = this.getNextWriteId_();
        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, transaction.currentWriteId, transaction.applyLocally);
        this.eventQueue_.raiseEventsForChangedPath(path, events);
        this.sendReadyTransactions_();
    }
};
/**
 * @param {!Path} path
 * @param {Array.<number>=} excludeSets A specific set to exclude
 * @return {Node}
 * @private
 */
Repo_1.Repo.prototype.getLatestState_ = function (path, excludeSets) {
    return (this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) ||
        ChildrenNode_1.ChildrenNode.EMPTY_NODE);
};
/**
 * Sends any already-run transactions that aren't waiting for outstanding transactions to
 * complete.
 *
 * Externally it's called with no arguments, but it calls itself recursively with a particular
 * transactionQueueTree node to recurse through the tree.
 *
 * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.
 * @private
 */
Repo_1.Repo.prototype.sendReadyTransactions_ = function (node) {
    var _this = this;
    if (node === void 0) { node = this.transactionQueueTree_; }
    // Before recursing, make sure any completed transactions are removed.
    if (!node) {
        this.pruneCompletedTransactionsBelowNode_(node);
    }
    if (node.getValue() !== null) {
        var queue = this.buildTransactionQueue_(node);
        util_1.assert(queue.length > 0, 'Sending zero length transaction queue');
        var allRun = queue.every(function (transaction) { return transaction.status === TransactionStatus.RUN; });
        // If they're all run (and not sent), we can send them.  Else, we must wait.
        if (allRun) {
            this.sendTransactionQueue_(node.path(), queue);
        }
    }
    else if (node.hasChildren()) {
        node.forEachChild(function (childNode) {
            _this.sendReadyTransactions_(childNode);
        });
    }
};
/**
 * Given a list of run transactions, send them to the server and then handle the result (success or failure).
 *
 * @param {!Path} path The location of the queue.
 * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.
 * @private
 */
Repo_1.Repo.prototype.sendTransactionQueue_ = function (path, queue) {
    var _this = this;
    // Mark transactions as sent and increment retry count!
    var setsToIgnore = queue.map(function (txn) {
        return txn.currentWriteId;
    });
    var latestState = this.getLatestState_(path, setsToIgnore);
    var snapToSend = latestState;
    var latestHash = latestState.hash();
    for (var i = 0; i < queue.length; i++) {
        var txn = queue[i];
        util_1.assert(txn.status === TransactionStatus.RUN, 'tryToSendTransactionQueue_: items in queue should all be run.');
        txn.status = TransactionStatus.SENT;
        txn.retryCount++;
        var relativePath = Path_1.Path.relativePath(path, txn.path);
        // If we've gotten to this point, the output snapshot must be defined.
        snapToSend = snapToSend.updateChild(relativePath /**@type {!Node} */, txn.currentOutputSnapshotRaw);
    }
    var dataToSend = snapToSend.val(true);
    var pathToSend = path;
    // Send the put.
    this.server_.put(pathToSend.toString(), dataToSend, function (status) {
        _this.log_('transaction put response', {
            path: pathToSend.toString(),
            status: status
        });
        var events = [];
        if (status === 'ok') {
            // Queue up the callbacks and fire them after cleaning up all of our transaction state, since
            // the callback could trigger more transactions or sets.
            var callbacks = [];
            for (var i = 0; i < queue.length; i++) {
                queue[i].status = TransactionStatus.COMPLETED;
                events = events.concat(_this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId));
                if (queue[i].onComplete) {
                    // We never unset the output snapshot, and given that this transaction is complete, it should be set
                    var node = queue[i].currentOutputSnapshotResolved;
                    var ref = new Reference_1.Reference(_this, queue[i].path);
                    var snapshot = new DataSnapshot_1.DataSnapshot(node, ref, PriorityIndex_1.PRIORITY_INDEX);
                    callbacks.push(queue[i].onComplete.bind(null, null, true, snapshot));
                }
                queue[i].unwatcher();
            }
            // Now remove the completed transactions.
            _this.pruneCompletedTransactionsBelowNode_(_this.transactionQueueTree_.subTree(path));
            // There may be pending transactions that we can now send.
            _this.sendReadyTransactions_();
            _this.eventQueue_.raiseEventsForChangedPath(path, events);
            // Finally, trigger onComplete callbacks.
            for (var i = 0; i < callbacks.length; i++) {
                util_2.exceptionGuard(callbacks[i]);
            }
        }
        else {
            // transactions are no longer sent.  Update their status appropriately.
            if (status === 'datastale') {
                for (var i = 0; i < queue.length; i++) {
                    if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT)
                        queue[i].status = TransactionStatus.NEEDS_ABORT;
                    else
                        queue[i].status = TransactionStatus.RUN;
                }
            }
            else {
                util_2.warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);
                for (var i = 0; i < queue.length; i++) {
                    queue[i].status = TransactionStatus.NEEDS_ABORT;
                    queue[i].abortReason = status;
                }
            }
            _this.rerunTransactions_(path);
        }
    }, latestHash);
};
/**
 * Finds all transactions dependent on the data at changedPath and reruns them.
 *
 * Should be called any time cached data changes.
 *
 * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to
 * be raised for.
 *
 * @param {!Path} changedPath The path in mergedData that changed.
 * @return {!Path} The rootmost path that was affected by rerunning transactions.
 * @private
 */
Repo_1.Repo.prototype.rerunTransactions_ = function (changedPath) {
    var rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);
    var path = rootMostTransactionNode.path();
    var queue = this.buildTransactionQueue_(rootMostTransactionNode);
    this.rerunTransactionQueue_(queue, path);
    return path;
};
/**
 * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).
 *
 * @param {Array.<Transaction>} queue The queue of transactions to run.
 * @param {!Path} path The path the queue is for.
 * @private
 */
Repo_1.Repo.prototype.rerunTransactionQueue_ = function (queue, path) {
    if (queue.length === 0) {
        return; // Nothing to do!
    }
    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since
    // the callback could trigger more transactions or sets.
    var callbacks = [];
    var events = [];
    // Ignore all of the sets we're going to re-run.
    var txnsToRerun = queue.filter(function (q) {
        return q.status === TransactionStatus.RUN;
    });
    var setsToIgnore = txnsToRerun.map(function (q) {
        return q.currentWriteId;
    });
    for (var i = 0; i < queue.length; i++) {
        var transaction = queue[i];
        var relativePath = Path_1.Path.relativePath(path, transaction.path);
        var abortTransaction = false, abortReason = void 0;
        util_1.assert(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');
        if (transaction.status === TransactionStatus.NEEDS_ABORT) {
            abortTransaction = true;
            abortReason = transaction.abortReason;
            events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
        }
        else if (transaction.status === TransactionStatus.RUN) {
            if (transaction.retryCount >= Repo_1.Repo.MAX_TRANSACTION_RETRIES_) {
                abortTransaction = true;
                abortReason = 'maxretry';
                events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
            }
            else {
                // This code reruns a transaction
                var currentNode = this.getLatestState_(transaction.path, setsToIgnore);
                transaction.currentInputSnapshot = currentNode;
                var newData = queue[i].update(currentNode.val());
                if (newData !== undefined) {
                    validation_1.validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);
                    var newDataNode = nodeFromJSON_1.nodeFromJSON(newData);
                    var hasExplicitPriority = typeof newData === 'object' &&
                        newData != null &&
                        util_3.contains(newData, '.priority');
                    if (!hasExplicitPriority) {
                        // Keep the old priority if there wasn't a priority explicitly specified.
                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());
                    }
                    var oldWriteId = transaction.currentWriteId;
                    var serverValues = this.generateServerValues();
                    var newNodeResolved = ServerValues_1.resolveDeferredValueSnapshot(newDataNode, serverValues);
                    transaction.currentOutputSnapshotRaw = newDataNode;
                    transaction.currentOutputSnapshotResolved = newNodeResolved;
                    transaction.currentWriteId = this.getNextWriteId_();
                    // Mutates setsToIgnore in place
                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
                    events = events.concat(this.serverSyncTree_.applyUserOverwrite(transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
                    events = events.concat(this.serverSyncTree_.ackUserWrite(oldWriteId, true));
                }
                else {
                    abortTransaction = true;
                    abortReason = 'nodata';
                    events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
                }
            }
        }
        this.eventQueue_.raiseEventsForChangedPath(path, events);
        events = [];
        if (abortTransaction) {
            // Abort.
            queue[i].status = TransactionStatus.COMPLETED;
            // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).
            // So defer the unwatcher until we're done.
            (function (unwatcher) {
                setTimeout(unwatcher, Math.floor(0));
            })(queue[i].unwatcher);
            if (queue[i].onComplete) {
                if (abortReason === 'nodata') {
                    var ref = new Reference_1.Reference(this, queue[i].path);
                    // We set this field immediately, so it's safe to cast to an actual snapshot
                    var lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;
                    var snapshot = new DataSnapshot_1.DataSnapshot(lastInput, ref, PriorityIndex_1.PRIORITY_INDEX);
                    callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));
                }
                else {
                    callbacks.push(queue[i].onComplete.bind(null, new Error(abortReason), false, null));
                }
            }
        }
    }
    // Clean up completed transactions.
    this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);
    // Now fire callbacks, now that we're in a good, known state.
    for (var i = 0; i < callbacks.length; i++) {
        util_2.exceptionGuard(callbacks[i]);
    }
    // Try to send the transaction result to the server.
    this.sendReadyTransactions_();
};
/**
 * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns
 * the node for the given path if there are no pending transactions on any ancestor.
 *
 * @param {!Path} path The location to start at.
 * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.
 * @private
 */
Repo_1.Repo.prototype.getAncestorTransactionNode_ = function (path) {
    var front;
    // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.
    var transactionNode = this.transactionQueueTree_;
    while ((front = path.getFront()) !== null &&
        transactionNode.getValue() === null) {
        transactionNode = transactionNode.subTree(front);
        path = path.popFront();
    }
    return transactionNode;
};
/**
 * Builds the queue of all transactions at or below the specified transactionNode.
 *
 * @param {!Tree.<Array.<Transaction>>} transactionNode
 * @return {Array.<Transaction>} The generated queue.
 * @private
 */
Repo_1.Repo.prototype.buildTransactionQueue_ = function (transactionNode) {
    // Walk any child transaction queues and aggregate them into a single queue.
    var transactionQueue = [];
    this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);
    // Sort them by the order the transactions were created.
    transactionQueue.sort(function (a, b) {
        return a.order - b.order;
    });
    return transactionQueue;
};
/**
 * @param {!Tree.<Array.<Transaction>>} node
 * @param {Array.<Transaction>} queue
 * @private
 */
Repo_1.Repo.prototype.aggregateTransactionQueuesForNode_ = function (node, queue) {
    var _this = this;
    var nodeQueue = node.getValue();
    if (nodeQueue !== null) {
        for (var i = 0; i < nodeQueue.length; i++) {
            queue.push(nodeQueue[i]);
        }
    }
    node.forEachChild(function (child) {
        _this.aggregateTransactionQueuesForNode_(child, queue);
    });
};
/**
 * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.
 *
 * @param {!Tree.<Array.<!Transaction>>} node
 * @private
 */
Repo_1.Repo.prototype.pruneCompletedTransactionsBelowNode_ = function (node) {
    var _this = this;
    var queue = node.getValue();
    if (queue) {
        var to = 0;
        for (var from = 0; from < queue.length; from++) {
            if (queue[from].status !== TransactionStatus.COMPLETED) {
                queue[to] = queue[from];
                to++;
            }
        }
        queue.length = to;
        node.setValue(queue.length > 0 ? queue : null);
    }
    node.forEachChild(function (childNode) {
        _this.pruneCompletedTransactionsBelowNode_(childNode);
    });
};
/**
 * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()
 * since we consider them incompatible with transactions.
 *
 * @param {!Path} path Path for which we want to abort related transactions.
 * @return {!Path}
 * @private
 */
Repo_1.Repo.prototype.abortTransactions_ = function (path) {
    var _this = this;
    var affectedPath = this.getAncestorTransactionNode_(path).path();
    var transactionNode = this.transactionQueueTree_.subTree(path);
    transactionNode.forEachAncestor(function (node) {
        _this.abortTransactionsOnNode_(node);
    });
    this.abortTransactionsOnNode_(transactionNode);
    transactionNode.forEachDescendant(function (node) {
        _this.abortTransactionsOnNode_(node);
    });
    return affectedPath;
};
/**
 * Abort transactions stored in this transaction queue node.
 *
 * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.
 * @private
 */
Repo_1.Repo.prototype.abortTransactionsOnNode_ = function (node) {
    var queue = node.getValue();
    if (queue !== null) {
        // Queue up the callbacks and fire them after cleaning up all of our transaction state, since
        // the callback could trigger more transactions or sets.
        var callbacks = [];
        // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones
        // can be immediately aborted and removed.
        var events = [];
        var lastSent = -1;
        for (var i = 0; i < queue.length; i++) {
            if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {
                // Already marked.  No action needed.
            }
            else if (queue[i].status === TransactionStatus.SENT) {
                util_1.assert(lastSent === i - 1, 'All SENT items should be at beginning of queue.');
                lastSent = i;
                // Mark transaction for abort when it comes back.
                queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;
                queue[i].abortReason = 'set';
            }
            else {
                util_1.assert(queue[i].status === TransactionStatus.RUN, 'Unexpected transaction status in abort');
                // We can abort it immediately.
                queue[i].unwatcher();
                events = events.concat(this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true));
                if (queue[i].onComplete) {
                    var snapshot = null;
                    callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, snapshot));
                }
            }
        }
        if (lastSent === -1) {
            // We're not waiting for any sent transactions.  We can clear the queue.
            node.setValue(null);
        }
        else {
            // Remove the transactions we aborted.
            queue.length = lastSent + 1;
        }
        // Now fire the callbacks.
        this.eventQueue_.raiseEventsForChangedPath(node.path(), events);
        for (var i = 0; i < callbacks.length; i++) {
            util_2.exceptionGuard(callbacks[i]);
        }
    }
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/Repo_transaction.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"../api/DataSnapshot":5,"../api/Reference":8,"./Repo":17,"./snap/ChildrenNode":32,"./snap/indexes/PriorityIndex":41,"./snap/nodeFromJSON":43,"./util/Path":57,"./util/ServerValues":58,"./util/Tree":60,"./util/util":63,"./util/validation":64,"@firebase/util":134,"_process":162,"buffer":160}],21:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Interface defining the set of actions that can be performed against the Firebase server
 * (basically corresponds to our wire protocol).
 *
 * @interface
 */
var ServerActions = /** @class */ (function () {
    function ServerActions() {
    }
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     * @param {string=} hash
     */
    ServerActions.prototype.put = function (pathString, data, onComplete, hash) { };
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, ?string)} onComplete
     * @param {string=} hash
     */
    ServerActions.prototype.merge = function (pathString, data, onComplete, hash) { };
    /**
     * Refreshes the auth token for the current connection.
     * @param {string} token The authentication token
     */
    ServerActions.prototype.refreshAuthToken = function (token) { };
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     */
    ServerActions.prototype.onDisconnectPut = function (pathString, data, onComplete) { };
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     */
    ServerActions.prototype.onDisconnectMerge = function (pathString, data, onComplete) { };
    /**
     * @param {string} pathString
     * @param {function(string, string)=} onComplete
     */
    ServerActions.prototype.onDisconnectCancel = function (pathString, onComplete) { };
    /**
     * @param {Object.<string, *>} stats
     */
    ServerActions.prototype.reportStats = function (stats) { };
    return ServerActions;
}());
exports.ServerActions = ServerActions;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/ServerActions.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"_process":162,"buffer":160}],22:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ChildrenNode_1 = require("./snap/ChildrenNode");
/**
 * Mutable object which basically just stores a reference to the "latest" immutable snapshot.
 *
 * @constructor
 */
var SnapshotHolder = /** @class */ (function () {
    function SnapshotHolder() {
        this.rootNode_ = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
    }
    SnapshotHolder.prototype.getNode = function (path) {
        return this.rootNode_.getChild(path);
    };
    SnapshotHolder.prototype.updateSnapshot = function (path, newSnapshotNode) {
        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
    };
    return SnapshotHolder;
}());
exports.SnapshotHolder = SnapshotHolder;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/SnapshotHolder.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"./snap/ChildrenNode":32,"_process":162,"buffer":160}],23:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Path_1 = require("./util/Path");
var PriorityIndex_1 = require("./snap/indexes/PriorityIndex");
var CountedSet_1 = require("./util/CountedSet");
/**
 * Helper class to store a sparse set of snapshots.
 *
 * @constructor
 */
var SparseSnapshotTree = /** @class */ (function () {
    function SparseSnapshotTree() {
        /**
         * @private
         * @type {Node}
         */
        this.value_ = null;
        /**
         * @private
         * @type {CountedSet}
         */
        this.children_ = null;
    }
    /**
     * Gets the node stored at the given path if one exists.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @return {?Node} The retrieved node, or null.
     */
    SparseSnapshotTree.prototype.find = function (path) {
        if (this.value_ != null) {
            return this.value_.getChild(path);
        }
        else if (!path.isEmpty() && this.children_ != null) {
            var childKey = path.getFront();
            path = path.popFront();
            if (this.children_.contains(childKey)) {
                var childTree = this.children_.get(childKey);
                return childTree.find(path);
            }
            else {
                return null;
            }
        }
        else {
            return null;
        }
    };
    /**
     * Stores the given node at the specified path. If there is already a node
     * at a shallower path, it merges the new data into that snapshot node.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @param {!Node} data The new data, or null.
     */
    SparseSnapshotTree.prototype.remember = function (path, data) {
        if (path.isEmpty()) {
            this.value_ = data;
            this.children_ = null;
        }
        else if (this.value_ !== null) {
            this.value_ = this.value_.updateChild(path, data);
        }
        else {
            if (this.children_ == null) {
                this.children_ = new CountedSet_1.CountedSet();
            }
            var childKey = path.getFront();
            if (!this.children_.contains(childKey)) {
                this.children_.add(childKey, new SparseSnapshotTree());
            }
            var child = this.children_.get(childKey);
            path = path.popFront();
            child.remember(path, data);
        }
    };
    /**
     * Purge the data at path from the cache.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @return {boolean} True if this node should now be removed.
     */
    SparseSnapshotTree.prototype.forget = function (path) {
        if (path.isEmpty()) {
            this.value_ = null;
            this.children_ = null;
            return true;
        }
        else {
            if (this.value_ !== null) {
                if (this.value_.isLeafNode()) {
                    // We're trying to forget a node that doesn't exist
                    return false;
                }
                else {
                    var value = this.value_;
                    this.value_ = null;
                    var self_1 = this;
                    value.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, tree) {
                        self_1.remember(new Path_1.Path(key), tree);
                    });
                    return this.forget(path);
                }
            }
            else if (this.children_ !== null) {
                var childKey = path.getFront();
                path = path.popFront();
                if (this.children_.contains(childKey)) {
                    var safeToRemove = this.children_.get(childKey).forget(path);
                    if (safeToRemove) {
                        this.children_.remove(childKey);
                    }
                }
                if (this.children_.isEmpty()) {
                    this.children_ = null;
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        }
    };
    /**
     * Recursively iterates through all of the stored tree and calls the
     * callback on each one.
     *
     * @param {!Path} prefixPath Path to look up node for.
     * @param {!Function} func The function to invoke for each tree.
     */
    SparseSnapshotTree.prototype.forEachTree = function (prefixPath, func) {
        if (this.value_ !== null) {
            func(prefixPath, this.value_);
        }
        else {
            this.forEachChild(function (key, tree) {
                var path = new Path_1.Path(prefixPath.toString() + '/' + key);
                tree.forEachTree(path, func);
            });
        }
    };
    /**
     * Iterates through each immediate child and triggers the callback.
     *
     * @param {!Function} func The function to invoke for each child.
     */
    SparseSnapshotTree.prototype.forEachChild = function (func) {
        if (this.children_ !== null) {
            this.children_.each(function (key, tree) {
                func(key, tree);
            });
        }
    };
    return SparseSnapshotTree;
}());
exports.SparseSnapshotTree = SparseSnapshotTree;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/SparseSnapshotTree.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"./snap/indexes/PriorityIndex":41,"./util/CountedSet":52,"./util/Path":57,"_process":162,"buffer":160}],24:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var CacheNode_1 = require("./view/CacheNode");
var ChildrenNode_1 = require("./snap/ChildrenNode");
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
var ViewCache_1 = require("./view/ViewCache");
var View_1 = require("./view/View");
var __referenceConstructor;
/**
 * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to
 * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes
 * and user writes (set, transaction, update).
 *
 * It's responsible for:
 *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).
 *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,
 *    applyUserOverwrite, etc.)
 */
var SyncPoint = /** @class */ (function () {
    function SyncPoint() {
        /**
         * The Views being tracked at this location in the tree, stored as a map where the key is a
         * queryId and the value is the View for that query.
         *
         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).
         *
         * @type {!Object.<!string, !View>}
         * @private
         */
        this.views_ = {};
    }
    Object.defineProperty(SyncPoint, "__referenceConstructor", {
        get: function () {
            util_1.assert(__referenceConstructor, 'Reference.ts has not been loaded');
            return __referenceConstructor;
        },
        set: function (val) {
            util_1.assert(!__referenceConstructor, '__referenceConstructor has already been defined');
            __referenceConstructor = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {boolean}
     */
    SyncPoint.prototype.isEmpty = function () {
        return util_2.isEmpty(this.views_);
    };
    /**
     *
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} optCompleteServerCache
     * @return {!Array.<!Event>}
     */
    SyncPoint.prototype.applyOperation = function (operation, writesCache, optCompleteServerCache) {
        var queryId = operation.source.queryId;
        if (queryId !== null) {
            var view = util_2.safeGet(this.views_, queryId);
            util_1.assert(view != null, 'SyncTree gave us an op for an invalid query.');
            return view.applyOperation(operation, writesCache, optCompleteServerCache);
        }
        else {
            var events_1 = [];
            util_2.forEach(this.views_, function (key, view) {
                events_1 = events_1.concat(view.applyOperation(operation, writesCache, optCompleteServerCache));
            });
            return events_1;
        }
    };
    /**
     * Add an event callback for the specified query.
     *
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache Complete server cache, if we have it.
     * @param {boolean} serverCacheComplete
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncPoint.prototype.addEventRegistration = function (query, eventRegistration, writesCache, serverCache, serverCacheComplete) {
        var queryId = query.queryIdentifier();
        var view = util_2.safeGet(this.views_, queryId);
        if (!view) {
            // TODO: make writesCache take flag for complete server node
            var eventCache = writesCache.calcCompleteEventCache(serverCacheComplete ? serverCache : null);
            var eventCacheComplete = false;
            if (eventCache) {
                eventCacheComplete = true;
            }
            else if (serverCache instanceof ChildrenNode_1.ChildrenNode) {
                eventCache = writesCache.calcCompleteEventChildren(serverCache);
                eventCacheComplete = false;
            }
            else {
                eventCache = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                eventCacheComplete = false;
            }
            var viewCache = new ViewCache_1.ViewCache(new CacheNode_1.CacheNode(
            /** @type {!Node} */ (eventCache), eventCacheComplete, false), new CacheNode_1.CacheNode(
            /** @type {!Node} */ (serverCache), serverCacheComplete, false));
            view = new View_1.View(query, viewCache);
            this.views_[queryId] = view;
        }
        // This is guaranteed to exist now, we just created anything that was missing
        view.addEventRegistration(eventRegistration);
        return view.getInitialEvents(eventRegistration);
    };
    /**
     * Remove event callback(s).  Return cancelEvents if a cancelError is specified.
     *
     * If query is the default query, we'll check all views for the specified eventRegistration.
     * If eventRegistration is null, we'll remove all callbacks for the specified view(s).
     *
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration If null, remove all callbacks.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events
     */
    SyncPoint.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {
        var queryId = query.queryIdentifier();
        var removed = [];
        var cancelEvents = [];
        var hadCompleteView = this.hasCompleteView();
        if (queryId === 'default') {
            // When you do ref.off(...), we search all views for the registration to remove.
            var self_1 = this;
            util_2.forEach(this.views_, function (viewQueryId, view) {
                cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));
                if (view.isEmpty()) {
                    delete self_1.views_[viewQueryId];
                    // We'll deal with complete views later.
                    if (!view
                        .getQuery()
                        .getQueryParams()
                        .loadsAllData()) {
                        removed.push(view.getQuery());
                    }
                }
            });
        }
        else {
            // remove the callback from the specific view.
            var view = util_2.safeGet(this.views_, queryId);
            if (view) {
                cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));
                if (view.isEmpty()) {
                    delete this.views_[queryId];
                    // We'll deal with complete views later.
                    if (!view
                        .getQuery()
                        .getQueryParams()
                        .loadsAllData()) {
                        removed.push(view.getQuery());
                    }
                }
            }
        }
        if (hadCompleteView && !this.hasCompleteView()) {
            // We removed our last complete view.
            removed.push(new SyncPoint.__referenceConstructor(query.repo, query.path));
        }
        return { removed: removed, events: cancelEvents };
    };
    /**
     * @return {!Array.<!View>}
     */
    SyncPoint.prototype.getQueryViews = function () {
        var _this = this;
        var values = Object.keys(this.views_).map(function (key) { return _this.views_[key]; });
        return values.filter(function (view) {
            return !view
                .getQuery()
                .getQueryParams()
                .loadsAllData();
        });
    };
    /**
     *
     * @param {!Path} path The path to the desired complete snapshot
     * @return {?Node} A complete cache, if it exists
     */
    SyncPoint.prototype.getCompleteServerCache = function (path) {
        var serverCache = null;
        util_2.forEach(this.views_, function (key, view) {
            serverCache = serverCache || view.getCompleteServerCache(path);
        });
        return serverCache;
    };
    /**
     * @param {!Query} query
     * @return {?View}
     */
    SyncPoint.prototype.viewForQuery = function (query) {
        var params = query.getQueryParams();
        if (params.loadsAllData()) {
            return this.getCompleteView();
        }
        else {
            var queryId = query.queryIdentifier();
            return util_2.safeGet(this.views_, queryId);
        }
    };
    /**
     * @param {!Query} query
     * @return {boolean}
     */
    SyncPoint.prototype.viewExistsForQuery = function (query) {
        return this.viewForQuery(query) != null;
    };
    /**
     * @return {boolean}
     */
    SyncPoint.prototype.hasCompleteView = function () {
        return this.getCompleteView() != null;
    };
    /**
     * @return {?View}
     */
    SyncPoint.prototype.getCompleteView = function () {
        var completeView = util_2.findValue(this.views_, function (view) {
            return view
                .getQuery()
                .getQueryParams()
                .loadsAllData();
        });
        return completeView || null;
    };
    return SyncPoint;
}());
exports.SyncPoint = SyncPoint;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/SyncPoint.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"./snap/ChildrenNode":32,"./view/CacheNode":65,"./view/View":74,"./view/ViewCache":75,"@firebase/util":134,"_process":162,"buffer":160}],25:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("./util/util");
var AckUserWrite_1 = require("./operation/AckUserWrite");
var ChildrenNode_1 = require("./snap/ChildrenNode");
var util_3 = require("@firebase/util");
var ImmutableTree_1 = require("./util/ImmutableTree");
var ListenComplete_1 = require("./operation/ListenComplete");
var Merge_1 = require("./operation/Merge");
var Operation_1 = require("./operation/Operation");
var Overwrite_1 = require("./operation/Overwrite");
var Path_1 = require("./util/Path");
var SyncPoint_1 = require("./SyncPoint");
var WriteTree_1 = require("./WriteTree");
/**
 * SyncTree is the central class for managing event callback registration, data caching, views
 * (query processing), and event generation.  There are typically two SyncTree instances for
 * each Repo, one for the normal Firebase data, and one for the .info data.
 *
 * It has a number of responsibilities, including:
 *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).
 *  - Applying and caching data changes for user set(), transaction(), and update() calls
 *    (applyUserOverwrite(), applyUserMerge()).
 *  - Applying and caching data changes for server data changes (applyServerOverwrite(),
 *    applyServerMerge()).
 *  - Generating user-facing events for server and user changes (all of the apply* methods
 *    return the set of events that need to be raised as a result).
 *  - Maintaining the appropriate set of server listens to ensure we are always subscribed
 *    to the correct set of paths and queries to satisfy the current set of user event
 *    callbacks (listens are started/stopped using the provided listenProvider).
 *
 * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual
 * events are returned to the caller rather than raised synchronously.
 *
 * @constructor
 */
var SyncTree = /** @class */ (function () {
    /**
     * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening
     *   to server data.
     */
    function SyncTree(listenProvider_) {
        this.listenProvider_ = listenProvider_;
        /**
         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.
         * @type {!ImmutableTree.<!SyncPoint>}
         * @private
         */
        this.syncPointTree_ = ImmutableTree_1.ImmutableTree.Empty;
        /**
         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).
         * @type {!WriteTree}
         * @private
         */
        this.pendingWriteTree_ = new WriteTree_1.WriteTree();
        this.tagToQueryMap_ = {};
        this.queryToTagMap_ = {};
    }
    /**
     * Apply the data changes for a user-generated set() or transaction() call.
     *
     * @param {!Path} path
     * @param {!Node} newData
     * @param {number} writeId
     * @param {boolean=} visible
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyUserOverwrite = function (path, newData, writeId, visible) {
        // Record pending write.
        this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);
        if (!visible) {
            return [];
        }
        else {
            return this.applyOperationToSyncPoints_(new Overwrite_1.Overwrite(Operation_1.OperationSource.User, path, newData));
        }
    };
    /**
     * Apply the data from a user-generated update() call
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} writeId
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyUserMerge = function (path, changedChildren, writeId) {
        // Record pending merge.
        this.pendingWriteTree_.addMerge(path, changedChildren, writeId);
        var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);
        return this.applyOperationToSyncPoints_(new Merge_1.Merge(Operation_1.OperationSource.User, path, changeTree));
    };
    /**
     * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().
     *
     * @param {!number} writeId
     * @param {boolean=} revert True if the given write failed and needs to be reverted
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.ackUserWrite = function (writeId, revert) {
        if (revert === void 0) { revert = false; }
        var write = this.pendingWriteTree_.getWrite(writeId);
        var needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);
        if (!needToReevaluate) {
            return [];
        }
        else {
            var affectedTree_1 = ImmutableTree_1.ImmutableTree.Empty;
            if (write.snap != null) {
                // overwrite
                affectedTree_1 = affectedTree_1.set(Path_1.Path.Empty, true);
            }
            else {
                util_3.forEach(write.children, function (pathString, node) {
                    affectedTree_1 = affectedTree_1.set(new Path_1.Path(pathString), node);
                });
            }
            return this.applyOperationToSyncPoints_(new AckUserWrite_1.AckUserWrite(write.path, affectedTree_1, revert));
        }
    };
    /**
     * Apply new server data for the specified path..
     *
     * @param {!Path} path
     * @param {!Node} newData
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyServerOverwrite = function (path, newData) {
        return this.applyOperationToSyncPoints_(new Overwrite_1.Overwrite(Operation_1.OperationSource.Server, path, newData));
    };
    /**
     * Apply new server data to be merged in at the specified path.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyServerMerge = function (path, changedChildren) {
        var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);
        return this.applyOperationToSyncPoints_(new Merge_1.Merge(Operation_1.OperationSource.Server, path, changeTree));
    };
    /**
     * Apply a listen complete for a query
     *
     * @param {!Path} path
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyListenComplete = function (path) {
        return this.applyOperationToSyncPoints_(new ListenComplete_1.ListenComplete(Operation_1.OperationSource.Server, path));
    };
    /**
     * Apply new server data for the specified tagged query.
     *
     * @param {!Path} path
     * @param {!Node} snap
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyTaggedQueryOverwrite = function (path, snap, tag) {
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey != null) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path_1.Path.relativePath(queryPath, path);
            var op = new Overwrite_1.Overwrite(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath, snap);
            return this.applyTaggedOperation_(queryPath, op);
        }
        else {
            // Query must have been removed already
            return [];
        }
    };
    /**
     * Apply server data to be merged in for the specified tagged query.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyTaggedQueryMerge = function (path, changedChildren, tag) {
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path_1.Path.relativePath(queryPath, path);
            var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);
            var op = new Merge_1.Merge(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath, changeTree);
            return this.applyTaggedOperation_(queryPath, op);
        }
        else {
            // We've already removed the query. No big deal, ignore the update
            return [];
        }
    };
    /**
     * Apply a listen complete for a tagged query
     *
     * @param {!Path} path
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyTaggedListenComplete = function (path, tag) {
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path_1.Path.relativePath(queryPath, path);
            var op = new ListenComplete_1.ListenComplete(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath);
            return this.applyTaggedOperation_(queryPath, op);
        }
        else {
            // We've already removed the query. No big deal, ignore the update
            return [];
        }
    };
    /**
     * Add an event callback for the specified query.
     *
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.addEventRegistration = function (query, eventRegistration) {
        var path = query.path;
        var serverCache = null;
        var foundAncestorDefaultView = false;
        // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
        // Consider optimizing this once there's a better understanding of what actual behavior will be.
        this.syncPointTree_.foreachOnPath(path, function (pathToSyncPoint, sp) {
            var relativePath = Path_1.Path.relativePath(pathToSyncPoint, path);
            serverCache = serverCache || sp.getCompleteServerCache(relativePath);
            foundAncestorDefaultView =
                foundAncestorDefaultView || sp.hasCompleteView();
        });
        var syncPoint = this.syncPointTree_.get(path);
        if (!syncPoint) {
            syncPoint = new SyncPoint_1.SyncPoint();
            this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);
        }
        else {
            foundAncestorDefaultView =
                foundAncestorDefaultView || syncPoint.hasCompleteView();
            serverCache = serverCache || syncPoint.getCompleteServerCache(Path_1.Path.Empty);
        }
        var serverCacheComplete;
        if (serverCache != null) {
            serverCacheComplete = true;
        }
        else {
            serverCacheComplete = false;
            serverCache = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
            var subtree = this.syncPointTree_.subtree(path);
            subtree.foreachChild(function (childName, childSyncPoint) {
                var completeCache = childSyncPoint.getCompleteServerCache(Path_1.Path.Empty);
                if (completeCache) {
                    serverCache = serverCache.updateImmediateChild(childName, completeCache);
                }
            });
        }
        var viewAlreadyExists = syncPoint.viewExistsForQuery(query);
        if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {
            // We need to track a tag for this query
            var queryKey = SyncTree.makeQueryKey_(query);
            util_1.assert(!(queryKey in this.queryToTagMap_), 'View does not exist, but we have a tag');
            var tag = SyncTree.getNextQueryTag_();
            this.queryToTagMap_[queryKey] = tag;
            // Coerce to string to avoid sparse arrays.
            this.tagToQueryMap_['_' + tag] = queryKey;
        }
        var writesCache = this.pendingWriteTree_.childWrites(path);
        var events = syncPoint.addEventRegistration(query, eventRegistration, writesCache, serverCache, serverCacheComplete);
        if (!viewAlreadyExists && !foundAncestorDefaultView) {
            var view /** @type !View */ = syncPoint.viewForQuery(query);
            events = events.concat(this.setupListener_(query, view));
        }
        return events;
    };
    /**
     * Remove event callback(s).
     *
     * If query is the default query, we'll check all queries for the specified eventRegistration.
     * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.
     *
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration If null, all callbacks are removed.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {!Array.<!Event>} Cancel events, if cancelError was provided.
     */
    SyncTree.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {
        var _this = this;
        // Find the syncPoint first. Then deal with whether or not it has matching listeners
        var path = query.path;
        var maybeSyncPoint = this.syncPointTree_.get(path);
        var cancelEvents = [];
        // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without
        // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and
        // not loadsAllData().
        if (maybeSyncPoint &&
            (query.queryIdentifier() === 'default' ||
                maybeSyncPoint.viewExistsForQuery(query))) {
            /**
             * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}
             */
            var removedAndEvents = maybeSyncPoint.removeEventRegistration(query, eventRegistration, cancelError);
            if (maybeSyncPoint.isEmpty()) {
                this.syncPointTree_ = this.syncPointTree_.remove(path);
            }
            var removed = removedAndEvents.removed;
            cancelEvents = removedAndEvents.events;
            // We may have just removed one of many listeners and can short-circuit this whole process
            // We may also not have removed a default listener, in which case all of the descendant listeners should already be
            // properly set up.
            //
            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of
            // queryId === 'default'
            var removingDefault = -1 !==
                removed.findIndex(function (query) {
                    return query.getQueryParams().loadsAllData();
                });
            var covered = this.syncPointTree_.findOnPath(path, function (relativePath, parentSyncPoint) {
                return parentSyncPoint.hasCompleteView();
            });
            if (removingDefault && !covered) {
                var subtree = this.syncPointTree_.subtree(path);
                // There are potentially child listeners. Determine what if any listens we need to send before executing the
                // removal
                if (!subtree.isEmpty()) {
                    // We need to fold over our subtree and collect the listeners to send
                    var newViews = this.collectDistinctViewsForSubTree_(subtree);
                    // Ok, we've collected all the listens we need. Set them up.
                    for (var i = 0; i < newViews.length; ++i) {
                        var view = newViews[i], newQuery = view.getQuery();
                        var listener = this.createListenerForView_(view);
                        this.listenProvider_.startListening(SyncTree.queryForListening_(newQuery), this.tagForQuery_(newQuery), listener.hashFn, listener.onComplete);
                    }
                }
                else {
                    // There's nothing below us, so nothing we need to start listening on
                }
            }
            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query
            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.
            // Also, note that if we have a cancelError, it's already been removed at the provider level.
            if (!covered && removed.length > 0 && !cancelError) {
                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one
                // default. Otherwise, we need to iterate through and cancel each individual query
                if (removingDefault) {
                    // We don't tag default listeners
                    var defaultTag = null;
                    this.listenProvider_.stopListening(SyncTree.queryForListening_(query), defaultTag);
                }
                else {
                    removed.forEach(function (queryToRemove) {
                        var tagToRemove = _this.queryToTagMap_[SyncTree.makeQueryKey_(queryToRemove)];
                        _this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToRemove), tagToRemove);
                    });
                }
            }
            // Now, clear all of the tags we're tracking for the removed listens
            this.removeTags_(removed);
        }
        else {
            // No-op, this listener must've been already removed
        }
        return cancelEvents;
    };
    /**
     * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above
     * it, but as this is only used by transaction code, that should always be the case anyways.
     *
     * Note: this method will *include* hidden writes from transaction with applyLocally set to false.
     * @param {!Path} path The path to the data we want
     * @param {Array.<number>=} writeIdsToExclude A specific set to be excluded
     * @return {?Node}
     */
    SyncTree.prototype.calcCompleteEventCache = function (path, writeIdsToExclude) {
        var includeHiddenSets = true;
        var writeTree = this.pendingWriteTree_;
        var serverCache = this.syncPointTree_.findOnPath(path, function (pathSoFar, syncPoint) {
            var relativePath = Path_1.Path.relativePath(pathSoFar, path);
            var serverCache = syncPoint.getCompleteServerCache(relativePath);
            if (serverCache) {
                return serverCache;
            }
        });
        return writeTree.calcCompleteEventCache(path, serverCache, writeIdsToExclude, includeHiddenSets);
    };
    /**
     * This collapses multiple unfiltered views into a single view, since we only need a single
     * listener for them.
     *
     * @param {!ImmutableTree.<!SyncPoint>} subtree
     * @return {!Array.<!View>}
     * @private
     */
    SyncTree.prototype.collectDistinctViewsForSubTree_ = function (subtree) {
        return subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {
            if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {
                var completeView = maybeChildSyncPoint.getCompleteView();
                return [completeView];
            }
            else {
                // No complete view here, flatten any deeper listens into an array
                var views_1 = [];
                if (maybeChildSyncPoint) {
                    views_1 = maybeChildSyncPoint.getQueryViews();
                }
                util_3.forEach(childMap, function (key, childViews) {
                    views_1 = views_1.concat(childViews);
                });
                return views_1;
            }
        });
    };
    /**
     * @param {!Array.<!Query>} queries
     * @private
     */
    SyncTree.prototype.removeTags_ = function (queries) {
        for (var j = 0; j < queries.length; ++j) {
            var removedQuery = queries[j];
            if (!removedQuery.getQueryParams().loadsAllData()) {
                // We should have a tag for this
                var removedQueryKey = SyncTree.makeQueryKey_(removedQuery);
                var removedQueryTag = this.queryToTagMap_[removedQueryKey];
                delete this.queryToTagMap_[removedQueryKey];
                delete this.tagToQueryMap_['_' + removedQueryTag];
            }
        }
    };
    /**
     * Normalizes a query to a query we send the server for listening
     * @param {!Query} query
     * @return {!Query} The normalized query
     * @private
     */
    SyncTree.queryForListening_ = function (query) {
        if (query.getQueryParams().loadsAllData() &&
            !query.getQueryParams().isDefault()) {
            // We treat queries that load all data as default queries
            // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits
            // from Query
            return /** @type {!Query} */ query.getRef();
        }
        else {
            return query;
        }
    };
    /**
     * For a given new listen, manage the de-duplication of outstanding subscriptions.
     *
     * @param {!Query} query
     * @param {!View} view
     * @return {!Array.<!Event>} This method can return events to support synchronous data sources
     * @private
     */
    SyncTree.prototype.setupListener_ = function (query, view) {
        var path = query.path;
        var tag = this.tagForQuery_(query);
        var listener = this.createListenerForView_(view);
        var events = this.listenProvider_.startListening(SyncTree.queryForListening_(query), tag, listener.hashFn, listener.onComplete);
        var subtree = this.syncPointTree_.subtree(path);
        // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we
        // may need to shadow other listens as well.
        if (tag) {
            util_1.assert(!subtree.value.hasCompleteView(), "If we're adding a query, it shouldn't be shadowed");
        }
        else {
            // Shadow everything at or below this location, this is a default listener.
            var queriesToStop = subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {
                if (!relativePath.isEmpty() &&
                    maybeChildSyncPoint &&
                    maybeChildSyncPoint.hasCompleteView()) {
                    return [maybeChildSyncPoint.getCompleteView().getQuery()];
                }
                else {
                    // No default listener here, flatten any deeper queries into an array
                    var queries_1 = [];
                    if (maybeChildSyncPoint) {
                        queries_1 = queries_1.concat(maybeChildSyncPoint.getQueryViews().map(function (view) { return view.getQuery(); }));
                    }
                    util_3.forEach(childMap, function (key, childQueries) {
                        queries_1 = queries_1.concat(childQueries);
                    });
                    return queries_1;
                }
            });
            for (var i = 0; i < queriesToStop.length; ++i) {
                var queryToStop = queriesToStop[i];
                this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToStop), this.tagForQuery_(queryToStop));
            }
        }
        return events;
    };
    /**
     *
     * @param {!View} view
     * @return {{hashFn: function(), onComplete: function(!string, *)}}
     * @private
     */
    SyncTree.prototype.createListenerForView_ = function (view) {
        var _this = this;
        var query = view.getQuery();
        var tag = this.tagForQuery_(query);
        return {
            hashFn: function () {
                var cache = view.getServerCache() || ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                return cache.hash();
            },
            onComplete: function (status) {
                if (status === 'ok') {
                    if (tag) {
                        return _this.applyTaggedListenComplete(query.path, tag);
                    }
                    else {
                        return _this.applyListenComplete(query.path);
                    }
                }
                else {
                    // If a listen failed, kill all of the listeners here, not just the one that triggered the error.
                    // Note that this may need to be scoped to just this listener if we change permissions on filtered children
                    var error = util_2.errorForServerCode(status, query);
                    return _this.removeEventRegistration(query, 
                    /*eventRegistration*/ null, error);
                }
            }
        };
    };
    /**
     * Given a query, computes a "queryKey" suitable for use in our queryToTagMap_.
     * @private
     * @param {!Query} query
     * @return {string}
     */
    SyncTree.makeQueryKey_ = function (query) {
        return query.path.toString() + '$' + query.queryIdentifier();
    };
    /**
     * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.
     * @private
     * @param {!string} queryKey
     * @return {{queryId: !string, path: !Path}}
     */
    SyncTree.parseQueryKey_ = function (queryKey) {
        var splitIndex = queryKey.indexOf('$');
        util_1.assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');
        return {
            queryId: queryKey.substr(splitIndex + 1),
            path: new Path_1.Path(queryKey.substr(0, splitIndex))
        };
    };
    /**
     * Return the query associated with the given tag, if we have one
     * @param {!number} tag
     * @return {?string}
     * @private
     */
    SyncTree.prototype.queryKeyForTag_ = function (tag) {
        return this.tagToQueryMap_['_' + tag];
    };
    /**
     * Return the tag associated with the given query.
     * @param {!Query} query
     * @return {?number}
     * @private
     */
    SyncTree.prototype.tagForQuery_ = function (query) {
        var queryKey = SyncTree.makeQueryKey_(query);
        return util_3.safeGet(this.queryToTagMap_, queryKey);
    };
    /**
     * Static accessor for query tags.
     * @return {number}
     * @private
     */
    SyncTree.getNextQueryTag_ = function () {
        return SyncTree.nextQueryTag_++;
    };
    /**
     * A helper method to apply tagged operations
     *
     * @param {!Path} queryPath
     * @param {!Operation} operation
     * @return {!Array.<!Event>}
     * @private
     */
    SyncTree.prototype.applyTaggedOperation_ = function (queryPath, operation) {
        var syncPoint = this.syncPointTree_.get(queryPath);
        util_1.assert(syncPoint, "Missing sync point for query tag that we're tracking");
        var writesCache = this.pendingWriteTree_.childWrites(queryPath);
        return syncPoint.applyOperation(operation, writesCache, 
        /*serverCache=*/ null);
    };
    /**
     * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.
     *
     * NOTES:
     * - Descendant SyncPoints will be visited first (since we raise events depth-first).
  
     * - We call applyOperation() on each SyncPoint passing three things:
     *   1. A version of the Operation that has been made relative to the SyncPoint location.
     *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.
     *   3. A snapshot Node with cached server data, if we have it.
  
     * - We concatenate all of the events returned by each SyncPoint and return the result.
     *
     * @param {!Operation} operation
     * @return {!Array.<!Event>}
     * @private
     */
    SyncTree.prototype.applyOperationToSyncPoints_ = function (operation) {
        return this.applyOperationHelper_(operation, this.syncPointTree_, 
        /*serverCache=*/ null, this.pendingWriteTree_.childWrites(Path_1.Path.Empty));
    };
    /**
     * Recursive helper for applyOperationToSyncPoints_
     *
     * @private
     * @param {!Operation} operation
     * @param {ImmutableTree.<!SyncPoint>} syncPointTree
     * @param {?Node} serverCache
     * @param {!WriteTreeRef} writesCache
     * @return {!Array.<!Event>}
     */
    SyncTree.prototype.applyOperationHelper_ = function (operation, syncPointTree, serverCache, writesCache) {
        if (operation.path.isEmpty()) {
            return this.applyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
        }
        else {
            var syncPoint = syncPointTree.get(Path_1.Path.Empty);
            // If we don't have cached server data, see if we can get it from this SyncPoint.
            if (serverCache == null && syncPoint != null) {
                serverCache = syncPoint.getCompleteServerCache(Path_1.Path.Empty);
            }
            var events = [];
            var childName = operation.path.getFront();
            var childOperation = operation.operationForChild(childName);
            var childTree = syncPointTree.children.get(childName);
            if (childTree && childOperation) {
                var childServerCache = serverCache
                    ? serverCache.getImmediateChild(childName)
                    : null;
                var childWritesCache = writesCache.child(childName);
                events = events.concat(this.applyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
            }
            if (syncPoint) {
                events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));
            }
            return events;
        }
    };
    /**
     * Recursive helper for applyOperationToSyncPoints_
     *
     * @private
     * @param {!Operation} operation
     * @param {ImmutableTree.<!SyncPoint>} syncPointTree
     * @param {?Node} serverCache
     * @param {!WriteTreeRef} writesCache
     * @return {!Array.<!Event>}
     */
    SyncTree.prototype.applyOperationDescendantsHelper_ = function (operation, syncPointTree, serverCache, writesCache) {
        var _this = this;
        var syncPoint = syncPointTree.get(Path_1.Path.Empty);
        // If we don't have cached server data, see if we can get it from this SyncPoint.
        if (serverCache == null && syncPoint != null) {
            serverCache = syncPoint.getCompleteServerCache(Path_1.Path.Empty);
        }
        var events = [];
        syncPointTree.children.inorderTraversal(function (childName, childTree) {
            var childServerCache = serverCache
                ? serverCache.getImmediateChild(childName)
                : null;
            var childWritesCache = writesCache.child(childName);
            var childOperation = operation.operationForChild(childName);
            if (childOperation) {
                events = events.concat(_this.applyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
            }
        });
        if (syncPoint) {
            events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));
        }
        return events;
    };
    /**
     * Static tracker for next query tag.
     * @type {number}
     * @private
     */
    SyncTree.nextQueryTag_ = 1;
    return SyncTree;
}());
exports.SyncTree = SyncTree;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/SyncTree.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"./SyncPoint":24,"./WriteTree":26,"./operation/AckUserWrite":27,"./operation/ListenComplete":28,"./operation/Merge":29,"./operation/Operation":30,"./operation/Overwrite":31,"./snap/ChildrenNode":32,"./util/ImmutableTree":54,"./util/Path":57,"./util/util":63,"@firebase/util":134,"_process":162,"buffer":160}],26:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
var Path_1 = require("./util/Path");
var CompoundWrite_1 = require("./CompoundWrite");
var PriorityIndex_1 = require("./snap/indexes/PriorityIndex");
var ChildrenNode_1 = require("./snap/ChildrenNode");
/**
 * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them
 * with underlying server data (to create "event cache" data).  Pending writes are added with addOverwrite()
 * and addMerge(), and removed with removeWrite().
 *
 * @constructor
 */
var WriteTree = /** @class */ (function () {
    function WriteTree() {
        /**
         * A tree tracking the result of applying all visible writes.  This does not include transactions with
         * applyLocally=false or writes that are completely shadowed by other writes.
         *
         * @type {!CompoundWrite}
         * @private
         */
        this.visibleWrites_ = CompoundWrite_1.CompoundWrite.Empty;
        /**
         * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary
         * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also
         * used by transactions).
         *
         * @type {!Array.<!WriteRecord>}
         * @private
         */
        this.allWrites_ = [];
        this.lastWriteId_ = -1;
    }
    /**
     * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.
     *
     * @param {!Path} path
     * @return {!WriteTreeRef}
     */
    WriteTree.prototype.childWrites = function (path) {
        return new WriteTreeRef(path, this);
    };
    /**
     * Record a new overwrite from user code.
     *
     * @param {!Path} path
     * @param {!Node} snap
     * @param {!number} writeId
     * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches
     */
    WriteTree.prototype.addOverwrite = function (path, snap, writeId, visible) {
        util_2.assert(writeId > this.lastWriteId_, 'Stacking an older write on top of newer ones');
        if (visible === undefined) {
            visible = true;
        }
        this.allWrites_.push({
            path: path,
            snap: snap,
            writeId: writeId,
            visible: visible
        });
        if (visible) {
            this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);
        }
        this.lastWriteId_ = writeId;
    };
    /**
     * Record a new merge from user code.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} writeId
     */
    WriteTree.prototype.addMerge = function (path, changedChildren, writeId) {
        util_2.assert(writeId > this.lastWriteId_, 'Stacking an older merge on top of newer ones');
        this.allWrites_.push({
            path: path,
            children: changedChildren,
            writeId: writeId,
            visible: true
        });
        this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);
        this.lastWriteId_ = writeId;
    };
    /**
     * @param {!number} writeId
     * @return {?WriteRecord}
     */
    WriteTree.prototype.getWrite = function (writeId) {
        for (var i = 0; i < this.allWrites_.length; i++) {
            var record = this.allWrites_[i];
            if (record.writeId === writeId) {
                return record;
            }
        }
        return null;
    };
    /**
     * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates
     * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.
     *
     * @param {!number} writeId
     * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise
     * events as a result).
     */
    WriteTree.prototype.removeWrite = function (writeId) {
        // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied
        // out of order.
        //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;
        //assert(validClear, "Either we don't have this write, or it's the first one in the queue");
        var _this = this;
        var idx = this.allWrites_.findIndex(function (s) {
            return s.writeId === writeId;
        });
        util_2.assert(idx >= 0, 'removeWrite called with nonexistent writeId.');
        var writeToRemove = this.allWrites_[idx];
        this.allWrites_.splice(idx, 1);
        var removedWriteWasVisible = writeToRemove.visible;
        var removedWriteOverlapsWithOtherWrites = false;
        var i = this.allWrites_.length - 1;
        while (removedWriteWasVisible && i >= 0) {
            var currentWrite = this.allWrites_[i];
            if (currentWrite.visible) {
                if (i >= idx &&
                    this.recordContainsPath_(currentWrite, writeToRemove.path)) {
                    // The removed write was completely shadowed by a subsequent write.
                    removedWriteWasVisible = false;
                }
                else if (writeToRemove.path.contains(currentWrite.path)) {
                    // Either we're covering some writes or they're covering part of us (depending on which came first).
                    removedWriteOverlapsWithOtherWrites = true;
                }
            }
            i--;
        }
        if (!removedWriteWasVisible) {
            return false;
        }
        else if (removedWriteOverlapsWithOtherWrites) {
            // There's some shadowing going on. Just rebuild the visible writes from scratch.
            this.resetTree_();
            return true;
        }
        else {
            // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.
            if (writeToRemove.snap) {
                this.visibleWrites_ = this.visibleWrites_.removeWrite(writeToRemove.path);
            }
            else {
                var children = writeToRemove.children;
                util_1.forEach(children, function (childName) {
                    _this.visibleWrites_ = _this.visibleWrites_.removeWrite(writeToRemove.path.child(childName));
                });
            }
            return true;
        }
    };
    /**
     * Return a complete snapshot for the given path if there's visible write data at that path, else null.
     * No server data is considered.
     *
     * @param {!Path} path
     * @return {?Node}
     */
    WriteTree.prototype.getCompleteWriteData = function (path) {
        return this.visibleWrites_.getCompleteNode(path);
    };
    /**
     * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden
     * writes), attempt to calculate a complete snapshot for the given path
     *
     * @param {!Path} treePath
     * @param {?Node} completeServerCache
     * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded
     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return {?Node}
     */
    WriteTree.prototype.calcCompleteEventCache = function (treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
        if (!writeIdsToExclude && !includeHiddenWrites) {
            var shadowingNode = this.visibleWrites_.getCompleteNode(treePath);
            if (shadowingNode != null) {
                return shadowingNode;
            }
            else {
                var subMerge = this.visibleWrites_.childCompoundWrite(treePath);
                if (subMerge.isEmpty()) {
                    return completeServerCache;
                }
                else if (completeServerCache == null &&
                    !subMerge.hasCompleteWrite(Path_1.Path.Empty)) {
                    // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow
                    return null;
                }
                else {
                    var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                    return subMerge.apply(layeredCache);
                }
            }
        }
        else {
            var merge = this.visibleWrites_.childCompoundWrite(treePath);
            if (!includeHiddenWrites && merge.isEmpty()) {
                return completeServerCache;
            }
            else {
                // If the server cache is null, and we don't have a complete cache, we need to return null
                if (!includeHiddenWrites &&
                    completeServerCache == null &&
                    !merge.hasCompleteWrite(Path_1.Path.Empty)) {
                    return null;
                }
                else {
                    var filter = function (write) {
                        return ((write.visible || includeHiddenWrites) &&
                            (!writeIdsToExclude ||
                                !~writeIdsToExclude.indexOf(write.writeId)) &&
                            (write.path.contains(treePath) || treePath.contains(write.path)));
                    };
                    var mergeAtPath = WriteTree.layerTree_(this.allWrites_, filter, treePath);
                    var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                    return mergeAtPath.apply(layeredCache);
                }
            }
        }
    };
    /**
     * With optional, underlying server data, attempt to return a children node of children that we have complete data for.
     * Used when creating new views, to pre-fill their complete event children snapshot.
     *
     * @param {!Path} treePath
     * @param {?ChildrenNode} completeServerChildren
     * @return {!ChildrenNode}
     */
    WriteTree.prototype.calcCompleteEventChildren = function (treePath, completeServerChildren) {
        var completeChildren = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        var topLevelSet = this.visibleWrites_.getCompleteNode(treePath);
        if (topLevelSet) {
            if (!topLevelSet.isLeafNode()) {
                // we're shadowing everything. Return the children.
                topLevelSet.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childSnap) {
                    completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
                });
            }
            return completeChildren;
        }
        else if (completeServerChildren) {
            // Layer any children we have on top of this
            // We know we don't have a top-level set, so just enumerate existing children
            var merge_1 = this.visibleWrites_.childCompoundWrite(treePath);
            completeServerChildren.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {
                var node = merge_1
                    .childCompoundWrite(new Path_1.Path(childName))
                    .apply(childNode);
                completeChildren = completeChildren.updateImmediateChild(childName, node);
            });
            // Add any complete children we have from the set
            merge_1.getCompleteChildren().forEach(function (namedNode) {
                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
            });
            return completeChildren;
        }
        else {
            // We don't have anything to layer on top of. Layer on any children we have
            // Note that we can return an empty snap if we have a defined delete
            var merge = this.visibleWrites_.childCompoundWrite(treePath);
            merge.getCompleteChildren().forEach(function (namedNode) {
                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
            });
            return completeChildren;
        }
    };
    /**
     * Given that the underlying server data has updated, determine what, if anything, needs to be
     * applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events
     *
     * Either existingEventSnap or existingServerSnap must exist
     *
     * @param {!Path} treePath
     * @param {!Path} childPath
     * @param {?Node} existingEventSnap
     * @param {?Node} existingServerSnap
     * @return {?Node}
     */
    WriteTree.prototype.calcEventCacheAfterServerOverwrite = function (treePath, childPath, existingEventSnap, existingServerSnap) {
        util_2.assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');
        var path = treePath.child(childPath);
        if (this.visibleWrites_.hasCompleteWrite(path)) {
            // At this point we can probably guarantee that we're in case 2, meaning no events
            // May need to check visibility while doing the findRootMostValueAndPath call
            return null;
        }
        else {
            // No complete shadowing. We're either partially shadowing or not shadowing at all.
            var childMerge = this.visibleWrites_.childCompoundWrite(path);
            if (childMerge.isEmpty()) {
                // We're not shadowing at all. Case 1
                return existingServerSnap.getChild(childPath);
            }
            else {
                // This could be more efficient if the serverNode + updates doesn't change the eventSnap
                // However this is tricky to find out, since user updates don't necessary change the server
                // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server
                // adds nodes, but doesn't change any existing writes. It is therefore not enough to
                // only check if the updates change the serverNode.
                // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?
                return childMerge.apply(existingServerSnap.getChild(childPath));
            }
        }
    };
    /**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param {!Path} treePath
     * @param {!string} childKey
     * @param {!CacheNode} existingServerSnap
     * @return {?Node}
     */
    WriteTree.prototype.calcCompleteChild = function (treePath, childKey, existingServerSnap) {
        var path = treePath.child(childKey);
        var shadowingNode = this.visibleWrites_.getCompleteNode(path);
        if (shadowingNode != null) {
            return shadowingNode;
        }
        else {
            if (existingServerSnap.isCompleteForChild(childKey)) {
                var childMerge = this.visibleWrites_.childCompoundWrite(path);
                return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));
            }
            else {
                return null;
            }
        }
    };
    /**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param {!Path} path
     * @return {?Node}
     */
    WriteTree.prototype.shadowingWrite = function (path) {
        return this.visibleWrites_.getCompleteNode(path);
    };
    /**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window.
     *
     * @param {!Path} treePath
     * @param {?Node} completeServerData
     * @param {!NamedNode} startPost
     * @param {!number} count
     * @param {boolean} reverse
     * @param {!Index} index
     * @return {!Array.<!NamedNode>}
     */
    WriteTree.prototype.calcIndexedSlice = function (treePath, completeServerData, startPost, count, reverse, index) {
        var toIterate;
        var merge = this.visibleWrites_.childCompoundWrite(treePath);
        var shadowingNode = merge.getCompleteNode(Path_1.Path.Empty);
        if (shadowingNode != null) {
            toIterate = shadowingNode;
        }
        else if (completeServerData != null) {
            toIterate = merge.apply(completeServerData);
        }
        else {
            // no children to iterate on
            return [];
        }
        toIterate = toIterate.withIndex(index);
        if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
            var nodes = [];
            var cmp = index.getCompare();
            var iter = reverse
                ? toIterate.getReverseIteratorFrom(startPost, index)
                : toIterate.getIteratorFrom(startPost, index);
            var next = iter.getNext();
            while (next && nodes.length < count) {
                if (cmp(next, startPost) !== 0) {
                    nodes.push(next);
                }
                next = iter.getNext();
            }
            return nodes;
        }
        else {
            return [];
        }
    };
    /**
     * @param {!WriteRecord} writeRecord
     * @param {!Path} path
     * @return {boolean}
     * @private
     */
    WriteTree.prototype.recordContainsPath_ = function (writeRecord, path) {
        if (writeRecord.snap) {
            return writeRecord.path.contains(path);
        }
        else {
            // findKey can return undefined, so use !! to coerce to boolean
            return !!util_1.findKey(writeRecord.children, function (childSnap, childName) {
                return writeRecord.path.child(childName).contains(path);
            });
        }
    };
    /**
     * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots
     * @private
     */
    WriteTree.prototype.resetTree_ = function () {
        this.visibleWrites_ = WriteTree.layerTree_(this.allWrites_, WriteTree.DefaultFilter_, Path_1.Path.Empty);
        if (this.allWrites_.length > 0) {
            this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;
        }
        else {
            this.lastWriteId_ = -1;
        }
    };
    /**
     * The default filter used when constructing the tree. Keep everything that's visible.
     *
     * @param {!WriteRecord} write
     * @return {boolean}
     * @private
     */
    WriteTree.DefaultFilter_ = function (write) {
        return write.visible;
    };
    /**
     * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of
     * event data at that path.
     *
     * @param {!Array.<!WriteRecord>} writes
     * @param {!function(!WriteRecord):boolean} filter
     * @param {!Path} treeRoot
     * @return {!CompoundWrite}
     * @private
     */
    WriteTree.layerTree_ = function (writes, filter, treeRoot) {
        var compoundWrite = CompoundWrite_1.CompoundWrite.Empty;
        for (var i = 0; i < writes.length; ++i) {
            var write = writes[i];
            // Theory, a later set will either:
            // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction
            // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction
            if (filter(write)) {
                var writePath = write.path;
                var relativePath = void 0;
                if (write.snap) {
                    if (treeRoot.contains(writePath)) {
                        relativePath = Path_1.Path.relativePath(treeRoot, writePath);
                        compoundWrite = compoundWrite.addWrite(relativePath, write.snap);
                    }
                    else if (writePath.contains(treeRoot)) {
                        relativePath = Path_1.Path.relativePath(writePath, treeRoot);
                        compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, write.snap.getChild(relativePath));
                    }
                    else {
                        // There is no overlap between root path and write path, ignore write
                    }
                }
                else if (write.children) {
                    if (treeRoot.contains(writePath)) {
                        relativePath = Path_1.Path.relativePath(treeRoot, writePath);
                        compoundWrite = compoundWrite.addWrites(relativePath, write.children);
                    }
                    else if (writePath.contains(treeRoot)) {
                        relativePath = Path_1.Path.relativePath(writePath, treeRoot);
                        if (relativePath.isEmpty()) {
                            compoundWrite = compoundWrite.addWrites(Path_1.Path.Empty, write.children);
                        }
                        else {
                            var child = util_1.safeGet(write.children, relativePath.getFront());
                            if (child) {
                                // There exists a child in this node that matches the root path
                                var deepNode = child.getChild(relativePath.popFront());
                                compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, deepNode);
                            }
                        }
                    }
                    else {
                        // There is no overlap between root path and write path, ignore write
                    }
                }
                else {
                    throw util_2.assertionError('WriteRecord should have .snap or .children');
                }
            }
        }
        return compoundWrite;
    };
    return WriteTree;
}());
exports.WriteTree = WriteTree;
/**
 * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods
 * just proxy to the underlying WriteTree.
 *
 * @constructor
 */
var WriteTreeRef = /** @class */ (function () {
    /**
     * @param {!Path} path
     * @param {!WriteTree} writeTree
     */
    function WriteTreeRef(path, writeTree) {
        this.treePath_ = path;
        this.writeTree_ = writeTree;
    }
    /**
     * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used
     * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node
     * can lead to a more expensive calculation.
     *
     * @param {?Node} completeServerCache
     * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.
     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return {?Node}
     */
    WriteTreeRef.prototype.calcCompleteEventCache = function (completeServerCache, writeIdsToExclude, includeHiddenWrites) {
        return this.writeTree_.calcCompleteEventCache(this.treePath_, completeServerCache, writeIdsToExclude, includeHiddenWrites);
    };
    /**
     * If possible, returns a children node containing all of the complete children we have data for. The returned data is a
     * mix of the given server data and write data.
     *
     * @param {?ChildrenNode} completeServerChildren
     * @return {!ChildrenNode}
     */
    WriteTreeRef.prototype.calcCompleteEventChildren = function (completeServerChildren) {
        return this.writeTree_.calcCompleteEventChildren(this.treePath_, completeServerChildren);
    };
    /**
     * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,
     * if anything, needs to be applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events should be raised
     *
     * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert
     *
     * @param {!Path} path
     * @param {?Node} existingEventSnap
     * @param {?Node} existingServerSnap
     * @return {?Node}
     */
    WriteTreeRef.prototype.calcEventCacheAfterServerOverwrite = function (path, existingEventSnap, existingServerSnap) {
        return this.writeTree_.calcEventCacheAfterServerOverwrite(this.treePath_, path, existingEventSnap, existingServerSnap);
    };
    /**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param {!Path} path
     * @return {?Node}
     */
    WriteTreeRef.prototype.shadowingWrite = function (path) {
        return this.writeTree_.shadowingWrite(this.treePath_.child(path));
    };
    /**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window
     *
     * @param {?Node} completeServerData
     * @param {!NamedNode} startPost
     * @param {!number} count
     * @param {boolean} reverse
     * @param {!Index} index
     * @return {!Array.<!NamedNode>}
     */
    WriteTreeRef.prototype.calcIndexedSlice = function (completeServerData, startPost, count, reverse, index) {
        return this.writeTree_.calcIndexedSlice(this.treePath_, completeServerData, startPost, count, reverse, index);
    };
    /**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param {!string} childKey
     * @param {!CacheNode} existingServerCache
     * @return {?Node}
     */
    WriteTreeRef.prototype.calcCompleteChild = function (childKey, existingServerCache) {
        return this.writeTree_.calcCompleteChild(this.treePath_, childKey, existingServerCache);
    };
    /**
     * Return a WriteTreeRef for a child.
     *
     * @param {string} childName
     * @return {!WriteTreeRef}
     */
    WriteTreeRef.prototype.child = function (childName) {
        return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);
    };
    return WriteTreeRef;
}());
exports.WriteTreeRef = WriteTreeRef;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/WriteTree.js","/node_modules/@firebase/database/dist/cjs/src/core")

},{"./CompoundWrite":14,"./snap/ChildrenNode":32,"./snap/indexes/PriorityIndex":41,"./util/Path":57,"@firebase/util":134,"_process":162,"buffer":160}],27:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var Path_1 = require("../util/Path");
var Operation_1 = require("./Operation");
var AckUserWrite = /** @class */ (function () {
    /**
     *
     * @param {!Path} path
     * @param {!ImmutableTree<!boolean>} affectedTree A tree containing true for each affected path. Affected paths can't overlap.
     * @param {!boolean} revert
     */
    function AckUserWrite(
        /**@inheritDoc */ path, 
        /**@inheritDoc */ affectedTree, 
        /**@inheritDoc */ revert) {
        this.path = path;
        this.affectedTree = affectedTree;
        this.revert = revert;
        /** @inheritDoc */
        this.type = Operation_1.OperationType.ACK_USER_WRITE;
        /** @inheritDoc */
        this.source = Operation_1.OperationSource.User;
    }
    /**
     * @inheritDoc
     */
    AckUserWrite.prototype.operationForChild = function (childName) {
        if (!this.path.isEmpty()) {
            util_1.assert(this.path.getFront() === childName, 'operationForChild called for unrelated child.');
            return new AckUserWrite(this.path.popFront(), this.affectedTree, this.revert);
        }
        else if (this.affectedTree.value != null) {
            util_1.assert(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.');
            // All child locations are affected as well; just return same operation.
            return this;
        }
        else {
            var childTree = this.affectedTree.subtree(new Path_1.Path(childName));
            return new AckUserWrite(Path_1.Path.Empty, childTree, this.revert);
        }
    };
    return AckUserWrite;
}());
exports.AckUserWrite = AckUserWrite;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/operation/AckUserWrite.js","/node_modules/@firebase/database/dist/cjs/src/core/operation")

},{"../util/Path":57,"./Operation":30,"@firebase/util":134,"_process":162,"buffer":160}],28:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Path_1 = require("../util/Path");
var Operation_1 = require("./Operation");
/**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @constructor
 * @implements {Operation}
 */
var ListenComplete = /** @class */ (function () {
    function ListenComplete(source, path) {
        this.source = source;
        this.path = path;
        /** @inheritDoc */
        this.type = Operation_1.OperationType.LISTEN_COMPLETE;
    }
    ListenComplete.prototype.operationForChild = function (childName) {
        if (this.path.isEmpty()) {
            return new ListenComplete(this.source, Path_1.Path.Empty);
        }
        else {
            return new ListenComplete(this.source, this.path.popFront());
        }
    };
    return ListenComplete;
}());
exports.ListenComplete = ListenComplete;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/operation/ListenComplete.js","/node_modules/@firebase/database/dist/cjs/src/core/operation")

},{"../util/Path":57,"./Operation":30,"_process":162,"buffer":160}],29:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Operation_1 = require("./Operation");
var Overwrite_1 = require("./Overwrite");
var Path_1 = require("../util/Path");
var util_1 = require("@firebase/util");
/**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @param {!ImmutableTree.<!Node>} children
 * @constructor
 * @implements {Operation}
 */
var Merge = /** @class */ (function () {
    function Merge(
        /**@inheritDoc */ source, 
        /**@inheritDoc */ path, 
        /**@inheritDoc */ children) {
        this.source = source;
        this.path = path;
        this.children = children;
        /** @inheritDoc */
        this.type = Operation_1.OperationType.MERGE;
    }
    /**
     * @inheritDoc
     */
    Merge.prototype.operationForChild = function (childName) {
        if (this.path.isEmpty()) {
            var childTree = this.children.subtree(new Path_1.Path(childName));
            if (childTree.isEmpty()) {
                // This child is unaffected
                return null;
            }
            else if (childTree.value) {
                // We have a snapshot for the child in question.  This becomes an overwrite of the child.
                return new Overwrite_1.Overwrite(this.source, Path_1.Path.Empty, childTree.value);
            }
            else {
                // This is a merge at a deeper level
                return new Merge(this.source, Path_1.Path.Empty, childTree);
            }
        }
        else {
            util_1.assert(this.path.getFront() === childName, "Can't get a merge for a child not on the path of the operation");
            return new Merge(this.source, this.path.popFront(), this.children);
        }
    };
    /**
     * @inheritDoc
     */
    Merge.prototype.toString = function () {
        return ('Operation(' +
            this.path +
            ': ' +
            this.source.toString() +
            ' merge: ' +
            this.children.toString() +
            ')');
    };
    return Merge;
}());
exports.Merge = Merge;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/operation/Merge.js","/node_modules/@firebase/database/dist/cjs/src/core/operation")

},{"../util/Path":57,"./Operation":30,"./Overwrite":31,"@firebase/util":134,"_process":162,"buffer":160}],30:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
/**
 *
 * @enum
 */
var OperationType;
(function (OperationType) {
    OperationType[OperationType["OVERWRITE"] = 0] = "OVERWRITE";
    OperationType[OperationType["MERGE"] = 1] = "MERGE";
    OperationType[OperationType["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
    OperationType[OperationType["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
})(OperationType = exports.OperationType || (exports.OperationType = {}));
/**
 * @param {boolean} fromUser
 * @param {boolean} fromServer
 * @param {?string} queryId
 * @param {boolean} tagged
 * @constructor
 */
var OperationSource = /** @class */ (function () {
    function OperationSource(fromUser, fromServer, queryId, tagged) {
        this.fromUser = fromUser;
        this.fromServer = fromServer;
        this.queryId = queryId;
        this.tagged = tagged;
        util_1.assert(!tagged || fromServer, 'Tagged queries must be from server.');
    }
    /**
     * @const
     * @type {!OperationSource}
     */
    OperationSource.User = new OperationSource(
    /*fromUser=*/ true, false, null, 
    /*tagged=*/ false);
    /**
     * @const
     * @type {!OperationSource}
     */
    OperationSource.Server = new OperationSource(false, 
    /*fromServer=*/ true, null, 
    /*tagged=*/ false);
    /**
     * @param {string} queryId
     * @return {!OperationSource}
     */
    OperationSource.forServerTaggedQuery = function (queryId) {
        return new OperationSource(false, 
        /*fromServer=*/ true, queryId, 
        /*tagged=*/ true);
    };
    return OperationSource;
}());
exports.OperationSource = OperationSource;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/operation/Operation.js","/node_modules/@firebase/database/dist/cjs/src/core/operation")

},{"@firebase/util":134,"_process":162,"buffer":160}],31:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Operation_1 = require("./Operation");
var Path_1 = require("../util/Path");
/**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @param {!Node} snap
 * @constructor
 * @implements {Operation}
 */
var Overwrite = /** @class */ (function () {
    function Overwrite(source, path, snap) {
        this.source = source;
        this.path = path;
        this.snap = snap;
        /** @inheritDoc */
        this.type = Operation_1.OperationType.OVERWRITE;
    }
    Overwrite.prototype.operationForChild = function (childName) {
        if (this.path.isEmpty()) {
            return new Overwrite(this.source, Path_1.Path.Empty, this.snap.getImmediateChild(childName));
        }
        else {
            return new Overwrite(this.source, this.path.popFront(), this.snap);
        }
    };
    return Overwrite;
}());
exports.Overwrite = Overwrite;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/operation/Overwrite.js","/node_modules/@firebase/database/dist/cjs/src/core/operation")

},{"../util/Path":57,"./Operation":30,"_process":162,"buffer":160}],32:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("../util/util");
var SortedMap_1 = require("../util/SortedMap");
var Node_1 = require("./Node");
var snap_1 = require("./snap");
var PriorityIndex_1 = require("./indexes/PriorityIndex");
var KeyIndex_1 = require("./indexes/KeyIndex");
var IndexMap_1 = require("./IndexMap");
var LeafNode_1 = require("./LeafNode");
var comparators_1 = require("./comparators");
// TODO: For memory savings, don't store priorityNode_ if it's empty.
var EMPTY_NODE;
/**
 * ChildrenNode is a class for storing internal nodes in a DataSnapshot
 * (i.e. nodes with children).  It implements Node and stores the
 * list of children in the children property, sorted by child name.
 *
 * @constructor
 * @implements {Node}
 */
var ChildrenNode = /** @class */ (function () {
    /**
     *
     * @param {!SortedMap.<string, !Node>} children_ List of children
     * of this node..
     * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).
     * @param {!IndexMap} indexMap_
     */
    function ChildrenNode(children_, priorityNode_, indexMap_) {
        this.children_ = children_;
        this.priorityNode_ = priorityNode_;
        this.indexMap_ = indexMap_;
        this.lazyHash_ = null;
        /**
         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use
         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own
         * class instead of an empty ChildrenNode.
         */
        if (this.priorityNode_) {
            snap_1.validatePriorityNode(this.priorityNode_);
        }
        if (this.children_.isEmpty()) {
            util_1.assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');
        }
    }
    Object.defineProperty(ChildrenNode, "EMPTY_NODE", {
        get: function () {
            return (EMPTY_NODE ||
                (EMPTY_NODE = new ChildrenNode(new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), null, IndexMap_1.IndexMap.Default)));
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritDoc */
    ChildrenNode.prototype.isLeafNode = function () {
        return false;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getPriority = function () {
        return this.priorityNode_ || EMPTY_NODE;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updatePriority = function (newPriorityNode) {
        if (this.children_.isEmpty()) {
            // Don't allow priorities on empty nodes
            return this;
        }
        else {
            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getImmediateChild = function (childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.getPriority();
        }
        else {
            var child = this.children_.get(childName);
            return child === null ? EMPTY_NODE : child;
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getChild = function (path) {
        var front = path.getFront();
        if (front === null)
            return this;
        return this.getImmediateChild(front).getChild(path.popFront());
    };
    /** @inheritDoc */
    ChildrenNode.prototype.hasChild = function (childName) {
        return this.children_.get(childName) !== null;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updateImmediateChild = function (childName, newChildNode) {
        util_1.assert(newChildNode, 'We should always be passing snapshot nodes');
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else {
            var namedNode = new Node_1.NamedNode(childName, newChildNode);
            var newChildren = void 0, newIndexMap = void 0, newPriority = void 0;
            if (newChildNode.isEmpty()) {
                newChildren = this.children_.remove(childName);
                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
            }
            else {
                newChildren = this.children_.insert(childName, newChildNode);
                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
            }
            newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;
            return new ChildrenNode(newChildren, newPriority, newIndexMap);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updateChild = function (path, newChildNode) {
        var front = path.getFront();
        if (front === null) {
            return newChildNode;
        }
        else {
            util_1.assert(path.getFront() !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');
            var newImmediateChild = this.getImmediateChild(front).updateChild(path.popFront(), newChildNode);
            return this.updateImmediateChild(front, newImmediateChild);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.isEmpty = function () {
        return this.children_.isEmpty();
    };
    /** @inheritDoc */
    ChildrenNode.prototype.numChildren = function () {
        return this.children_.count();
    };
    /** @inheritDoc */
    ChildrenNode.prototype.val = function (exportFormat) {
        if (this.isEmpty())
            return null;
        var obj = {};
        var numKeys = 0, maxKey = 0, allIntegerKeys = true;
        this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
            obj[key] = childNode.val(exportFormat);
            numKeys++;
            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {
                maxKey = Math.max(maxKey, Number(key));
            }
            else {
                allIntegerKeys = false;
            }
        });
        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
            // convert to array.
            var array = [];
            for (var key in obj)
                array[key] = obj[key];
            return array;
        }
        else {
            if (exportFormat && !this.getPriority().isEmpty()) {
                obj['.priority'] = this.getPriority().val();
            }
            return obj;
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.hash = function () {
        if (this.lazyHash_ === null) {
            var toHash_1 = '';
            if (!this.getPriority().isEmpty())
                toHash_1 +=
                    'priority:' +
                        snap_1.priorityHashText(this.getPriority().val()) +
                        ':';
            this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
                var childHash = childNode.hash();
                if (childHash !== '')
                    toHash_1 += ':' + key + ':' + childHash;
            });
            this.lazyHash_ = toHash_1 === '' ? '' : util_2.sha1(toHash_1);
        }
        return this.lazyHash_;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getPredecessorChildName = function (childName, childNode, index) {
        var idx = this.resolveIndex_(index);
        if (idx) {
            var predecessor = idx.getPredecessorKey(new Node_1.NamedNode(childName, childNode));
            return predecessor ? predecessor.name : null;
        }
        else {
            return this.children_.getPredecessorKey(childName);
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {?string}
     */
    ChildrenNode.prototype.getFirstChildName = function (indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            var minKey = idx.minKey();
            return minKey && minKey.name;
        }
        else {
            return this.children_.minKey();
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {?NamedNode}
     */
    ChildrenNode.prototype.getFirstChild = function (indexDefinition) {
        var minKey = this.getFirstChildName(indexDefinition);
        if (minKey) {
            return new Node_1.NamedNode(minKey, this.children_.get(minKey));
        }
        else {
            return null;
        }
    };
    /**
     * Given an index, return the key name of the largest value we have, according to that index
     * @param {!Index} indexDefinition
     * @return {?string}
     */
    ChildrenNode.prototype.getLastChildName = function (indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            var maxKey = idx.maxKey();
            return maxKey && maxKey.name;
        }
        else {
            return this.children_.maxKey();
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {?NamedNode}
     */
    ChildrenNode.prototype.getLastChild = function (indexDefinition) {
        var maxKey = this.getLastChildName(indexDefinition);
        if (maxKey) {
            return new Node_1.NamedNode(maxKey, this.children_.get(maxKey));
        }
        else {
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.forEachChild = function (index, action) {
        var idx = this.resolveIndex_(index);
        if (idx) {
            return idx.inorderTraversal(function (wrappedNode) {
                return action(wrappedNode.name, wrappedNode.node);
            });
        }
        else {
            return this.children_.inorderTraversal(action);
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {SortedMapIterator}
     */
    ChildrenNode.prototype.getIterator = function (indexDefinition) {
        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
    };
    /**
     *
     * @param {!NamedNode} startPost
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */
    ChildrenNode.prototype.getIteratorFrom = function (startPost, indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getIteratorFrom(startPost, function (key) { return key; });
        }
        else {
            var iterator = this.children_.getIteratorFrom(startPost.name, Node_1.NamedNode.Wrap);
            var next = iterator.peek();
            while (next != null && indexDefinition.compare(next, startPost) < 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */
    ChildrenNode.prototype.getReverseIterator = function (indexDefinition) {
        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
    };
    /**
     * @param {!NamedNode} endPost
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */
    ChildrenNode.prototype.getReverseIteratorFrom = function (endPost, indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getReverseIteratorFrom(endPost, function (key) {
                return key;
            });
        }
        else {
            var iterator = this.children_.getReverseIteratorFrom(endPost.name, Node_1.NamedNode.Wrap);
            var next = iterator.peek();
            while (next != null && indexDefinition.compare(next, endPost) > 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.compareTo = function (other) {
        if (this.isEmpty()) {
            if (other.isEmpty()) {
                return 0;
            }
            else {
                return -1;
            }
        }
        else if (other.isLeafNode() || other.isEmpty()) {
            return 1;
        }
        else if (other === exports.MAX_NODE) {
            return -1;
        }
        else {
            // Must be another node with children.
            return 0;
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.withIndex = function (indexDefinition) {
        if (indexDefinition === KeyIndex_1.KEY_INDEX ||
            this.indexMap_.hasIndex(indexDefinition)) {
            return this;
        }
        else {
            var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.isIndexed = function (index) {
        return index === KeyIndex_1.KEY_INDEX || this.indexMap_.hasIndex(index);
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            return false;
        }
        else {
            var otherChildrenNode = other;
            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
                return false;
            }
            else if (this.children_.count() === otherChildrenNode.children_.count()) {
                var thisIter = this.getIterator(PriorityIndex_1.PRIORITY_INDEX);
                var otherIter = otherChildrenNode.getIterator(PriorityIndex_1.PRIORITY_INDEX);
                var thisCurrent = thisIter.getNext();
                var otherCurrent = otherIter.getNext();
                while (thisCurrent && otherCurrent) {
                    if (thisCurrent.name !== otherCurrent.name ||
                        !thisCurrent.node.equals(otherCurrent.node)) {
                        return false;
                    }
                    thisCurrent = thisIter.getNext();
                    otherCurrent = otherIter.getNext();
                }
                return thisCurrent === null && otherCurrent === null;
            }
            else {
                return false;
            }
        }
    };
    /**
     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used
     * instead.
     *
     * @private
     * @param {!Index} indexDefinition
     * @return {?SortedMap.<NamedNode, Node>}
     */
    ChildrenNode.prototype.resolveIndex_ = function (indexDefinition) {
        if (indexDefinition === KeyIndex_1.KEY_INDEX) {
            return null;
        }
        else {
            return this.indexMap_.get(indexDefinition.toString());
        }
    };
    /**
     * @private
     * @type {RegExp}
     */
    ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
    return ChildrenNode;
}());
exports.ChildrenNode = ChildrenNode;
/**
 * @constructor
 * @extends {ChildrenNode}
 * @private
 */
var MaxNode = /** @class */ (function (_super) {
    __extends(MaxNode, _super);
    function MaxNode() {
        return _super.call(this, new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap_1.IndexMap.Default) || this;
    }
    MaxNode.prototype.compareTo = function (other) {
        if (other === this) {
            return 0;
        }
        else {
            return 1;
        }
    };
    MaxNode.prototype.equals = function (other) {
        // Not that we every compare it, but MAX_NODE is only ever equal to itself
        return other === this;
    };
    MaxNode.prototype.getPriority = function () {
        return this;
    };
    MaxNode.prototype.getImmediateChild = function (childName) {
        return ChildrenNode.EMPTY_NODE;
    };
    MaxNode.prototype.isEmpty = function () {
        return false;
    };
    return MaxNode;
}(ChildrenNode));
exports.MaxNode = MaxNode;
/**
 * Marker that will sort higher than any other snapshot.
 * @type {!MAX_NODE}
 * @const
 */
exports.MAX_NODE = new MaxNode();
Object.defineProperties(Node_1.NamedNode, {
    MIN: {
        value: new Node_1.NamedNode(util_2.MIN_NAME, ChildrenNode.EMPTY_NODE)
    },
    MAX: {
        value: new Node_1.NamedNode(util_2.MAX_NAME, exports.MAX_NODE)
    }
});
/**
 * Reference Extensions
 */
KeyIndex_1.KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
LeafNode_1.LeafNode.__childrenNodeConstructor = ChildrenNode;
snap_1.setMaxNode(exports.MAX_NODE);
PriorityIndex_1.setMaxNode(exports.MAX_NODE);



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/ChildrenNode.js","/node_modules/@firebase/database/dist/cjs/src/core/snap")

},{"../util/SortedMap":59,"../util/util":63,"./IndexMap":33,"./LeafNode":34,"./Node":35,"./comparators":37,"./indexes/KeyIndex":39,"./indexes/PriorityIndex":41,"./snap":44,"@firebase/util":134,"_process":162,"buffer":160}],33:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var childSet_1 = require("./childSet");
var util_2 = require("@firebase/util");
var Node_1 = require("./Node");
var PriorityIndex_1 = require("./indexes/PriorityIndex");
var KeyIndex_1 = require("./indexes/KeyIndex");
var _defaultIndexMap;
var fallbackObject = {};
/**
 *
 * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes
 * @param {Object.<string, Index>} indexSet
 * @constructor
 */
var IndexMap = /** @class */ (function () {
    function IndexMap(indexes_, indexSet_) {
        this.indexes_ = indexes_;
        this.indexSet_ = indexSet_;
    }
    Object.defineProperty(IndexMap, "Default", {
        /**
         * The default IndexMap for nodes without a priority
         * @type {!IndexMap}
         * @const
         */
        get: function () {
            util_1.assert(fallbackObject && PriorityIndex_1.PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');
            _defaultIndexMap =
                _defaultIndexMap ||
                    new IndexMap({ '.priority': fallbackObject }, { '.priority': PriorityIndex_1.PRIORITY_INDEX });
            return _defaultIndexMap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @param {!string} indexKey
     * @return {?SortedMap.<NamedNode, Node>}
     */
    IndexMap.prototype.get = function (indexKey) {
        var sortedMap = util_2.safeGet(this.indexes_, indexKey);
        if (!sortedMap)
            throw new Error('No index defined for ' + indexKey);
        if (sortedMap === fallbackObject) {
            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the
            // regular child map
            return null;
        }
        else {
            return sortedMap;
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {boolean}
     */
    IndexMap.prototype.hasIndex = function (indexDefinition) {
        return util_2.contains(this.indexSet_, indexDefinition.toString());
    };
    /**
     * @param {!Index} indexDefinition
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */
    IndexMap.prototype.addIndex = function (indexDefinition, existingChildren) {
        util_1.assert(indexDefinition !== KeyIndex_1.KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        var childList = [];
        var sawIndexedValue = false;
        var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);
        var next = iter.getNext();
        while (next) {
            sawIndexedValue =
                sawIndexedValue || indexDefinition.isDefinedOn(next.node);
            childList.push(next);
            next = iter.getNext();
        }
        var newIndex;
        if (sawIndexedValue) {
            newIndex = childSet_1.buildChildSet(childList, indexDefinition.getCompare());
        }
        else {
            newIndex = fallbackObject;
        }
        var indexName = indexDefinition.toString();
        var newIndexSet = util_2.clone(this.indexSet_);
        newIndexSet[indexName] = indexDefinition;
        var newIndexes = util_2.clone(this.indexes_);
        newIndexes[indexName] = newIndex;
        return new IndexMap(newIndexes, newIndexSet);
    };
    /**
     * Ensure that this node is properly tracked in any indexes that we're maintaining
     * @param {!NamedNode} namedNode
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */
    IndexMap.prototype.addToIndexes = function (namedNode, existingChildren) {
        var _this = this;
        var newIndexes = util_2.map(this.indexes_, function (indexedChildren, indexName) {
            var index = util_2.safeGet(_this.indexSet_, indexName);
            util_1.assert(index, 'Missing index implementation for ' + indexName);
            if (indexedChildren === fallbackObject) {
                // Check to see if we need to index everything
                if (index.isDefinedOn(namedNode.node)) {
                    // We need to build this index
                    var childList = [];
                    var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);
                    var next = iter.getNext();
                    while (next) {
                        if (next.name != namedNode.name) {
                            childList.push(next);
                        }
                        next = iter.getNext();
                    }
                    childList.push(namedNode);
                    return childSet_1.buildChildSet(childList, index.getCompare());
                }
                else {
                    // No change, this remains a fallback
                    return fallbackObject;
                }
            }
            else {
                var existingSnap = existingChildren.get(namedNode.name);
                var newChildren = indexedChildren;
                if (existingSnap) {
                    newChildren = newChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));
                }
                return newChildren.insert(namedNode, namedNode.node);
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    };
    /**
     * Create a new IndexMap instance with the given value removed
     * @param {!NamedNode} namedNode
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */
    IndexMap.prototype.removeFromIndexes = function (namedNode, existingChildren) {
        var newIndexes = util_2.map(this.indexes_, function (indexedChildren) {
            if (indexedChildren === fallbackObject) {
                // This is the fallback. Just return it, nothing to do in this case
                return indexedChildren;
            }
            else {
                var existingSnap = existingChildren.get(namedNode.name);
                if (existingSnap) {
                    return indexedChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));
                }
                else {
                    // No record of this child
                    return indexedChildren;
                }
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    };
    return IndexMap;
}());
exports.IndexMap = IndexMap;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/IndexMap.js","/node_modules/@firebase/database/dist/cjs/src/core/snap")

},{"./Node":35,"./childSet":36,"./indexes/KeyIndex":39,"./indexes/PriorityIndex":41,"@firebase/util":134,"_process":162,"buffer":160}],34:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("../util/util");
var snap_1 = require("./snap");
var __childrenNodeConstructor;
/**
 * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It
 * implements Node and stores the value of the node (a string,
 * number, or boolean) accessible via getValue().
 */
var LeafNode = /** @class */ (function () {
    /**
     * @implements {Node}
     * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.
     *                                         The object type is possible in the event of a deferred value
     * @param {!Node=} priorityNode_ The priority of this node.
     */
    function LeafNode(value_, priorityNode_) {
        if (priorityNode_ === void 0) { priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE; }
        this.value_ = value_;
        this.priorityNode_ = priorityNode_;
        this.lazyHash_ = null;
        util_1.assert(this.value_ !== undefined && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
        snap_1.validatePriorityNode(this.priorityNode_);
    }
    Object.defineProperty(LeafNode, "__childrenNodeConstructor", {
        get: function () {
            return __childrenNodeConstructor;
        },
        set: function (val) {
            __childrenNodeConstructor = val;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritDoc */
    LeafNode.prototype.isLeafNode = function () {
        return true;
    };
    /** @inheritDoc */
    LeafNode.prototype.getPriority = function () {
        return this.priorityNode_;
    };
    /** @inheritDoc */
    LeafNode.prototype.updatePriority = function (newPriorityNode) {
        return new LeafNode(this.value_, newPriorityNode);
    };
    /** @inheritDoc */
    LeafNode.prototype.getImmediateChild = function (childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.getChild = function (path) {
        if (path.isEmpty()) {
            return this;
        }
        else if (path.getFront() === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.hasChild = function () {
        return false;
    };
    /** @inheritDoc */
    LeafNode.prototype.getPredecessorChildName = function (childName, childNode) {
        return null;
    };
    /** @inheritDoc */
    LeafNode.prototype.updateImmediateChild = function (childName, newChildNode) {
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else if (newChildNode.isEmpty() && childName !== '.priority') {
            return this;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE
                .updateImmediateChild(childName, newChildNode)
                .updatePriority(this.priorityNode_);
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.updateChild = function (path, newChildNode) {
        var front = path.getFront();
        if (front === null) {
            return newChildNode;
        }
        else if (newChildNode.isEmpty() && front !== '.priority') {
            return this;
        }
        else {
            util_1.assert(front !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');
            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(path.popFront(), newChildNode));
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.isEmpty = function () {
        return false;
    };
    /** @inheritDoc */
    LeafNode.prototype.numChildren = function () {
        return 0;
    };
    /** @inheritDoc */
    LeafNode.prototype.forEachChild = function (index, action) {
        return false;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.val = function (exportFormat) {
        if (exportFormat && !this.getPriority().isEmpty())
            return {
                '.value': this.getValue(),
                '.priority': this.getPriority().val()
            };
        else
            return this.getValue();
    };
    /** @inheritDoc */
    LeafNode.prototype.hash = function () {
        if (this.lazyHash_ === null) {
            var toHash = '';
            if (!this.priorityNode_.isEmpty())
                toHash +=
                    'priority:' +
                        snap_1.priorityHashText(this.priorityNode_.val()) +
                        ':';
            var type = typeof this.value_;
            toHash += type + ':';
            if (type === 'number') {
                toHash += util_2.doubleToIEEE754String(this.value_);
            }
            else {
                toHash += this.value_;
            }
            this.lazyHash_ = util_2.sha1(toHash);
        }
        return this.lazyHash_;
    };
    /**
     * Returns the value of the leaf node.
     * @return {Object|string|number|boolean} The value of the node.
     */
    LeafNode.prototype.getValue = function () {
        return this.value_;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.compareTo = function (other) {
        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
            return 1;
        }
        else if (other instanceof LeafNode.__childrenNodeConstructor) {
            return -1;
        }
        else {
            util_1.assert(other.isLeafNode(), 'Unknown node type');
            return this.compareToLeafNode_(other);
        }
    };
    /**
     * Comparison specifically for two leaf nodes
     * @param {!LeafNode} otherLeaf
     * @return {!number}
     * @private
     */
    LeafNode.prototype.compareToLeafNode_ = function (otherLeaf) {
        var otherLeafType = typeof otherLeaf.value_;
        var thisLeafType = typeof this.value_;
        var otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
        var thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
        util_1.assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);
        util_1.assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);
        if (otherIndex === thisIndex) {
            // Same type, compare values
            if (thisLeafType === 'object') {
                // Deferred value nodes are all equal, but we should also never get to this point...
                return 0;
            }
            else {
                // Note that this works because true > false, all others are number or string comparisons
                if (this.value_ < otherLeaf.value_) {
                    return -1;
                }
                else if (this.value_ === otherLeaf.value_) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
        }
        else {
            return thisIndex - otherIndex;
        }
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.withIndex = function () {
        return this;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.isIndexed = function () {
        return true;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.equals = function (other) {
        /**
         * @inheritDoc
         */
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            var otherLeaf = other;
            return (this.value_ === otherLeaf.value_ &&
                this.priorityNode_.equals(otherLeaf.priorityNode_));
        }
        else {
            return false;
        }
    };
    /**
     * The sort order for comparing leaf nodes of different types. If two leaf nodes have
     * the same type, the comparison falls back to their value
     * @type {Array.<!string>}
     * @const
     */
    LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];
    return LeafNode;
}());
exports.LeafNode = LeafNode;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/LeafNode.js","/node_modules/@firebase/database/dist/cjs/src/core/snap")

},{"../util/util":63,"./snap":44,"@firebase/util":134,"_process":162,"buffer":160}],35:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 * @param {!string} name
 * @param {!Node} node
 * @constructor
 * @struct
 */
var NamedNode = /** @class */ (function () {
    function NamedNode(name, node) {
        this.name = name;
        this.node = node;
    }
    /**
     *
     * @param {!string} name
     * @param {!Node} node
     * @return {NamedNode}
     */
    NamedNode.Wrap = function (name, node) {
        return new NamedNode(name, node);
    };
    return NamedNode;
}());
exports.NamedNode = NamedNode;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/Node.js","/node_modules/@firebase/database/dist/cjs/src/core/snap")

},{"_process":162,"buffer":160}],36:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var SortedMap_1 = require("../util/SortedMap");
var SortedMap_2 = require("../util/SortedMap");
var LOG_2 = Math.log(2);
/**
 * @constructor
 */
var Base12Num = /** @class */ (function () {
    /**
     * @param {number} length
     */
    function Base12Num(length) {
        var logBase2 = function (num) {
            return parseInt((Math.log(num) / LOG_2), 10);
        };
        var bitMask = function (bits) { return parseInt(Array(bits + 1).join('1'), 2); };
        this.count = logBase2(length + 1);
        this.current_ = this.count - 1;
        var mask = bitMask(this.count);
        this.bits_ = (length + 1) & mask;
    }
    /**
     * @return {boolean}
     */
    Base12Num.prototype.nextBitIsOne = function () {
        //noinspection JSBitwiseOperatorUsage
        var result = !(this.bits_ & (0x1 << this.current_));
        this.current_--;
        return result;
    };
    return Base12Num;
}());
/**
 * Takes a list of child nodes and constructs a SortedSet using the given comparison
 * function
 *
 * Uses the algorithm described in the paper linked here:
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458
 *
 * @template K, V
 * @param {Array.<!NamedNode>} childList Unsorted list of children
 * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used
 * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's
 *                                                        type is not NamedNode
 * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map
 * @return {SortedMap.<K, V>}
 */
exports.buildChildSet = function (childList, cmp, keyFn, mapSortFn) {
    childList.sort(cmp);
    var buildBalancedTree = function (low, high) {
        var length = high - low;
        var namedNode;
        var key;
        if (length == 0) {
            return null;
        }
        else if (length == 1) {
            namedNode = childList[low];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, null, null);
        }
        else {
            var middle = parseInt((length / 2), 10) + low;
            var left = buildBalancedTree(low, middle);
            var right = buildBalancedTree(middle + 1, high);
            namedNode = childList[middle];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, left, right);
        }
    };
    var buildFrom12Array = function (base12) {
        var node = null;
        var root = null;
        var index = childList.length;
        var buildPennant = function (chunkSize, color) {
            var low = index - chunkSize;
            var high = index;
            index -= chunkSize;
            var childTree = buildBalancedTree(low + 1, high);
            var namedNode = childList[low];
            var key = keyFn ? keyFn(namedNode) : namedNode;
            attachPennant(new SortedMap_1.LLRBNode(key, namedNode.node, color, null, childTree));
        };
        var attachPennant = function (pennant) {
            if (node) {
                node.left = pennant;
                node = pennant;
            }
            else {
                root = pennant;
                node = pennant;
            }
        };
        for (var i = 0; i < base12.count; ++i) {
            var isOne = base12.nextBitIsOne();
            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))
            var chunkSize = Math.pow(2, base12.count - (i + 1));
            if (isOne) {
                buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);
            }
            else {
                // current == 2
                buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);
                buildPennant(chunkSize, SortedMap_1.LLRBNode.RED);
            }
        }
        return root;
    };
    var base12 = new Base12Num(childList.length);
    var root = buildFrom12Array(base12);
    return new SortedMap_2.SortedMap(mapSortFn || cmp, root);
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/childSet.js","/node_modules/@firebase/database/dist/cjs/src/core/snap")

},{"../util/SortedMap":59,"_process":162,"buffer":160}],37:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util/util");
function NAME_ONLY_COMPARATOR(left, right) {
    return util_1.nameCompare(left.name, right.name);
}
exports.NAME_ONLY_COMPARATOR = NAME_ONLY_COMPARATOR;
function NAME_COMPARATOR(left, right) {
    return util_1.nameCompare(left, right);
}
exports.NAME_COMPARATOR = NAME_COMPARATOR;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/comparators.js","/node_modules/@firebase/database/dist/cjs/src/core/snap")

},{"../util/util":63,"_process":162,"buffer":160}],38:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Node_1 = require("../Node");
var util_1 = require("../../util/util");
/**
 *
 * @constructor
 */
var Index = /** @class */ (function () {
    function Index() {
    }
    /**
     * @return {function(!NamedNode, !NamedNode):number} A standalone comparison function for
     * this index
     */
    Index.prototype.getCompare = function () {
        return this.compare.bind(this);
    };
    /**
     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,
     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.
     *
     * @param {!Node} oldNode
     * @param {!Node} newNode
     * @return {boolean} True if the portion of the snapshot being indexed changed between oldNode and newNode
     */
    Index.prototype.indexedValueChanged = function (oldNode, newNode) {
        var oldWrapped = new Node_1.NamedNode(util_1.MIN_NAME, oldNode);
        var newWrapped = new Node_1.NamedNode(util_1.MIN_NAME, newNode);
        return this.compare(oldWrapped, newWrapped) !== 0;
    };
    /**
     * @return {!NamedNode} a node wrapper that will sort equal to or less than
     * any other node wrapper, using this index
     */
    Index.prototype.minPost = function () {
        return Node_1.NamedNode.MIN;
    };
    return Index;
}());
exports.Index = Index;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/indexes/Index.js","/node_modules/@firebase/database/dist/cjs/src/core/snap/indexes")

},{"../../util/util":63,"../Node":35,"_process":162,"buffer":160}],39:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Index_1 = require("./Index");
var Node_1 = require("../Node");
var util_1 = require("../../util/util");
var util_2 = require("@firebase/util");
var __EMPTY_NODE;
var KeyIndex = /** @class */ (function (_super) {
    __extends(KeyIndex, _super);
    function KeyIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(KeyIndex, "__EMPTY_NODE", {
        get: function () {
            return __EMPTY_NODE;
        },
        set: function (val) {
            __EMPTY_NODE = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.compare = function (a, b) {
        return util_1.nameCompare(a.name, b.name);
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.isDefinedOn = function (node) {
        // We could probably return true here (since every node has a key), but it's never called
        // so just leaving unimplemented for now.
        throw util_2.assertionError('KeyIndex.isDefinedOn not expected to be called.');
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return false; // The key for a node never changes.
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.minPost = function () {
        return Node_1.NamedNode.MIN;
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.maxPost = function () {
        // TODO: This should really be created once and cached in a static property, but
        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.
        return new Node_1.NamedNode(util_1.MAX_NAME, __EMPTY_NODE);
    };
    /**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */
    KeyIndex.prototype.makePost = function (indexValue, name) {
        util_2.assert(typeof indexValue === 'string', 'KeyIndex indexValue must always be a string.');
        // We just use empty node, but it'll never be compared, since our comparator only looks at name.
        return new Node_1.NamedNode(indexValue, __EMPTY_NODE);
    };
    /**
     * @return {!string} String representation for inclusion in a query spec
     */
    KeyIndex.prototype.toString = function () {
        return '.key';
    };
    return KeyIndex;
}(Index_1.Index));
exports.KeyIndex = KeyIndex;
exports.KEY_INDEX = new KeyIndex();



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/indexes/KeyIndex.js","/node_modules/@firebase/database/dist/cjs/src/core/snap/indexes")

},{"../../util/util":63,"../Node":35,"./Index":38,"@firebase/util":134,"_process":162,"buffer":160}],40:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("../../util/util");
var Index_1 = require("./Index");
var ChildrenNode_1 = require("../ChildrenNode");
var Node_1 = require("../Node");
var nodeFromJSON_1 = require("../nodeFromJSON");
/**
 * @param {!Path} indexPath
 * @constructor
 * @extends {Index}
 */
var PathIndex = /** @class */ (function (_super) {
    __extends(PathIndex, _super);
    function PathIndex(indexPath_) {
        var _this = _super.call(this) || this;
        _this.indexPath_ = indexPath_;
        util_1.assert(!indexPath_.isEmpty() && indexPath_.getFront() !== '.priority', "Can't create PathIndex with empty path or .priority key");
        return _this;
    }
    /**
     * @param {!Node} snap
     * @return {!Node}
     * @protected
     */
    PathIndex.prototype.extractChild = function (snap) {
        return snap.getChild(this.indexPath_);
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.isDefinedOn = function (node) {
        return !node.getChild(this.indexPath_).isEmpty();
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.compare = function (a, b) {
        var aChild = this.extractChild(a.node);
        var bChild = this.extractChild(b.node);
        var indexCmp = aChild.compareTo(bChild);
        if (indexCmp === 0) {
            return util_2.nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.makePost = function (indexValue, name) {
        var valueNode = nodeFromJSON_1.nodeFromJSON(indexValue);
        var node = ChildrenNode_1.ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
        return new Node_1.NamedNode(name, node);
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.maxPost = function () {
        var node = ChildrenNode_1.ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, ChildrenNode_1.MAX_NODE);
        return new Node_1.NamedNode(util_2.MAX_NAME, node);
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.toString = function () {
        return this.indexPath_.slice().join('/');
    };
    return PathIndex;
}(Index_1.Index));
exports.PathIndex = PathIndex;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/indexes/PathIndex.js","/node_modules/@firebase/database/dist/cjs/src/core/snap/indexes")

},{"../../util/util":63,"../ChildrenNode":32,"../Node":35,"../nodeFromJSON":43,"./Index":38,"@firebase/util":134,"_process":162,"buffer":160}],41:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Index_1 = require("./Index");
var util_1 = require("../../util/util");
var Node_1 = require("../Node");
var LeafNode_1 = require("../LeafNode");
var nodeFromJSON;
var MAX_NODE;
function setNodeFromJSON(val) {
    nodeFromJSON = val;
}
exports.setNodeFromJSON = setNodeFromJSON;
function setMaxNode(val) {
    MAX_NODE = val;
}
exports.setMaxNode = setMaxNode;
/**
 * @constructor
 * @extends {Index}
 * @private
 */
var PriorityIndex = /** @class */ (function (_super) {
    __extends(PriorityIndex, _super);
    function PriorityIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.compare = function (a, b) {
        var aPriority = a.node.getPriority();
        var bPriority = b.node.getPriority();
        var indexCmp = aPriority.compareTo(bPriority);
        if (indexCmp === 0) {
            return util_1.nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.isDefinedOn = function (node) {
        return !node.getPriority().isEmpty();
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return !oldNode.getPriority().equals(newNode.getPriority());
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.minPost = function () {
        return Node_1.NamedNode.MIN;
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.maxPost = function () {
        return new Node_1.NamedNode(util_1.MAX_NAME, new LeafNode_1.LeafNode('[PRIORITY-POST]', MAX_NODE));
    };
    /**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */
    PriorityIndex.prototype.makePost = function (indexValue, name) {
        var priorityNode = nodeFromJSON(indexValue);
        return new Node_1.NamedNode(name, new LeafNode_1.LeafNode('[PRIORITY-POST]', priorityNode));
    };
    /**
     * @return {!string} String representation for inclusion in a query spec
     */
    PriorityIndex.prototype.toString = function () {
        return '.priority';
    };
    return PriorityIndex;
}(Index_1.Index));
exports.PriorityIndex = PriorityIndex;
exports.PRIORITY_INDEX = new PriorityIndex();



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/indexes/PriorityIndex.js","/node_modules/@firebase/database/dist/cjs/src/core/snap/indexes")

},{"../../util/util":63,"../LeafNode":34,"../Node":35,"./Index":38,"_process":162,"buffer":160}],42:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Index_1 = require("./Index");
var Node_1 = require("../Node");
var util_1 = require("../../util/util");
var nodeFromJSON_1 = require("../nodeFromJSON");
/**
 * @constructor
 * @extends {Index}
 * @private
 */
var ValueIndex = /** @class */ (function (_super) {
    __extends(ValueIndex, _super);
    function ValueIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.compare = function (a, b) {
        var indexCmp = a.node.compareTo(b.node);
        if (indexCmp === 0) {
            return util_1.nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.isDefinedOn = function (node) {
        return true;
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return !oldNode.equals(newNode);
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.minPost = function () {
        return Node_1.NamedNode.MIN;
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.maxPost = function () {
        return Node_1.NamedNode.MAX;
    };
    /**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */
    ValueIndex.prototype.makePost = function (indexValue, name) {
        var valueNode = nodeFromJSON_1.nodeFromJSON(indexValue);
        return new Node_1.NamedNode(name, valueNode);
    };
    /**
     * @return {!string} String representation for inclusion in a query spec
     */
    ValueIndex.prototype.toString = function () {
        return '.value';
    };
    return ValueIndex;
}(Index_1.Index));
exports.ValueIndex = ValueIndex;
exports.VALUE_INDEX = new ValueIndex();



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/indexes/ValueIndex.js","/node_modules/@firebase/database/dist/cjs/src/core/snap/indexes")

},{"../../util/util":63,"../Node":35,"../nodeFromJSON":43,"./Index":38,"_process":162,"buffer":160}],43:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ChildrenNode_1 = require("./ChildrenNode");
var LeafNode_1 = require("./LeafNode");
var Node_1 = require("./Node");
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
var childSet_1 = require("./childSet");
var comparators_1 = require("./comparators");
var IndexMap_1 = require("./IndexMap");
var PriorityIndex_1 = require("./indexes/PriorityIndex");
var USE_HINZE = true;
/**
 * Constructs a snapshot node representing the passed JSON and returns it.
 * @param {*} json JSON to create a node for.
 * @param {?string|?number=} priority Optional priority to use.  This will be ignored if the
 * passed JSON contains a .priority property.
 * @return {!Node}
 */
function nodeFromJSON(json, priority) {
    if (priority === void 0) { priority = null; }
    if (json === null) {
        return ChildrenNode_1.ChildrenNode.EMPTY_NODE;
    }
    if (typeof json === 'object' && '.priority' in json) {
        priority = json['.priority'];
    }
    util_2.assert(priority === null ||
        typeof priority === 'string' ||
        typeof priority === 'number' ||
        (typeof priority === 'object' && '.sv' in priority), 'Invalid priority type found: ' + typeof priority);
    if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {
        json = json['.value'];
    }
    // Valid leaf nodes include non-objects or server-value wrapper objects
    if (typeof json !== 'object' || '.sv' in json) {
        var jsonLeaf = json;
        return new LeafNode_1.LeafNode(jsonLeaf, nodeFromJSON(priority));
    }
    if (!(json instanceof Array) && USE_HINZE) {
        var children_1 = [];
        var childrenHavePriority_1 = false;
        var hinzeJsonObj_1 = json;
        util_1.forEach(hinzeJsonObj_1, function (key, child) {
            if (typeof key !== 'string' || key.substring(0, 1) !== '.') {
                // Ignore metadata nodes
                var childNode = nodeFromJSON(hinzeJsonObj_1[key]);
                if (!childNode.isEmpty()) {
                    childrenHavePriority_1 =
                        childrenHavePriority_1 || !childNode.getPriority().isEmpty();
                    children_1.push(new Node_1.NamedNode(key, childNode));
                }
            }
        });
        if (children_1.length == 0) {
            return ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        }
        var childSet = childSet_1.buildChildSet(children_1, comparators_1.NAME_ONLY_COMPARATOR, function (namedNode) { return namedNode.name; }, comparators_1.NAME_COMPARATOR);
        if (childrenHavePriority_1) {
            var sortedChildSet = childSet_1.buildChildSet(children_1, PriorityIndex_1.PRIORITY_INDEX.getCompare());
            return new ChildrenNode_1.ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap_1.IndexMap({ '.priority': sortedChildSet }, { '.priority': PriorityIndex_1.PRIORITY_INDEX }));
        }
        else {
            return new ChildrenNode_1.ChildrenNode(childSet, nodeFromJSON(priority), IndexMap_1.IndexMap.Default);
        }
    }
    else {
        var node_1 = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        var jsonObj_1 = json;
        util_1.forEach(jsonObj_1, function (key, childData) {
            if (util_1.contains(jsonObj_1, key)) {
                if (key.substring(0, 1) !== '.') {
                    // ignore metadata nodes.
                    var childNode = nodeFromJSON(childData);
                    if (childNode.isLeafNode() || !childNode.isEmpty())
                        node_1 = node_1.updateImmediateChild(key, childNode);
                }
            }
        });
        return node_1.updatePriority(nodeFromJSON(priority));
    }
}
exports.nodeFromJSON = nodeFromJSON;
PriorityIndex_1.setNodeFromJSON(nodeFromJSON);



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/nodeFromJSON.js","/node_modules/@firebase/database/dist/cjs/src/core/snap")

},{"./ChildrenNode":32,"./IndexMap":33,"./LeafNode":34,"./Node":35,"./childSet":36,"./comparators":37,"./indexes/PriorityIndex":41,"@firebase/util":134,"_process":162,"buffer":160}],44:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("../util/util");
var util_3 = require("@firebase/util");
var MAX_NODE;
function setMaxNode(val) {
    MAX_NODE = val;
}
exports.setMaxNode = setMaxNode;
/**
 * @param {(!string|!number)} priority
 * @return {!string}
 */
exports.priorityHashText = function (priority) {
    if (typeof priority === 'number')
        return 'number:' + util_2.doubleToIEEE754String(priority);
    else
        return 'string:' + priority;
};
/**
 * Validates that a priority snapshot Node is valid.
 *
 * @param {!Node} priorityNode
 */
exports.validatePriorityNode = function (priorityNode) {
    if (priorityNode.isLeafNode()) {
        var val = priorityNode.val();
        util_1.assert(typeof val === 'string' ||
            typeof val === 'number' ||
            (typeof val === 'object' && util_3.contains(val, '.sv')), 'Priority must be a string or number.');
    }
    else {
        util_1.assert(priorityNode === MAX_NODE || priorityNode.isEmpty(), 'priority of unexpected type.');
    }
    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.
    util_1.assert(priorityNode === MAX_NODE || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/snap/snap.js","/node_modules/@firebase/database/dist/cjs/src/core/snap")

},{"../util/util":63,"@firebase/util":134,"_process":162,"buffer":160}],45:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
/**
 * Tracks a collection of stats.
 *
 * @constructor
 */
var StatsCollection = /** @class */ (function () {
    function StatsCollection() {
        this.counters_ = {};
    }
    StatsCollection.prototype.incrementCounter = function (name, amount) {
        if (amount === void 0) { amount = 1; }
        if (!util_2.contains(this.counters_, name))
            this.counters_[name] = 0;
        this.counters_[name] += amount;
    };
    StatsCollection.prototype.get = function () {
        return util_1.deepCopy(this.counters_);
    };
    return StatsCollection;
}());
exports.StatsCollection = StatsCollection;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/stats/StatsCollection.js","/node_modules/@firebase/database/dist/cjs/src/core/stats")

},{"@firebase/util":134,"_process":162,"buffer":160}],46:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
/**
 * Returns the delta from the previous call to get stats.
 *
 * @param collection_ The collection to "listen" to.
 * @constructor
 */
var StatsListener = /** @class */ (function () {
    function StatsListener(collection_) {
        this.collection_ = collection_;
        this.last_ = null;
    }
    StatsListener.prototype.get = function () {
        var newStats = this.collection_.get();
        var delta = util_1.clone(newStats);
        if (this.last_) {
            util_1.forEach(this.last_, function (stat, value) {
                delta[stat] = delta[stat] - value;
            });
        }
        this.last_ = newStats;
        return delta;
    };
    return StatsListener;
}());
exports.StatsListener = StatsListener;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/stats/StatsListener.js","/node_modules/@firebase/database/dist/cjs/src/core/stats")

},{"@firebase/util":134,"_process":162,"buffer":160}],47:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var StatsCollection_1 = require("./StatsCollection");
var StatsManager = /** @class */ (function () {
    function StatsManager() {
    }
    StatsManager.getCollection = function (repoInfo) {
        var hashString = repoInfo.toString();
        if (!this.collections_[hashString]) {
            this.collections_[hashString] = new StatsCollection_1.StatsCollection();
        }
        return this.collections_[hashString];
    };
    StatsManager.getOrCreateReporter = function (repoInfo, creatorFunction) {
        var hashString = repoInfo.toString();
        if (!this.reporters_[hashString]) {
            this.reporters_[hashString] = creatorFunction();
        }
        return this.reporters_[hashString];
    };
    StatsManager.collections_ = {};
    StatsManager.reporters_ = {};
    return StatsManager;
}());
exports.StatsManager = StatsManager;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/stats/StatsManager.js","/node_modules/@firebase/database/dist/cjs/src/core/stats")

},{"./StatsCollection":45,"_process":162,"buffer":160}],48:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("../util/util");
var StatsListener_1 = require("./StatsListener");
// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably
// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10
// seconds to try to ensure the Firebase connection is established / settled.
var FIRST_STATS_MIN_TIME = 10 * 1000;
var FIRST_STATS_MAX_TIME = 30 * 1000;
// We'll continue to report stats on average every 5 minutes.
var REPORT_STATS_INTERVAL = 5 * 60 * 1000;
/**
 * @constructor
 */
var StatsReporter = /** @class */ (function () {
    /**
     * @param collection
     * @param server_
     */
    function StatsReporter(collection, server_) {
        this.server_ = server_;
        this.statsToReport_ = {};
        this.statsListener_ = new StatsListener_1.StatsListener(collection);
        var timeout = FIRST_STATS_MIN_TIME +
            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
        util_2.setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
    }
    StatsReporter.prototype.includeStat = function (stat) {
        this.statsToReport_[stat] = true;
    };
    StatsReporter.prototype.reportStats_ = function () {
        var _this = this;
        var stats = this.statsListener_.get();
        var reportedStats = {};
        var haveStatsToReport = false;
        util_1.forEach(stats, function (stat, value) {
            if (value > 0 && util_1.contains(_this.statsToReport_, stat)) {
                reportedStats[stat] = value;
                haveStatsToReport = true;
            }
        });
        if (haveStatsToReport) {
            this.server_.reportStats(reportedStats);
        }
        // queue our next run.
        util_2.setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
    };
    return StatsReporter;
}());
exports.StatsReporter = StatsReporter;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/stats/StatsReporter.js","/node_modules/@firebase/database/dist/cjs/src/core/stats")

},{"../util/util":63,"./StatsListener":46,"@firebase/util":134,"_process":162,"buffer":160}],49:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
/**
 * Wraps a DOM Storage object and:
 * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.
 * - prefixes names with "firebase:" to avoid collisions with app data.
 *
 * We automatically (see storage.js) create two such wrappers, one for sessionStorage,
 * and one for localStorage.
 *
 * @constructor
 */
var DOMStorageWrapper = /** @class */ (function () {
    /**
     * @param {Storage} domStorage_ The underlying storage object (e.g. localStorage or sessionStorage)
     */
    function DOMStorageWrapper(domStorage_) {
        this.domStorage_ = domStorage_;
        // Use a prefix to avoid collisions with other stuff saved by the app.
        this.prefix_ = 'firebase:';
    }
    /**
     * @param {string} key The key to save the value under
     * @param {?Object} value The value being stored, or null to remove the key.
     */
    DOMStorageWrapper.prototype.set = function (key, value) {
        if (value == null) {
            this.domStorage_.removeItem(this.prefixedName_(key));
        }
        else {
            this.domStorage_.setItem(this.prefixedName_(key), util_1.stringify(value));
        }
    };
    /**
     * @param {string} key
     * @return {*} The value that was stored under this key, or null
     */
    DOMStorageWrapper.prototype.get = function (key) {
        var storedVal = this.domStorage_.getItem(this.prefixedName_(key));
        if (storedVal == null) {
            return null;
        }
        else {
            return util_1.jsonEval(storedVal);
        }
    };
    /**
     * @param {string} key
     */
    DOMStorageWrapper.prototype.remove = function (key) {
        this.domStorage_.removeItem(this.prefixedName_(key));
    };
    /**
     * @param {string} name
     * @return {string}
     */
    DOMStorageWrapper.prototype.prefixedName_ = function (name) {
        return this.prefix_ + name;
    };
    DOMStorageWrapper.prototype.toString = function () {
        return this.domStorage_.toString();
    };
    return DOMStorageWrapper;
}());
exports.DOMStorageWrapper = DOMStorageWrapper;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/storage/DOMStorageWrapper.js","/node_modules/@firebase/database/dist/cjs/src/core/storage")

},{"@firebase/util":134,"_process":162,"buffer":160}],50:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
/**
 * An in-memory storage implementation that matches the API of DOMStorageWrapper
 * (TODO: create interface for both to implement).
 *
 * @constructor
 */
var MemoryStorage = /** @class */ (function () {
    function MemoryStorage() {
        this.cache_ = {};
        this.isInMemoryStorage = true;
    }
    MemoryStorage.prototype.set = function (key, value) {
        if (value == null) {
            delete this.cache_[key];
        }
        else {
            this.cache_[key] = value;
        }
    };
    MemoryStorage.prototype.get = function (key) {
        if (util_1.contains(this.cache_, key)) {
            return this.cache_[key];
        }
        return null;
    };
    MemoryStorage.prototype.remove = function (key) {
        delete this.cache_[key];
    };
    return MemoryStorage;
}());
exports.MemoryStorage = MemoryStorage;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/storage/MemoryStorage.js","/node_modules/@firebase/database/dist/cjs/src/core/storage")

},{"@firebase/util":134,"_process":162,"buffer":160}],51:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var DOMStorageWrapper_1 = require("./DOMStorageWrapper");
var MemoryStorage_1 = require("./MemoryStorage");
/**
 * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.
 * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change
 * to reflect this type
 *
 * @param {string} domStorageName Name of the underlying storage object
 *   (e.g. 'localStorage' or 'sessionStorage').
 * @return {?} Turning off type information until a common interface is defined.
 */
var createStoragefor = function (domStorageName) {
    try {
        // NOTE: just accessing "localStorage" or "window['localStorage']" may throw a security exception,
        // so it must be inside the try/catch.
        if (typeof window !== 'undefined' &&
            typeof window[domStorageName] !== 'undefined') {
            // Need to test cache. Just because it's here doesn't mean it works
            var domStorage = window[domStorageName];
            domStorage.setItem('firebase:sentinel', 'cache');
            domStorage.removeItem('firebase:sentinel');
            return new DOMStorageWrapper_1.DOMStorageWrapper(domStorage);
        }
    }
    catch (e) { }
    // Failed to create wrapper.  Just return in-memory storage.
    // TODO: log?
    return new MemoryStorage_1.MemoryStorage();
};
/** A storage object that lasts across sessions */
exports.PersistentStorage = createStoragefor('localStorage');
/** A storage object that only lasts one session */
exports.SessionStorage = createStoragefor('sessionStorage');



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/storage/storage.js","/node_modules/@firebase/database/dist/cjs/src/core/storage")

},{"./DOMStorageWrapper":49,"./MemoryStorage":50,"_process":162,"buffer":160}],52:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
/**
 * Implements a set with a count of elements.
 *
 * @template K, V
 */
var CountedSet = /** @class */ (function () {
    function CountedSet() {
        this.set = {};
    }
    /**
     * @param {!K} item
     * @param {V} val
     */
    CountedSet.prototype.add = function (item, val) {
        this.set[item] = val !== null ? val : true;
    };
    /**
     * @param {!K} key
     * @return {boolean}
     */
    CountedSet.prototype.contains = function (key) {
        return util_1.contains(this.set, key);
    };
    /**
     * @param {!K} item
     * @return {V}
     */
    CountedSet.prototype.get = function (item) {
        return this.contains(item) ? this.set[item] : undefined;
    };
    /**
     * @param {!K} item
     */
    CountedSet.prototype.remove = function (item) {
        delete this.set[item];
    };
    /**
     * Deletes everything in the set
     */
    CountedSet.prototype.clear = function () {
        this.set = {};
    };
    /**
     * True if there's nothing in the set
     * @return {boolean}
     */
    CountedSet.prototype.isEmpty = function () {
        return util_1.isEmpty(this.set);
    };
    /**
     * @return {number} The number of items in the set
     */
    CountedSet.prototype.count = function () {
        return util_1.getCount(this.set);
    };
    /**
     * Run a function on each k,v pair in the set
     * @param {function(K, V)} fn
     */
    CountedSet.prototype.each = function (fn) {
        util_1.forEach(this.set, function (k, v) { return fn(k, v); });
    };
    /**
     * Mostly for debugging
     * @return {Array.<K>} The keys present in this CountedSet
     */
    CountedSet.prototype.keys = function () {
        var keys = [];
        util_1.forEach(this.set, function (k) {
            keys.push(k);
        });
        return keys;
    };
    return CountedSet;
}());
exports.CountedSet = CountedSet;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/CountedSet.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"@firebase/util":134,"_process":162,"buffer":160}],53:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
/**
 * Base class to be used if you want to emit events. Call the constructor with
 * the set of allowed event names.
 */
var EventEmitter = /** @class */ (function () {
    /**
     * @param {!Array.<string>} allowedEvents_
     */
    function EventEmitter(allowedEvents_) {
        this.allowedEvents_ = allowedEvents_;
        this.listeners_ = {};
        util_1.assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, 'Requires a non-empty array');
    }
    /**
     * To be called by derived classes to trigger events.
     * @param {!string} eventType
     * @param {...*} var_args
     */
    EventEmitter.prototype.trigger = function (eventType) {
        var var_args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            var_args[_i - 1] = arguments[_i];
        }
        if (Array.isArray(this.listeners_[eventType])) {
            // Clone the list, since callbacks could add/remove listeners.
            var listeners = this.listeners_[eventType].slice();
            for (var i = 0; i < listeners.length; i++) {
                listeners[i].callback.apply(listeners[i].context, var_args);
            }
        }
    };
    EventEmitter.prototype.on = function (eventType, callback, context) {
        this.validateEventType_(eventType);
        this.listeners_[eventType] = this.listeners_[eventType] || [];
        this.listeners_[eventType].push({ callback: callback, context: context });
        var eventData = this.getInitialEvent(eventType);
        if (eventData) {
            callback.apply(context, eventData);
        }
    };
    EventEmitter.prototype.off = function (eventType, callback, context) {
        this.validateEventType_(eventType);
        var listeners = this.listeners_[eventType] || [];
        for (var i = 0; i < listeners.length; i++) {
            if (listeners[i].callback === callback &&
                (!context || context === listeners[i].context)) {
                listeners.splice(i, 1);
                return;
            }
        }
    };
    EventEmitter.prototype.validateEventType_ = function (eventType) {
        util_1.assert(this.allowedEvents_.find(function (et) {
            return et === eventType;
        }), 'Unknown event: ' + eventType);
    };
    return EventEmitter;
}());
exports.EventEmitter = EventEmitter;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/EventEmitter.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"@firebase/util":134,"_process":162,"buffer":160}],54:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var SortedMap_1 = require("./SortedMap");
var Path_1 = require("./Path");
var util_1 = require("./util");
var util_2 = require("@firebase/util");
var emptyChildrenSingleton;
/**
 * Singleton empty children collection.
 *
 * @const
 * @type {!SortedMap.<string, !ImmutableTree.<?>>}
 */
var EmptyChildren = function () {
    if (!emptyChildrenSingleton) {
        emptyChildrenSingleton = new SortedMap_1.SortedMap(util_1.stringCompare);
    }
    return emptyChildrenSingleton;
};
/**
 * A tree with immutable elements.
 */
var ImmutableTree = /** @class */ (function () {
    /**
     * @template T
     * @param {?T} value
     * @param {SortedMap.<string, !ImmutableTree.<T>>=} children
     */
    function ImmutableTree(value, children) {
        if (children === void 0) { children = EmptyChildren(); }
        this.value = value;
        this.children = children;
    }
    /**
     * @template T
     * @param {!Object.<string, !T>} obj
     * @return {!ImmutableTree.<!T>}
     */
    ImmutableTree.fromObject = function (obj) {
        var tree = ImmutableTree.Empty;
        util_2.forEach(obj, function (childPath, childSnap) {
            tree = tree.set(new Path_1.Path(childPath), childSnap);
        });
        return tree;
    };
    /**
     * True if the value is empty and there are no children
     * @return {boolean}
     */
    ImmutableTree.prototype.isEmpty = function () {
        return this.value === null && this.children.isEmpty();
    };
    /**
     * Given a path and predicate, return the first node and the path to that node
     * where the predicate returns true.
     *
     * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects
     * on the way back out, it may be better to pass down a pathSoFar obj.
     *
     * @param {!Path} relativePath The remainder of the path
     * @param {function(T):boolean} predicate The predicate to satisfy to return a
     *   node
     * @return {?{path:!Path, value:!T}}
     */
    ImmutableTree.prototype.findRootMostMatchingPathAndValue = function (relativePath, predicate) {
        if (this.value != null && predicate(this.value)) {
            return { path: Path_1.Path.Empty, value: this.value };
        }
        else {
            if (relativePath.isEmpty()) {
                return null;
            }
            else {
                var front = relativePath.getFront();
                var child = this.children.get(front);
                if (child !== null) {
                    var childExistingPathAndValue = child.findRootMostMatchingPathAndValue(relativePath.popFront(), predicate);
                    if (childExistingPathAndValue != null) {
                        var fullPath = new Path_1.Path(front).child(childExistingPathAndValue.path);
                        return { path: fullPath, value: childExistingPathAndValue.value };
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
        }
    };
    /**
     * Find, if it exists, the shortest subpath of the given path that points a defined
     * value in the tree
     * @param {!Path} relativePath
     * @return {?{path: !Path, value: !T}}
     */
    ImmutableTree.prototype.findRootMostValueAndPath = function (relativePath) {
        return this.findRootMostMatchingPathAndValue(relativePath, function () { return true; });
    };
    /**
     * @param {!Path} relativePath
     * @return {!ImmutableTree.<T>} The subtree at the given path
     */
    ImmutableTree.prototype.subtree = function (relativePath) {
        if (relativePath.isEmpty()) {
            return this;
        }
        else {
            var front = relativePath.getFront();
            var childTree = this.children.get(front);
            if (childTree !== null) {
                return childTree.subtree(relativePath.popFront());
            }
            else {
                return ImmutableTree.Empty;
            }
        }
    };
    /**
     * Sets a value at the specified path.
     *
     * @param {!Path} relativePath Path to set value at.
     * @param {?T} toSet Value to set.
     * @return {!ImmutableTree.<T>} Resulting tree.
     */
    ImmutableTree.prototype.set = function (relativePath, toSet) {
        if (relativePath.isEmpty()) {
            return new ImmutableTree(toSet, this.children);
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front) || ImmutableTree.Empty;
            var newChild = child.set(relativePath.popFront(), toSet);
            var newChildren = this.children.insert(front, newChild);
            return new ImmutableTree(this.value, newChildren);
        }
    };
    /**
     * Removes the value at the specified path.
     *
     * @param {!Path} relativePath Path to value to remove.
     * @return {!ImmutableTree.<T>} Resulting tree.
     */
    ImmutableTree.prototype.remove = function (relativePath) {
        if (relativePath.isEmpty()) {
            if (this.children.isEmpty()) {
                return ImmutableTree.Empty;
            }
            else {
                return new ImmutableTree(null, this.children);
            }
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front);
            if (child) {
                var newChild = child.remove(relativePath.popFront());
                var newChildren = void 0;
                if (newChild.isEmpty()) {
                    newChildren = this.children.remove(front);
                }
                else {
                    newChildren = this.children.insert(front, newChild);
                }
                if (this.value === null && newChildren.isEmpty()) {
                    return ImmutableTree.Empty;
                }
                else {
                    return new ImmutableTree(this.value, newChildren);
                }
            }
            else {
                return this;
            }
        }
    };
    /**
     * Gets a value from the tree.
     *
     * @param {!Path} relativePath Path to get value for.
     * @return {?T} Value at path, or null.
     */
    ImmutableTree.prototype.get = function (relativePath) {
        if (relativePath.isEmpty()) {
            return this.value;
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front);
            if (child) {
                return child.get(relativePath.popFront());
            }
            else {
                return null;
            }
        }
    };
    /**
     * Replace the subtree at the specified path with the given new tree.
     *
     * @param {!Path} relativePath Path to replace subtree for.
     * @param {!ImmutableTree} newTree New tree.
     * @return {!ImmutableTree} Resulting tree.
     */
    ImmutableTree.prototype.setTree = function (relativePath, newTree) {
        if (relativePath.isEmpty()) {
            return newTree;
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front) || ImmutableTree.Empty;
            var newChild = child.setTree(relativePath.popFront(), newTree);
            var newChildren = void 0;
            if (newChild.isEmpty()) {
                newChildren = this.children.remove(front);
            }
            else {
                newChildren = this.children.insert(front, newChild);
            }
            return new ImmutableTree(this.value, newChildren);
        }
    };
    /**
     * Performs a depth first fold on this tree. Transforms a tree into a single
     * value, given a function that operates on the path to a node, an optional
     * current value, and a map of child names to folded subtrees
     * @template V
     * @param {function(Path, ?T, Object.<string, V>):V} fn
     * @return {V}
     */
    ImmutableTree.prototype.fold = function (fn) {
        return this.fold_(Path_1.Path.Empty, fn);
    };
    /**
     * Recursive helper for public-facing fold() method
     * @template V
     * @param {!Path} pathSoFar
     * @param {function(Path, ?T, Object.<string, V>):V} fn
     * @return {V}
     * @private
     */
    ImmutableTree.prototype.fold_ = function (pathSoFar, fn) {
        var accum = {};
        this.children.inorderTraversal(function (childKey, childTree) {
            accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);
        });
        return fn(pathSoFar, this.value, accum);
    };
    /**
     * Find the first matching value on the given path. Return the result of applying f to it.
     * @template V
     * @param {!Path} path
     * @param {!function(!Path, !T):?V} f
     * @return {?V}
     */
    ImmutableTree.prototype.findOnPath = function (path, f) {
        return this.findOnPath_(path, Path_1.Path.Empty, f);
    };
    ImmutableTree.prototype.findOnPath_ = function (pathToFollow, pathSoFar, f) {
        var result = this.value ? f(pathSoFar, this.value) : false;
        if (result) {
            return result;
        }
        else {
            if (pathToFollow.isEmpty()) {
                return null;
            }
            else {
                var front = pathToFollow.getFront();
                var nextChild = this.children.get(front);
                if (nextChild) {
                    return nextChild.findOnPath_(pathToFollow.popFront(), pathSoFar.child(front), f);
                }
                else {
                    return null;
                }
            }
        }
    };
    /**
     *
     * @param {!Path} path
     * @param {!function(!Path, !T)} f
     * @returns {!ImmutableTree.<T>}
     */
    ImmutableTree.prototype.foreachOnPath = function (path, f) {
        return this.foreachOnPath_(path, Path_1.Path.Empty, f);
    };
    ImmutableTree.prototype.foreachOnPath_ = function (pathToFollow, currentRelativePath, f) {
        if (pathToFollow.isEmpty()) {
            return this;
        }
        else {
            if (this.value) {
                f(currentRelativePath, this.value);
            }
            var front = pathToFollow.getFront();
            var nextChild = this.children.get(front);
            if (nextChild) {
                return nextChild.foreachOnPath_(pathToFollow.popFront(), currentRelativePath.child(front), f);
            }
            else {
                return ImmutableTree.Empty;
            }
        }
    };
    /**
     * Calls the given function for each node in the tree that has a value.
     *
     * @param {function(!Path, !T)} f A function to be called with
     *   the path from the root of the tree to a node, and the value at that node.
     *   Called in depth-first order.
     */
    ImmutableTree.prototype.foreach = function (f) {
        this.foreach_(Path_1.Path.Empty, f);
    };
    ImmutableTree.prototype.foreach_ = function (currentRelativePath, f) {
        this.children.inorderTraversal(function (childName, childTree) {
            childTree.foreach_(currentRelativePath.child(childName), f);
        });
        if (this.value) {
            f(currentRelativePath, this.value);
        }
    };
    /**
     *
     * @param {function(string, !T)} f
     */
    ImmutableTree.prototype.foreachChild = function (f) {
        this.children.inorderTraversal(function (childName, childTree) {
            if (childTree.value) {
                f(childName, childTree.value);
            }
        });
    };
    ImmutableTree.Empty = new ImmutableTree(null);
    return ImmutableTree;
}());
exports.ImmutableTree = ImmutableTree;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/ImmutableTree.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"./Path":57,"./SortedMap":59,"./util":63,"@firebase/util":134,"_process":162,"buffer":160}],55:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
/**
 * Fancy ID generator that creates 20-character string identifiers with the
 * following properties:
 *
 * 1. They're based on timestamp so that they sort *after* any existing ids.
 * 2. They contain 72-bits of random data after the timestamp so that IDs won't
 *    collide with other clients' IDs.
 * 3. They sort *lexicographically* (so the timestamp is converted to characters
 *    that will sort properly).
 * 4. They're monotonically increasing. Even if you generate more than one in
 *    the same timestamp, the latter ones will sort after the former ones. We do
 *    this by using the previous random bits but "incrementing" them by 1 (only
 *    in the case of a timestamp collision).
 */
exports.nextPushId = (function () {
    // Modeled after base64 web-safe chars, but ordered by ASCII.
    var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';
    // Timestamp of last push, used to prevent local collisions if you push twice
    // in one ms.
    var lastPushTime = 0;
    // We generate 72-bits of randomness which get turned into 12 characters and
    // appended to the timestamp to prevent collisions with other clients. We
    // store the last characters we generated because in the event of a collision,
    // we'll use those same characters except "incremented" by one.
    var lastRandChars = [];
    return function (now) {
        var duplicateTime = now === lastPushTime;
        lastPushTime = now;
        var i;
        var timeStampChars = new Array(8);
        for (i = 7; i >= 0; i--) {
            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
            // NOTE: Can't use << here because javascript will convert to int and lose
            // the upper bits.
            now = Math.floor(now / 64);
        }
        util_1.assert(now === 0, 'Cannot push at time == 0');
        var id = timeStampChars.join('');
        if (!duplicateTime) {
            for (i = 0; i < 12; i++) {
                lastRandChars[i] = Math.floor(Math.random() * 64);
            }
        }
        else {
            // If the timestamp hasn't changed since last push, use the same random
            // number, except incremented by 1.
            for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
                lastRandChars[i] = 0;
            }
            lastRandChars[i]++;
        }
        for (i = 0; i < 12; i++) {
            id += PUSH_CHARS.charAt(lastRandChars[i]);
        }
        util_1.assert(id.length === 20, 'nextPushId: Length should be 20.');
        return id;
    };
})();



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/NextPushId.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"@firebase/util":134,"_process":162,"buffer":160}],56:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var EventEmitter_1 = require("./EventEmitter");
var util_2 = require("@firebase/util");
/**
 * Monitors online state (as reported by window.online/offline events).
 *
 * The expectation is that this could have many false positives (thinks we are online
 * when we're not), but no false negatives.  So we can safely use it to determine when
 * we definitely cannot reach the internet.
 *
 * @extends {EventEmitter}
 */
var OnlineMonitor = /** @class */ (function (_super) {
    __extends(OnlineMonitor, _super);
    function OnlineMonitor() {
        var _this = _super.call(this, ['online']) || this;
        _this.online_ = true;
        // We've had repeated complaints that Cordova apps can get stuck "offline", e.g.
        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810
        // It would seem that the 'online' event does not always fire consistently. So we disable it
        // for Cordova.
        if (typeof window !== 'undefined' &&
            typeof window.addEventListener !== 'undefined' &&
            !util_2.isMobileCordova()) {
            window.addEventListener('online', function () {
                if (!_this.online_) {
                    _this.online_ = true;
                    _this.trigger('online', true);
                }
            }, false);
            window.addEventListener('offline', function () {
                if (_this.online_) {
                    _this.online_ = false;
                    _this.trigger('online', false);
                }
            }, false);
        }
        return _this;
    }
    OnlineMonitor.getInstance = function () {
        return new OnlineMonitor();
    };
    /**
     * @param {!string} eventType
     * @return {Array.<boolean>}
     */
    OnlineMonitor.prototype.getInitialEvent = function (eventType) {
        util_1.assert(eventType === 'online', 'Unknown event type: ' + eventType);
        return [this.online_];
    };
    /**
     * @return {boolean}
     */
    OnlineMonitor.prototype.currentlyOnline = function () {
        return this.online_;
    };
    return OnlineMonitor;
}(EventEmitter_1.EventEmitter));
exports.OnlineMonitor = OnlineMonitor;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/OnlineMonitor.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"./EventEmitter":53,"@firebase/util":134,"_process":162,"buffer":160}],57:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var util_2 = require("@firebase/util");
/**
 * An immutable object representing a parsed path.  It's immutable so that you
 * can pass them around to other functions without worrying about them changing
 * it.
 */
var Path = /** @class */ (function () {
    /**
     * @param {string|Array.<string>} pathOrString Path string to parse,
     *      or another path, or the raw tokens array
     * @param {number=} pieceNum
     */
    function Path(pathOrString, pieceNum) {
        if (pieceNum === void 0) {
            this.pieces_ = pathOrString.split('/');
            // Remove empty pieces.
            var copyTo = 0;
            for (var i = 0; i < this.pieces_.length; i++) {
                if (this.pieces_[i].length > 0) {
                    this.pieces_[copyTo] = this.pieces_[i];
                    copyTo++;
                }
            }
            this.pieces_.length = copyTo;
            this.pieceNum_ = 0;
        }
        else {
            this.pieces_ = pathOrString;
            this.pieceNum_ = pieceNum;
        }
    }
    Object.defineProperty(Path, "Empty", {
        /**
         * Singleton to represent an empty path
         *
         * @const
         */
        get: function () {
            return new Path('');
        },
        enumerable: true,
        configurable: true
    });
    Path.prototype.getFront = function () {
        if (this.pieceNum_ >= this.pieces_.length)
            return null;
        return this.pieces_[this.pieceNum_];
    };
    /**
     * @return {number} The number of segments in this path
     */
    Path.prototype.getLength = function () {
        return this.pieces_.length - this.pieceNum_;
    };
    /**
     * @return {!Path}
     */
    Path.prototype.popFront = function () {
        var pieceNum = this.pieceNum_;
        if (pieceNum < this.pieces_.length) {
            pieceNum++;
        }
        return new Path(this.pieces_, pieceNum);
    };
    /**
     * @return {?string}
     */
    Path.prototype.getBack = function () {
        if (this.pieceNum_ < this.pieces_.length)
            return this.pieces_[this.pieces_.length - 1];
        return null;
    };
    Path.prototype.toString = function () {
        var pathString = '';
        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {
            if (this.pieces_[i] !== '')
                pathString += '/' + this.pieces_[i];
        }
        return pathString || '/';
    };
    Path.prototype.toUrlEncodedString = function () {
        var pathString = '';
        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {
            if (this.pieces_[i] !== '')
                pathString += '/' + encodeURIComponent(String(this.pieces_[i]));
        }
        return pathString || '/';
    };
    /**
     * Shallow copy of the parts of the path.
     *
     * @param {number=} begin
     * @return {!Array<string>}
     */
    Path.prototype.slice = function (begin) {
        if (begin === void 0) { begin = 0; }
        return this.pieces_.slice(this.pieceNum_ + begin);
    };
    /**
     * @return {?Path}
     */
    Path.prototype.parent = function () {
        if (this.pieceNum_ >= this.pieces_.length)
            return null;
        var pieces = [];
        for (var i = this.pieceNum_; i < this.pieces_.length - 1; i++)
            pieces.push(this.pieces_[i]);
        return new Path(pieces, 0);
    };
    /**
     * @param {string|!Path} childPathObj
     * @return {!Path}
     */
    Path.prototype.child = function (childPathObj) {
        var pieces = [];
        for (var i = this.pieceNum_; i < this.pieces_.length; i++)
            pieces.push(this.pieces_[i]);
        if (childPathObj instanceof Path) {
            for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {
                pieces.push(childPathObj.pieces_[i]);
            }
        }
        else {
            var childPieces = childPathObj.split('/');
            for (var i = 0; i < childPieces.length; i++) {
                if (childPieces[i].length > 0)
                    pieces.push(childPieces[i]);
            }
        }
        return new Path(pieces, 0);
    };
    /**
     * @return {boolean} True if there are no segments in this path
     */
    Path.prototype.isEmpty = function () {
        return this.pieceNum_ >= this.pieces_.length;
    };
    /**
     * @param {!Path} outerPath
     * @param {!Path} innerPath
     * @return {!Path} The path from outerPath to innerPath
     */
    Path.relativePath = function (outerPath, innerPath) {
        var outer = outerPath.getFront(), inner = innerPath.getFront();
        if (outer === null) {
            return innerPath;
        }
        else if (outer === inner) {
            return Path.relativePath(outerPath.popFront(), innerPath.popFront());
        }
        else {
            throw new Error('INTERNAL ERROR: innerPath (' +
                innerPath +
                ') is not within ' +
                'outerPath (' +
                outerPath +
                ')');
        }
    };
    /**
     * @param {!Path} left
     * @param {!Path} right
     * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.
     */
    Path.comparePaths = function (left, right) {
        var leftKeys = left.slice();
        var rightKeys = right.slice();
        for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {
            var cmp = util_1.nameCompare(leftKeys[i], rightKeys[i]);
            if (cmp !== 0)
                return cmp;
        }
        if (leftKeys.length === rightKeys.length)
            return 0;
        return leftKeys.length < rightKeys.length ? -1 : 1;
    };
    /**
     *
     * @param {Path} other
     * @return {boolean} true if paths are the same.
     */
    Path.prototype.equals = function (other) {
        if (this.getLength() !== other.getLength()) {
            return false;
        }
        for (var i = this.pieceNum_, j = other.pieceNum_; i <= this.pieces_.length; i++, j++) {
            if (this.pieces_[i] !== other.pieces_[j]) {
                return false;
            }
        }
        return true;
    };
    /**
     *
     * @param {!Path} other
     * @return {boolean} True if this path is a parent (or the same as) other
     */
    Path.prototype.contains = function (other) {
        var i = this.pieceNum_;
        var j = other.pieceNum_;
        if (this.getLength() > other.getLength()) {
            return false;
        }
        while (i < this.pieces_.length) {
            if (this.pieces_[i] !== other.pieces_[j]) {
                return false;
            }
            ++i;
            ++j;
        }
        return true;
    };
    return Path;
}()); // end Path
exports.Path = Path;
/**
 * Dynamic (mutable) path used to count path lengths.
 *
 * This class is used to efficiently check paths for valid
 * length (in UTF8 bytes) and depth (used in path validation).
 *
 * Throws Error exception if path is ever invalid.
 *
 * The definition of a path always begins with '/'.
 */
var ValidationPath = /** @class */ (function () {
    /**
     * @param {!Path} path Initial Path.
     * @param {string} errorPrefix_ Prefix for any error messages.
     */
    function ValidationPath(path, errorPrefix_) {
        this.errorPrefix_ = errorPrefix_;
        /** @type {!Array<string>} */
        this.parts_ = path.slice();
        /** @type {number} Initialize to number of '/' chars needed in path. */
        this.byteLength_ = Math.max(1, this.parts_.length);
        for (var i = 0; i < this.parts_.length; i++) {
            this.byteLength_ += util_2.stringLength(this.parts_[i]);
        }
        this.checkValid_();
    }
    Object.defineProperty(ValidationPath, "MAX_PATH_DEPTH", {
        /** @const {number} Maximum key depth. */
        get: function () {
            return 32;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValidationPath, "MAX_PATH_LENGTH_BYTES", {
        /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */
        get: function () {
            return 768;
        },
        enumerable: true,
        configurable: true
    });
    /** @param {string} child */
    ValidationPath.prototype.push = function (child) {
        // Count the needed '/'
        if (this.parts_.length > 0) {
            this.byteLength_ += 1;
        }
        this.parts_.push(child);
        this.byteLength_ += util_2.stringLength(child);
        this.checkValid_();
    };
    ValidationPath.prototype.pop = function () {
        var last = this.parts_.pop();
        this.byteLength_ -= util_2.stringLength(last);
        // Un-count the previous '/'
        if (this.parts_.length > 0) {
            this.byteLength_ -= 1;
        }
    };
    ValidationPath.prototype.checkValid_ = function () {
        if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {
            throw new Error(this.errorPrefix_ +
                'has a key path longer than ' +
                ValidationPath.MAX_PATH_LENGTH_BYTES +
                ' bytes (' +
                this.byteLength_ +
                ').');
        }
        if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {
            throw new Error(this.errorPrefix_ +
                'path specified exceeds the maximum depth that can be written (' +
                ValidationPath.MAX_PATH_DEPTH +
                ') or object contains a cycle ' +
                this.toErrorString());
        }
    };
    /**
     * String for use in error messages - uses '.' notation for path.
     *
     * @return {string}
     */
    ValidationPath.prototype.toErrorString = function () {
        if (this.parts_.length == 0) {
            return '';
        }
        return "in property '" + this.parts_.join('.') + "'";
    };
    return ValidationPath;
}());
exports.ValidationPath = ValidationPath;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/Path.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"./util":63,"@firebase/util":134,"_process":162,"buffer":160}],58:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var Path_1 = require("./Path");
var SparseSnapshotTree_1 = require("../SparseSnapshotTree");
var LeafNode_1 = require("../snap/LeafNode");
var nodeFromJSON_1 = require("../snap/nodeFromJSON");
var PriorityIndex_1 = require("../snap/indexes/PriorityIndex");
/**
 * Generate placeholders for deferred values.
 * @param {?Object} values
 * @return {!Object}
 */
exports.generateWithValues = function (values) {
    values = values || {};
    values['timestamp'] = values['timestamp'] || new Date().getTime();
    return values;
};
/**
 * Value to use when firing local events. When writing server values, fire
 * local events with an approximate value, otherwise return value as-is.
 * @param {(Object|string|number|boolean)} value
 * @param {!Object} serverValues
 * @return {!(string|number|boolean)}
 */
exports.resolveDeferredValue = function (value, serverValues) {
    if (!value || typeof value !== 'object') {
        return value;
    }
    else {
        util_1.assert('.sv' in value, 'Unexpected leaf node or priority contents');
        return serverValues[value['.sv']];
    }
};
/**
 * Recursively replace all deferred values and priorities in the tree with the
 * specified generated replacement values.
 * @param {!SparseSnapshotTree} tree
 * @param {!Object} serverValues
 * @return {!SparseSnapshotTree}
 */
exports.resolveDeferredValueTree = function (tree, serverValues) {
    var resolvedTree = new SparseSnapshotTree_1.SparseSnapshotTree();
    tree.forEachTree(new Path_1.Path(''), function (path, node) {
        resolvedTree.remember(path, exports.resolveDeferredValueSnapshot(node, serverValues));
    });
    return resolvedTree;
};
/**
 * Recursively replace all deferred values and priorities in the node with the
 * specified generated replacement values.  If there are no server values in the node,
 * it'll be returned as-is.
 * @param {!Node} node
 * @param {!Object} serverValues
 * @return {!Node}
 */
exports.resolveDeferredValueSnapshot = function (node, serverValues) {
    var rawPri = node.getPriority().val();
    var priority = exports.resolveDeferredValue(rawPri, serverValues);
    var newNode;
    if (node.isLeafNode()) {
        var leafNode = node;
        var value = exports.resolveDeferredValue(leafNode.getValue(), serverValues);
        if (value !== leafNode.getValue() ||
            priority !== leafNode.getPriority().val()) {
            return new LeafNode_1.LeafNode(value, nodeFromJSON_1.nodeFromJSON(priority));
        }
        else {
            return node;
        }
    }
    else {
        var childrenNode = node;
        newNode = childrenNode;
        if (priority !== childrenNode.getPriority().val()) {
            newNode = newNode.updatePriority(new LeafNode_1.LeafNode(priority));
        }
        childrenNode.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {
            var newChildNode = exports.resolveDeferredValueSnapshot(childNode, serverValues);
            if (newChildNode !== childNode) {
                newNode = newNode.updateImmediateChild(childName, newChildNode);
            }
        });
        return newNode;
    }
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/ServerValues.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"../SparseSnapshotTree":23,"../snap/LeafNode":34,"../snap/indexes/PriorityIndex":41,"../snap/nodeFromJSON":43,"./Path":57,"@firebase/util":134,"_process":162,"buffer":160}],59:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An iterator over an LLRBNode.
 */
var SortedMapIterator = /** @class */ (function () {
    /**
     * @template K, V, T
     * @param {LLRBNode|LLRBEmptyNode} node Node to iterate.
     * @param {?K} startKey
     * @param {function(K, K): number} comparator
     * @param {boolean} isReverse_ Whether or not to iterate in reverse
     * @param {(function(K, V):T)=} resultGenerator_
     */
    function SortedMapIterator(node, startKey, comparator, isReverse_, resultGenerator_) {
        if (resultGenerator_ === void 0) { resultGenerator_ = null; }
        this.isReverse_ = isReverse_;
        this.resultGenerator_ = resultGenerator_;
        /** @private
         * @type {Array.<!LLRBNode>}
         */
        this.nodeStack_ = [];
        var cmp = 1;
        while (!node.isEmpty()) {
            node = node;
            cmp = startKey ? comparator(node.key, startKey) : 1;
            // flip the comparison if we're going in reverse
            if (isReverse_)
                cmp *= -1;
            if (cmp < 0) {
                // This node is less than our start key. ignore it
                if (this.isReverse_) {
                    node = node.left;
                }
                else {
                    node = node.right;
                }
            }
            else if (cmp === 0) {
                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;
                this.nodeStack_.push(node);
                break;
            }
            else {
                // This node is greater than our start key, add it to the stack and move to the next one
                this.nodeStack_.push(node);
                if (this.isReverse_) {
                    node = node.right;
                }
                else {
                    node = node.left;
                }
            }
        }
    }
    SortedMapIterator.prototype.getNext = function () {
        if (this.nodeStack_.length === 0)
            return null;
        var node = this.nodeStack_.pop();
        var result;
        if (this.resultGenerator_)
            result = this.resultGenerator_(node.key, node.value);
        else
            result = { key: node.key, value: node.value };
        if (this.isReverse_) {
            node = node.left;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.right;
            }
        }
        else {
            node = node.right;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.left;
            }
        }
        return result;
    };
    SortedMapIterator.prototype.hasNext = function () {
        return this.nodeStack_.length > 0;
    };
    SortedMapIterator.prototype.peek = function () {
        if (this.nodeStack_.length === 0)
            return null;
        var node = this.nodeStack_[this.nodeStack_.length - 1];
        if (this.resultGenerator_) {
            return this.resultGenerator_(node.key, node.value);
        }
        else {
            return { key: node.key, value: node.value };
        }
    };
    return SortedMapIterator;
}());
exports.SortedMapIterator = SortedMapIterator;
/**
 * Represents a node in a Left-leaning Red-Black tree.
 */
var LLRBNode = /** @class */ (function () {
    /**
     * @template K, V
     * @param {!K} key Key associated with this node.
     * @param {!V} value Value associated with this node.
     * @param {?boolean} color Whether this node is red.
     * @param {?(LLRBNode|LLRBEmptyNode)=} left Left child.
     * @param {?(LLRBNode|LLRBEmptyNode)=} right Right child.
     */
    function LLRBNode(key, value, color, left, right) {
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left =
            left != null ? left : SortedMap.EMPTY_NODE;
        this.right =
            right != null ? right : SortedMap.EMPTY_NODE;
    }
    /**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param {?K} key New key for the node, or null.
     * @param {?V} value New value for the node, or null.
     * @param {?boolean} color New color for the node, or null.
     * @param {?LLRBNode|LLRBEmptyNode} left New left child for the node, or null.
     * @param {?LLRBNode|LLRBEmptyNode} right New right child for the node, or null.
     * @return {!LLRBNode} The node copy.
     */
    LLRBNode.prototype.copy = function (key, value, color, left, right) {
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    };
    /**
     * @return {number} The total number of nodes in the tree.
     */
    LLRBNode.prototype.count = function () {
        return this.left.count() + 1 + this.right.count();
    };
    /**
     * @return {boolean} True if the tree is empty.
     */
    LLRBNode.prototype.isEmpty = function () {
        return false;
    };
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V):*} action Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @return {*} The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    LLRBNode.prototype.inorderTraversal = function (action) {
        return (this.left.inorderTraversal(action) ||
            action(this.key, this.value) ||
            this.right.inorderTraversal(action));
    };
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param {function(!Object, !Object)} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {*} True if traversal was aborted.
     */
    LLRBNode.prototype.reverseTraversal = function (action) {
        return (this.right.reverseTraversal(action) ||
            action(this.key, this.value) ||
            this.left.reverseTraversal(action));
    };
    /**
     * @return {!Object} The minimum node in the tree.
     * @private
     */
    LLRBNode.prototype.min_ = function () {
        if (this.left.isEmpty()) {
            return this;
        }
        else {
            return this.left.min_();
        }
    };
    /**
     * @return {!K} The maximum key in the tree.
     */
    LLRBNode.prototype.minKey = function () {
        return this.min_().key;
    };
    /**
     * @return {!K} The maximum key in the tree.
     */
    LLRBNode.prototype.maxKey = function () {
        if (this.right.isEmpty()) {
            return this.key;
        }
        else {
            return this.right.maxKey();
        }
    };
    /**
     *
     * @param {!Object} key Key to insert.
     * @param {!Object} value Value to insert.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode} New tree, with the key/value added.
     */
    LLRBNode.prototype.insert = function (key, value, comparator) {
        var cmp, n;
        n = this;
        cmp = comparator(key, n.key);
        if (cmp < 0) {
            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        }
        else if (cmp === 0) {
            n = n.copy(null, value, null, null, null);
        }
        else {
            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        }
        return n.fixUp_();
    };
    /**
     * @private
     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the minimum key removed.
     */
    LLRBNode.prototype.removeMin_ = function () {
        if (this.left.isEmpty()) {
            return SortedMap.EMPTY_NODE;
        }
        var n = this;
        if (!n.left.isRed_() && !n.left.left.isRed_())
            n = n.moveRedLeft_();
        n = n.copy(null, null, null, n.left.removeMin_(), null);
        return n.fixUp_();
    };
    /**
     * @param {!Object} key The key of the item to remove.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the specified item removed.
     */
    LLRBNode.prototype.remove = function (key, comparator) {
        var n, smallest;
        n = this;
        if (comparator(key, n.key) < 0) {
            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {
                n = n.moveRedLeft_();
            }
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        }
        else {
            if (n.left.isRed_())
                n = n.rotateRight_();
            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {
                n = n.moveRedRight_();
            }
            if (comparator(key, n.key) === 0) {
                if (n.right.isEmpty()) {
                    return SortedMap.EMPTY_NODE;
                }
                else {
                    smallest = n.right.min_();
                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
                }
            }
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        }
        return n.fixUp_();
    };
    /**
     * @private
     * @return {boolean} Whether this is a RED node.
     */
    LLRBNode.prototype.isRed_ = function () {
        return this.color;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree after performing any needed rotations.
     */
    LLRBNode.prototype.fixUp_ = function () {
        var n = this;
        if (n.right.isRed_() && !n.left.isRed_())
            n = n.rotateLeft_();
        if (n.left.isRed_() && n.left.left.isRed_())
            n = n.rotateRight_();
        if (n.left.isRed_() && n.right.isRed_())
            n = n.colorFlip_();
        return n;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after moveRedLeft.
     */
    LLRBNode.prototype.moveRedLeft_ = function () {
        var n = this.colorFlip_();
        if (n.right.left.isRed_()) {
            n = n.copy(null, null, null, null, n.right.rotateRight_());
            n = n.rotateLeft_();
            n = n.colorFlip_();
        }
        return n;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after moveRedRight.
     */
    LLRBNode.prototype.moveRedRight_ = function () {
        var n = this.colorFlip_();
        if (n.left.left.isRed_()) {
            n = n.rotateRight_();
            n = n.colorFlip_();
        }
        return n;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after rotateLeft.
     */
    LLRBNode.prototype.rotateLeft_ = function () {
        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after rotateRight.
     */
    LLRBNode.prototype.rotateRight_ = function () {
        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after colorFlip.
     */
    LLRBNode.prototype.colorFlip_ = function () {
        var left = this.left.copy(null, null, !this.left.color, null, null);
        var right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
    };
    /**
     * For testing.
     *
     * @private
     * @return {boolean} True if all is well.
     */
    LLRBNode.prototype.checkMaxDepth_ = function () {
        var blackDepth = this.check_();
        return Math.pow(2.0, blackDepth) <= this.count() + 1;
    };
    /**
     * @private
     * @return {number} Not sure what this returns exactly. :-).
     */
    LLRBNode.prototype.check_ = function () {
        var blackDepth;
        if (this.isRed_() && this.left.isRed_()) {
            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');
        }
        if (this.right.isRed_()) {
            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');
        }
        blackDepth = this.left.check_();
        if (blackDepth !== this.right.check_()) {
            throw new Error('Black depths differ');
        }
        else {
            return blackDepth + (this.isRed_() ? 0 : 1);
        }
    };
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    return LLRBNode;
}());
exports.LLRBNode = LLRBNode;
/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */
var LLRBEmptyNode = /** @class */ (function () {
    function LLRBEmptyNode() {
    }
    /**
     * Returns a copy of the current node.
     *
     * @return {!LLRBEmptyNode} The node copy.
     */
    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {
        return this;
    };
    /**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param {!K} key Key to be added.
     * @param {!V} value Value to be added.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode} New tree, with item added.
     */
    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {
        return new LLRBNode(key, value, null);
    };
    /**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param {!K} key The key to remove.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBEmptyNode} New tree, with item removed.
     */
    LLRBEmptyNode.prototype.remove = function (key, comparator) {
        return this;
    };
    /**
     * @return {number} The total number of nodes in the tree.
     */
    LLRBEmptyNode.prototype.count = function () {
        return 0;
    };
    /**
     * @return {boolean} True if the tree is empty.
     */
    LLRBEmptyNode.prototype.isEmpty = function () {
        return true;
    };
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V):*} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {boolean} True if traversal was aborted.
     */
    LLRBEmptyNode.prototype.inorderTraversal = function (action) {
        return false;
    };
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V)} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {boolean} True if traversal was aborted.
     */
    LLRBEmptyNode.prototype.reverseTraversal = function (action) {
        return false;
    };
    /**
     * @return {null}
     */
    LLRBEmptyNode.prototype.minKey = function () {
        return null;
    };
    /**
     * @return {null}
     */
    LLRBEmptyNode.prototype.maxKey = function () {
        return null;
    };
    /**
     * @private
     * @return {number} Not sure what this returns exactly. :-).
     */
    LLRBEmptyNode.prototype.check_ = function () {
        return 0;
    };
    /**
     * @private
     * @return {boolean} Whether this node is red.
     */
    LLRBEmptyNode.prototype.isRed_ = function () {
        return false;
    };
    return LLRBEmptyNode;
}());
exports.LLRBEmptyNode = LLRBEmptyNode;
/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */
var SortedMap = /** @class */ (function () {
    /**
     * @template K, V
     * @param {function(K, K):number} comparator_ Key comparator.
     * @param {LLRBNode=} root_ (Optional) Root node for the map.
     */
    function SortedMap(comparator_, root_) {
        if (root_ === void 0) { root_ = SortedMap.EMPTY_NODE; }
        this.comparator_ = comparator_;
        this.root_ = root_;
    }
    /**
     * Returns a copy of the map, with the specified key/value added or replaced.
     * (TODO: We should perhaps rename this method to 'put')
     *
     * @param {!K} key Key to be added.
     * @param {!V} value Value to be added.
     * @return {!SortedMap.<K, V>} New map, with item added.
     */
    SortedMap.prototype.insert = function (key, value) {
        return new SortedMap(this.comparator_, this.root_
            .insert(key, value, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    };
    /**
     * Returns a copy of the map, with the specified key removed.
     *
     * @param {!K} key The key to remove.
     * @return {!SortedMap.<K, V>} New map, with item removed.
     */
    SortedMap.prototype.remove = function (key) {
        return new SortedMap(this.comparator_, this.root_
            .remove(key, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    };
    /**
     * Returns the value of the node with the given key, or null.
     *
     * @param {!K} key The key to look up.
     * @return {?V} The value of the node with the given key, or null if the
     * key doesn't exist.
     */
    SortedMap.prototype.get = function (key) {
        var cmp;
        var node = this.root_;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                return node.value;
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                node = node.right;
            }
        }
        return null;
    };
    /**
     * Returns the key of the item *before* the specified key, or null if key is the first item.
     * @param {K} key The key to find the predecessor of
     * @return {?K} The predecessor key.
     */
    SortedMap.prototype.getPredecessorKey = function (key) {
        var cmp, node = this.root_, rightParent = null;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                if (!node.left.isEmpty()) {
                    node = node.left;
                    while (!node.right.isEmpty())
                        node = node.right;
                    return node.key;
                }
                else if (rightParent) {
                    return rightParent.key;
                }
                else {
                    return null; // first item.
                }
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                rightParent = node;
                node = node.right;
            }
        }
        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');
    };
    /**
     * @return {boolean} True if the map is empty.
     */
    SortedMap.prototype.isEmpty = function () {
        return this.root_.isEmpty();
    };
    /**
     * @return {number} The total number of nodes in the map.
     */
    SortedMap.prototype.count = function () {
        return this.root_.count();
    };
    /**
     * @return {?K} The minimum key in the map.
     */
    SortedMap.prototype.minKey = function () {
        return this.root_.minKey();
    };
    /**
     * @return {?K} The maximum key in the map.
     */
    SortedMap.prototype.maxKey = function () {
        return this.root_.maxKey();
    };
    /**
     * Traverses the map in key order and calls the specified action function
     * for each key/value pair.
     *
     * @param {function(!K, !V):*} action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return {*} The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    SortedMap.prototype.inorderTraversal = function (action) {
        return this.root_.inorderTraversal(action);
    };
    /**
     * Traverses the map in reverse key order and calls the specified action function
     * for each key/value pair.
     *
     * @param {function(!Object, !Object)} action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return {*} True if the traversal was aborted.
     */
    SortedMap.prototype.reverseTraversal = function (action) {
        return this.root_.reverseTraversal(action);
    };
    /**
     * Returns an iterator over the SortedMap.
     * @template T
     * @param {(function(K, V):T)=} resultGenerator
     * @return {SortedMapIterator.<K, V, T>} The iterator.
     */
    SortedMap.prototype.getIterator = function (resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
    };
    SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
    };
    SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
    };
    SortedMap.prototype.getReverseIterator = function (resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
    };
    /**
     * Always use the same empty node, to reduce memory.
     * @const
     */
    SortedMap.EMPTY_NODE = new LLRBEmptyNode();
    return SortedMap;
}());
exports.SortedMap = SortedMap;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/SortedMap.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"_process":162,"buffer":160}],60:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var Path_1 = require("./Path");
var util_2 = require("@firebase/util");
/**
 * Node in a Tree.
 */
var TreeNode = /** @class */ (function () {
    function TreeNode() {
        // TODO: Consider making accessors that create children and value lazily or
        // separate Internal / Leaf 'types'.
        this.children = {};
        this.childCount = 0;
        this.value = null;
    }
    return TreeNode;
}());
exports.TreeNode = TreeNode;
/**
 * A light-weight tree, traversable by path.  Nodes can have both values and children.
 * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty
 * children.
 */
var Tree = /** @class */ (function () {
    /**
     * @template T
     * @param {string=} name_ Optional name of the node.
     * @param {Tree=} parent_ Optional parent node.
     * @param {TreeNode=} node_ Optional node to wrap.
     */
    function Tree(name_, parent_, node_) {
        if (name_ === void 0) { name_ = ''; }
        if (parent_ === void 0) { parent_ = null; }
        if (node_ === void 0) { node_ = new TreeNode(); }
        this.name_ = name_;
        this.parent_ = parent_;
        this.node_ = node_;
    }
    /**
     * Returns a sub-Tree for the given path.
     *
     * @param {!(string|Path)} pathObj Path to look up.
     * @return {!Tree.<T>} Tree for path.
     */
    Tree.prototype.subTree = function (pathObj) {
        // TODO: Require pathObj to be Path?
        var path = pathObj instanceof Path_1.Path ? pathObj : new Path_1.Path(pathObj);
        var child = this, next;
        while ((next = path.getFront()) !== null) {
            var childNode = util_2.safeGet(child.node_.children, next) || new TreeNode();
            child = new Tree(next, child, childNode);
            path = path.popFront();
        }
        return child;
    };
    /**
     * Returns the data associated with this tree node.
     *
     * @return {?T} The data or null if no data exists.
     */
    Tree.prototype.getValue = function () {
        return this.node_.value;
    };
    /**
     * Sets data to this tree node.
     *
     * @param {!T} value Value to set.
     */
    Tree.prototype.setValue = function (value) {
        util_1.assert(typeof value !== 'undefined', 'Cannot set value to undefined');
        this.node_.value = value;
        this.updateParents_();
    };
    /**
     * Clears the contents of the tree node (its value and all children).
     */
    Tree.prototype.clear = function () {
        this.node_.value = null;
        this.node_.children = {};
        this.node_.childCount = 0;
        this.updateParents_();
    };
    /**
     * @return {boolean} Whether the tree has any children.
     */
    Tree.prototype.hasChildren = function () {
        return this.node_.childCount > 0;
    };
    /**
     * @return {boolean} Whether the tree is empty (no value or children).
     */
    Tree.prototype.isEmpty = function () {
        return this.getValue() === null && !this.hasChildren();
    };
    /**
     * Calls action for each child of this tree node.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     */
    Tree.prototype.forEachChild = function (action) {
        var _this = this;
        util_2.forEach(this.node_.children, function (child, childTree) {
            action(new Tree(child, _this, childTree));
        });
    };
    /**
     * Does a depth-first traversal of this node's descendants, calling action for each one.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to
     *   false.
     * @param {boolean=} childrenFirst Whether to call action on children before calling it on
     *   parent.
     */
    Tree.prototype.forEachDescendant = function (action, includeSelf, childrenFirst) {
        if (includeSelf && !childrenFirst)
            action(this);
        this.forEachChild(function (child) {
            child.forEachDescendant(action, /*includeSelf=*/ true, childrenFirst);
        });
        if (includeSelf && childrenFirst)
            action(this);
    };
    /**
     * Calls action on each ancestor node.
     *
     * @param {function(!Tree.<T>)} action Action to be called on each parent; return
     *   true to abort.
     * @param {boolean=} includeSelf Whether to call action on this node as well.
     * @return {boolean} true if the action callback returned true.
     */
    Tree.prototype.forEachAncestor = function (action, includeSelf) {
        var node = includeSelf ? this : this.parent();
        while (node !== null) {
            if (action(node)) {
                return true;
            }
            node = node.parent();
        }
        return false;
    };
    /**
     * Does a depth-first traversal of this node's descendants.  When a descendant with a value
     * is found, action is called on it and traversal does not continue inside the node.
     * Action is *not* called on this node.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     */
    Tree.prototype.forEachImmediateDescendantWithValue = function (action) {
        this.forEachChild(function (child) {
            if (child.getValue() !== null)
                action(child);
            else
                child.forEachImmediateDescendantWithValue(action);
        });
    };
    /**
     * @return {!Path} The path of this tree node, as a Path.
     */
    Tree.prototype.path = function () {
        return new Path_1.Path(this.parent_ === null
            ? this.name_
            : this.parent_.path() + '/' + this.name_);
    };
    /**
     * @return {string} The name of the tree node.
     */
    Tree.prototype.name = function () {
        return this.name_;
    };
    /**
     * @return {?Tree} The parent tree node, or null if this is the root of the tree.
     */
    Tree.prototype.parent = function () {
        return this.parent_;
    };
    /**
     * Adds or removes this child from its parent based on whether it's empty or not.
     *
     * @private
     */
    Tree.prototype.updateParents_ = function () {
        if (this.parent_ !== null)
            this.parent_.updateChild_(this.name_, this);
    };
    /**
     * Adds or removes the passed child to this tree node, depending on whether it's empty.
     *
     * @param {string} childName The name of the child to update.
     * @param {!Tree.<T>} child The child to update.
     * @private
     */
    Tree.prototype.updateChild_ = function (childName, child) {
        var childEmpty = child.isEmpty();
        var childExists = util_2.contains(this.node_.children, childName);
        if (childEmpty && childExists) {
            delete this.node_.children[childName];
            this.node_.childCount--;
            this.updateParents_();
        }
        else if (!childEmpty && !childExists) {
            this.node_.children[childName] = child.node_;
            this.node_.childCount++;
            this.updateParents_();
        }
    };
    return Tree;
}());
exports.Tree = Tree;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/Tree.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"./Path":57,"@firebase/util":134,"_process":162,"buffer":160}],61:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EventEmitter_1 = require("./EventEmitter");
var util_1 = require("@firebase/util");
/**
 * @extends {EventEmitter}
 */
var VisibilityMonitor = /** @class */ (function (_super) {
    __extends(VisibilityMonitor, _super);
    function VisibilityMonitor() {
        var _this = _super.call(this, ['visible']) || this;
        var hidden;
        var visibilityChange;
        if (typeof document !== 'undefined' &&
            typeof document.addEventListener !== 'undefined') {
            if (typeof document['hidden'] !== 'undefined') {
                // Opera 12.10 and Firefox 18 and later support
                visibilityChange = 'visibilitychange';
                hidden = 'hidden';
            }
            else if (typeof document['mozHidden'] !== 'undefined') {
                visibilityChange = 'mozvisibilitychange';
                hidden = 'mozHidden';
            }
            else if (typeof document['msHidden'] !== 'undefined') {
                visibilityChange = 'msvisibilitychange';
                hidden = 'msHidden';
            }
            else if (typeof document['webkitHidden'] !== 'undefined') {
                visibilityChange = 'webkitvisibilitychange';
                hidden = 'webkitHidden';
            }
        }
        // Initially, we always assume we are visible. This ensures that in browsers
        // without page visibility support or in cases where we are never visible
        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay
        // reconnects
        _this.visible_ = true;
        if (visibilityChange) {
            document.addEventListener(visibilityChange, function () {
                var visible = !document[hidden];
                if (visible !== _this.visible_) {
                    _this.visible_ = visible;
                    _this.trigger('visible', visible);
                }
            }, false);
        }
        return _this;
    }
    VisibilityMonitor.getInstance = function () {
        return new VisibilityMonitor();
    };
    /**
     * @param {!string} eventType
     * @return {Array.<boolean>}
     */
    VisibilityMonitor.prototype.getInitialEvent = function (eventType) {
        util_1.assert(eventType === 'visible', 'Unknown event type: ' + eventType);
        return [this.visible_];
    };
    return VisibilityMonitor;
}(EventEmitter_1.EventEmitter));
exports.VisibilityMonitor = VisibilityMonitor;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/VisibilityMonitor.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"./EventEmitter":53,"@firebase/util":134,"_process":162,"buffer":160}],62:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Path_1 = require("../Path");
var RepoInfo_1 = require("../../RepoInfo");
var util_1 = require("../util");
/**
 * @param {!string} pathString
 * @return {string}
 */
function decodePath(pathString) {
    var pathStringDecoded = '';
    var pieces = pathString.split('/');
    for (var i = 0; i < pieces.length; i++) {
        if (pieces[i].length > 0) {
            var piece = pieces[i];
            try {
                piece = decodeURIComponent(piece.replace(/\+/g, ' '));
            }
            catch (e) { }
            pathStringDecoded += '/' + piece;
        }
    }
    return pathStringDecoded;
}
/**
 *
 * @param {!string} dataURL
 * @return {{repoInfo: !RepoInfo, path: !Path}}
 */
exports.parseRepoInfo = function (dataURL) {
    var parsedUrl = exports.parseURL(dataURL), namespace = parsedUrl.subdomain;
    if (parsedUrl.domain === 'firebase') {
        util_1.fatal(parsedUrl.host +
            ' is no longer supported. ' +
            'Please use <YOUR FIREBASE>.firebaseio.com instead');
    }
    // Catch common error of uninitialized namespace value.
    if (!namespace || namespace == 'undefined') {
        util_1.fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');
    }
    if (!parsedUrl.secure) {
        util_1.warnIfPageIsSecure();
    }
    var webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';
    return {
        repoInfo: new RepoInfo_1.RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly),
        path: new Path_1.Path(parsedUrl.pathString)
    };
};
/**
 *
 * @param {!string} dataURL
 * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string}}
 */
exports.parseURL = function (dataURL) {
    // Default to empty strings in the event of a malformed string.
    var host = '', domain = '', subdomain = '', pathString = '';
    // Always default to SSL, unless otherwise specified.
    var secure = true, scheme = 'https', port = 443;
    // Don't do any validation here. The caller is responsible for validating the result of parsing.
    if (typeof dataURL === 'string') {
        // Parse scheme.
        var colonInd = dataURL.indexOf('//');
        if (colonInd >= 0) {
            scheme = dataURL.substring(0, colonInd - 1);
            dataURL = dataURL.substring(colonInd + 2);
        }
        // Parse host and path.
        var slashInd = dataURL.indexOf('/');
        if (slashInd === -1) {
            slashInd = dataURL.length;
        }
        host = dataURL.substring(0, slashInd);
        pathString = decodePath(dataURL.substring(slashInd));
        var parts = host.split('.');
        if (parts.length === 3) {
            // Normalize namespaces to lowercase to share storage / connection.
            domain = parts[1];
            subdomain = parts[0].toLowerCase();
        }
        else if (parts.length === 2) {
            domain = parts[0];
        }
        // If we have a port, use scheme for determining if it's secure.
        colonInd = host.indexOf(':');
        if (colonInd >= 0) {
            secure = scheme === 'https' || scheme === 'wss';
            port = parseInt(host.substring(colonInd + 1), 10);
        }
    }
    return {
        host: host,
        port: port,
        domain: domain,
        subdomain: subdomain,
        secure: secure,
        scheme: scheme,
        pathString: pathString
    };
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/libs/parser.js","/node_modules/@firebase/database/dist/cjs/src/core/util/libs")

},{"../../RepoInfo":18,"../Path":57,"../util":63,"_process":162,"buffer":160}],63:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
var util_3 = require("@firebase/util");
var util_4 = require("@firebase/util");
var util_5 = require("@firebase/util");
var util_6 = require("@firebase/util");
var storage_1 = require("../storage/storage");
var util_7 = require("@firebase/util");
/**
 * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).
 * @type {function(): number} Generated ID.
 */
exports.LUIDGenerator = (function () {
    var id = 1;
    return function () {
        return id++;
    };
})();
/**
 * Sha1 hash of the input string
 * @param {!string} str The string to hash
 * @return {!string} The resulting hash
 */
exports.sha1 = function (str) {
    var utf8Bytes = util_5.stringToByteArray(str);
    var sha1 = new util_4.Sha1();
    sha1.update(utf8Bytes);
    var sha1Bytes = sha1.digest();
    return util_3.base64.encodeByteArray(sha1Bytes);
};
/**
 * @param {...*} var_args
 * @return {string}
 * @private
 */
var buildLogMessage_ = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    var message = '';
    for (var i = 0; i < var_args.length; i++) {
        if (Array.isArray(var_args[i]) ||
            (var_args[i] &&
                typeof var_args[i] === 'object' &&
                typeof var_args[i].length === 'number')) {
            message += buildLogMessage_.apply(null, var_args[i]);
        }
        else if (typeof var_args[i] === 'object') {
            message += util_6.stringify(var_args[i]);
        }
        else {
            message += var_args[i];
        }
        message += ' ';
    }
    return message;
};
/**
 * Use this for all debug messages in Firebase.
 * @type {?function(string)}
 */
exports.logger = null;
/**
 * Flag to check for log availability on first log message
 * @type {boolean}
 * @private
 */
var firstLog_ = true;
/**
 * The implementation of Firebase.enableLogging (defined here to break dependencies)
 * @param {boolean|?function(string)} logger_ A flag to turn on logging, or a custom logger
 * @param {boolean=} persistent Whether or not to persist logging settings across refreshes
 */
exports.enableLogging = function (logger_, persistent) {
    util_1.assert(!persistent || (logger_ === true || logger_ === false), "Can't turn on custom loggers persistently.");
    if (logger_ === true) {
        if (typeof console !== 'undefined') {
            if (typeof console.log === 'function') {
                exports.logger = console.log.bind(console);
            }
            else if (typeof console.log === 'object') {
                // IE does this.
                exports.logger = function (message) {
                    console.log(message);
                };
            }
        }
        if (persistent)
            storage_1.SessionStorage.set('logging_enabled', true);
    }
    else if (typeof logger_ === 'function') {
        exports.logger = logger_;
    }
    else {
        exports.logger = null;
        storage_1.SessionStorage.remove('logging_enabled');
    }
};
/**
 *
 * @param {...(string|Arguments)} var_args
 */
exports.log = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    if (firstLog_ === true) {
        firstLog_ = false;
        if (exports.logger === null && storage_1.SessionStorage.get('logging_enabled') === true)
            exports.enableLogging(true);
    }
    if (exports.logger) {
        var message = buildLogMessage_.apply(null, var_args);
        exports.logger(message);
    }
};
/**
 * @param {!string} prefix
 * @return {function(...[*])}
 */
exports.logWrapper = function (prefix) {
    return function () {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            var_args[_i] = arguments[_i];
        }
        exports.log.apply(void 0, [prefix].concat(var_args));
    };
};
/**
 * @param {...string} var_args
 */
exports.error = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    if (typeof console !== 'undefined') {
        var message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_.apply(void 0, var_args);
        if (typeof console.error !== 'undefined') {
            console.error(message);
        }
        else {
            console.log(message);
        }
    }
};
/**
 * @param {...string} var_args
 */
exports.fatal = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    var message = buildLogMessage_.apply(void 0, var_args);
    throw new Error('FIREBASE FATAL ERROR: ' + message);
};
/**
 * @param {...*} var_args
 */
exports.warn = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    if (typeof console !== 'undefined') {
        var message = 'FIREBASE WARNING: ' + buildLogMessage_.apply(void 0, var_args);
        if (typeof console.warn !== 'undefined') {
            console.warn(message);
        }
        else {
            console.log(message);
        }
    }
};
/**
 * Logs a warning if the containing page uses https. Called when a call to new Firebase
 * does not use https.
 */
exports.warnIfPageIsSecure = function () {
    // Be very careful accessing browser globals. Who knows what may or may not exist.
    if (typeof window !== 'undefined' &&
        window.location &&
        window.location.protocol &&
        window.location.protocol.indexOf('https:') !== -1) {
        exports.warn('Insecure Firebase access from a secure page. ' +
            'Please use https in calls to new Firebase().');
    }
};
/**
 * @param {!String} methodName
 */
exports.warnAboutUnsupportedMethod = function (methodName) {
    exports.warn(methodName +
        ' is unsupported and will likely change soon.  ' +
        'Please do not use.');
};
/**
 * Returns true if data is NaN, or +/- Infinity.
 * @param {*} data
 * @return {boolean}
 */
exports.isInvalidJSONNumber = function (data) {
    return (typeof data === 'number' &&
        (data != data || // NaN
            data == Number.POSITIVE_INFINITY ||
            data == Number.NEGATIVE_INFINITY));
};
/**
 * @param {function()} fn
 */
exports.executeWhenDOMReady = function (fn) {
    if (util_7.isNodeSdk() || document.readyState === 'complete') {
        fn();
    }
    else {
        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which
        // fire before onload), but fall back to onload.
        var called_1 = false;
        var wrappedFn_1 = function () {
            if (!document.body) {
                setTimeout(wrappedFn_1, Math.floor(10));
                return;
            }
            if (!called_1) {
                called_1 = true;
                fn();
            }
        };
        if (document.addEventListener) {
            document.addEventListener('DOMContentLoaded', wrappedFn_1, false);
            // fallback to onload.
            window.addEventListener('load', wrappedFn_1, false);
        }
        else if (document.attachEvent) {
            // IE.
            document.attachEvent('onreadystatechange', function () {
                if (document.readyState === 'complete')
                    wrappedFn_1();
            });
            // fallback to onload.
            window.attachEvent('onload', wrappedFn_1);
            // jQuery has an extra hack for IE that we could employ (based on
            // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.
            // I'm hoping we don't need it.
        }
    }
};
/**
 * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names
 * @type {!string}
 */
exports.MIN_NAME = '[MIN_NAME]';
/**
 * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names
 * @type {!string}
 */
exports.MAX_NAME = '[MAX_NAME]';
/**
 * Compares valid Firebase key names, plus min and max name
 * @param {!string} a
 * @param {!string} b
 * @return {!number}
 */
exports.nameCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a === exports.MIN_NAME || b === exports.MAX_NAME) {
        return -1;
    }
    else if (b === exports.MIN_NAME || a === exports.MAX_NAME) {
        return 1;
    }
    else {
        var aAsInt = exports.tryParseInt(a), bAsInt = exports.tryParseInt(b);
        if (aAsInt !== null) {
            if (bAsInt !== null) {
                return aAsInt - bAsInt == 0 ? a.length - b.length : aAsInt - bAsInt;
            }
            else {
                return -1;
            }
        }
        else if (bAsInt !== null) {
            return 1;
        }
        else {
            return a < b ? -1 : 1;
        }
    }
};
/**
 * @param {!string} a
 * @param {!string} b
 * @return {!number} comparison result.
 */
exports.stringCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
};
/**
 * @param {string} key
 * @param {Object} obj
 * @return {*}
 */
exports.requireKey = function (key, obj) {
    if (obj && key in obj) {
        return obj[key];
    }
    else {
        throw new Error('Missing required key (' + key + ') in object: ' + util_6.stringify(obj));
    }
};
/**
 * @param {*} obj
 * @return {string}
 */
exports.ObjectToUniqueKey = function (obj) {
    if (typeof obj !== 'object' || obj === null)
        return util_6.stringify(obj);
    var keys = [];
    for (var k in obj) {
        keys.push(k);
    }
    // Export as json, but with the keys sorted.
    keys.sort();
    var key = '{';
    for (var i = 0; i < keys.length; i++) {
        if (i !== 0)
            key += ',';
        key += util_6.stringify(keys[i]);
        key += ':';
        key += exports.ObjectToUniqueKey(obj[keys[i]]);
    }
    key += '}';
    return key;
};
/**
 * Splits a string into a number of smaller segments of maximum size
 * @param {!string} str The string
 * @param {!number} segsize The maximum number of chars in the string.
 * @return {Array.<string>} The string, split into appropriately-sized chunks
 */
exports.splitStringBySize = function (str, segsize) {
    var len = str.length;
    if (len <= segsize) {
        return [str];
    }
    var dataSegs = [];
    for (var c = 0; c < len; c += segsize) {
        if (c + segsize > len) {
            dataSegs.push(str.substring(c, len));
        }
        else {
            dataSegs.push(str.substring(c, c + segsize));
        }
    }
    return dataSegs;
};
/**
 * Apply a function to each (key, value) pair in an object or
 * apply a function to each (index, value) pair in an array
 * @param {!(Object|Array)} obj The object or array to iterate over
 * @param {function(?, ?)} fn The function to apply
 */
exports.each = function (obj, fn) {
    if (Array.isArray(obj)) {
        for (var i = 0; i < obj.length; ++i) {
            fn(i, obj[i]);
        }
    }
    else {
        /**
         * in the conversion of code we removed the goog.object.forEach
         * function which did a value,key callback. We standardized on
         * a single impl that does a key, value callback. So we invert
         * to not have to touch the `each` code points
         */
        util_2.forEach(obj, function (key, val) { return fn(val, key); });
    }
};
/**
 * Like goog.bind, but doesn't bother to create a closure if opt_context is null/undefined.
 * @param {function(*)} callback Callback function.
 * @param {?Object=} context Optional context to bind to.
 * @return {function(*)}
 */
exports.bindCallback = function (callback, context) {
    return context ? callback.bind(context) : callback;
};
/**
 * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)
 * I made one modification at the end and removed the NaN / Infinity
 * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.
 * @param {!number} v A double
 * @return {string}
 */
exports.doubleToIEEE754String = function (v) {
    util_1.assert(!exports.isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL
    var ebits = 11, fbits = 52;
    var bias = (1 << (ebits - 1)) - 1, s, e, f, ln, i, bits, str;
    // Compute sign, exponent, fraction
    // Skip NaN / Infinity handling --MJL.
    if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
    }
    else {
        s = v < 0;
        v = Math.abs(v);
        if (v >= Math.pow(2, 1 - bias)) {
            // Normalized
            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
            e = ln + bias;
            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
        }
        else {
            // Denormalized
            e = 0;
            f = Math.round(v / Math.pow(2, 1 - bias - fbits));
        }
    }
    // Pack sign, exponent, fraction
    bits = [];
    for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
    }
    for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    str = bits.join('');
    // Return the data as a hex string. --MJL
    var hexByteString = '';
    for (i = 0; i < 64; i += 8) {
        var hexByte = parseInt(str.substr(i, 8), 2).toString(16);
        if (hexByte.length === 1)
            hexByte = '0' + hexByte;
        hexByteString = hexByteString + hexByte;
    }
    return hexByteString.toLowerCase();
};
/**
 * Used to detect if we're in a Chrome content script (which executes in an
 * isolated environment where long-polling doesn't work).
 * @return {boolean}
 */
exports.isChromeExtensionContentScript = function () {
    return !!(typeof window === 'object' &&
        window['chrome'] &&
        window['chrome']['extension'] &&
        !/^chrome/.test(window.location.href));
};
/**
 * Used to detect if we're in a Windows 8 Store app.
 * @return {boolean}
 */
exports.isWindowsStoreApp = function () {
    // Check for the presence of a couple WinRT globals
    return typeof Windows === 'object' && typeof Windows.UI === 'object';
};
/**
 * Converts a server error code to a Javascript Error
 * @param {!string} code
 * @param {!Query} query
 * @return {Error}
 */
exports.errorForServerCode = function (code, query) {
    var reason = 'Unknown Error';
    if (code === 'too_big') {
        reason =
            'The data requested exceeds the maximum size ' +
                'that can be accessed with a single request.';
    }
    else if (code == 'permission_denied') {
        reason = "Client doesn't have permission to access the desired data.";
    }
    else if (code == 'unavailable') {
        reason = 'The service is unavailable';
    }
    var error = new Error(code + ' at ' + query.path.toString() + ': ' + reason);
    error.code = code.toUpperCase();
    return error;
};
/**
 * Used to test for integer-looking strings
 * @type {RegExp}
 * @private
 */
exports.INTEGER_REGEXP_ = new RegExp('^-?\\d{1,10}$');
/**
 * If the string contains a 32-bit integer, return it.  Else return null.
 * @param {!string} str
 * @return {?number}
 */
exports.tryParseInt = function (str) {
    if (exports.INTEGER_REGEXP_.test(str)) {
        var intVal = Number(str);
        if (intVal >= -2147483648 && intVal <= 2147483647) {
            return intVal;
        }
    }
    return null;
};
/**
 * Helper to run some code but catch any exceptions and re-throw them later.
 * Useful for preventing user callbacks from breaking internal code.
 *
 * Re-throwing the exception from a setTimeout is a little evil, but it's very
 * convenient (we don't have to try to figure out when is a safe point to
 * re-throw it), and the behavior seems reasonable:
 *
 * * If you aren't pausing on exceptions, you get an error in the console with
 *   the correct stack trace.
 * * If you're pausing on all exceptions, the debugger will pause on your
 *   exception and then again when we rethrow it.
 * * If you're only pausing on uncaught exceptions, the debugger will only pause
 *   on us re-throwing it.
 *
 * @param {!function()} fn The code to guard.
 */
exports.exceptionGuard = function (fn) {
    try {
        fn();
    }
    catch (e) {
        // Re-throw exception when it's safe.
        setTimeout(function () {
            // It used to be that "throw e" would result in a good console error with
            // relevant context, but as of Chrome 39, you just get the firebase.js
            // file/line number where we re-throw it, which is useless. So we log
            // e.stack explicitly.
            var stack = e.stack || '';
            exports.warn('Exception was thrown by user callback.', stack);
            throw e;
        }, Math.floor(0));
    }
};
/**
 * Helper function to safely call opt_callback with the specified arguments.  It:
 * 1. Turns into a no-op if opt_callback is null or undefined.
 * 2. Wraps the call inside exceptionGuard to prevent exceptions from breaking our state.
 *
 * @param {?Function=} callback Optional onComplete callback.
 * @param {...*} var_args Arbitrary args to be passed to opt_onComplete
 */
exports.callUserCallback = function (callback) {
    var var_args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        var_args[_i - 1] = arguments[_i];
    }
    if (typeof callback === 'function') {
        exports.exceptionGuard(function () {
            callback.apply(void 0, var_args);
        });
    }
};
/**
 * @return {boolean} true if we think we're currently being crawled.
 */
exports.beingCrawled = function () {
    var userAgent = (typeof window === 'object' &&
        window['navigator'] &&
        window['navigator']['userAgent']) ||
        '';
    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we
    // believe to support JavaScript/AJAX rendering.
    // NOTE: Google Webmaster Tools doesn't really belong, but their "This is how a visitor to your website
    // would have seen the page" is flaky if we don't treat it as a crawler.
    return (userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0);
};
/**
 * Export a property of an object using a getter function.
 *
 * @param {!Object} object
 * @param {string} name
 * @param {!function(): *} fnGet
 */
exports.exportPropGetter = function (object, name, fnGet) {
    Object.defineProperty(object, name, { get: fnGet });
};
/**
 * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.
 *
 * It is removed with clearTimeout() as normal.
 *
 * @param {Function} fn Function to run.
 * @param {number} time Milliseconds to wait before running.
 * @return {number|Object} The setTimeout() return value.
 */
exports.setTimeoutNonBlocking = function (fn, time) {
    var timeout = setTimeout(fn, time);
    if (typeof timeout === 'object' && timeout['unref']) {
        timeout['unref']();
    }
    return timeout;
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/util.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"../storage/storage":51,"@firebase/util":134,"_process":162,"buffer":160}],64:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Path_1 = require("./Path");
var util_1 = require("@firebase/util");
var util_2 = require("./util");
var util_3 = require("@firebase/util");
var util_4 = require("@firebase/util");
/**
 * True for invalid Firebase keys
 * @type {RegExp}
 * @private
 */
exports.INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
/**
 * True for invalid Firebase paths.
 * Allows '/' in paths.
 * @type {RegExp}
 * @private
 */
exports.INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
/**
 * Maximum number of characters to allow in leaf value
 * @type {number}
 * @private
 */
exports.MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
/**
 * @param {*} key
 * @return {boolean}
 */
exports.isValidKey = function (key) {
    return (typeof key === 'string' && key.length !== 0 && !exports.INVALID_KEY_REGEX_.test(key));
};
/**
 * @param {string} pathString
 * @return {boolean}
 */
exports.isValidPathString = function (pathString) {
    return (typeof pathString === 'string' &&
        pathString.length !== 0 &&
        !exports.INVALID_PATH_REGEX_.test(pathString));
};
/**
 * @param {string} pathString
 * @return {boolean}
 */
exports.isValidRootPathString = function (pathString) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    return exports.isValidPathString(pathString);
};
/**
 * @param {*} priority
 * @return {boolean}
 */
exports.isValidPriority = function (priority) {
    return (priority === null ||
        typeof priority === 'string' ||
        (typeof priority === 'number' && !util_2.isInvalidJSONNumber(priority)) ||
        (priority && typeof priority === 'object' && util_1.contains(priority, '.sv')));
};
/**
 * Pre-validate a datum passed as an argument to Firebase function.
 *
 * @param {string} fnName
 * @param {number} argumentNumber
 * @param {*} data
 * @param {!Path} path
 * @param {boolean} optional
 */
exports.validateFirebaseDataArg = function (fnName, argumentNumber, data, path, optional) {
    if (optional && data === undefined)
        return;
    exports.validateFirebaseData(util_3.errorPrefix(fnName, argumentNumber, optional), data, path);
};
/**
 * Validate a data object client-side before sending to server.
 *
 * @param {string} errorPrefix
 * @param {*} data
 * @param {!Path|!ValidationPath} path_
 */
exports.validateFirebaseData = function (errorPrefix, data, path_) {
    var path = path_ instanceof Path_1.Path ? new Path_1.ValidationPath(path_, errorPrefix) : path_;
    if (data === undefined) {
        throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());
    }
    if (typeof data === 'function') {
        throw new Error(errorPrefix +
            'contains a function ' +
            path.toErrorString() +
            ' with contents = ' +
            data.toString());
    }
    if (util_2.isInvalidJSONNumber(data)) {
        throw new Error(errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString());
    }
    // Check max leaf size, but try to avoid the utf8 conversion if we can.
    if (typeof data === 'string' &&
        data.length > exports.MAX_LEAF_SIZE_ / 3 &&
        util_4.stringLength(data) > exports.MAX_LEAF_SIZE_) {
        throw new Error(errorPrefix +
            'contains a string greater than ' +
            exports.MAX_LEAF_SIZE_ +
            ' utf8 bytes ' +
            path.toErrorString() +
            " ('" +
            data.substring(0, 50) +
            "...')");
    }
    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON
    // to save extra walking of large objects.
    if (data && typeof data === 'object') {
        var hasDotValue_1 = false, hasActualChild_1 = false;
        util_1.forEach(data, function (key, value) {
            if (key === '.value') {
                hasDotValue_1 = true;
            }
            else if (key !== '.priority' && key !== '.sv') {
                hasActualChild_1 = true;
                if (!exports.isValidKey(key)) {
                    throw new Error(errorPrefix +
                        ' contains an invalid key (' +
                        key +
                        ') ' +
                        path.toErrorString() +
                        '.  Keys must be non-empty strings ' +
                        'and can\'t contain ".", "#", "$", "/", "[", or "]"');
                }
            }
            path.push(key);
            exports.validateFirebaseData(errorPrefix, value, path);
            path.pop();
        });
        if (hasDotValue_1 && hasActualChild_1) {
            throw new Error(errorPrefix +
                ' contains ".value" child ' +
                path.toErrorString() +
                ' in addition to actual children.');
        }
    }
};
/**
 * Pre-validate paths passed in the firebase function.
 *
 * @param {string} errorPrefix
 * @param {Array<!Path>} mergePaths
 */
exports.validateFirebaseMergePaths = function (errorPrefix, mergePaths) {
    var i, curPath;
    for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        var keys = curPath.slice();
        for (var j = 0; j < keys.length; j++) {
            if (keys[j] === '.priority' && j === keys.length - 1) {
                // .priority is OK
            }
            else if (!exports.isValidKey(keys[j])) {
                throw new Error(errorPrefix +
                    'contains an invalid key (' +
                    keys[j] +
                    ') in path ' +
                    curPath.toString() +
                    '. Keys must be non-empty strings ' +
                    'and can\'t contain ".", "#", "$", "/", "[", or "]"');
            }
        }
    }
    // Check that update keys are not descendants of each other.
    // We rely on the property that sorting guarantees that ancestors come
    // right before descendants.
    mergePaths.sort(Path_1.Path.comparePaths);
    var prevPath = null;
    for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        if (prevPath !== null && prevPath.contains(curPath)) {
            throw new Error(errorPrefix +
                'contains a path ' +
                prevPath.toString() +
                ' that is ancestor of another path ' +
                curPath.toString());
        }
        prevPath = curPath;
    }
};
/**
 * pre-validate an object passed as an argument to firebase function (
 * must be an object - e.g. for firebase.update()).
 *
 * @param {string} fnName
 * @param {number} argumentNumber
 * @param {*} data
 * @param {!Path} path
 * @param {boolean} optional
 */
exports.validateFirebaseMergeDataArg = function (fnName, argumentNumber, data, path, optional) {
    if (optional && data === undefined)
        return;
    var errorPrefix = util_3.errorPrefix(fnName, argumentNumber, optional);
    if (!(data && typeof data === 'object') || Array.isArray(data)) {
        throw new Error(errorPrefix + ' must be an object containing the children to replace.');
    }
    var mergePaths = [];
    util_1.forEach(data, function (key, value) {
        var curPath = new Path_1.Path(key);
        exports.validateFirebaseData(errorPrefix, value, path.child(curPath));
        if (curPath.getBack() === '.priority') {
            if (!exports.isValidPriority(value)) {
                throw new Error(errorPrefix +
                    "contains an invalid value for '" +
                    curPath.toString() +
                    "', which must be a valid " +
                    'Firebase priority (a string, finite number, server value, or null).');
            }
        }
        mergePaths.push(curPath);
    });
    exports.validateFirebaseMergePaths(errorPrefix, mergePaths);
};
exports.validatePriority = function (fnName, argumentNumber, priority, optional) {
    if (optional && priority === undefined)
        return;
    if (util_2.isInvalidJSONNumber(priority))
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'is ' +
            priority.toString() +
            ', but must be a valid Firebase priority (a string, finite number, ' +
            'server value, or null).');
    // Special case to allow importing data with a .sv.
    if (!exports.isValidPriority(priority))
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid Firebase priority ' +
            '(a string, finite number, server value, or null).');
};
exports.validateEventType = function (fnName, argumentNumber, eventType, optional) {
    if (optional && eventType === undefined)
        return;
    switch (eventType) {
        case 'value':
        case 'child_added':
        case 'child_removed':
        case 'child_changed':
        case 'child_moved':
            break;
        default:
            throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
                'must be a valid event type = "value", "child_added", "child_removed", ' +
                '"child_changed", or "child_moved".');
    }
};
exports.validateKey = function (fnName, argumentNumber, key, optional) {
    if (optional && key === undefined)
        return;
    if (!exports.isValidKey(key))
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'was an invalid key = "' +
            key +
            '".  Firebase keys must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "/", "[", or "]").');
};
exports.validatePathString = function (fnName, argumentNumber, pathString, optional) {
    if (optional && pathString === undefined)
        return;
    if (!exports.isValidPathString(pathString))
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'was an invalid path = "' +
            pathString +
            '". Paths must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "[", or "]"');
};
exports.validateRootPathString = function (fnName, argumentNumber, pathString, optional) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    exports.validatePathString(fnName, argumentNumber, pathString, optional);
};
exports.validateWritablePath = function (fnName, path) {
    if (path.getFront() === '.info') {
        throw new Error(fnName + " failed = Can't modify data under /.info/");
    }
};
exports.validateUrl = function (fnName, argumentNumber, parsedUrl) {
    // TODO = Validate server better.
    var pathString = parsedUrl.path.toString();
    if (!(typeof parsedUrl.repoInfo.host === 'string') ||
        parsedUrl.repoInfo.host.length === 0 ||
        !exports.isValidKey(parsedUrl.repoInfo.namespace) ||
        (pathString.length !== 0 && !exports.isValidRootPathString(pathString))) {
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, false) +
            'must be a valid firebase URL and ' +
            'the path can\'t contain ".", "#", "$", "[", or "]".');
    }
};
exports.validateCredential = function (fnName, argumentNumber, cred, optional) {
    if (optional && cred === undefined)
        return;
    if (!(typeof cred === 'string'))
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid credential (a string).');
};
exports.validateBoolean = function (fnName, argumentNumber, bool, optional) {
    if (optional && bool === undefined)
        return;
    if (typeof bool !== 'boolean')
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a boolean.');
};
exports.validateString = function (fnName, argumentNumber, string, optional) {
    if (optional && string === undefined)
        return;
    if (!(typeof string === 'string')) {
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid string.');
    }
};
exports.validateObject = function (fnName, argumentNumber, obj, optional) {
    if (optional && obj === undefined)
        return;
    if (!(obj && typeof obj === 'object') || obj === null) {
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid object.');
    }
};
exports.validateObjectContainsKey = function (fnName, argumentNumber, obj, key, optional, opt_type) {
    var objectContainsKey = obj && typeof obj === 'object' && util_1.contains(obj, key);
    if (!objectContainsKey) {
        if (optional) {
            return;
        }
        else {
            throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
                'must contain the key "' +
                key +
                '"');
        }
    }
    if (opt_type) {
        var val = util_1.safeGet(obj, key);
        if ((opt_type === 'number' && !(typeof val === 'number')) ||
            (opt_type === 'string' && !(typeof val === 'string')) ||
            (opt_type === 'boolean' && !(typeof val === 'boolean')) ||
            (opt_type === 'function' && !(typeof val === 'function')) ||
            (opt_type === 'object' && !(typeof val === 'object') && val)) {
            if (optional) {
                throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
                    'contains invalid value for key "' +
                    key +
                    '" (must be of type "' +
                    opt_type +
                    '")');
            }
            else {
                throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
                    'must contain the key "' +
                    key +
                    '" with type "' +
                    opt_type +
                    '"');
            }
        }
    }
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/util/validation.js","/node_modules/@firebase/database/dist/cjs/src/core/util")

},{"./Path":57,"./util":63,"@firebase/util":134,"_process":162,"buffer":160}],65:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully
 * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.
 * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks
 * whether a node potentially had children removed due to a filter.
 */
var CacheNode = /** @class */ (function () {
    /**
     * @param {!Node} node_
     * @param {boolean} fullyInitialized_
     * @param {boolean} filtered_
     */
    function CacheNode(node_, fullyInitialized_, filtered_) {
        this.node_ = node_;
        this.fullyInitialized_ = fullyInitialized_;
        this.filtered_ = filtered_;
    }
    /**
     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client
     * @return {boolean}
     */
    CacheNode.prototype.isFullyInitialized = function () {
        return this.fullyInitialized_;
    };
    /**
     * Returns whether this node is potentially missing children due to a filter applied to the node
     * @return {boolean}
     */
    CacheNode.prototype.isFiltered = function () {
        return this.filtered_;
    };
    /**
     * @param {!Path} path
     * @return {boolean}
     */
    CacheNode.prototype.isCompleteForPath = function (path) {
        if (path.isEmpty()) {
            return this.isFullyInitialized() && !this.filtered_;
        }
        var childKey = path.getFront();
        return this.isCompleteForChild(childKey);
    };
    /**
     * @param {!string} key
     * @return {boolean}
     */
    CacheNode.prototype.isCompleteForChild = function (key) {
        return ((this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(key));
    };
    /**
     * @return {!Node}
     */
    CacheNode.prototype.getNode = function () {
        return this.node_;
    };
    return CacheNode;
}());
exports.CacheNode = CacheNode;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/CacheNode.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"_process":162,"buffer":160}],66:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @constructor
 * @struct
 * @param {!string} type The event type
 * @param {!Node} snapshotNode The data
 * @param {string=} childName The name for this child, if it's a child event
 * @param {Node=} oldSnap Used for intermediate processing of child changed events
 * @param {string=} prevName The name for the previous child, if applicable
 */
var Change = /** @class */ (function () {
    function Change(type, snapshotNode, childName, oldSnap, prevName) {
        this.type = type;
        this.snapshotNode = snapshotNode;
        this.childName = childName;
        this.oldSnap = oldSnap;
        this.prevName = prevName;
    }
    /**
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.valueChange = function (snapshot) {
        return new Change(Change.VALUE, snapshot);
    };
    /**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.childAddedChange = function (childKey, snapshot) {
        return new Change(Change.CHILD_ADDED, snapshot, childKey);
    };
    /**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.childRemovedChange = function (childKey, snapshot) {
        return new Change(Change.CHILD_REMOVED, snapshot, childKey);
    };
    /**
     * @param {string} childKey
     * @param {!Node} newSnapshot
     * @param {!Node} oldSnapshot
     * @return {!Change}
     */
    Change.childChangedChange = function (childKey, newSnapshot, oldSnapshot) {
        return new Change(Change.CHILD_CHANGED, newSnapshot, childKey, oldSnapshot);
    };
    /**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.childMovedChange = function (childKey, snapshot) {
        return new Change(Change.CHILD_MOVED, snapshot, childKey);
    };
    //event types
    /** Event type for a child added */
    Change.CHILD_ADDED = 'child_added';
    /** Event type for a child removed */
    Change.CHILD_REMOVED = 'child_removed';
    /** Event type for a child changed */
    Change.CHILD_CHANGED = 'child_changed';
    /** Event type for a child moved */
    Change.CHILD_MOVED = 'child_moved';
    /** Event type for a value change */
    Change.VALUE = 'value';
    return Change;
}());
exports.Change = Change;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/Change.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"_process":162,"buffer":160}],67:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var Change_1 = require("./Change");
var util_2 = require("@firebase/util");
/**
 * @constructor
 */
var ChildChangeAccumulator = /** @class */ (function () {
    function ChildChangeAccumulator() {
        this.changeMap_ = {};
    }
    /**
     * @param {!Change} change
     */
    ChildChangeAccumulator.prototype.trackChildChange = function (change) {
        var type = change.type;
        var childKey /** @type {!string} */ = change.childName;
        util_2.assert(type == Change_1.Change.CHILD_ADDED ||
            type == Change_1.Change.CHILD_CHANGED ||
            type == Change_1.Change.CHILD_REMOVED, 'Only child changes supported for tracking');
        util_2.assert(childKey !== '.priority', 'Only non-priority child changes can be tracked.');
        var oldChange = util_1.safeGet(this.changeMap_, childKey);
        if (oldChange) {
            var oldType = oldChange.type;
            if (type == Change_1.Change.CHILD_ADDED && oldType == Change_1.Change.CHILD_REMOVED) {
                this.changeMap_[childKey] = Change_1.Change.childChangedChange(childKey, change.snapshotNode, oldChange.snapshotNode);
            }
            else if (type == Change_1.Change.CHILD_REMOVED &&
                oldType == Change_1.Change.CHILD_ADDED) {
                delete this.changeMap_[childKey];
            }
            else if (type == Change_1.Change.CHILD_REMOVED &&
                oldType == Change_1.Change.CHILD_CHANGED) {
                this.changeMap_[childKey] = Change_1.Change.childRemovedChange(childKey, oldChange.oldSnap);
            }
            else if (type == Change_1.Change.CHILD_CHANGED &&
                oldType == Change_1.Change.CHILD_ADDED) {
                this.changeMap_[childKey] = Change_1.Change.childAddedChange(childKey, change.snapshotNode);
            }
            else if (type == Change_1.Change.CHILD_CHANGED &&
                oldType == Change_1.Change.CHILD_CHANGED) {
                this.changeMap_[childKey] = Change_1.Change.childChangedChange(childKey, change.snapshotNode, oldChange.oldSnap);
            }
            else {
                throw util_2.assertionError('Illegal combination of changes: ' +
                    change +
                    ' occurred after ' +
                    oldChange);
            }
        }
        else {
            this.changeMap_[childKey] = change;
        }
    };
    /**
     * @return {!Array.<!Change>}
     */
    ChildChangeAccumulator.prototype.getChanges = function () {
        return util_1.getValues(this.changeMap_);
    };
    return ChildChangeAccumulator;
}());
exports.ChildChangeAccumulator = ChildChangeAccumulator;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/ChildChangeAccumulator.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"./Change":66,"@firebase/util":134,"_process":162,"buffer":160}],68:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var CacheNode_1 = require("./CacheNode");
/**
 * An implementation of CompleteChildSource that never returns any additional children
 *
 * @private
 * @constructor
 * @implements CompleteChildSource
 */
var NoCompleteChildSource_ = /** @class */ (function () {
    function NoCompleteChildSource_() {
    }
    /**
     * @inheritDoc
     */
    NoCompleteChildSource_.prototype.getCompleteChild = function (childKey) {
        return null;
    };
    /**
     * @inheritDoc
     */
    NoCompleteChildSource_.prototype.getChildAfterChild = function (index, child, reverse) {
        return null;
    };
    return NoCompleteChildSource_;
}());
exports.NoCompleteChildSource_ = NoCompleteChildSource_;
/**
 * Singleton instance.
 * @const
 * @type {!CompleteChildSource}
 */
exports.NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
/**
 * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or
 * old event caches available to calculate complete children.
 *
 *
 * @implements CompleteChildSource
 */
var WriteTreeCompleteChildSource = /** @class */ (function () {
    /**
     * @param {!WriteTreeRef} writes_
     * @param {!ViewCache} viewCache_
     * @param {?Node} optCompleteServerCache_
     */
    function WriteTreeCompleteChildSource(writes_, viewCache_, optCompleteServerCache_) {
        if (optCompleteServerCache_ === void 0) { optCompleteServerCache_ = null; }
        this.writes_ = writes_;
        this.viewCache_ = viewCache_;
        this.optCompleteServerCache_ = optCompleteServerCache_;
    }
    /**
     * @inheritDoc
     */
    WriteTreeCompleteChildSource.prototype.getCompleteChild = function (childKey) {
        var node = this.viewCache_.getEventCache();
        if (node.isCompleteForChild(childKey)) {
            return node.getNode().getImmediateChild(childKey);
        }
        else {
            var serverNode = this.optCompleteServerCache_ != null
                ? new CacheNode_1.CacheNode(this.optCompleteServerCache_, true, false)
                : this.viewCache_.getServerCache();
            return this.writes_.calcCompleteChild(childKey, serverNode);
        }
    };
    /**
     * @inheritDoc
     */
    WriteTreeCompleteChildSource.prototype.getChildAfterChild = function (index, child, reverse) {
        var completeServerData = this.optCompleteServerCache_ != null
            ? this.optCompleteServerCache_
            : this.viewCache_.getCompleteServerSnap();
        var nodes = this.writes_.calcIndexedSlice(completeServerData, child, 1, reverse, index);
        if (nodes.length === 0) {
            return null;
        }
        else {
            return nodes[0];
        }
    };
    return WriteTreeCompleteChildSource;
}());
exports.WriteTreeCompleteChildSource = WriteTreeCompleteChildSource;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/CompleteChildSource.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"./CacheNode":65,"_process":162,"buffer":160}],69:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
/**
 * Encapsulates the data needed to raise an event
 * @implements {Event}
 */
var DataEvent = /** @class */ (function () {
    /**
     * @param {!string} eventType One of: value, child_added, child_changed, child_moved, child_removed
     * @param {!EventRegistration} eventRegistration The function to call to with the event data. User provided
     * @param {!DataSnapshot} snapshot The data backing the event
     * @param {?string=} prevName Optional, the name of the previous child for child_* events.
     */
    function DataEvent(eventType, eventRegistration, snapshot, prevName) {
        this.eventType = eventType;
        this.eventRegistration = eventRegistration;
        this.snapshot = snapshot;
        this.prevName = prevName;
    }
    /**
     * @inheritDoc
     */
    DataEvent.prototype.getPath = function () {
        var ref = this.snapshot.getRef();
        if (this.eventType === 'value') {
            return ref.path;
        }
        else {
            return ref.getParent().path;
        }
    };
    /**
     * @inheritDoc
     */
    DataEvent.prototype.getEventType = function () {
        return this.eventType;
    };
    /**
     * @inheritDoc
     */
    DataEvent.prototype.getEventRunner = function () {
        return this.eventRegistration.getEventRunner(this);
    };
    /**
     * @inheritDoc
     */
    DataEvent.prototype.toString = function () {
        return (this.getPath().toString() +
            ':' +
            this.eventType +
            ':' +
            util_1.stringify(this.snapshot.exportVal()));
    };
    return DataEvent;
}());
exports.DataEvent = DataEvent;
var CancelEvent = /** @class */ (function () {
    /**
     * @param {EventRegistration} eventRegistration
     * @param {Error} error
     * @param {!Path} path
     */
    function CancelEvent(eventRegistration, error, path) {
        this.eventRegistration = eventRegistration;
        this.error = error;
        this.path = path;
    }
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.getPath = function () {
        return this.path;
    };
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.getEventType = function () {
        return 'cancel';
    };
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.getEventRunner = function () {
        return this.eventRegistration.getEventRunner(this);
    };
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.toString = function () {
        return this.path.toString() + ':cancel';
    };
    return CancelEvent;
}());
exports.CancelEvent = CancelEvent;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/Event.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"@firebase/util":134,"_process":162,"buffer":160}],70:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Node_1 = require("../snap/Node");
var Change_1 = require("./Change");
var util_1 = require("@firebase/util");
/**
 * An EventGenerator is used to convert "raw" changes (Change) as computed by the
 * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()
 * for details.
 *
 * @constructor
 */
var EventGenerator = /** @class */ (function () {
    /**
     *
     * @param {!Query} query_
     */
    function EventGenerator(query_) {
        this.query_ = query_;
        /**
         * @private
         * @type {!Index}
         */
        this.index_ = this.query_.getQueryParams().getIndex();
    }
    /**
     * Given a set of raw changes (no moved events and prevName not specified yet), and a set of
     * EventRegistrations that should be notified of these changes, generate the actual events to be raised.
     *
     * Notes:
     *  - child_moved events will be synthesized at this time for any child_changed events that affect
     *    our index.
     *  - prevName will be calculated based on the index ordering.
     *
     * @param {!Array.<!Change>} changes
     * @param {!Node} eventCache
     * @param {!Array.<!EventRegistration>} eventRegistrations
     * @return {!Array.<!Event>}
     */
    EventGenerator.prototype.generateEventsForChanges = function (changes, eventCache, eventRegistrations) {
        var _this = this;
        var events = [];
        var moves = [];
        changes.forEach(function (change) {
            if (change.type === Change_1.Change.CHILD_CHANGED &&
                _this.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
                moves.push(Change_1.Change.childMovedChange(change.childName, change.snapshotNode));
            }
        });
        this.generateEventsForType_(events, Change_1.Change.CHILD_REMOVED, changes, eventRegistrations, eventCache);
        this.generateEventsForType_(events, Change_1.Change.CHILD_ADDED, changes, eventRegistrations, eventCache);
        this.generateEventsForType_(events, Change_1.Change.CHILD_MOVED, moves, eventRegistrations, eventCache);
        this.generateEventsForType_(events, Change_1.Change.CHILD_CHANGED, changes, eventRegistrations, eventCache);
        this.generateEventsForType_(events, Change_1.Change.VALUE, changes, eventRegistrations, eventCache);
        return events;
    };
    /**
     * Given changes of a single change type, generate the corresponding events.
     *
     * @param {!Array.<!Event>} events
     * @param {!string} eventType
     * @param {!Array.<!Change>} changes
     * @param {!Array.<!EventRegistration>} registrations
     * @param {!Node} eventCache
     * @private
     */
    EventGenerator.prototype.generateEventsForType_ = function (events, eventType, changes, registrations, eventCache) {
        var _this = this;
        var filteredChanges = changes.filter(function (change) { return change.type === eventType; });
        filteredChanges.sort(this.compareChanges_.bind(this));
        filteredChanges.forEach(function (change) {
            var materializedChange = _this.materializeSingleChange_(change, eventCache);
            registrations.forEach(function (registration) {
                if (registration.respondsTo(change.type)) {
                    events.push(registration.createEvent(materializedChange, _this.query_));
                }
            });
        });
    };
    /**
     * @param {!Change} change
     * @param {!Node} eventCache
     * @return {!Change}
     * @private
     */
    EventGenerator.prototype.materializeSingleChange_ = function (change, eventCache) {
        if (change.type === 'value' || change.type === 'child_removed') {
            return change;
        }
        else {
            change.prevName = eventCache.getPredecessorChildName(
            /** @type {!string} */
            change.childName, change.snapshotNode, this.index_);
            return change;
        }
    };
    /**
     * @param {!Change} a
     * @param {!Change} b
     * @return {number}
     * @private
     */
    EventGenerator.prototype.compareChanges_ = function (a, b) {
        if (a.childName == null || b.childName == null) {
            throw util_1.assertionError('Should only compare child_ events.');
        }
        var aWrapped = new Node_1.NamedNode(a.childName, a.snapshotNode);
        var bWrapped = new Node_1.NamedNode(b.childName, b.snapshotNode);
        return this.index_.compare(aWrapped, bWrapped);
    };
    return EventGenerator;
}());
exports.EventGenerator = EventGenerator;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/EventGenerator.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"../snap/Node":35,"./Change":66,"@firebase/util":134,"_process":162,"buffer":160}],71:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util/util");
/**
 * The event queue serves a few purposes:
 * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more
 *    events being queued.
 * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,
 *    raiseQueuedEvents() is called again, the "inner" call will pick up raising events where the "outer" call
 *    left off, ensuring that the events are still raised synchronously and in order.
 * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued
 *    events are raised synchronously.
 *
 * NOTE: This can all go away if/when we move to async events.
 *
 * @constructor
 */
var EventQueue = /** @class */ (function () {
    function EventQueue() {
        /**
         * @private
         * @type {!Array.<EventList>}
         */
        this.eventLists_ = [];
        /**
         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.
         * @private
         * @type {!number}
         */
        this.recursionDepth_ = 0;
    }
    /**
     * @param {!Array.<Event>} eventDataList The new events to queue.
     */
    EventQueue.prototype.queueEvents = function (eventDataList) {
        // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.
        var currList = null;
        for (var i = 0; i < eventDataList.length; i++) {
            var eventData = eventDataList[i];
            var eventPath = eventData.getPath();
            if (currList !== null && !eventPath.equals(currList.getPath())) {
                this.eventLists_.push(currList);
                currList = null;
            }
            if (currList === null) {
                currList = new EventList(eventPath);
            }
            currList.add(eventData);
        }
        if (currList) {
            this.eventLists_.push(currList);
        }
    };
    /**
     * Queues the specified events and synchronously raises all events (including previously queued ones)
     * for the specified path.
     *
     * It is assumed that the new events are all for the specified path.
     *
     * @param {!Path} path The path to raise events for.
     * @param {!Array.<Event>} eventDataList The new events to raise.
     */
    EventQueue.prototype.raiseEventsAtPath = function (path, eventDataList) {
        this.queueEvents(eventDataList);
        this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {
            return eventPath.equals(path);
        });
    };
    /**
     * Queues the specified events and synchronously raises all events (including previously queued ones) for
     * locations related to the specified change path (i.e. all ancestors and descendants).
     *
     * It is assumed that the new events are all related (ancestor or descendant) to the specified path.
     *
     * @param {!Path} changedPath The path to raise events for.
     * @param {!Array.<!Event>} eventDataList The events to raise
     */
    EventQueue.prototype.raiseEventsForChangedPath = function (changedPath, eventDataList) {
        this.queueEvents(eventDataList);
        this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {
            return eventPath.contains(changedPath) || changedPath.contains(eventPath);
        });
    };
    /**
     * @param {!function(!Path):boolean} predicate
     * @private
     */
    EventQueue.prototype.raiseQueuedEventsMatchingPredicate_ = function (predicate) {
        this.recursionDepth_++;
        var sentAll = true;
        for (var i = 0; i < this.eventLists_.length; i++) {
            var eventList = this.eventLists_[i];
            if (eventList) {
                var eventPath = eventList.getPath();
                if (predicate(eventPath)) {
                    this.eventLists_[i].raise();
                    this.eventLists_[i] = null;
                }
                else {
                    sentAll = false;
                }
            }
        }
        if (sentAll) {
            this.eventLists_ = [];
        }
        this.recursionDepth_--;
    };
    return EventQueue;
}());
exports.EventQueue = EventQueue;
/**
 * @param {!Path} path
 * @constructor
 */
var EventList = /** @class */ (function () {
    function EventList(path_) {
        this.path_ = path_;
        /**
         * @type {!Array.<Event>}
         * @private
         */
        this.events_ = [];
    }
    /**
     * @param {!Event} eventData
     */
    EventList.prototype.add = function (eventData) {
        this.events_.push(eventData);
    };
    /**
     * Iterates through the list and raises each event
     */
    EventList.prototype.raise = function () {
        for (var i = 0; i < this.events_.length; i++) {
            var eventData = this.events_[i];
            if (eventData !== null) {
                this.events_[i] = null;
                var eventFn = eventData.getEventRunner();
                if (util_1.logger) {
                    util_1.log('event: ' + eventData.toString());
                }
                util_1.exceptionGuard(eventFn);
            }
        }
    };
    /**
     * @return {!Path}
     */
    EventList.prototype.getPath = function () {
        return this.path_;
    };
    return EventList;
}());
exports.EventList = EventList;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/EventQueue.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"../util/util":63,"_process":162,"buffer":160}],72:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var DataSnapshot_1 = require("../../api/DataSnapshot");
var Event_1 = require("./Event");
var util_1 = require("@firebase/util");
var util_2 = require("@firebase/util");
/**
 * Represents registration for 'value' events.
 */
var ValueEventRegistration = /** @class */ (function () {
    /**
     * @param {?function(!DataSnapshot)} callback_
     * @param {?function(Error)} cancelCallback_
     * @param {?Object} context_
     */
    function ValueEventRegistration(callback_, cancelCallback_, context_) {
        this.callback_ = callback_;
        this.cancelCallback_ = cancelCallback_;
        this.context_ = context_;
    }
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.respondsTo = function (eventType) {
        return eventType === 'value';
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.createEvent = function (change, query) {
        var index = query.getQueryParams().getIndex();
        return new Event_1.DataEvent('value', this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, query.getRef(), index));
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.getEventRunner = function (eventData) {
        var ctx = this.context_;
        if (eventData.getEventType() === 'cancel') {
            util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');
            var cancelCB_1 = this.cancelCallback_;
            return function () {
                // We know that error exists, we checked above that this is a cancel event
                cancelCB_1.call(ctx, eventData.error);
            };
        }
        else {
            var cb_1 = this.callback_;
            return function () {
                cb_1.call(ctx, eventData.snapshot);
            };
        }
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.createCancelEvent = function (error, path) {
        if (this.cancelCallback_) {
            return new Event_1.CancelEvent(this, error, path);
        }
        else {
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.matches = function (other) {
        if (!(other instanceof ValueEventRegistration)) {
            return false;
        }
        else if (!other.callback_ || !this.callback_) {
            // If no callback specified, we consider it to match any callback.
            return true;
        }
        else {
            return (other.callback_ === this.callback_ && other.context_ === this.context_);
        }
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.hasAnyCallback = function () {
        return this.callback_ !== null;
    };
    return ValueEventRegistration;
}());
exports.ValueEventRegistration = ValueEventRegistration;
/**
 * Represents the registration of 1 or more child_xxx events.
 *
 * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you
 * register a group of callbacks together in the future.
 *
 * @constructor
 * @implements {EventRegistration}
 */
var ChildEventRegistration = /** @class */ (function () {
    /**
     * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_
     * @param {?function(Error)} cancelCallback_
     * @param {Object=} context_
     */
    function ChildEventRegistration(callbacks_, cancelCallback_, context_) {
        this.callbacks_ = callbacks_;
        this.cancelCallback_ = cancelCallback_;
        this.context_ = context_;
    }
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.respondsTo = function (eventType) {
        var eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;
        eventToCheck =
            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;
        return util_1.contains(this.callbacks_, eventToCheck);
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.createCancelEvent = function (error, path) {
        if (this.cancelCallback_) {
            return new Event_1.CancelEvent(this, error, path);
        }
        else {
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.createEvent = function (change, query) {
        util_2.assert(change.childName != null, 'Child events should have a childName.');
        var ref = query.getRef().child(/** @type {!string} */ (change.childName));
        var index = query.getQueryParams().getIndex();
        return new Event_1.DataEvent(change.type, this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, ref, index), change.prevName);
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.getEventRunner = function (eventData) {
        var ctx = this.context_;
        if (eventData.getEventType() === 'cancel') {
            util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');
            var cancelCB_2 = this.cancelCallback_;
            return function () {
                // We know that error exists, we checked above that this is a cancel event
                cancelCB_2.call(ctx, eventData.error);
            };
        }
        else {
            var cb_2 = this.callbacks_[eventData.eventType];
            return function () {
                cb_2.call(ctx, eventData.snapshot, eventData.prevName);
            };
        }
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.matches = function (other) {
        if (other instanceof ChildEventRegistration) {
            if (!this.callbacks_ || !other.callbacks_) {
                return true;
            }
            else if (this.context_ === other.context_) {
                var otherCount = util_1.getCount(other.callbacks_);
                var thisCount = util_1.getCount(this.callbacks_);
                if (otherCount === thisCount) {
                    // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.
                    //  If event types don't match, not a match
                    // If count is not 1, exact match across all
                    if (otherCount === 1) {
                        var otherKey /** @type {!string} */ = util_1.getAnyKey(other.callbacks_);
                        var thisKey /** @type {!string} */ = util_1.getAnyKey(this.callbacks_);
                        return (thisKey === otherKey &&
                            (!other.callbacks_[otherKey] ||
                                !this.callbacks_[thisKey] ||
                                other.callbacks_[otherKey] === this.callbacks_[thisKey]));
                    }
                    else {
                        // Exact match on each key.
                        return util_1.every(this.callbacks_, function (eventType, cb) { return other.callbacks_[eventType] === cb; });
                    }
                }
            }
        }
        return false;
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.hasAnyCallback = function () {
        return this.callbacks_ !== null;
    };
    return ChildEventRegistration;
}());
exports.ChildEventRegistration = ChildEventRegistration;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/EventRegistration.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"../../api/DataSnapshot":5,"./Event":69,"@firebase/util":134,"_process":162,"buffer":160}],73:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var util_2 = require("../util/util");
var KeyIndex_1 = require("../snap/indexes/KeyIndex");
var PriorityIndex_1 = require("../snap/indexes/PriorityIndex");
var ValueIndex_1 = require("../snap/indexes/ValueIndex");
var PathIndex_1 = require("../snap/indexes/PathIndex");
var IndexedFilter_1 = require("./filter/IndexedFilter");
var LimitedFilter_1 = require("./filter/LimitedFilter");
var RangedFilter_1 = require("./filter/RangedFilter");
var util_3 = require("@firebase/util");
/**
 * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a
 * range to be returned for a particular location. It is assumed that validation of parameters is done at the
 * user-facing API level, so it is not done here.
 * @constructor
 */
var QueryParams = /** @class */ (function () {
    function QueryParams() {
        this.limitSet_ = false;
        this.startSet_ = false;
        this.startNameSet_ = false;
        this.endSet_ = false;
        this.endNameSet_ = false;
        this.limit_ = 0;
        this.viewFrom_ = '';
        this.indexStartValue_ = null;
        this.indexStartName_ = '';
        this.indexEndValue_ = null;
        this.indexEndName_ = '';
        this.index_ = PriorityIndex_1.PRIORITY_INDEX;
    }
    /**
     * @return {boolean}
     */
    QueryParams.prototype.hasStart = function () {
        return this.startSet_;
    };
    /**
     * @return {boolean} True if it would return from left.
     */
    QueryParams.prototype.isViewFromLeft = function () {
        if (this.viewFrom_ === '') {
            // limit(), rather than limitToFirst or limitToLast was called.
            // This means that only one of startSet_ and endSet_ is true. Use them
            // to calculate which side of the view to anchor to. If neither is set,
            // anchor to the end.
            return this.startSet_;
        }
        else {
            return (this.viewFrom_ === QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT);
        }
    };
    /**
     * Only valid to call if hasStart() returns true
     * @return {*}
     */
    QueryParams.prototype.getIndexStartValue = function () {
        util_1.assert(this.startSet_, 'Only valid if start has been set');
        return this.indexStartValue_;
    };
    /**
     * Only valid to call if hasStart() returns true.
     * Returns the starting key name for the range defined by these query parameters
     * @return {!string}
     */
    QueryParams.prototype.getIndexStartName = function () {
        util_1.assert(this.startSet_, 'Only valid if start has been set');
        if (this.startNameSet_) {
            return this.indexStartName_;
        }
        else {
            return util_2.MIN_NAME;
        }
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.hasEnd = function () {
        return this.endSet_;
    };
    /**
     * Only valid to call if hasEnd() returns true.
     * @return {*}
     */
    QueryParams.prototype.getIndexEndValue = function () {
        util_1.assert(this.endSet_, 'Only valid if end has been set');
        return this.indexEndValue_;
    };
    /**
     * Only valid to call if hasEnd() returns true.
     * Returns the end key name for the range defined by these query parameters
     * @return {!string}
     */
    QueryParams.prototype.getIndexEndName = function () {
        util_1.assert(this.endSet_, 'Only valid if end has been set');
        if (this.endNameSet_) {
            return this.indexEndName_;
        }
        else {
            return util_2.MAX_NAME;
        }
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.hasLimit = function () {
        return this.limitSet_;
    };
    /**
     * @return {boolean} True if a limit has been set and it has been explicitly anchored
     */
    QueryParams.prototype.hasAnchoredLimit = function () {
        return this.limitSet_ && this.viewFrom_ !== '';
    };
    /**
     * Only valid to call if hasLimit() returns true
     * @return {!number}
     */
    QueryParams.prototype.getLimit = function () {
        util_1.assert(this.limitSet_, 'Only valid if limit has been set');
        return this.limit_;
    };
    /**
     * @return {!Index}
     */
    QueryParams.prototype.getIndex = function () {
        return this.index_;
    };
    /**
     * @return {!QueryParams}
     * @private
     */
    QueryParams.prototype.copy_ = function () {
        var copy = new QueryParams();
        copy.limitSet_ = this.limitSet_;
        copy.limit_ = this.limit_;
        copy.startSet_ = this.startSet_;
        copy.indexStartValue_ = this.indexStartValue_;
        copy.startNameSet_ = this.startNameSet_;
        copy.indexStartName_ = this.indexStartName_;
        copy.endSet_ = this.endSet_;
        copy.indexEndValue_ = this.indexEndValue_;
        copy.endNameSet_ = this.endNameSet_;
        copy.indexEndName_ = this.indexEndName_;
        copy.index_ = this.index_;
        copy.viewFrom_ = this.viewFrom_;
        return copy;
    };
    /**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */
    QueryParams.prototype.limit = function (newLimit) {
        var newParams = this.copy_();
        newParams.limitSet_ = true;
        newParams.limit_ = newLimit;
        newParams.viewFrom_ = '';
        return newParams;
    };
    /**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */
    QueryParams.prototype.limitToFirst = function (newLimit) {
        var newParams = this.copy_();
        newParams.limitSet_ = true;
        newParams.limit_ = newLimit;
        newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT;
        return newParams;
    };
    /**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */
    QueryParams.prototype.limitToLast = function (newLimit) {
        var newParams = this.copy_();
        newParams.limitSet_ = true;
        newParams.limit_ = newLimit;
        newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_RIGHT;
        return newParams;
    };
    /**
     * @param {*} indexValue
     * @param {?string=} key
     * @return {!QueryParams}
     */
    QueryParams.prototype.startAt = function (indexValue, key) {
        var newParams = this.copy_();
        newParams.startSet_ = true;
        if (!(indexValue !== undefined)) {
            indexValue = null;
        }
        newParams.indexStartValue_ = indexValue;
        if (key != null) {
            newParams.startNameSet_ = true;
            newParams.indexStartName_ = key;
        }
        else {
            newParams.startNameSet_ = false;
            newParams.indexStartName_ = '';
        }
        return newParams;
    };
    /**
     * @param {*} indexValue
     * @param {?string=} key
     * @return {!QueryParams}
     */
    QueryParams.prototype.endAt = function (indexValue, key) {
        var newParams = this.copy_();
        newParams.endSet_ = true;
        if (!(indexValue !== undefined)) {
            indexValue = null;
        }
        newParams.indexEndValue_ = indexValue;
        if (key !== undefined) {
            newParams.endNameSet_ = true;
            newParams.indexEndName_ = key;
        }
        else {
            newParams.endNameSet_ = false;
            newParams.indexEndName_ = '';
        }
        return newParams;
    };
    /**
     * @param {!Index} index
     * @return {!QueryParams}
     */
    QueryParams.prototype.orderBy = function (index) {
        var newParams = this.copy_();
        newParams.index_ = index;
        return newParams;
    };
    /**
     * @return {!Object}
     */
    QueryParams.prototype.getQueryObject = function () {
        var WIRE_PROTOCOL_CONSTANTS = QueryParams.WIRE_PROTOCOL_CONSTANTS_;
        var obj = {};
        if (this.startSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE] = this.indexStartValue_;
            if (this.startNameSet_) {
                obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME] = this.indexStartName_;
            }
        }
        if (this.endSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE] = this.indexEndValue_;
            if (this.endNameSet_) {
                obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME] = this.indexEndName_;
            }
        }
        if (this.limitSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.LIMIT] = this.limit_;
            var viewFrom = this.viewFrom_;
            if (viewFrom === '') {
                if (this.isViewFromLeft()) {
                    viewFrom = WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT;
                }
                else {
                    viewFrom = WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT;
                }
            }
            obj[WIRE_PROTOCOL_CONSTANTS.VIEW_FROM] = viewFrom;
        }
        // For now, priority index is the default, so we only specify if it's some other index
        if (this.index_ !== PriorityIndex_1.PRIORITY_INDEX) {
            obj[WIRE_PROTOCOL_CONSTANTS.INDEX] = this.index_.toString();
        }
        return obj;
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.loadsAllData = function () {
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.isDefault = function () {
        return this.loadsAllData() && this.index_ == PriorityIndex_1.PRIORITY_INDEX;
    };
    /**
     * @return {!NodeFilter}
     */
    QueryParams.prototype.getNodeFilter = function () {
        if (this.loadsAllData()) {
            return new IndexedFilter_1.IndexedFilter(this.getIndex());
        }
        else if (this.hasLimit()) {
            return new LimitedFilter_1.LimitedFilter(this);
        }
        else {
            return new RangedFilter_1.RangedFilter(this);
        }
    };
    /**
     * Returns a set of REST query string parameters representing this query.
     *
     * @return {!Object.<string,*>} query string parameters
     */
    QueryParams.prototype.toRestQueryStringParameters = function () {
        var REST_CONSTANTS = QueryParams.REST_QUERY_CONSTANTS_;
        var qs = {};
        if (this.isDefault()) {
            return qs;
        }
        var orderBy;
        if (this.index_ === PriorityIndex_1.PRIORITY_INDEX) {
            orderBy = REST_CONSTANTS.PRIORITY_INDEX;
        }
        else if (this.index_ === ValueIndex_1.VALUE_INDEX) {
            orderBy = REST_CONSTANTS.VALUE_INDEX;
        }
        else if (this.index_ === KeyIndex_1.KEY_INDEX) {
            orderBy = REST_CONSTANTS.KEY_INDEX;
        }
        else {
            util_1.assert(this.index_ instanceof PathIndex_1.PathIndex, 'Unrecognized index type!');
            orderBy = this.index_.toString();
        }
        qs[REST_CONSTANTS.ORDER_BY] = util_3.stringify(orderBy);
        if (this.startSet_) {
            qs[REST_CONSTANTS.START_AT] = util_3.stringify(this.indexStartValue_);
            if (this.startNameSet_) {
                qs[REST_CONSTANTS.START_AT] += ',' + util_3.stringify(this.indexStartName_);
            }
        }
        if (this.endSet_) {
            qs[REST_CONSTANTS.END_AT] = util_3.stringify(this.indexEndValue_);
            if (this.endNameSet_) {
                qs[REST_CONSTANTS.END_AT] += ',' + util_3.stringify(this.indexEndName_);
            }
        }
        if (this.limitSet_) {
            if (this.isViewFromLeft()) {
                qs[REST_CONSTANTS.LIMIT_TO_FIRST] = this.limit_;
            }
            else {
                qs[REST_CONSTANTS.LIMIT_TO_LAST] = this.limit_;
            }
        }
        return qs;
    };
    /**
     * Wire Protocol Constants
     * @const
     * @enum {string}
     * @private
     */
    QueryParams.WIRE_PROTOCOL_CONSTANTS_ = {
        INDEX_START_VALUE: 'sp',
        INDEX_START_NAME: 'sn',
        INDEX_END_VALUE: 'ep',
        INDEX_END_NAME: 'en',
        LIMIT: 'l',
        VIEW_FROM: 'vf',
        VIEW_FROM_LEFT: 'l',
        VIEW_FROM_RIGHT: 'r',
        INDEX: 'i'
    };
    /**
     * REST Query Constants
     * @const
     * @enum {string}
     * @private
     */
    QueryParams.REST_QUERY_CONSTANTS_ = {
        ORDER_BY: 'orderBy',
        PRIORITY_INDEX: '$priority',
        VALUE_INDEX: '$value',
        KEY_INDEX: '$key',
        START_AT: 'startAt',
        END_AT: 'endAt',
        LIMIT_TO_FIRST: 'limitToFirst',
        LIMIT_TO_LAST: 'limitToLast'
    };
    /**
     * Default, empty query parameters
     * @type {!QueryParams}
     * @const
     */
    QueryParams.DEFAULT = new QueryParams();
    return QueryParams;
}());
exports.QueryParams = QueryParams;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/QueryParams.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"../snap/indexes/KeyIndex":39,"../snap/indexes/PathIndex":40,"../snap/indexes/PriorityIndex":41,"../snap/indexes/ValueIndex":42,"../util/util":63,"./filter/IndexedFilter":77,"./filter/LimitedFilter":78,"./filter/RangedFilter":79,"@firebase/util":134,"_process":162,"buffer":160}],74:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var IndexedFilter_1 = require("./filter/IndexedFilter");
var ViewProcessor_1 = require("./ViewProcessor");
var ChildrenNode_1 = require("../snap/ChildrenNode");
var CacheNode_1 = require("./CacheNode");
var ViewCache_1 = require("./ViewCache");
var EventGenerator_1 = require("./EventGenerator");
var util_1 = require("@firebase/util");
var Operation_1 = require("../operation/Operation");
var Change_1 = require("./Change");
var PriorityIndex_1 = require("../snap/indexes/PriorityIndex");
/**
 * A view represents a specific location and query that has 1 or more event registrations.
 *
 * It does several things:
 *  - Maintains the list of event registrations for this location/query.
 *  - Maintains a cache of the data visible for this location/query.
 *  - Applies new operations (via applyOperation), updates the cache, and based on the event
 *    registrations returns the set of events to be raised.
 * @constructor
 */
var View = /** @class */ (function () {
    /**
     *
     * @param {!Query} query_
     * @param {!ViewCache} initialViewCache
     */
    function View(query_, initialViewCache) {
        this.query_ = query_;
        this.eventRegistrations_ = [];
        var params = this.query_.getQueryParams();
        var indexFilter = new IndexedFilter_1.IndexedFilter(params.getIndex());
        var filter = params.getNodeFilter();
        /**
         * @type {ViewProcessor}
         * @private
         */
        this.processor_ = new ViewProcessor_1.ViewProcessor(filter);
        var initialServerCache = initialViewCache.getServerCache();
        var initialEventCache = initialViewCache.getEventCache();
        // Don't filter server node with other filter than index, wait for tagged listen
        var serverSnap = indexFilter.updateFullNode(ChildrenNode_1.ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
        var eventSnap = filter.updateFullNode(ChildrenNode_1.ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
        var newServerCache = new CacheNode_1.CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
        var newEventCache = new CacheNode_1.CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
        /**
         * @type {!ViewCache}
         * @private
         */
        this.viewCache_ = new ViewCache_1.ViewCache(newEventCache, newServerCache);
        /**
         * @type {!EventGenerator}
         * @private
         */
        this.eventGenerator_ = new EventGenerator_1.EventGenerator(this.query_);
    }
    /**
     * @return {!Query}
     */
    View.prototype.getQuery = function () {
        return this.query_;
    };
    /**
     * @return {?Node}
     */
    View.prototype.getServerCache = function () {
        return this.viewCache_.getServerCache().getNode();
    };
    /**
     * @param {!Path} path
     * @return {?Node}
     */
    View.prototype.getCompleteServerCache = function (path) {
        var cache = this.viewCache_.getCompleteServerSnap();
        if (cache) {
            // If this isn't a "loadsAllData" view, then cache isn't actually a complete cache and
            // we need to see if it contains the child we're interested in.
            if (this.query_.getQueryParams().loadsAllData() ||
                (!path.isEmpty() && !cache.getImmediateChild(path.getFront()).isEmpty())) {
                return cache.getChild(path);
            }
        }
        return null;
    };
    /**
     * @return {boolean}
     */
    View.prototype.isEmpty = function () {
        return this.eventRegistrations_.length === 0;
    };
    /**
     * @param {!EventRegistration} eventRegistration
     */
    View.prototype.addEventRegistration = function (eventRegistration) {
        this.eventRegistrations_.push(eventRegistration);
    };
    /**
     * @param {?EventRegistration} eventRegistration If null, remove all callbacks.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {!Array.<!Event>} Cancel events, if cancelError was provided.
     */
    View.prototype.removeEventRegistration = function (eventRegistration, cancelError) {
        var cancelEvents = [];
        if (cancelError) {
            util_1.assert(eventRegistration == null, 'A cancel should cancel all event registrations.');
            var path_1 = this.query_.path;
            this.eventRegistrations_.forEach(function (registration) {
                cancelError /** @type {!Error} */ = cancelError;
                var maybeEvent = registration.createCancelEvent(cancelError, path_1);
                if (maybeEvent) {
                    cancelEvents.push(maybeEvent);
                }
            });
        }
        if (eventRegistration) {
            var remaining = [];
            for (var i = 0; i < this.eventRegistrations_.length; ++i) {
                var existing = this.eventRegistrations_[i];
                if (!existing.matches(eventRegistration)) {
                    remaining.push(existing);
                }
                else if (eventRegistration.hasAnyCallback()) {
                    // We're removing just this one
                    remaining = remaining.concat(this.eventRegistrations_.slice(i + 1));
                    break;
                }
            }
            this.eventRegistrations_ = remaining;
        }
        else {
            this.eventRegistrations_ = [];
        }
        return cancelEvents;
    };
    /**
     * Applies the given Operation, updates our cache, and returns the appropriate events.
     *
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeServerCache
     * @return {!Array.<!Event>}
     */
    View.prototype.applyOperation = function (operation, writesCache, completeServerCache) {
        if (operation.type === Operation_1.OperationType.MERGE &&
            operation.source.queryId !== null) {
            util_1.assert(this.viewCache_.getCompleteServerSnap(), 'We should always have a full cache before handling merges');
            util_1.assert(this.viewCache_.getCompleteEventSnap(), 'Missing event cache, even though we have a server cache');
        }
        var oldViewCache = this.viewCache_;
        var result = this.processor_.applyOperation(oldViewCache, operation, writesCache, completeServerCache);
        this.processor_.assertIndexed(result.viewCache);
        util_1.assert(result.viewCache.getServerCache().isFullyInitialized() ||
            !oldViewCache.getServerCache().isFullyInitialized(), 'Once a server snap is complete, it should never go back');
        this.viewCache_ = result.viewCache;
        return this.generateEventsForChanges_(result.changes, result.viewCache.getEventCache().getNode(), null);
    };
    /**
     * @param {!EventRegistration} registration
     * @return {!Array.<!Event>}
     */
    View.prototype.getInitialEvents = function (registration) {
        var eventSnap = this.viewCache_.getEventCache();
        var initialChanges = [];
        if (!eventSnap.getNode().isLeafNode()) {
            var eventNode = eventSnap.getNode();
            eventNode.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
                initialChanges.push(Change_1.Change.childAddedChange(key, childNode));
            });
        }
        if (eventSnap.isFullyInitialized()) {
            initialChanges.push(Change_1.Change.valueChange(eventSnap.getNode()));
        }
        return this.generateEventsForChanges_(initialChanges, eventSnap.getNode(), registration);
    };
    /**
     * @private
     * @param {!Array.<!Change>} changes
     * @param {!Node} eventCache
     * @param {EventRegistration=} eventRegistration
     * @return {!Array.<!Event>}
     */
    View.prototype.generateEventsForChanges_ = function (changes, eventCache, eventRegistration) {
        var registrations = eventRegistration
            ? [eventRegistration]
            : this.eventRegistrations_;
        return this.eventGenerator_.generateEventsForChanges(changes, eventCache, registrations);
    };
    return View;
}());
exports.View = View;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/View.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"../operation/Operation":30,"../snap/ChildrenNode":32,"../snap/indexes/PriorityIndex":41,"./CacheNode":65,"./Change":66,"./EventGenerator":70,"./ViewCache":75,"./ViewProcessor":76,"./filter/IndexedFilter":77,"@firebase/util":134,"_process":162,"buffer":160}],75:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ChildrenNode_1 = require("../snap/ChildrenNode");
var CacheNode_1 = require("./CacheNode");
/**
 * Stores the data we have cached for a view.
 *
 * serverSnap is the cached server data, eventSnap is the cached event data (server data plus any local writes).
 *
 * @constructor
 */
var ViewCache = /** @class */ (function () {
    /**
     *
     * @param {!CacheNode} eventCache_
     * @param {!CacheNode} serverCache_
     */
    function ViewCache(eventCache_, serverCache_) {
        this.eventCache_ = eventCache_;
        this.serverCache_ = serverCache_;
    }
    /**
     * @param {!Node} eventSnap
     * @param {boolean} complete
     * @param {boolean} filtered
     * @return {!ViewCache}
     */
    ViewCache.prototype.updateEventSnap = function (eventSnap, complete, filtered) {
        return new ViewCache(new CacheNode_1.CacheNode(eventSnap, complete, filtered), this.serverCache_);
    };
    /**
     * @param {!Node} serverSnap
     * @param {boolean} complete
     * @param {boolean} filtered
     * @return {!ViewCache}
     */
    ViewCache.prototype.updateServerSnap = function (serverSnap, complete, filtered) {
        return new ViewCache(this.eventCache_, new CacheNode_1.CacheNode(serverSnap, complete, filtered));
    };
    /**
     * @return {!CacheNode}
     */
    ViewCache.prototype.getEventCache = function () {
        return this.eventCache_;
    };
    /**
     * @return {?Node}
     */
    ViewCache.prototype.getCompleteEventSnap = function () {
        return this.eventCache_.isFullyInitialized()
            ? this.eventCache_.getNode()
            : null;
    };
    /**
     * @return {!CacheNode}
     */
    ViewCache.prototype.getServerCache = function () {
        return this.serverCache_;
    };
    /**
     * @return {?Node}
     */
    ViewCache.prototype.getCompleteServerSnap = function () {
        return this.serverCache_.isFullyInitialized()
            ? this.serverCache_.getNode()
            : null;
    };
    /**
     * @const
     * @type {ViewCache}
     */
    ViewCache.Empty = new ViewCache(new CacheNode_1.CacheNode(ChildrenNode_1.ChildrenNode.EMPTY_NODE, 
    /*fullyInitialized=*/ false, 
    /*filtered=*/ false), new CacheNode_1.CacheNode(ChildrenNode_1.ChildrenNode.EMPTY_NODE, 
    /*fullyInitialized=*/ false, 
    /*filtered=*/ false));
    return ViewCache;
}());
exports.ViewCache = ViewCache;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/ViewCache.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"../snap/ChildrenNode":32,"./CacheNode":65,"_process":162,"buffer":160}],76:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Operation_1 = require("../operation/Operation");
var util_1 = require("@firebase/util");
var ChildChangeAccumulator_1 = require("./ChildChangeAccumulator");
var Change_1 = require("./Change");
var ChildrenNode_1 = require("../snap/ChildrenNode");
var KeyIndex_1 = require("../snap/indexes/KeyIndex");
var ImmutableTree_1 = require("../util/ImmutableTree");
var Path_1 = require("../util/Path");
var CompleteChildSource_1 = require("./CompleteChildSource");
/**
 * @constructor
 * @struct
 */
var ProcessorResult = /** @class */ (function () {
    /**
     * @param {!ViewCache} viewCache
     * @param {!Array.<!Change>} changes
     */
    function ProcessorResult(viewCache, changes) {
        this.viewCache = viewCache;
        this.changes = changes;
    }
    return ProcessorResult;
}());
exports.ProcessorResult = ProcessorResult;
/**
 * @constructor
 */
var ViewProcessor = /** @class */ (function () {
    /**
     * @param {!NodeFilter} filter_
     */
    function ViewProcessor(filter_) {
        this.filter_ = filter_;
    }
    /**
     * @param {!ViewCache} viewCache
     */
    ViewProcessor.prototype.assertIndexed = function (viewCache) {
        util_1.assert(viewCache
            .getEventCache()
            .getNode()
            .isIndexed(this.filter_.getIndex()), 'Event snap not indexed');
        util_1.assert(viewCache
            .getServerCache()
            .getNode()
            .isIndexed(this.filter_.getIndex()), 'Server snap not indexed');
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @return {!ProcessorResult}
     */
    ViewProcessor.prototype.applyOperation = function (oldViewCache, operation, writesCache, completeCache) {
        var accumulator = new ChildChangeAccumulator_1.ChildChangeAccumulator();
        var newViewCache, filterServerNode;
        if (operation.type === Operation_1.OperationType.OVERWRITE) {
            var overwrite = operation;
            if (overwrite.source.fromUser) {
                newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
            }
            else {
                util_1.assert(overwrite.source.fromServer, 'Unknown source.');
                // We filter the node if it's a tagged update or the node has been previously filtered  and the
                // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered
                // again
                filterServerNode =
                    overwrite.source.tagged ||
                        (oldViewCache.getServerCache().isFiltered() &&
                            !overwrite.path.isEmpty());
                newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
            }
        }
        else if (operation.type === Operation_1.OperationType.MERGE) {
            var merge = operation;
            if (merge.source.fromUser) {
                newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
            }
            else {
                util_1.assert(merge.source.fromServer, 'Unknown source.');
                // We filter the node if it's a tagged update or the node has been previously filtered
                filterServerNode =
                    merge.source.tagged || oldViewCache.getServerCache().isFiltered();
                newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
            }
        }
        else if (operation.type === Operation_1.OperationType.ACK_USER_WRITE) {
            var ackUserWrite = operation;
            if (!ackUserWrite.revert) {
                newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
            }
            else {
                newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
            }
        }
        else if (operation.type === Operation_1.OperationType.LISTEN_COMPLETE) {
            newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);
        }
        else {
            throw util_1.assertionError('Unknown operation type: ' + operation.type);
        }
        var changes = accumulator.getChanges();
        ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);
        return new ProcessorResult(newViewCache, changes);
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!ViewCache} newViewCache
     * @param {!Array.<!Change>} accumulator
     * @private
     */
    ViewProcessor.maybeAddValueEvent_ = function (oldViewCache, newViewCache, accumulator) {
        var eventSnap = newViewCache.getEventCache();
        if (eventSnap.isFullyInitialized()) {
            var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
            var oldCompleteSnap = oldViewCache.getCompleteEventSnap();
            if (accumulator.length > 0 ||
                !oldViewCache.getEventCache().isFullyInitialized() ||
                (isLeafOrEmpty &&
                    !eventSnap
                        .getNode()
                        .equals(/** @type {!Node} */ (oldCompleteSnap))) ||
                !eventSnap
                    .getNode()
                    .getPriority()
                    .equals(oldCompleteSnap.getPriority())) {
                accumulator.push(Change_1.Change.valueChange(
                /** @type {!Node} */ newViewCache.getCompleteEventSnap()));
            }
        }
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} changePath
     * @param {!WriteTreeRef} writesCache
     * @param {!CompleteChildSource} source
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function (viewCache, changePath, writesCache, source, accumulator) {
        var oldEventSnap = viewCache.getEventCache();
        if (writesCache.shadowingWrite(changePath) != null) {
            // we have a shadowing write, ignore changes
            return viewCache;
        }
        else {
            var newEventCache = void 0, serverNode = void 0;
            if (changePath.isEmpty()) {
                // TODO: figure out how this plays with "sliding ack windows"
                util_1.assert(viewCache.getServerCache().isFullyInitialized(), 'If change path is empty, we must have complete server data');
                if (viewCache.getServerCache().isFiltered()) {
                    // We need to special case this, because we need to only apply writes to complete children, or
                    // we might end up raising events for incomplete children. If the server data is filtered deep
                    // writes cannot be guaranteed to be complete
                    var serverCache = viewCache.getCompleteServerSnap();
                    var completeChildren = serverCache instanceof ChildrenNode_1.ChildrenNode
                        ? serverCache
                        : ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                    var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);
                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);
                }
                else {
                    var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);
                }
            }
            else {
                var childKey = changePath.getFront();
                if (childKey == '.priority') {
                    util_1.assert(changePath.getLength() == 1, "Can't have a priority with additional path components");
                    var oldEventNode = oldEventSnap.getNode();
                    serverNode = viewCache.getServerCache().getNode();
                    // we might have overwrites for this priority
                    var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);
                    if (updatedPriority != null) {
                        newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);
                    }
                    else {
                        // priority didn't change, keep old node
                        newEventCache = oldEventSnap.getNode();
                    }
                }
                else {
                    var childChangePath = changePath.popFront();
                    // update child
                    var newEventChild = void 0;
                    if (oldEventSnap.isCompleteForChild(childKey)) {
                        serverNode = viewCache.getServerCache().getNode();
                        var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);
                        if (eventChildUpdate != null) {
                            newEventChild = oldEventSnap
                                .getNode()
                                .getImmediateChild(childKey)
                                .updateChild(childChangePath, eventChildUpdate);
                        }
                        else {
                            // Nothing changed, just keep the old child
                            newEventChild = oldEventSnap
                                .getNode()
                                .getImmediateChild(childKey);
                        }
                    }
                    else {
                        newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());
                    }
                    if (newEventChild != null) {
                        newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
                    }
                    else {
                        // no complete child available or no change
                        newEventCache = oldEventSnap.getNode();
                    }
                }
            }
            return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());
        }
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!Path} changePath
     * @param {!Node} changedSnap
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {boolean} filterServerNode
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyServerOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
        var oldServerSnap = oldViewCache.getServerCache();
        var newServerCache;
        var serverFilter = filterServerNode
            ? this.filter_
            : this.filter_.getIndexedFilter();
        if (changePath.isEmpty()) {
            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
        }
        else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
            // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update
            var newServerNode = oldServerSnap
                .getNode()
                .updateChild(changePath, changedSnap);
            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
        }
        else {
            var childKey = changePath.getFront();
            if (!oldServerSnap.isCompleteForPath(changePath) &&
                changePath.getLength() > 1) {
                // We don't update incomplete nodes with updates intended for other listeners
                return oldViewCache;
            }
            var childChangePath = changePath.popFront();
            var childNode = oldServerSnap.getNode().getImmediateChild(childKey);
            var newChildNode = childNode.updateChild(childChangePath, changedSnap);
            if (childKey == '.priority') {
                newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
            }
            else {
                newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, null);
            }
        }
        var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());
        var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);
        return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!Path} changePath
     * @param {!Node} changedSnap
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyUserOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
        var oldEventSnap = oldViewCache.getEventCache();
        var newViewCache, newEventCache;
        var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
        if (changePath.isEmpty()) {
            newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);
            newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());
        }
        else {
            var childKey = changePath.getFront();
            if (childKey === '.priority') {
                newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);
                newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
            }
            else {
                var childChangePath = changePath.popFront();
                var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
                var newChild = void 0;
                if (childChangePath.isEmpty()) {
                    // Child overwrite, we can replace the child
                    newChild = changedSnap;
                }
                else {
                    var childNode = source.getCompleteChild(childKey);
                    if (childNode != null) {
                        if (childChangePath.getBack() === '.priority' &&
                            childNode.getChild(childChangePath.parent()).isEmpty()) {
                            // This is a priority update on an empty node. If this node exists on the server, the
                            // server will send down the priority in the update, so ignore for now
                            newChild = childNode;
                        }
                        else {
                            newChild = childNode.updateChild(childChangePath, changedSnap);
                        }
                    }
                    else {
                        // There is no complete child node available
                        newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                    }
                }
                if (!oldChild.equals(newChild)) {
                    var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
                    newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());
                }
                else {
                    newViewCache = oldViewCache;
                }
            }
        }
        return newViewCache;
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {string} childKey
     * @return {boolean}
     * @private
     */
    ViewProcessor.cacheHasChild_ = function (viewCache, childKey) {
        return viewCache.getEventCache().isCompleteForChild(childKey);
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {ImmutableTree.<!Node>} changedChildren
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyUserMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
        var _this = this;
        // HACK: In the case of a limit query, there may be some changes that bump things out of the
        // window leaving room for new items.  It's important we process these changes first, so we
        // iterate the changes twice, first processing any that affect items currently in view.
        // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
        // not the other.
        var curViewCache = viewCache;
        changedChildren.foreach(function (relativePath, childNode) {
            var writePath = path.child(relativePath);
            if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {
                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
            }
        });
        changedChildren.foreach(function (relativePath, childNode) {
            var writePath = path.child(relativePath);
            if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {
                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
            }
        });
        return curViewCache;
    };
    /**
     * @param {!Node} node
     * @param {ImmutableTree.<!Node>} merge
     * @return {!Node}
     * @private
     */
    ViewProcessor.prototype.applyMerge_ = function (node, merge) {
        merge.foreach(function (relativePath, childNode) {
            node = node.updateChild(relativePath, childNode);
        });
        return node;
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!ImmutableTree.<!Node>} changedChildren
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache
     * @param {boolean} filterServerNode
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyServerMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
        var _this = this;
        // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and
        // wait for the complete data update coming soon.
        if (viewCache
            .getServerCache()
            .getNode()
            .isEmpty() &&
            !viewCache.getServerCache().isFullyInitialized()) {
            return viewCache;
        }
        // HACK: In the case of a limit query, there may be some changes that bump things out of the
        // window leaving room for new items.  It's important we process these changes first, so we
        // iterate the changes twice, first processing any that affect items currently in view.
        // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
        // not the other.
        var curViewCache = viewCache;
        var viewMergeTree;
        if (path.isEmpty()) {
            viewMergeTree = changedChildren;
        }
        else {
            viewMergeTree = ImmutableTree_1.ImmutableTree.Empty.setTree(path, changedChildren);
        }
        var serverNode = viewCache.getServerCache().getNode();
        viewMergeTree.children.inorderTraversal(function (childKey, childTree) {
            if (serverNode.hasChild(childKey)) {
                var serverChild = viewCache
                    .getServerCache()
                    .getNode()
                    .getImmediateChild(childKey);
                var newChild = _this.applyMerge_(serverChild, childTree);
                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
            }
        });
        viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) {
            var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey) &&
                childMergeTree.value == null;
            if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
                var serverChild = viewCache
                    .getServerCache()
                    .getNode()
                    .getImmediateChild(childKey);
                var newChild = _this.applyMerge_(serverChild, childMergeTree);
                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
            }
        });
        return curViewCache;
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} ackPath
     * @param {!ImmutableTree<!boolean>} affectedTree
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.ackUserWrite_ = function (viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
        if (writesCache.shadowingWrite(ackPath) != null) {
            return viewCache;
        }
        // Only filter server node if it is currently filtered
        var filterServerNode = viewCache.getServerCache().isFiltered();
        // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update
        // now that it won't be shadowed.
        var serverCache = viewCache.getServerCache();
        if (affectedTree.value != null) {
            // This is an overwrite.
            if ((ackPath.isEmpty() && serverCache.isFullyInitialized()) ||
                serverCache.isCompleteForPath(ackPath)) {
                return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
            }
            else if (ackPath.isEmpty()) {
                // This is a goofy edge case where we are acking data at this location but don't have full data.  We
                // should just re-apply whatever we have in our cache as a merge.
                var changedChildren_1 = ImmutableTree_1.ImmutableTree.Empty;
                serverCache.getNode().forEachChild(KeyIndex_1.KEY_INDEX, function (name, node) {
                    changedChildren_1 = changedChildren_1.set(new Path_1.Path(name), node);
                });
                return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);
            }
            else {
                return viewCache;
            }
        }
        else {
            // This is a merge.
            var changedChildren_2 = ImmutableTree_1.ImmutableTree.Empty;
            affectedTree.foreach(function (mergePath, value) {
                var serverCachePath = ackPath.child(mergePath);
                if (serverCache.isCompleteForPath(serverCachePath)) {
                    changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));
                }
            });
            return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);
        }
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!WriteTreeRef} writesCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.listenComplete_ = function (viewCache, path, writesCache, accumulator) {
        var oldServerNode = viewCache.getServerCache();
        var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());
        return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, accumulator);
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeServerCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.revertUserWrite_ = function (viewCache, path, writesCache, completeServerCache, accumulator) {
        var complete;
        if (writesCache.shadowingWrite(path) != null) {
            return viewCache;
        }
        else {
            var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
            var oldEventCache = viewCache.getEventCache().getNode();
            var newEventCache = void 0;
            if (path.isEmpty() || path.getFront() === '.priority') {
                var newNode = void 0;
                if (viewCache.getServerCache().isFullyInitialized()) {
                    newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                }
                else {
                    var serverChildren = viewCache.getServerCache().getNode();
                    util_1.assert(serverChildren instanceof ChildrenNode_1.ChildrenNode, 'serverChildren would be complete if leaf node');
                    newNode = writesCache.calcCompleteEventChildren(serverChildren);
                }
                newNode = newNode;
                newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);
            }
            else {
                var childKey = path.getFront();
                var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());
                if (newChild == null &&
                    viewCache.getServerCache().isCompleteForChild(childKey)) {
                    newChild = oldEventCache.getImmediateChild(childKey);
                }
                if (newChild != null) {
                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator);
                }
                else if (viewCache
                    .getEventCache()
                    .getNode()
                    .hasChild(childKey)) {
                    // No complete child available, delete the existing one, if any
                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, ChildrenNode_1.ChildrenNode.EMPTY_NODE, path.popFront(), source, accumulator);
                }
                else {
                    newEventCache = oldEventCache;
                }
                if (newEventCache.isEmpty() &&
                    viewCache.getServerCache().isFullyInitialized()) {
                    // We might have reverted all child writes. Maybe the old event was a leaf node
                    complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                    if (complete.isLeafNode()) {
                        newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);
                    }
                }
            }
            complete =
                viewCache.getServerCache().isFullyInitialized() ||
                    writesCache.shadowingWrite(Path_1.Path.Empty) != null;
            return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());
        }
    };
    return ViewProcessor;
}());
exports.ViewProcessor = ViewProcessor;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/ViewProcessor.js","/node_modules/@firebase/database/dist/cjs/src/core/view")

},{"../operation/Operation":30,"../snap/ChildrenNode":32,"../snap/indexes/KeyIndex":39,"../util/ImmutableTree":54,"../util/Path":57,"./Change":66,"./ChildChangeAccumulator":67,"./CompleteChildSource":68,"@firebase/util":134,"_process":162,"buffer":160}],77:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var Change_1 = require("../Change");
var ChildrenNode_1 = require("../../snap/ChildrenNode");
var PriorityIndex_1 = require("../../snap/indexes/PriorityIndex");
/**
 * Doesn't really filter nodes but applies an index to the node and keeps track of any changes
 *
 * @constructor
 * @implements {NodeFilter}
 * @param {!Index} index
 */
var IndexedFilter = /** @class */ (function () {
    function IndexedFilter(index_) {
        this.index_ = index_;
    }
    IndexedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        util_1.assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');
        var oldChild = snap.getImmediateChild(key);
        // Check if anything actually changed.
        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {
            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.
            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need
            // to avoid treating these cases as "nothing changed."
            if (oldChild.isEmpty() == newChild.isEmpty()) {
                // Nothing changed.
                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.
                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');
                return snap;
            }
        }
        if (optChangeAccumulator != null) {
            if (newChild.isEmpty()) {
                if (snap.hasChild(key)) {
                    optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, oldChild));
                }
                else {
                    util_1.assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');
                }
            }
            else if (oldChild.isEmpty()) {
                optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, newChild));
            }
            else {
                optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, newChild, oldChild));
            }
        }
        if (snap.isLeafNode() && newChild.isEmpty()) {
            return snap;
        }
        else {
            // Make sure the node is indexed
            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
        }
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        if (optChangeAccumulator != null) {
            if (!oldSnap.isLeafNode()) {
                oldSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
                    if (!newSnap.hasChild(key)) {
                        optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, childNode));
                    }
                });
            }
            if (!newSnap.isLeafNode()) {
                newSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
                    if (oldSnap.hasChild(key)) {
                        var oldChild = oldSnap.getImmediateChild(key);
                        if (!oldChild.equals(childNode)) {
                            optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, childNode, oldChild));
                        }
                    }
                    else {
                        optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, childNode));
                    }
                });
            }
        }
        return newSnap.withIndex(this.index_);
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        if (oldSnap.isEmpty()) {
            return ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        }
        else {
            return oldSnap.updatePriority(newPriority);
        }
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.filtersNodes = function () {
        return false;
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.getIndexedFilter = function () {
        return this;
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    return IndexedFilter;
}());
exports.IndexedFilter = IndexedFilter;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/filter/IndexedFilter.js","/node_modules/@firebase/database/dist/cjs/src/core/view/filter")

},{"../../snap/ChildrenNode":32,"../../snap/indexes/PriorityIndex":41,"../Change":66,"@firebase/util":134,"_process":162,"buffer":160}],78:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var RangedFilter_1 = require("./RangedFilter");
var ChildrenNode_1 = require("../../snap/ChildrenNode");
var Node_1 = require("../../snap/Node");
var util_1 = require("@firebase/util");
var Change_1 = require("../Change");
/**
 * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible
 *
 * @constructor
 * @implements {NodeFilter}
 */
var LimitedFilter = /** @class */ (function () {
    /**
     * @param {!QueryParams} params
     */
    function LimitedFilter(params) {
        this.rangedFilter_ = new RangedFilter_1.RangedFilter(params);
        this.index_ = params.getIndex();
        this.limit_ = params.getLimit();
        this.reverse_ = !params.isViewFromLeft();
    }
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.rangedFilter_.matches(new Node_1.NamedNode(key, newChild))) {
            newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        }
        if (snap.getImmediateChild(key).equals(newChild)) {
            // No change
            return snap;
        }
        else if (snap.numChildren() < this.limit_) {
            return this.rangedFilter_
                .getIndexedFilter()
                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
        }
        else {
            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
        }
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        var filtered;
        if (newSnap.isLeafNode() || newSnap.isEmpty()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            filtered = ChildrenNode_1.ChildrenNode.EMPTY_NODE.withIndex(this.index_);
        }
        else {
            if (this.limit_ * 2 < newSnap.numChildren() &&
                newSnap.isIndexed(this.index_)) {
                // Easier to build up a snapshot, since what we're given has more than twice the elements we want
                filtered = ChildrenNode_1.ChildrenNode.EMPTY_NODE.withIndex(this.index_);
                // anchor to the startPost, endPost, or last element as appropriate
                var iterator = void 0;
                if (this.reverse_) {
                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
                }
                else {
                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
                }
                var count = 0;
                while (iterator.hasNext() && count < this.limit_) {
                    var next = iterator.getNext();
                    var inRange = void 0;
                    if (this.reverse_) {
                        inRange =
                            this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;
                    }
                    else {
                        inRange =
                            this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;
                    }
                    if (inRange) {
                        filtered = filtered.updateImmediateChild(next.name, next.node);
                        count++;
                    }
                    else {
                        // if we have reached the end post, we cannot keep adding elemments
                        break;
                    }
                }
            }
            else {
                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one
                filtered = newSnap.withIndex(this.index_);
                // Don't support priorities on queries
                filtered = filtered.updatePriority(ChildrenNode_1.ChildrenNode.EMPTY_NODE);
                var startPost = void 0;
                var endPost = void 0;
                var cmp = void 0;
                var iterator = void 0;
                if (this.reverse_) {
                    iterator = filtered.getReverseIterator(this.index_);
                    startPost = this.rangedFilter_.getEndPost();
                    endPost = this.rangedFilter_.getStartPost();
                    var indexCompare_1 = this.index_.getCompare();
                    cmp = function (a, b) { return indexCompare_1(b, a); };
                }
                else {
                    iterator = filtered.getIterator(this.index_);
                    startPost = this.rangedFilter_.getStartPost();
                    endPost = this.rangedFilter_.getEndPost();
                    cmp = this.index_.getCompare();
                }
                var count = 0;
                var foundStartPost = false;
                while (iterator.hasNext()) {
                    var next = iterator.getNext();
                    if (!foundStartPost && cmp(startPost, next) <= 0) {
                        // start adding
                        foundStartPost = true;
                    }
                    var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;
                    if (inRange) {
                        count++;
                    }
                    else {
                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode_1.ChildrenNode.EMPTY_NODE);
                    }
                }
            }
        }
        return this.rangedFilter_
            .getIndexedFilter()
            .updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.filtersNodes = function () {
        return true;
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.getIndexedFilter = function () {
        return this.rangedFilter_.getIndexedFilter();
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    /**
     * @param {!Node} snap
     * @param {string} childKey
     * @param {!Node} childSnap
     * @param {!CompleteChildSource} source
     * @param {?ChildChangeAccumulator} changeAccumulator
     * @return {!Node}
     * @private
     */
    LimitedFilter.prototype.fullLimitUpdateChild_ = function (snap, childKey, childSnap, source, changeAccumulator) {
        // TODO: rename all cache stuff etc to general snap terminology
        var cmp;
        if (this.reverse_) {
            var indexCmp_1 = this.index_.getCompare();
            cmp = function (a, b) { return indexCmp_1(b, a); };
        }
        else {
            cmp = this.index_.getCompare();
        }
        var oldEventCache = snap;
        util_1.assert(oldEventCache.numChildren() == this.limit_, '');
        var newChildNamedNode = new Node_1.NamedNode(childKey, childSnap);
        var windowBoundary = this.reverse_
            ? oldEventCache.getFirstChild(this.index_)
            : oldEventCache.getLastChild(this.index_);
        var inRange = this.rangedFilter_.matches(newChildNamedNode);
        if (oldEventCache.hasChild(childKey)) {
            var oldChildSnap = oldEventCache.getImmediateChild(childKey);
            var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
            while (nextChild != null &&
                (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))) {
                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't
                // been applied to the limited filter yet. Ignore this next child which will be updated later in
                // the limited filter...
                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
            }
            var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
            var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
            if (remainsInWindow) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(Change_1.Change.childChangedChange(childKey, childSnap, oldChildSnap));
                }
                return oldEventCache.updateImmediateChild(childKey, childSnap);
            }
            else {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(childKey, oldChildSnap));
                }
                var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode_1.ChildrenNode.EMPTY_NODE);
                var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
                if (nextChildInRange) {
                    if (changeAccumulator != null) {
                        changeAccumulator.trackChildChange(Change_1.Change.childAddedChange(nextChild.name, nextChild.node));
                    }
                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
                }
                else {
                    return newEventCache;
                }
            }
        }
        else if (childSnap.isEmpty()) {
            // we're deleting a node, but it was not in the window, so ignore it
            return snap;
        }
        else if (inRange) {
            if (cmp(windowBoundary, newChildNamedNode) >= 0) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(windowBoundary.name, windowBoundary.node));
                    changeAccumulator.trackChildChange(Change_1.Change.childAddedChange(childKey, childSnap));
                }
                return oldEventCache
                    .updateImmediateChild(childKey, childSnap)
                    .updateImmediateChild(windowBoundary.name, ChildrenNode_1.ChildrenNode.EMPTY_NODE);
            }
            else {
                return snap;
            }
        }
        else {
            return snap;
        }
    };
    return LimitedFilter;
}());
exports.LimitedFilter = LimitedFilter;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/filter/LimitedFilter.js","/node_modules/@firebase/database/dist/cjs/src/core/view/filter")

},{"../../snap/ChildrenNode":32,"../../snap/Node":35,"../Change":66,"./RangedFilter":79,"@firebase/util":134,"_process":162,"buffer":160}],79:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var IndexedFilter_1 = require("./IndexedFilter");
var PriorityIndex_1 = require("../../snap/indexes/PriorityIndex");
var Node_1 = require("../../../core/snap/Node");
var ChildrenNode_1 = require("../../snap/ChildrenNode");
/**
 * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node
 *
 * @constructor
 * @implements {NodeFilter}
 */
var RangedFilter = /** @class */ (function () {
    /**
     * @param {!QueryParams} params
     */
    function RangedFilter(params) {
        this.indexedFilter_ = new IndexedFilter_1.IndexedFilter(params.getIndex());
        this.index_ = params.getIndex();
        this.startPost_ = RangedFilter.getStartPost_(params);
        this.endPost_ = RangedFilter.getEndPost_(params);
    }
    /**
     * @return {!NamedNode}
     */
    RangedFilter.prototype.getStartPost = function () {
        return this.startPost_;
    };
    /**
     * @return {!NamedNode}
     */
    RangedFilter.prototype.getEndPost = function () {
        return this.endPost_;
    };
    /**
     * @param {!NamedNode} node
     * @return {boolean}
     */
    RangedFilter.prototype.matches = function (node) {
        return (this.index_.compare(this.getStartPost(), node) <= 0 &&
            this.index_.compare(node, this.getEndPost()) <= 0);
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.matches(new Node_1.NamedNode(key, newChild))) {
            newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        }
        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        if (newSnap.isLeafNode()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            newSnap = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        }
        var filtered = newSnap.withIndex(this.index_);
        // Don't support priorities on queries
        filtered = filtered.updatePriority(ChildrenNode_1.ChildrenNode.EMPTY_NODE);
        var self = this;
        newSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
            if (!self.matches(new Node_1.NamedNode(key, childNode))) {
                filtered = filtered.updateImmediateChild(key, ChildrenNode_1.ChildrenNode.EMPTY_NODE);
            }
        });
        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.filtersNodes = function () {
        return true;
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.getIndexedFilter = function () {
        return this.indexedFilter_;
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    /**
     * @param {!QueryParams} params
     * @return {!NamedNode}
     * @private
     */
    RangedFilter.getStartPost_ = function (params) {
        if (params.hasStart()) {
            var startName = params.getIndexStartName();
            return params.getIndex().makePost(params.getIndexStartValue(), startName);
        }
        else {
            return params.getIndex().minPost();
        }
    };
    /**
     * @param {!QueryParams} params
     * @return {!NamedNode}
     * @private
     */
    RangedFilter.getEndPost_ = function (params) {
        if (params.hasEnd()) {
            var endName = params.getIndexEndName();
            return params.getIndex().makePost(params.getIndexEndValue(), endName);
        }
        else {
            return params.getIndex().maxPost();
        }
    };
    return RangedFilter;
}());
exports.RangedFilter = RangedFilter;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/core/view/filter/RangedFilter.js","/node_modules/@firebase/database/dist/cjs/src/core/view/filter")

},{"../../../core/snap/Node":35,"../../snap/ChildrenNode":32,"../../snap/indexes/PriorityIndex":41,"./IndexedFilter":77,"_process":162,"buffer":160}],80:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../core/util/util");
var CountedSet_1 = require("../core/util/CountedSet");
var StatsManager_1 = require("../core/stats/StatsManager");
var PacketReceiver_1 = require("./polling/PacketReceiver");
var Constants_1 = require("./Constants");
var util_2 = require("@firebase/util");
var util_3 = require("@firebase/util");
// URL query parameters associated with longpolling
exports.FIREBASE_LONGPOLL_START_PARAM = 'start';
exports.FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';
exports.FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';
exports.FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';
exports.FIREBASE_LONGPOLL_ID_PARAM = 'id';
exports.FIREBASE_LONGPOLL_PW_PARAM = 'pw';
exports.FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';
exports.FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';
exports.FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';
exports.FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';
exports.FIREBASE_LONGPOLL_DATA_PARAM = 'd';
exports.FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = 'disconn';
exports.FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';
//Data size constants.
//TODO: Perf: the maximum length actually differs from browser to browser.
// We should check what browser we're on and set accordingly.
var MAX_URL_DATA_SIZE = 1870;
var SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=
var MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
/**
 * Keepalive period
 * send a fresh request at minimum every 25 seconds. Opera has a maximum request
 * length of 30 seconds that we can't exceed.
 * @const
 * @type {number}
 */
var KEEPALIVE_REQUEST_INTERVAL = 25000;
/**
 * How long to wait before aborting a long-polling connection attempt.
 * @const
 * @type {number}
 */
var LP_CONNECT_TIMEOUT = 30000;
/**
 * This class manages a single long-polling connection.
 *
 * @constructor
 * @implements {Transport}
 */
var BrowserPollConnection = /** @class */ (function () {
    /**
     * @param {string} connId An identifier for this connection, used for logging
     * @param {RepoInfo} repoInfo The info for the endpoint to send data to.
     * @param {string=} transportSessionId Optional transportSessionid if we are reconnecting for an existing
     *                                         transport session
     * @param {string=}  lastSessionId Optional lastSessionId if the PersistentConnection has already created a
     *                                     connection previously
     */
    function BrowserPollConnection(connId, repoInfo, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.repoInfo = repoInfo;
        this.transportSessionId = transportSessionId;
        this.lastSessionId = lastSessionId;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.everConnected_ = false;
        this.log_ = util_1.logWrapper(connId);
        this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo);
        this.urlFn = function (params) {
            return repoInfo.connectionURL(Constants_1.LONG_POLLING, params);
        };
    }
    /**
     *
     * @param {function(Object)} onMessage Callback when messages arrive
     * @param {function()} onDisconnect Callback with connection lost.
     */
    BrowserPollConnection.prototype.open = function (onMessage, onDisconnect) {
        var _this = this;
        this.curSegmentNum = 0;
        this.onDisconnect_ = onDisconnect;
        this.myPacketOrderer = new PacketReceiver_1.PacketReceiver(onMessage);
        this.isClosed_ = false;
        this.connectTimeoutTimer_ = setTimeout(function () {
            _this.log_('Timed out trying to connect.');
            // Make sure we clear the host cache
            _this.onClosed_();
            _this.connectTimeoutTimer_ = null;
        }, Math.floor(LP_CONNECT_TIMEOUT));
        // Ensure we delay the creation of the iframe until the DOM is loaded.
        util_1.executeWhenDOMReady(function () {
            if (_this.isClosed_)
                return;
            //Set up a callback that gets triggered once a connection is set up.
            _this.scriptTagHolder = new FirebaseIFrameScriptHolder(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var command = args[0], arg1 = args[1], arg2 = args[2], arg3 = args[3], arg4 = args[4];
                _this.incrementIncomingBytes_(args);
                if (!_this.scriptTagHolder)
                    return; // we closed the connection.
                if (_this.connectTimeoutTimer_) {
                    clearTimeout(_this.connectTimeoutTimer_);
                    _this.connectTimeoutTimer_ = null;
                }
                _this.everConnected_ = true;
                if (command == exports.FIREBASE_LONGPOLL_START_PARAM) {
                    _this.id = arg1;
                    _this.password = arg2;
                }
                else if (command === exports.FIREBASE_LONGPOLL_CLOSE_COMMAND) {
                    // Don't clear the host cache. We got a response from the server, so we know it's reachable
                    if (arg1) {
                        // We aren't expecting any more data (other than what the server's already in the process of sending us
                        // through our already open polls), so don't send any more.
                        _this.scriptTagHolder.sendNewPolls = false;
                        // arg1 in this case is the last response number sent by the server. We should try to receive
                        // all of the responses up to this one before closing
                        _this.myPacketOrderer.closeAfter(arg1, function () {
                            _this.onClosed_();
                        });
                    }
                    else {
                        _this.onClosed_();
                    }
                }
                else {
                    throw new Error('Unrecognized command received: ' + command);
                }
            }, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var pN = args[0], data = args[1];
                _this.incrementIncomingBytes_(args);
                _this.myPacketOrderer.handleResponse(pN, data);
            }, function () {
                _this.onClosed_();
            }, _this.urlFn);
            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results
            //from cache.
            var urlParams = {};
            urlParams[exports.FIREBASE_LONGPOLL_START_PARAM] = 't';
            urlParams[exports.FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);
            if (_this.scriptTagHolder.uniqueCallbackIdentifier)
                urlParams[exports.FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = _this.scriptTagHolder.uniqueCallbackIdentifier;
            urlParams[Constants_1.VERSION_PARAM] = Constants_1.PROTOCOL_VERSION;
            if (_this.transportSessionId) {
                urlParams[Constants_1.TRANSPORT_SESSION_PARAM] = _this.transportSessionId;
            }
            if (_this.lastSessionId) {
                urlParams[Constants_1.LAST_SESSION_PARAM] = _this.lastSessionId;
            }
            if (!util_3.isNodeSdk() &&
                typeof location !== 'undefined' &&
                location.href &&
                location.href.indexOf(Constants_1.FORGE_DOMAIN) !== -1) {
                urlParams[Constants_1.REFERER_PARAM] = Constants_1.FORGE_REF;
            }
            var connectURL = _this.urlFn(urlParams);
            _this.log_('Connecting via long-poll to ' + connectURL);
            _this.scriptTagHolder.addTag(connectURL, function () {
                /* do nothing */
            });
        });
    };
    /**
     * Call this when a handshake has completed successfully and we want to consider the connection established
     */
    BrowserPollConnection.prototype.start = function () {
        this.scriptTagHolder.startLongPoll(this.id, this.password);
        this.addDisconnectPingFrame(this.id, this.password);
    };
    /**
     * Forces long polling to be considered as a potential transport
     */
    BrowserPollConnection.forceAllow = function () {
        BrowserPollConnection.forceAllow_ = true;
    };
    /**
     * Forces longpolling to not be considered as a potential transport
     */
    BrowserPollConnection.forceDisallow = function () {
        BrowserPollConnection.forceDisallow_ = true;
    };
    // Static method, use string literal so it can be accessed in a generic way
    BrowserPollConnection.isAvailable = function () {
        // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in
        // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).
        return (BrowserPollConnection.forceAllow_ ||
            (!BrowserPollConnection.forceDisallow_ &&
                typeof document !== 'undefined' &&
                document.createElement != null &&
                !util_1.isChromeExtensionContentScript() &&
                !util_1.isWindowsStoreApp() &&
                !util_3.isNodeSdk()));
    };
    /**
     * No-op for polling
     */
    BrowserPollConnection.prototype.markConnectionHealthy = function () { };
    /**
     * Stops polling and cleans up the iframe
     * @private
     */
    BrowserPollConnection.prototype.shutdown_ = function () {
        this.isClosed_ = true;
        if (this.scriptTagHolder) {
            this.scriptTagHolder.close();
            this.scriptTagHolder = null;
        }
        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.
        if (this.myDisconnFrame) {
            document.body.removeChild(this.myDisconnFrame);
            this.myDisconnFrame = null;
        }
        if (this.connectTimeoutTimer_) {
            clearTimeout(this.connectTimeoutTimer_);
            this.connectTimeoutTimer_ = null;
        }
    };
    /**
     * Triggered when this transport is closed
     * @private
     */
    BrowserPollConnection.prototype.onClosed_ = function () {
        if (!this.isClosed_) {
            this.log_('Longpoll is closing itself');
            this.shutdown_();
            if (this.onDisconnect_) {
                this.onDisconnect_(this.everConnected_);
                this.onDisconnect_ = null;
            }
        }
    };
    /**
     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server
     * that we've left.
     */
    BrowserPollConnection.prototype.close = function () {
        if (!this.isClosed_) {
            this.log_('Longpoll is being closed.');
            this.shutdown_();
        }
    };
    /**
     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then
     * broken into chunks (since URLs have a small maximum length).
     * @param {!Object} data The JSON data to transmit.
     */
    BrowserPollConnection.prototype.send = function (data) {
        var dataStr = util_2.stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //first, lets get the base64-encoded data
        var base64data = util_2.base64Encode(dataStr);
        //We can only fit a certain amount in each URL, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        var dataSegs = util_1.splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number
        //of segments so that we can reassemble the packet on the server.
        for (var i = 0; i < dataSegs.length; i++) {
            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
            this.curSegmentNum++;
        }
    };
    /**
     * This is how we notify the server that we're leaving.
     * We aren't able to send requests with DHTML on a window close event, but we can
     * trigger XHR requests in some browsers (everything but Opera basically).
     * @param {!string} id
     * @param {!string} pw
     */
    BrowserPollConnection.prototype.addDisconnectPingFrame = function (id, pw) {
        if (util_3.isNodeSdk())
            return;
        this.myDisconnFrame = document.createElement('iframe');
        var urlParams = {};
        urlParams[exports.FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';
        urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = id;
        urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = pw;
        this.myDisconnFrame.src = this.urlFn(urlParams);
        this.myDisconnFrame.style.display = 'none';
        document.body.appendChild(this.myDisconnFrame);
    };
    /**
     * Used to track the bytes received by this client
     * @param {*} args
     * @private
     */
    BrowserPollConnection.prototype.incrementIncomingBytes_ = function (args) {
        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.
        var bytesReceived = util_2.stringify(args).length;
        this.bytesReceived += bytesReceived;
        this.stats_.incrementCounter('bytes_received', bytesReceived);
    };
    return BrowserPollConnection;
}());
exports.BrowserPollConnection = BrowserPollConnection;
/*********************************************************************************************
 * A wrapper around an iframe that is used as a long-polling script holder.
 * @constructor
 *********************************************************************************************/
var FirebaseIFrameScriptHolder = /** @class */ (function () {
    /**
     * @param commandCB - The callback to be called when control commands are recevied from the server.
     * @param onMessageCB - The callback to be triggered when responses arrive from the server.
     * @param onDisconnect - The callback to be triggered when this tag holder is closed
     * @param urlFn - A function that provides the URL of the endpoint to send data to.
     */
    function FirebaseIFrameScriptHolder(commandCB, onMessageCB, onDisconnect, urlFn) {
        this.onDisconnect = onDisconnect;
        this.urlFn = urlFn;
        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause
        //problems in some browsers.
        /**
         * @type {CountedSet.<number, number>}
         */
        this.outstandingRequests = new CountedSet_1.CountedSet();
        //A queue of the pending segments waiting for transmission to the server.
        this.pendingSegs = [];
        //A serial number. We use this for two things:
        // 1) A way to ensure the browser doesn't cache responses to polls
        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The
        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute
        //    JSONP code in the order it was added to the iframe.
        this.currentSerial = Math.floor(Math.random() * 100000000);
        // This gets set to false when we're "closing down" the connection (e.g. we're switching transports but there's still
        // incoming data from the server that we're waiting for).
        this.sendNewPolls = true;
        if (!util_3.isNodeSdk()) {
            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the
            //iframes where we put the long-polling script tags. We have two callbacks:
            //   1) Command Callback - Triggered for control issues, like starting a connection.
            //   2) Message Callback - Triggered when new data arrives.
            this.uniqueCallbackIdentifier = util_1.LUIDGenerator();
            window[exports.FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
            window[exports.FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;
            //Create an iframe for us to add script tags to.
            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();
            // Set the iframe's contents.
            var script = '';
            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient
            // for ie9, but ie8 needs to do it again in the document itself.
            if (this.myIFrame.src &&
                this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {
                var currentDomain = document.domain;
                script = '<script>document.domain="' + currentDomain + '";</script>';
            }
            var iframeContents = '<html><body>' + script + '</body></html>';
            try {
                this.myIFrame.doc.open();
                this.myIFrame.doc.write(iframeContents);
                this.myIFrame.doc.close();
            }
            catch (e) {
                util_1.log('frame writing exception');
                if (e.stack) {
                    util_1.log(e.stack);
                }
                util_1.log(e);
            }
        }
        else {
            this.commandCB = commandCB;
            this.onMessageCB = onMessageCB;
        }
    }
    /**
     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can
     * actually use.
     * @private
     * @return {Element}
     */
    FirebaseIFrameScriptHolder.createIFrame_ = function () {
        var iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        // This is necessary in order to initialize the document inside the iframe
        if (document.body) {
            document.body.appendChild(iframe);
            try {
                // If document.domain has been modified in IE, this will throw an error, and we need to set the
                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute
                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.
                var a = iframe.contentWindow.document;
                if (!a) {
                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.
                    util_1.log('No IE domain setting required');
                }
            }
            catch (e) {
                var domain = document.domain;
                iframe.src =
                    "javascript:void((function(){document.open();document.domain='" +
                        domain +
                        "';document.close();})())";
            }
        }
        else {
            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this
            // never gets hit.
            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';
        }
        // Get the document of the iframe in a browser-specific way.
        if (iframe.contentDocument) {
            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari
        }
        else if (iframe.contentWindow) {
            iframe.doc = iframe.contentWindow.document; // Internet Explorer
        }
        else if (iframe.document) {
            iframe.doc = iframe.document; //others?
        }
        return iframe;
    };
    /**
     * Cancel all outstanding queries and remove the frame.
     */
    FirebaseIFrameScriptHolder.prototype.close = function () {
        var _this = this;
        //Mark this iframe as dead, so no new requests are sent.
        this.alive = false;
        if (this.myIFrame) {
            //We have to actually remove all of the html inside this iframe before removing it from the
            //window, or IE will continue loading and executing the script tags we've already added, which
            //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.
            this.myIFrame.doc.body.innerHTML = '';
            setTimeout(function () {
                if (_this.myIFrame !== null) {
                    document.body.removeChild(_this.myIFrame);
                    _this.myIFrame = null;
                }
            }, Math.floor(0));
        }
        if (util_3.isNodeSdk() && this.myID) {
            var urlParams = {};
            urlParams[exports.FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM] = 't';
            urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
            urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
            var theURL = this.urlFn(urlParams);
            FirebaseIFrameScriptHolder.nodeRestRequest(theURL);
        }
        // Protect from being called recursively.
        var onDisconnect = this.onDisconnect;
        if (onDisconnect) {
            this.onDisconnect = null;
            onDisconnect();
        }
    };
    /**
     * Actually start the long-polling session by adding the first script tag(s) to the iframe.
     * @param {!string} id - The ID of this connection
     * @param {!string} pw - The password for this connection
     */
    FirebaseIFrameScriptHolder.prototype.startLongPoll = function (id, pw) {
        this.myID = id;
        this.myPW = pw;
        this.alive = true;
        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.
        while (this.newRequest_()) { }
    };
    /**
     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't
     * too many outstanding requests and we are still alive.
     *
     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if
     * needed.
     */
    FirebaseIFrameScriptHolder.prototype.newRequest_ = function () {
        // We keep one outstanding request open all the time to receive data, but if we need to send data
        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically
        // close the old request.
        if (this.alive &&
            this.sendNewPolls &&
            this.outstandingRequests.count() < (this.pendingSegs.length > 0 ? 2 : 1)) {
            //construct our url
            this.currentSerial++;
            var urlParams = {};
            urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
            urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
            urlParams[exports.FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
            var theURL = this.urlFn(urlParams);
            //Now add as much data as we can.
            var curDataString = '';
            var i = 0;
            while (this.pendingSegs.length > 0) {
                //first, lets see if the next segment will fit.
                var nextSeg = this.pendingSegs[0];
                if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <=
                    MAX_URL_DATA_SIZE) {
                    //great, the segment will fit. Lets append it.
                    var theSeg = this.pendingSegs.shift();
                    curDataString =
                        curDataString +
                            '&' +
                            exports.FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +
                            i +
                            '=' +
                            theSeg.seg +
                            '&' +
                            exports.FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +
                            i +
                            '=' +
                            theSeg.ts +
                            '&' +
                            exports.FIREBASE_LONGPOLL_DATA_PARAM +
                            i +
                            '=' +
                            theSeg.d;
                    i++;
                }
                else {
                    break;
                }
            }
            theURL = theURL + curDataString;
            this.addLongPollTag_(theURL, this.currentSerial);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Queue a packet for transmission to the server.
     * @param segnum - A sequential id for this packet segment used for reassembly
     * @param totalsegs - The total number of segments in this packet
     * @param data - The data for this segment.
     */
    FirebaseIFrameScriptHolder.prototype.enqueueSegment = function (segnum, totalsegs, data) {
        //add this to the queue of segments to send.
        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });
        //send the data immediately if there isn't already data being transmitted, unless
        //startLongPoll hasn't been called yet.
        if (this.alive) {
            this.newRequest_();
        }
    };
    /**
     * Add a script tag for a regular long-poll request.
     * @param {!string} url - The URL of the script tag.
     * @param {!number} serial - The serial number of the request.
     * @private
     */
    FirebaseIFrameScriptHolder.prototype.addLongPollTag_ = function (url, serial) {
        var _this = this;
        //remember that we sent this request.
        this.outstandingRequests.add(serial, 1);
        var doNewRequest = function () {
            _this.outstandingRequests.remove(serial);
            _this.newRequest_();
        };
        // If this request doesn't return on its own accord (by the server sending us some data), we'll
        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.
        var keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
        var readyStateCB = function () {
            // Request completed.  Cancel the keepalive.
            clearTimeout(keepaliveTimeout);
            // Trigger a new request so we can continue receiving data.
            doNewRequest();
        };
        this.addTag(url, readyStateCB);
    };
    /**
     * Add an arbitrary script tag to the iframe.
     * @param {!string} url - The URL for the script tag source.
     * @param {!function()} loadCB - A callback to be triggered once the script has loaded.
     */
    FirebaseIFrameScriptHolder.prototype.addTag = function (url, loadCB) {
        var _this = this;
        if (util_3.isNodeSdk()) {
            this.doNodeLongPoll(url, loadCB);
        }
        else {
            setTimeout(function () {
                try {
                    // if we're already closed, don't add this poll
                    if (!_this.sendNewPolls)
                        return;
                    var newScript_1 = _this.myIFrame.doc.createElement('script');
                    newScript_1.type = 'text/javascript';
                    newScript_1.async = true;
                    newScript_1.src = url;
                    newScript_1.onload = newScript_1.onreadystatechange = function () {
                        var rstate = newScript_1.readyState;
                        if (!rstate || rstate === 'loaded' || rstate === 'complete') {
                            newScript_1.onload = newScript_1.onreadystatechange = null;
                            if (newScript_1.parentNode) {
                                newScript_1.parentNode.removeChild(newScript_1);
                            }
                            loadCB();
                        }
                    };
                    newScript_1.onerror = function () {
                        util_1.log('Long-poll script failed to load: ' + url);
                        _this.sendNewPolls = false;
                        _this.close();
                    };
                    _this.myIFrame.doc.body.appendChild(newScript_1);
                }
                catch (e) {
                    // TODO: we should make this error visible somehow
                }
            }, Math.floor(1));
        }
    };
    return FirebaseIFrameScriptHolder;
}());
exports.FirebaseIFrameScriptHolder = FirebaseIFrameScriptHolder;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/realtime/BrowserPollConnection.js","/node_modules/@firebase/database/dist/cjs/src/realtime")

},{"../core/stats/StatsManager":47,"../core/util/CountedSet":52,"../core/util/util":63,"./Constants":82,"./polling/PacketReceiver":85,"@firebase/util":134,"_process":162,"buffer":160}],81:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../core/util/util");
var storage_1 = require("../core/storage/storage");
var Constants_1 = require("./Constants");
var TransportManager_1 = require("./TransportManager");
// Abort upgrade attempt if it takes longer than 60s.
var UPGRADE_TIMEOUT = 60000;
// For some transports (WebSockets), we need to "validate" the transport by exchanging a few requests and responses.
// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.
var DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;
// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)
// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout
// but we've sent/received enough bytes, we don't cancel the connection.
var BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
var BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
var MESSAGE_TYPE = 't';
var MESSAGE_DATA = 'd';
var CONTROL_SHUTDOWN = 's';
var CONTROL_RESET = 'r';
var CONTROL_ERROR = 'e';
var CONTROL_PONG = 'o';
var SWITCH_ACK = 'a';
var END_TRANSMISSION = 'n';
var PING = 'p';
var SERVER_HELLO = 'h';
/**
 * Creates a new real-time connection to the server using whichever method works
 * best in the current browser.
 *
 * @constructor
 */
var Connection = /** @class */ (function () {
    /**
     * @param {!string} id - an id for this connection
     * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to
     * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives
     * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.
     * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost
     * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.
     * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server
     */
    function Connection(id, repoInfo_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
        this.id = id;
        this.repoInfo_ = repoInfo_;
        this.onMessage_ = onMessage_;
        this.onReady_ = onReady_;
        this.onDisconnect_ = onDisconnect_;
        this.onKill_ = onKill_;
        this.lastSessionId = lastSessionId;
        this.connectionCount = 0;
        this.pendingDataMessages = [];
        this.state_ = 0 /* CONNECTING */;
        this.log_ = util_1.logWrapper('c:' + this.id + ':');
        this.transportManager_ = new TransportManager_1.TransportManager(repoInfo_);
        this.log_('Connection created');
        this.start_();
    }
    /**
     * Starts a connection attempt
     * @private
     */
    Connection.prototype.start_ = function () {
        var _this = this;
        var conn = this.transportManager_.initialTransport();
        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, undefined, this.lastSessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;
        var onMessageReceived = this.connReceiver_(this.conn_);
        var onConnectionLost = this.disconnReceiver_(this.conn_);
        this.tx_ = this.conn_;
        this.rx_ = this.conn_;
        this.secondaryConn_ = null;
        this.isHealthy_ = false;
        /*
         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.
         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.
         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should
         * still have the context of your originating frame.
         */
        setTimeout(function () {
            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it
            _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);
        }, Math.floor(0));
        var healthyTimeout_ms = conn['healthyTimeout'] || 0;
        if (healthyTimeout_ms > 0) {
            this.healthyTimeout_ = util_1.setTimeoutNonBlocking(function () {
                _this.healthyTimeout_ = null;
                if (!_this.isHealthy_) {
                    if (_this.conn_ &&
                        _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
                        _this.log_('Connection exceeded healthy timeout but has received ' +
                            _this.conn_.bytesReceived +
                            ' bytes.  Marking connection healthy.');
                        _this.isHealthy_ = true;
                        _this.conn_.markConnectionHealthy();
                    }
                    else if (_this.conn_ &&
                        _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {
                        _this.log_('Connection exceeded healthy timeout but has sent ' +
                            _this.conn_.bytesSent +
                            ' bytes.  Leaving connection alive.');
                        // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to
                        // the server.
                    }
                    else {
                        _this.log_('Closing unhealthy connection after timeout.');
                        _this.close();
                    }
                }
            }, Math.floor(healthyTimeout_ms));
        }
    };
    /**
     * @return {!string}
     * @private
     */
    Connection.prototype.nextTransportId_ = function () {
        return 'c:' + this.id + ':' + this.connectionCount++;
    };
    Connection.prototype.disconnReceiver_ = function (conn) {
        var _this = this;
        return function (everConnected) {
            if (conn === _this.conn_) {
                _this.onConnectionLost_(everConnected);
            }
            else if (conn === _this.secondaryConn_) {
                _this.log_('Secondary connection lost.');
                _this.onSecondaryConnectionLost_();
            }
            else {
                _this.log_('closing an old connection');
            }
        };
    };
    Connection.prototype.connReceiver_ = function (conn) {
        var _this = this;
        return function (message) {
            if (_this.state_ != 2 /* DISCONNECTED */) {
                if (conn === _this.rx_) {
                    _this.onPrimaryMessageReceived_(message);
                }
                else if (conn === _this.secondaryConn_) {
                    _this.onSecondaryMessageReceived_(message);
                }
                else {
                    _this.log_('message on old connection');
                }
            }
        };
    };
    /**
     *
     * @param {Object} dataMsg An arbitrary data message to be sent to the server
     */
    Connection.prototype.sendRequest = function (dataMsg) {
        // wrap in a data message envelope and send it on
        var msg = { t: 'd', d: dataMsg };
        this.sendData_(msg);
    };
    Connection.prototype.tryCleanupConnection = function () {
        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
            this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);
            this.conn_ = this.secondaryConn_;
            this.secondaryConn_ = null;
            // the server will shutdown the old connection
        }
    };
    Connection.prototype.onSecondaryControl_ = function (controlData) {
        if (MESSAGE_TYPE in controlData) {
            var cmd = controlData[MESSAGE_TYPE];
            if (cmd === SWITCH_ACK) {
                this.upgradeIfSecondaryHealthy_();
            }
            else if (cmd === CONTROL_RESET) {
                // Most likely the session wasn't valid. Abandon the switch attempt
                this.log_('Got a reset on secondary, closing it');
                this.secondaryConn_.close();
                // If we were already using this connection for something, than we need to fully close
                if (this.tx_ === this.secondaryConn_ ||
                    this.rx_ === this.secondaryConn_) {
                    this.close();
                }
            }
            else if (cmd === CONTROL_PONG) {
                this.log_('got pong on secondary.');
                this.secondaryResponsesRequired_--;
                this.upgradeIfSecondaryHealthy_();
            }
        }
    };
    Connection.prototype.onSecondaryMessageReceived_ = function (parsedData) {
        var layer = util_1.requireKey('t', parsedData);
        var data = util_1.requireKey('d', parsedData);
        if (layer == 'c') {
            this.onSecondaryControl_(data);
        }
        else if (layer == 'd') {
            // got a data message, but we're still second connection. Need to buffer it up
            this.pendingDataMessages.push(data);
        }
        else {
            throw new Error('Unknown protocol layer: ' + layer);
        }
    };
    Connection.prototype.upgradeIfSecondaryHealthy_ = function () {
        if (this.secondaryResponsesRequired_ <= 0) {
            this.log_('Secondary connection is healthy.');
            this.isHealthy_ = true;
            this.secondaryConn_.markConnectionHealthy();
            this.proceedWithUpgrade_();
        }
        else {
            // Send a ping to make sure the connection is healthy.
            this.log_('sending ping on secondary.');
            this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });
        }
    };
    Connection.prototype.proceedWithUpgrade_ = function () {
        // tell this connection to consider itself open
        this.secondaryConn_.start();
        // send ack
        this.log_('sending client ack on secondary');
        this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });
        // send end packet on primary transport, switch to sending on this one
        // can receive on this one, buffer responses until end received on primary transport
        this.log_('Ending transmission on primary');
        this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });
        this.tx_ = this.secondaryConn_;
        this.tryCleanupConnection();
    };
    Connection.prototype.onPrimaryMessageReceived_ = function (parsedData) {
        // Must refer to parsedData properties in quotes, so closure doesn't touch them.
        var layer = util_1.requireKey('t', parsedData);
        var data = util_1.requireKey('d', parsedData);
        if (layer == 'c') {
            this.onControl_(data);
        }
        else if (layer == 'd') {
            this.onDataMessage_(data);
        }
    };
    Connection.prototype.onDataMessage_ = function (message) {
        this.onPrimaryResponse_();
        // We don't do anything with data messages, just kick them up a level
        this.onMessage_(message);
    };
    Connection.prototype.onPrimaryResponse_ = function () {
        if (!this.isHealthy_) {
            this.primaryResponsesRequired_--;
            if (this.primaryResponsesRequired_ <= 0) {
                this.log_('Primary connection is healthy.');
                this.isHealthy_ = true;
                this.conn_.markConnectionHealthy();
            }
        }
    };
    Connection.prototype.onControl_ = function (controlData) {
        var cmd = util_1.requireKey(MESSAGE_TYPE, controlData);
        if (MESSAGE_DATA in controlData) {
            var payload = controlData[MESSAGE_DATA];
            if (cmd === SERVER_HELLO) {
                this.onHandshake_(payload);
            }
            else if (cmd === END_TRANSMISSION) {
                this.log_('recvd end transmission on primary');
                this.rx_ = this.secondaryConn_;
                for (var i = 0; i < this.pendingDataMessages.length; ++i) {
                    this.onDataMessage_(this.pendingDataMessages[i]);
                }
                this.pendingDataMessages = [];
                this.tryCleanupConnection();
            }
            else if (cmd === CONTROL_SHUTDOWN) {
                // This was previously the 'onKill' callback passed to the lower-level connection
                // payload in this case is the reason for the shutdown. Generally a human-readable error
                this.onConnectionShutdown_(payload);
            }
            else if (cmd === CONTROL_RESET) {
                // payload in this case is the host we should contact
                this.onReset_(payload);
            }
            else if (cmd === CONTROL_ERROR) {
                util_1.error('Server Error: ' + payload);
            }
            else if (cmd === CONTROL_PONG) {
                this.log_('got pong on primary.');
                this.onPrimaryResponse_();
                this.sendPingOnPrimaryIfNecessary_();
            }
            else {
                util_1.error('Unknown control packet command: ' + cmd);
            }
        }
    };
    /**
     *
     * @param {Object} handshake The handshake data returned from the server
     * @private
     */
    Connection.prototype.onHandshake_ = function (handshake) {
        var timestamp = handshake.ts;
        var version = handshake.v;
        var host = handshake.h;
        this.sessionId = handshake.s;
        this.repoInfo_.updateHost(host);
        // if we've already closed the connection, then don't bother trying to progress further
        if (this.state_ == 0 /* CONNECTING */) {
            this.conn_.start();
            this.onConnectionEstablished_(this.conn_, timestamp);
            if (Constants_1.PROTOCOL_VERSION !== version) {
                util_1.warn('Protocol version mismatch detected');
            }
            // TODO: do we want to upgrade? when? maybe a delay?
            this.tryStartUpgrade_();
        }
    };
    Connection.prototype.tryStartUpgrade_ = function () {
        var conn = this.transportManager_.upgradeTransport();
        if (conn) {
            this.startUpgrade_(conn);
        }
    };
    Connection.prototype.startUpgrade_ = function (conn) {
        var _this = this;
        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.sessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.secondaryResponsesRequired_ =
            conn['responsesRequiredToBeHealthy'] || 0;
        var onMessage = this.connReceiver_(this.secondaryConn_);
        var onDisconnect = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(onMessage, onDisconnect);
        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.
        util_1.setTimeoutNonBlocking(function () {
            if (_this.secondaryConn_) {
                _this.log_('Timed out trying to upgrade.');
                _this.secondaryConn_.close();
            }
        }, Math.floor(UPGRADE_TIMEOUT));
    };
    Connection.prototype.onReset_ = function (host) {
        this.log_('Reset packet received.  New host: ' + host);
        this.repoInfo_.updateHost(host);
        // TODO: if we're already "connected", we need to trigger a disconnect at the next layer up.
        // We don't currently support resets after the connection has already been established
        if (this.state_ === 1 /* CONNECTED */) {
            this.close();
        }
        else {
            // Close whatever connections we have open and start again.
            this.closeConnections_();
            this.start_();
        }
    };
    Connection.prototype.onConnectionEstablished_ = function (conn, timestamp) {
        var _this = this;
        this.log_('Realtime connection established.');
        this.conn_ = conn;
        this.state_ = 1 /* CONNECTED */;
        if (this.onReady_) {
            this.onReady_(timestamp, this.sessionId);
            this.onReady_ = null;
        }
        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,
        // send some pings.
        if (this.primaryResponsesRequired_ === 0) {
            this.log_('Primary connection is healthy.');
            this.isHealthy_ = true;
        }
        else {
            util_1.setTimeoutNonBlocking(function () {
                _this.sendPingOnPrimaryIfNecessary_();
            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
        }
    };
    Connection.prototype.sendPingOnPrimaryIfNecessary_ = function () {
        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.
        if (!this.isHealthy_ && this.state_ === 1 /* CONNECTED */) {
            this.log_('sending ping on primary.');
            this.sendData_({ t: 'c', d: { t: PING, d: {} } });
        }
    };
    Connection.prototype.onSecondaryConnectionLost_ = function () {
        var conn = this.secondaryConn_;
        this.secondaryConn_ = null;
        if (this.tx_ === conn || this.rx_ === conn) {
            // we are relying on this connection already in some capacity. Therefore, a failure is real
            this.close();
        }
    };
    /**
     *
     * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if
     * we should flush the host cache
     * @private
     */
    Connection.prototype.onConnectionLost_ = function (everConnected) {
        this.conn_ = null;
        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting
        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.
        if (!everConnected && this.state_ === 0 /* CONNECTING */) {
            this.log_('Realtime connection failed.');
            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away
            if (this.repoInfo_.isCacheableHost()) {
                storage_1.PersistentStorage.remove('host:' + this.repoInfo_.host);
                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com
                this.repoInfo_.internalHost = this.repoInfo_.host;
            }
        }
        else if (this.state_ === 1 /* CONNECTED */) {
            this.log_('Realtime connection lost.');
        }
        this.close();
    };
    /**
     *
     * @param {string} reason
     * @private
     */
    Connection.prototype.onConnectionShutdown_ = function (reason) {
        this.log_('Connection shutdown command received. Shutting down...');
        if (this.onKill_) {
            this.onKill_(reason);
            this.onKill_ = null;
        }
        // We intentionally don't want to fire onDisconnect (kill is a different case),
        // so clear the callback.
        this.onDisconnect_ = null;
        this.close();
    };
    Connection.prototype.sendData_ = function (data) {
        if (this.state_ !== 1 /* CONNECTED */) {
            throw 'Connection is not connected';
        }
        else {
            this.tx_.send(data);
        }
    };
    /**
     * Cleans up this connection, calling the appropriate callbacks
     */
    Connection.prototype.close = function () {
        if (this.state_ !== 2 /* DISCONNECTED */) {
            this.log_('Closing realtime connection.');
            this.state_ = 2 /* DISCONNECTED */;
            this.closeConnections_();
            if (this.onDisconnect_) {
                this.onDisconnect_();
                this.onDisconnect_ = null;
            }
        }
    };
    /**
     *
     * @private
     */
    Connection.prototype.closeConnections_ = function () {
        this.log_('Shutting down all connections');
        if (this.conn_) {
            this.conn_.close();
            this.conn_ = null;
        }
        if (this.secondaryConn_) {
            this.secondaryConn_.close();
            this.secondaryConn_ = null;
        }
        if (this.healthyTimeout_) {
            clearTimeout(this.healthyTimeout_);
            this.healthyTimeout_ = null;
        }
    };
    return Connection;
}());
exports.Connection = Connection;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/realtime/Connection.js","/node_modules/@firebase/database/dist/cjs/src/realtime")

},{"../core/storage/storage":51,"../core/util/util":63,"./Constants":82,"./TransportManager":83,"_process":162,"buffer":160}],82:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PROTOCOL_VERSION = '5';
exports.VERSION_PARAM = 'v';
exports.TRANSPORT_SESSION_PARAM = 's';
exports.REFERER_PARAM = 'r';
exports.FORGE_REF = 'f';
exports.FORGE_DOMAIN = 'firebaseio.com';
exports.LAST_SESSION_PARAM = 'ls';
exports.WEBSOCKET = 'websocket';
exports.LONG_POLLING = 'long_polling';



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/realtime/Constants.js","/node_modules/@firebase/database/dist/cjs/src/realtime")

},{"_process":162,"buffer":160}],83:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserPollConnection_1 = require("./BrowserPollConnection");
var WebSocketConnection_1 = require("./WebSocketConnection");
var util_1 = require("../core/util/util");
/**
 * Currently simplistic, this class manages what transport a Connection should use at various stages of its
 * lifecycle.
 *
 * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if
 * they are available.
 * @constructor
 */
var TransportManager = /** @class */ (function () {
    /**
     * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to
     */
    function TransportManager(repoInfo) {
        this.initTransports_(repoInfo);
    }
    Object.defineProperty(TransportManager, "ALL_TRANSPORTS", {
        /**
         * @const
         * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}
         */
        get: function () {
            return [BrowserPollConnection_1.BrowserPollConnection, WebSocketConnection_1.WebSocketConnection];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {!RepoInfo} repoInfo
     * @private
     */
    TransportManager.prototype.initTransports_ = function (repoInfo) {
        var isWebSocketsAvailable = WebSocketConnection_1.WebSocketConnection && WebSocketConnection_1.WebSocketConnection['isAvailable']();
        var isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection_1.WebSocketConnection.previouslyFailed();
        if (repoInfo.webSocketOnly) {
            if (!isWebSocketsAvailable)
                util_1.warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
            isSkipPollConnection = true;
        }
        if (isSkipPollConnection) {
            this.transports_ = [WebSocketConnection_1.WebSocketConnection];
        }
        else {
            var transports_1 = (this.transports_ = []);
            util_1.each(TransportManager.ALL_TRANSPORTS, function (i, transport) {
                if (transport && transport['isAvailable']()) {
                    transports_1.push(transport);
                }
            });
        }
    };
    /**
     * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the
     * initial transport to use
     */
    TransportManager.prototype.initialTransport = function () {
        if (this.transports_.length > 0) {
            return this.transports_[0];
        }
        else {
            throw new Error('No transports available');
        }
    };
    /**
     * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next
     * transport, or null
     */
    TransportManager.prototype.upgradeTransport = function () {
        if (this.transports_.length > 1) {
            return this.transports_[1];
        }
        else {
            return null;
        }
    };
    return TransportManager;
}());
exports.TransportManager = TransportManager;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/realtime/TransportManager.js","/node_modules/@firebase/database/dist/cjs/src/realtime")

},{"../core/util/util":63,"./BrowserPollConnection":80,"./WebSocketConnection":84,"_process":162,"buffer":160}],84:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var app_1 = require("@firebase/app");
var util_1 = require("@firebase/util");
var util_2 = require("../core/util/util");
var StatsManager_1 = require("../core/stats/StatsManager");
var Constants_1 = require("./Constants");
var util_3 = require("@firebase/util");
var storage_1 = require("../core/storage/storage");
var util_4 = require("@firebase/util");
var util_5 = require("@firebase/util");
var WEBSOCKET_MAX_FRAME_SIZE = 16384;
var WEBSOCKET_KEEPALIVE_INTERVAL = 45000;
var WebSocketImpl = null;
if (typeof MozWebSocket !== 'undefined') {
    WebSocketImpl = MozWebSocket;
}
else if (typeof WebSocket !== 'undefined') {
    WebSocketImpl = WebSocket;
}
function setWebSocketImpl(impl) {
    WebSocketImpl = impl;
}
exports.setWebSocketImpl = setWebSocketImpl;
/**
 * Create a new websocket connection with the given callbacks.
 * @constructor
 * @implements {Transport}
 */
var WebSocketConnection = /** @class */ (function () {
    /**
     * @param {string} connId identifier for this transport
     * @param {RepoInfo} repoInfo The info for the websocket endpoint.
     * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection
     */
    function WebSocketConnection(connId, repoInfo, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.keepaliveTimer = null;
        this.frames = null;
        this.totalFrames = 0;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.log_ = util_2.logWrapper(this.connId);
        this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo);
        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId);
    }
    /**
     * @param {RepoInfo} repoInfo The info for the websocket endpoint.
     * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection
     * @return {string} connection url
     * @private
     */
    WebSocketConnection.connectionURL_ = function (repoInfo, transportSessionId, lastSessionId) {
        var urlParams = {};
        urlParams[Constants_1.VERSION_PARAM] = Constants_1.PROTOCOL_VERSION;
        if (!util_5.isNodeSdk() &&
            typeof location !== 'undefined' &&
            location.href &&
            location.href.indexOf(Constants_1.FORGE_DOMAIN) !== -1) {
            urlParams[Constants_1.REFERER_PARAM] = Constants_1.FORGE_REF;
        }
        if (transportSessionId) {
            urlParams[Constants_1.TRANSPORT_SESSION_PARAM] = transportSessionId;
        }
        if (lastSessionId) {
            urlParams[Constants_1.LAST_SESSION_PARAM] = lastSessionId;
        }
        return repoInfo.connectionURL(Constants_1.WEBSOCKET, urlParams);
    };
    /**
     *
     * @param onMessage Callback when messages arrive
     * @param onDisconnect Callback with connection lost.
     */
    WebSocketConnection.prototype.open = function (onMessage, onDisconnect) {
        var _this = this;
        this.onDisconnect = onDisconnect;
        this.onMessage = onMessage;
        this.log_('Websocket connecting to ' + this.connURL);
        this.everConnected_ = false;
        // Assume failure until proven otherwise.
        storage_1.PersistentStorage.set('previous_websocket_failure', true);
        try {
            if (util_5.isNodeSdk()) {
                var device = util_3.CONSTANTS.NODE_ADMIN ? 'AdminNode' : 'Node';
                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>
                var options = {
                    headers: {
                        'User-Agent': "Firebase/" + Constants_1.PROTOCOL_VERSION + "/" + app_1.default.SDK_VERSION + "/" + process.platform + "/" + device
                    }
                };
                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.
                var env = process['env'];
                var proxy = this.connURL.indexOf('wss://') == 0
                    ? env['HTTPS_PROXY'] || env['https_proxy']
                    : env['HTTP_PROXY'] || env['http_proxy'];
                if (proxy) {
                    options['proxy'] = { origin: proxy };
                }
                this.mySock = new WebSocketImpl(this.connURL, [], options);
            }
            else {
                this.mySock = new WebSocketImpl(this.connURL);
            }
        }
        catch (e) {
            this.log_('Error instantiating WebSocket.');
            var error = e.message || e.data;
            if (error) {
                this.log_(error);
            }
            this.onClosed_();
            return;
        }
        this.mySock.onopen = function () {
            _this.log_('Websocket connected.');
            _this.everConnected_ = true;
        };
        this.mySock.onclose = function () {
            _this.log_('Websocket connection was disconnected.');
            _this.mySock = null;
            _this.onClosed_();
        };
        this.mySock.onmessage = function (m) {
            _this.handleIncomingFrame(m);
        };
        this.mySock.onerror = function (e) {
            _this.log_('WebSocket error.  Closing connection.');
            var error = e.message || e.data;
            if (error) {
                _this.log_(error);
            }
            _this.onClosed_();
        };
    };
    /**
     * No-op for websockets, we don't need to do anything once the connection is confirmed as open
     */
    WebSocketConnection.prototype.start = function () { };
    WebSocketConnection.forceDisallow = function () {
        WebSocketConnection.forceDisallow_ = true;
    };
    WebSocketConnection.isAvailable = function () {
        var isOldAndroid = false;
        if (typeof navigator !== 'undefined' && navigator.userAgent) {
            var oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
            var oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
            if (oldAndroidMatch && oldAndroidMatch.length > 1) {
                if (parseFloat(oldAndroidMatch[1]) < 4.4) {
                    isOldAndroid = true;
                }
            }
        }
        return (!isOldAndroid &&
            WebSocketImpl !== null &&
            !WebSocketConnection.forceDisallow_);
    };
    /**
     * Returns true if we previously failed to connect with this transport.
     * @return {boolean}
     */
    WebSocketConnection.previouslyFailed = function () {
        // If our persistent storage is actually only in-memory storage,
        // we default to assuming that it previously failed to be safe.
        return (storage_1.PersistentStorage.isInMemoryStorage ||
            storage_1.PersistentStorage.get('previous_websocket_failure') === true);
    };
    WebSocketConnection.prototype.markConnectionHealthy = function () {
        storage_1.PersistentStorage.remove('previous_websocket_failure');
    };
    WebSocketConnection.prototype.appendFrame_ = function (data) {
        this.frames.push(data);
        if (this.frames.length == this.totalFrames) {
            var fullMess = this.frames.join('');
            this.frames = null;
            var jsonMess = util_4.jsonEval(fullMess);
            //handle the message
            this.onMessage(jsonMess);
        }
    };
    /**
     * @param {number} frameCount The number of frames we are expecting from the server
     * @private
     */
    WebSocketConnection.prototype.handleNewFrameCount_ = function (frameCount) {
        this.totalFrames = frameCount;
        this.frames = [];
    };
    /**
     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1
     * @param {!String} data
     * @return {?String} Any remaining data to be process, or null if there is none
     * @private
     */
    WebSocketConnection.prototype.extractFrameCount_ = function (data) {
        util_1.assert(this.frames === null, 'We already have a frame buffer');
        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced
        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508
        if (data.length <= 6) {
            var frameCount = Number(data);
            if (!isNaN(frameCount)) {
                this.handleNewFrameCount_(frameCount);
                return null;
            }
        }
        this.handleNewFrameCount_(1);
        return data;
    };
    /**
     * Process a websocket frame that has arrived from the server.
     * @param mess The frame data
     */
    WebSocketConnection.prototype.handleIncomingFrame = function (mess) {
        if (this.mySock === null)
            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.
        var data = mess['data'];
        this.bytesReceived += data.length;
        this.stats_.incrementCounter('bytes_received', data.length);
        this.resetKeepAlive();
        if (this.frames !== null) {
            // we're buffering
            this.appendFrame_(data);
        }
        else {
            // try to parse out a frame count, otherwise, assume 1 and process it
            var remainingData = this.extractFrameCount_(data);
            if (remainingData !== null) {
                this.appendFrame_(remainingData);
            }
        }
    };
    /**
     * Send a message to the server
     * @param {Object} data The JSON object to transmit
     */
    WebSocketConnection.prototype.send = function (data) {
        this.resetKeepAlive();
        var dataStr = util_4.stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //We can only fit a certain amount in each websocket frame, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        var dataSegs = util_2.splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
        //Send the length header
        if (dataSegs.length > 1) {
            this.sendString_(String(dataSegs.length));
        }
        //Send the actual data in segments.
        for (var i = 0; i < dataSegs.length; i++) {
            this.sendString_(dataSegs[i]);
        }
    };
    WebSocketConnection.prototype.shutdown_ = function () {
        this.isClosed_ = true;
        if (this.keepaliveTimer) {
            clearInterval(this.keepaliveTimer);
            this.keepaliveTimer = null;
        }
        if (this.mySock) {
            this.mySock.close();
            this.mySock = null;
        }
    };
    WebSocketConnection.prototype.onClosed_ = function () {
        if (!this.isClosed_) {
            this.log_('WebSocket is closing itself');
            this.shutdown_();
            // since this is an internal close, trigger the close listener
            if (this.onDisconnect) {
                this.onDisconnect(this.everConnected_);
                this.onDisconnect = null;
            }
        }
    };
    /**
     * External-facing close handler.
     * Close the websocket and kill the connection.
     */
    WebSocketConnection.prototype.close = function () {
        if (!this.isClosed_) {
            this.log_('WebSocket is being closed');
            this.shutdown_();
        }
    };
    /**
     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after
     * the last activity.
     */
    WebSocketConnection.prototype.resetKeepAlive = function () {
        var _this = this;
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = setInterval(function () {
            //If there has been no websocket activity for a while, send a no-op
            if (_this.mySock) {
                _this.sendString_('0');
            }
            _this.resetKeepAlive();
        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
    };
    /**
     * Send a string over the websocket.
     *
     * @param {string} str String to send.
     * @private
     */
    WebSocketConnection.prototype.sendString_ = function (str) {
        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()
        // calls for some unknown reason.  We treat these as an error and disconnect.
        // See https://app.asana.com/0/58926111402292/68021340250410
        try {
            this.mySock.send(str);
        }
        catch (e) {
            this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');
            setTimeout(this.onClosed_.bind(this), 0);
        }
    };
    /**
     * Number of response before we consider the connection "healthy."
     * @type {number}
     */
    WebSocketConnection.responsesRequiredToBeHealthy = 2;
    /**
     * Time to wait for the connection te become healthy before giving up.
     * @type {number}
     */
    WebSocketConnection.healthyTimeout = 30000;
    return WebSocketConnection;
}());
exports.WebSocketConnection = WebSocketConnection;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/realtime/WebSocketConnection.js","/node_modules/@firebase/database/dist/cjs/src/realtime")

},{"../core/stats/StatsManager":47,"../core/storage/storage":51,"../core/util/util":63,"./Constants":82,"@firebase/app":1,"@firebase/util":134,"_process":162,"buffer":160}],85:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../core/util/util");
/**
 * This class ensures the packets from the server arrive in order
 * This class takes data from the server and ensures it gets passed into the callbacks in order.
 * @constructor
 */
var PacketReceiver = /** @class */ (function () {
    /**
     * @param onMessage_
     */
    function PacketReceiver(onMessage_) {
        this.onMessage_ = onMessage_;
        this.pendingResponses = [];
        this.currentResponseNum = 0;
        this.closeAfterResponse = -1;
        this.onClose = null;
    }
    PacketReceiver.prototype.closeAfter = function (responseNum, callback) {
        this.closeAfterResponse = responseNum;
        this.onClose = callback;
        if (this.closeAfterResponse < this.currentResponseNum) {
            this.onClose();
            this.onClose = null;
        }
    };
    /**
     * Each message from the server comes with a response number, and an array of data. The responseNumber
     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all
     * browsers will respond in the same order as the requests we sent
     * @param {number} requestNum
     * @param {Array} data
     */
    PacketReceiver.prototype.handleResponse = function (requestNum, data) {
        var _this = this;
        this.pendingResponses[requestNum] = data;
        var _loop_1 = function () {
            var toProcess = this_1.pendingResponses[this_1.currentResponseNum];
            delete this_1.pendingResponses[this_1.currentResponseNum];
            var _loop_2 = function (i) {
                if (toProcess[i]) {
                    util_1.exceptionGuard(function () {
                        _this.onMessage_(toProcess[i]);
                    });
                }
            };
            for (var i = 0; i < toProcess.length; ++i) {
                _loop_2(i);
            }
            if (this_1.currentResponseNum === this_1.closeAfterResponse) {
                if (this_1.onClose) {
                    this_1.onClose();
                    this_1.onClose = null;
                }
                return "break";
            }
            this_1.currentResponseNum++;
        };
        var this_1 = this;
        while (this.pendingResponses[this.currentResponseNum]) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
    };
    return PacketReceiver;
}());
exports.PacketReceiver = PacketReceiver;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/database/dist/cjs/src/realtime/polling/PacketReceiver.js","/node_modules/@firebase/database/dist/cjs/src/realtime/polling")

},{"../../core/util/util":63,"_process":162,"buffer":160}],86:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var window_controller_1 = require("./src/controllers/window-controller");
var sw_controller_1 = require("./src/controllers/sw-controller");
var app_1 = require("@firebase/app");
function registerMessaging(instance) {
    var messagingName = 'messaging';
    var factoryMethod = function (app) {
        if (self && 'ServiceWorkerGlobalScope' in self) {
            return new sw_controller_1.default(app);
        }
        // Assume we are in the window context.
        return new window_controller_1.default(app);
    };
    var namespaceExports = {
        // no-inline
        Messaging: window_controller_1.default
    };
    instance.INTERNAL.registerService(messagingName, factoryMethod, namespaceExports);
}
exports.registerMessaging = registerMessaging;
registerMessaging(app_1.default);



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/messaging/dist/cjs/index.js","/node_modules/@firebase/messaging/dist/cjs")

},{"./src/controllers/sw-controller":88,"./src/controllers/window-controller":89,"@firebase/app":1,"_process":162,"buffer":160}],87:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var errors_1 = require("../models/errors");
var token_manager_1 = require("../models/token-manager");
var notification_permission_1 = require("../models/notification-permission");
var SENDER_ID_OPTION_NAME = 'messagingSenderId';
var ControllerInterface = /** @class */ (function () {
    /**
     * An interface of the Messaging Service API
     * @param {!firebase.app.App} app
     */
    function ControllerInterface(app) {
        var _this = this;
        this.errorFactory_ = new util_1.ErrorFactory('messaging', 'Messaging', errors_1.default.map);
        if (!app.options[SENDER_ID_OPTION_NAME] ||
            typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {
            throw this.errorFactory_.create(errors_1.default.codes.BAD_SENDER_ID);
        }
        this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];
        this.tokenManager_ = new token_manager_1.default();
        this.app = app;
        this.INTERNAL = {};
        this.INTERNAL.delete = function () { return _this.delete; };
    }
    /**
     * @export
     * @return {Promise<string> | Promise<null>} Returns a promise that
     * resolves to an FCM token.
     */
    ControllerInterface.prototype.getToken = function () {
        var _this = this;
        // Check with permissions
        var currentPermission = this.getNotificationPermission_();
        if (currentPermission !== notification_permission_1.default.granted) {
            if (currentPermission === notification_permission_1.default.denied) {
                return Promise.reject(this.errorFactory_.create(errors_1.default.codes.NOTIFICATIONS_BLOCKED));
            }
            // We must wait for permission to be granted
            return Promise.resolve(null);
        }
        return this.getSWRegistration_().then(function (registration) {
            return _this.tokenManager_
                .getSavedToken(_this.messagingSenderId_, registration)
                .then(function (token) {
                if (token) {
                    return token;
                }
                return _this.tokenManager_.createToken(_this.messagingSenderId_, registration);
            });
        });
    };
    /**
     * This method deletes tokens that the token manager looks after and then
     * unregisters the push subscription if it exists.
     * @export
     * @param {string} token
     * @return {Promise<void>}
     */
    ControllerInterface.prototype.deleteToken = function (token) {
        var _this = this;
        return this.tokenManager_.deleteToken(token).then(function () {
            return _this.getSWRegistration_()
                .then(function (registration) {
                if (registration) {
                    return registration.pushManager.getSubscription();
                }
            })
                .then(function (subscription) {
                if (subscription) {
                    return subscription.unsubscribe();
                }
            });
        });
    };
    ControllerInterface.prototype.getSWRegistration_ = function () {
        throw this.errorFactory_.create(errors_1.default.codes.SHOULD_BE_INHERITED);
    };
    //
    // The following methods should only be available in the window.
    //
    ControllerInterface.prototype.requestPermission = function () {
        throw this.errorFactory_.create(errors_1.default.codes.AVAILABLE_IN_WINDOW);
    };
    /**
     * @export
     * @param {!ServiceWorkerRegistration} registration
     */
    ControllerInterface.prototype.useServiceWorker = function (registration) {
        throw this.errorFactory_.create(errors_1.default.codes.AVAILABLE_IN_WINDOW);
    };
    /**
     * @export
     * @param {!firebase.Observer|function(*)} nextOrObserver
     * @param {function(!Error)=} optError
     * @param {function()=} optCompleted
     * @return {!function()}
     */
    ControllerInterface.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {
        throw this.errorFactory_.create(errors_1.default.codes.AVAILABLE_IN_WINDOW);
    };
    /**
     * @export
     * @param {!firebase.Observer|function()} nextOrObserver An observer object
     * or a function triggered on token refresh.
     * @param {function(!Error)=} optError Optional A function
     * triggered on token refresh error.
     * @param {function()=} optCompleted Optional function triggered when the
     * observer is removed.
     * @return {!function()} The unsubscribe function for the observer.
     */
    ControllerInterface.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {
        throw this.errorFactory_.create(errors_1.default.codes.AVAILABLE_IN_WINDOW);
    };
    //
    // The following methods are used by the service worker only.
    //
    /**
     * @export
     * @param {function(Object)} callback
     */
    ControllerInterface.prototype.setBackgroundMessageHandler = function (callback) {
        throw this.errorFactory_.create(errors_1.default.codes.AVAILABLE_IN_SW);
    };
    //
    // The following methods are used by the service themselves and not exposed
    // publicly or not expected to be used by developers.
    //
    /**
     * This method is required to adhere to the Firebase interface.
     * It closes any currently open indexdb database connections.
     */
    ControllerInterface.prototype.delete = function () {
        return this.tokenManager_.closeDatabase();
    };
    /**
     * Returns the current Notification Permission state.
     * @private
     * @return {string} The currenct permission state.
     */
    ControllerInterface.prototype.getNotificationPermission_ = function () {
        return Notification.permission;
    };
    /**
     * @protected
     * @returns {TokenManager}
     */
    ControllerInterface.prototype.getTokenManager = function () {
        return this.tokenManager_;
    };
    return ControllerInterface;
}());
exports.default = ControllerInterface;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/messaging/dist/cjs/src/controllers/controller-interface.js","/node_modules/@firebase/messaging/dist/cjs/src/controllers")

},{"../models/errors":92,"../models/notification-permission":94,"../models/token-manager":95,"@firebase/util":134,"_process":162,"buffer":160}],88:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var controller_interface_1 = require("./controller-interface");
var errors_1 = require("../models/errors");
var worker_page_message_1 = require("../models/worker-page-message");
var fcm_details_1 = require("../models/fcm-details");
var FCM_MSG = 'FCM_MSG';
var SWController = /** @class */ (function (_super) {
    __extends(SWController, _super);
    function SWController(app) {
        var _this = _super.call(this, app) || this;
        self.addEventListener('push', function (e) { return _this.onPush_(e); }, false);
        self.addEventListener('pushsubscriptionchange', function (e) { return _this.onSubChange_(e); }, false);
        self.addEventListener('notificationclick', function (e) { return _this.onNotificationClick_(e); }, false);
        /**
         * @private
         * @type {function(Object)|null}
         */
        _this.bgMessageHandler_ = null;
        return _this;
    }
    /**
    * A handler for push events that shows notifications based on the content of
    * the payload.
    *
    * The payload must be a JSON-encoded Object with a `notification` key. The
    * value of the `notification` property will be used as the NotificationOptions
    * object passed to showNotification. Additionally, the `title` property of the
    * notification object will be used as the title.
    *
    * If there is no notification data in the payload then no notification will be
    * shown.
    * @private
    */
    SWController.prototype.onPush_ = function (event) {
        var _this = this;
        var msgPayload;
        try {
            msgPayload = event.data.json();
        }
        catch (err) {
            // Not JSON so not an FCM message
            return;
        }
        var handleMsgPromise = this.hasVisibleClients_().then(function (hasVisibleClients) {
            if (hasVisibleClients) {
                // Do not need to show a notification.
                if (msgPayload.notification || _this.bgMessageHandler_) {
                    // Send to page
                    return _this.sendMessageToWindowClients_(msgPayload);
                }
                return;
            }
            var notificationDetails = _this.getNotificationData_(msgPayload);
            if (notificationDetails) {
                var notificationTitle = notificationDetails.title || '';
                return self.registration.showNotification(notificationTitle, notificationDetails);
            }
            else if (_this.bgMessageHandler_) {
                return _this.bgMessageHandler_(msgPayload);
            }
        });
        event.waitUntil(handleMsgPromise);
    };
    /**
    * @private
    */
    SWController.prototype.onSubChange_ = function (event) {
        var _this = this;
        var promiseChain = this.getToken().then(function (token) {
            if (!token) {
                // We can't resubscribe if we don't have an FCM token for this scope.
                throw _this.errorFactory_.create(errors_1.default.codes.NO_FCM_TOKEN_FOR_RESUBSCRIBE);
            }
            var tokenDetails = null;
            var tokenManager = _this.getTokenManager();
            return tokenManager
                .getTokenDetailsFromToken(token)
                .then(function (details) {
                tokenDetails = details;
                if (!tokenDetails) {
                    throw _this.errorFactory_.create(errors_1.default.codes.INVALID_SAVED_TOKEN);
                }
                // Attempt to get a new subscription
                return self.registration.pushManager.subscribe(fcm_details_1.default.SUBSCRIPTION_OPTIONS);
            })
                .then(function (newSubscription) {
                // Send new subscription to FCM.
                return tokenManager.subscribeToFCM(tokenDetails.fcmSenderId, newSubscription, tokenDetails.fcmPushSet);
            })
                .catch(function (err) {
                // The best thing we can do is log this to the terminal so
                // developers might notice the error.
                return tokenManager.deleteToken(tokenDetails.fcmToken).then(function () {
                    throw _this.errorFactory_.create(errors_1.default.codes.UNABLE_TO_RESUBSCRIBE, {
                        message: err
                    });
                });
            });
        });
        event.waitUntil(promiseChain);
    };
    /**
    * @private
    */
    SWController.prototype.onNotificationClick_ = function (event) {
        var _this = this;
        if (!(event.notification &&
            event.notification.data &&
            event.notification.data[FCM_MSG])) {
            // Not an FCM notification, do nothing.
            return;
        }
        // Prevent other listeners from receiving the event
        event.stopImmediatePropagation();
        event.notification.close();
        var msgPayload = event.notification.data[FCM_MSG];
        var clickAction = msgPayload['notification']['click_action'];
        if (!clickAction) {
            // Nothing to do.
            return;
        }
        var promiseChain = this.getWindowClient_(clickAction)
            .then(function (windowClient) {
            if (!windowClient) {
                // Unable to find window client so need to open one.
                return self.clients.openWindow(clickAction);
            }
            return windowClient;
        })
            .then(function (windowClient) {
            if (!windowClient) {
                // Window Client will not be returned if it's for a third party origin.
                return;
            }
            // Delete notification data from payload before sending to the page.
            var notificationData = msgPayload['notification'];
            delete msgPayload['notification'];
            var internalMsg = worker_page_message_1.default.createNewMsg(worker_page_message_1.default.TYPES_OF_MSG.NOTIFICATION_CLICKED, msgPayload);
            // Attempt to send a message to the client to handle the data
            // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728
            return _this.attemptToMessageClient_(windowClient, internalMsg);
        });
        event.waitUntil(promiseChain);
    };
    /**
     * @private
     * @param {Object} msgPayload
     * @return {NotificationOptions|undefined}
     */
    SWController.prototype.getNotificationData_ = function (msgPayload) {
        if (!msgPayload) {
            return;
        }
        if (typeof msgPayload.notification !== 'object') {
            return;
        }
        var notificationInformation = Object.assign({}, msgPayload.notification);
        // Put the message payload under FCM_MSG name so we can identify the
        // notification as being an FCM notification vs a notification from
        // somewhere else (i.e. normal web push or developer generated
        // notification).
        notificationInformation['data'] = (_a = {},
            _a[FCM_MSG] = msgPayload,
            _a);
        return notificationInformation;
        var _a;
    };
    /**
     * Calling setBackgroundMessageHandler will opt in to some specific
     * behaviours.
     * 1.) If a notification doesn't need to be shown due to a window already
     * being visible, then push messages will be sent to the page.
     * 2.) If a notification needs to be shown, and the message contains no
     * notification data this method will be called
     * and the promise it returns will be passed to event.waitUntil.
     * If you do not set this callback then all push messages will let and the
     * developer can handle them in a their own 'push' event callback
     * @export
     * @param {function(Object)} callback The callback to be called when a push
     * message is received and a notification must be shown. The callback will
     * be given the data from the push message.
     */
    SWController.prototype.setBackgroundMessageHandler = function (callback) {
        if (callback && typeof callback !== 'function') {
            throw this.errorFactory_.create(errors_1.default.codes.BG_HANDLER_FUNCTION_EXPECTED);
        }
        this.bgMessageHandler_ = callback;
    };
    /**
     * @private
     * @param {string} url The URL to look for when focusing a client.
     * @return {Object} Returns an existing window client or a newly opened
     * WindowClient.
     */
    SWController.prototype.getWindowClient_ = function (url) {
        // Use URL to normalize the URL when comparing to windowClients.
        // This at least handles whether to include trailing slashes or not
        var parsedURL = new URL(url).href;
        return self.clients
            .matchAll({
            type: 'window',
            includeUncontrolled: true
        })
            .then(function (clientList) {
            var suitableClient = null;
            for (var i = 0; i < clientList.length; i++) {
                var parsedClientUrl = new URL(clientList[i].url).href;
                if (parsedClientUrl === parsedURL) {
                    suitableClient = clientList[i];
                    break;
                }
            }
            if (suitableClient) {
                suitableClient.focus();
                return suitableClient;
            }
        });
    };
    /**
     * This message will attempt to send the message to a window client.
     * @private
     * @param {Object} client The WindowClient to send the message to.
     * @param {Object} message The message to send to the client.
     * @returns {Promise} Returns a promise that resolves after sending the
     * message. This does not guarantee that the message was successfully
     * received.
     */
    SWController.prototype.attemptToMessageClient_ = function (client, message) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!client) {
                return reject(_this.errorFactory_.create(errors_1.default.codes.NO_WINDOW_CLIENT_TO_MSG));
            }
            client.postMessage(message);
            resolve();
        });
    };
    /**
     * @private
     * @returns {Promise<boolean>} If there is currently a visible WindowClient,
     * this method will resolve to true, otherwise false.
     */
    SWController.prototype.hasVisibleClients_ = function () {
        return self.clients
            .matchAll({
            type: 'window',
            includeUncontrolled: true
        })
            .then(function (clientList) {
            return clientList.some(function (client) { return client.visibilityState === 'visible'; });
        });
    };
    /**
     * @private
     * @param {Object} msgPayload The data from the push event that should be sent
     * to all available pages.
     * @returns {Promise} Returns a promise that resolves once the message
     * has been sent to all WindowClients.
     */
    SWController.prototype.sendMessageToWindowClients_ = function (msgPayload) {
        var _this = this;
        return self.clients
            .matchAll({
            type: 'window',
            includeUncontrolled: true
        })
            .then(function (clientList) {
            var internalMsg = worker_page_message_1.default.createNewMsg(worker_page_message_1.default.TYPES_OF_MSG.PUSH_MSG_RECEIVED, msgPayload);
            return Promise.all(clientList.map(function (client) {
                return _this.attemptToMessageClient_(client, internalMsg);
            }));
        });
    };
    /**
     * This will register the default service worker and return the registration.
     * @private
     * @return {Promise<!ServiceWorkerRegistration>} The service worker
     * registration to be used for the push service.
     */
    SWController.prototype.getSWRegistration_ = function () {
        return Promise.resolve(self.registration);
    };
    return SWController;
}(controller_interface_1.default));
exports.default = SWController;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/messaging/dist/cjs/src/controllers/sw-controller.js","/node_modules/@firebase/messaging/dist/cjs/src/controllers")

},{"../models/errors":92,"../models/fcm-details":93,"../models/worker-page-message":96,"./controller-interface":87,"_process":162,"buffer":160}],89:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var controller_interface_1 = require("./controller-interface");
var errors_1 = require("../models/errors");
var worker_page_message_1 = require("../models/worker-page-message");
var default_sw_1 = require("../models/default-sw");
var notification_permission_1 = require("../models/notification-permission");
var util_1 = require("@firebase/util");
var WindowController = /** @class */ (function (_super) {
    __extends(WindowController, _super);
    /**
     * A service that provides a MessagingService instance.
     * @param {!firebase.app.App} app
     */
    function WindowController(app) {
        var _this = _super.call(this, app) || this;
        /**
         * @private
         * @type {ServiceWorkerRegistration}
         */
        _this.registrationToUse_;
        /**
         * @private
         * @type {Promise}
         */
        _this.manifestCheckPromise_;
        /**
         * @private
         * @type {firebase.Observer}
         */
        _this.messageObserver_ = null;
        /**
         * @private {!firebase.Subscribe} The subscribe function to the onMessage
         * observer.
         */
        _this.onMessage_ = util_1.createSubscribe(function (observer) {
            _this.messageObserver_ = observer;
        });
        /**
         * @private
         * @type {firebase.Observer}
         */
        _this.tokenRefreshObserver_ = null;
        _this.onTokenRefresh_ = util_1.createSubscribe(function (observer) {
            _this.tokenRefreshObserver_ = observer;
        });
        _this.setupSWMessageListener_();
        return _this;
    }
    /**
     * This method returns an FCM token if it can be generated.
     * The return promise will reject if the browser doesn't support
     * FCM, if permission is denied for notifications or it's not
     * possible to generate a token.
     * @export
     * @return {Promise<string> | Promise<null>} Returns a promise the
     * resolves to an FCM token or null if permission isn't granted.
     */
    WindowController.prototype.getToken = function () {
        var _this = this;
        // Check that the required API's are available
        if (!this.isSupported_()) {
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.UNSUPPORTED_BROWSER));
        }
        return this.manifestCheck_().then(function () {
            return _super.prototype.getToken.call(_this);
        });
    };
    /**
     * The method checks that a manifest is defined and has the correct GCM
     * sender ID.
     * @private
     * @return {Promise} Returns a promise that resolves if the manifest matches
     * our required sender ID
     */
    WindowController.prototype.manifestCheck_ = function () {
        var _this = this;
        if (this.manifestCheckPromise_) {
            return this.manifestCheckPromise_;
        }
        var manifestTag = document.querySelector('link[rel="manifest"]');
        if (!manifestTag) {
            this.manifestCheckPromise_ = Promise.resolve();
        }
        else {
            this.manifestCheckPromise_ = fetch(manifestTag.href)
                .then(function (response) {
                return response.json();
            })
                .catch(function () {
                // If the download or parsing fails allow check.
                // We only want to error if we KNOW that the gcm_sender_id is incorrect.
                return Promise.resolve();
            })
                .then(function (manifestContent) {
                if (!manifestContent) {
                    return;
                }
                if (!manifestContent['gcm_sender_id']) {
                    return;
                }
                if (manifestContent['gcm_sender_id'] !== '103953800507') {
                    throw _this.errorFactory_.create(errors_1.default.codes.INCORRECT_GCM_SENDER_ID);
                }
            });
        }
        return this.manifestCheckPromise_;
    };
    /**
     * Request permission if it is not currently granted
     * @export
     * @returns {Promise} Resolves if the permission was granted, otherwise
     * rejects
     */
    WindowController.prototype.requestPermission = function () {
        var _this = this;
        if (Notification.permission === notification_permission_1.default.granted) {
            return Promise.resolve();
        }
        return new Promise(function (resolve, reject) {
            var managePermissionResult = function (result) {
                if (result === notification_permission_1.default.granted) {
                    return resolve();
                }
                else if (result === notification_permission_1.default.denied) {
                    return reject(_this.errorFactory_.create(errors_1.default.codes.PERMISSION_BLOCKED));
                }
                else {
                    return reject(_this.errorFactory_.create(errors_1.default.codes.PERMISSION_DEFAULT));
                }
            };
            // The Notification.requestPermission API was changed to
            // return a promise so now have to handle both in case
            // browsers stop support callbacks for promised version
            var permissionPromise = Notification.requestPermission(function (result) {
                if (permissionPromise) {
                    // Let the promise manage this
                    return;
                }
                managePermissionResult(result);
            });
            if (permissionPromise) {
                // Prefer the promise version as it's the future API.
                permissionPromise.then(managePermissionResult);
            }
        });
    };
    /**
     * This method allows a developer to override the default service worker and
     * instead use a custom service worker.
     * @export
     * @param {!ServiceWorkerRegistration} registration The service worker
     * registration that should be used to receive the push messages.
     */
    WindowController.prototype.useServiceWorker = function (registration) {
        if (!(registration instanceof ServiceWorkerRegistration)) {
            throw this.errorFactory_.create(errors_1.default.codes.SW_REGISTRATION_EXPECTED);
        }
        if (typeof this.registrationToUse_ !== 'undefined') {
            throw this.errorFactory_.create(errors_1.default.codes.USE_SW_BEFORE_GET_TOKEN);
        }
        this.registrationToUse_ = registration;
    };
    /**
     * @export
     * @param {!firebase.Observer|function(*)} nextOrObserver An observer object
     * or a function triggered on message.
     * @param {function(!Error)=} optError Optional A function triggered on
     * message error.
     * @param {function()=} optCompleted Optional function triggered when the
     * observer is removed.
     * @return {!function()} The unsubscribe function for the observer.
     */
    WindowController.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {
        return this.onMessage_(nextOrObserver, optError, optCompleted);
    };
    /**
     * @export
     * @param {!firebase.Observer|function()} nextOrObserver An observer object
     * or a function triggered on token refresh.
     * @param {function(!Error)=} optError Optional A function
     * triggered on token refresh error.
     * @param {function()=} optCompleted Optional function triggered when the
     * observer is removed.
     * @return {!function()} The unsubscribe function for the observer.
     */
    WindowController.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {
        return this.onTokenRefresh_(nextOrObserver, optError, optCompleted);
    };
    /**
     * Given a registration, wait for the service worker it relates to
     * become activer
     * @private
     * @param  {ServiceWorkerRegistration} registration Registration to wait
     * for service worker to become active
     * @return {Promise<!ServiceWorkerRegistration>} Wait for service worker
     * registration to become active
     */
    WindowController.prototype.waitForRegistrationToActivate_ = function (registration) {
        var _this = this;
        var serviceWorker = registration.installing || registration.waiting || registration.active;
        return new Promise(function (resolve, reject) {
            if (!serviceWorker) {
                // This is a rare scenario but has occured in firefox
                reject(_this.errorFactory_.create(errors_1.default.codes.NO_SW_IN_REG));
                return;
            }
            // Because the Promise function is called on next tick there is a
            // small chance that the worker became active or redundant already.
            if (serviceWorker.state === 'activated') {
                resolve(registration);
                return;
            }
            if (serviceWorker.state === 'redundant') {
                reject(_this.errorFactory_.create(errors_1.default.codes.SW_REG_REDUNDANT));
                return;
            }
            var stateChangeListener = function () {
                if (serviceWorker.state === 'activated') {
                    resolve(registration);
                }
                else if (serviceWorker.state === 'redundant') {
                    reject(_this.errorFactory_.create(errors_1.default.codes.SW_REG_REDUNDANT));
                }
                else {
                    // Return early and wait to next state change
                    return;
                }
                serviceWorker.removeEventListener('statechange', stateChangeListener);
            };
            serviceWorker.addEventListener('statechange', stateChangeListener);
        });
    };
    /**
     * This will regiater the default service worker and return the registration
     * @private
     * @return {Promise<!ServiceWorkerRegistration>} The service worker
     * registration to be used for the push service.
     */
    WindowController.prototype.getSWRegistration_ = function () {
        var _this = this;
        if (this.registrationToUse_) {
            return this.waitForRegistrationToActivate_(this.registrationToUse_);
        }
        // Make the registration null so we know useServiceWorker will not
        // use a new service worker as registrationToUse_ is no longer undefined
        this.registrationToUse_ = null;
        return navigator.serviceWorker
            .register(default_sw_1.default.path, {
            scope: default_sw_1.default.scope
        })
            .catch(function (err) {
            throw _this.errorFactory_.create(errors_1.default.codes.FAILED_DEFAULT_REGISTRATION, {
                browserErrorMessage: err.message
            });
        })
            .then(function (registration) {
            return _this.waitForRegistrationToActivate_(registration).then(function () {
                _this.registrationToUse_ = registration;
                // We update after activation due to an issue with Firefox v49 where
                // a race condition occassionally causes the service work to not
                // install
                registration.update();
                return registration;
            });
        });
    };
    /**
     * This method will set up a message listener to handle
     * events from the service worker that should trigger
     * events in the page.
     *
     * @private
     */
    WindowController.prototype.setupSWMessageListener_ = function () {
        var _this = this;
        if (!('serviceWorker' in navigator)) {
            return;
        }
        navigator.serviceWorker.addEventListener('message', function (event) {
            if (!event.data || !event.data[worker_page_message_1.default.PARAMS.TYPE_OF_MSG]) {
                // Not a message from FCM
                return;
            }
            var workerPageMessage = event.data;
            switch (workerPageMessage[worker_page_message_1.default.PARAMS.TYPE_OF_MSG]) {
                case worker_page_message_1.default.TYPES_OF_MSG.PUSH_MSG_RECEIVED:
                case worker_page_message_1.default.TYPES_OF_MSG.NOTIFICATION_CLICKED:
                    var pushMessage = workerPageMessage[worker_page_message_1.default.PARAMS.DATA];
                    _this.messageObserver_.next(pushMessage);
                    break;
                default:
                    // Noop.
                    break;
            }
        }, false);
    };
    /**
     * Checks to see if the required API's are valid or not.
     * @private
     * @return {boolean} Returns true if the desired APIs are available.
     */
    WindowController.prototype.isSupported_ = function () {
        return ('serviceWorker' in navigator &&
            'PushManager' in window &&
            'Notification' in window &&
            'fetch' in window &&
            ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&
            PushSubscription.prototype.hasOwnProperty('getKey'));
    };
    return WindowController;
}(controller_interface_1.default));
exports.default = WindowController;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/messaging/dist/cjs/src/controllers/window-controller.js","/node_modules/@firebase/messaging/dist/cjs/src/controllers")

},{"../models/default-sw":91,"../models/errors":92,"../models/notification-permission":94,"../models/worker-page-message":96,"./controller-interface":87,"@firebase/util":134,"_process":162,"buffer":160}],90:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function toBase64(arrayBuffer) {
    var uint8Version = new Uint8Array(arrayBuffer);
    return window.btoa(String.fromCharCode.apply(null, uint8Version));
}
exports.default = function (arrayBuffer) {
    var base64String = toBase64(arrayBuffer);
    return base64String
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/messaging/dist/cjs/src/helpers/array-buffer-to-base64.js","/node_modules/@firebase/messaging/dist/cjs/src/helpers")

},{"_process":162,"buffer":160}],91:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    path: '/firebase-messaging-sw.js',
    scope: '/firebase-cloud-messaging-push-scope'
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/messaging/dist/cjs/src/models/default-sw.js","/node_modules/@firebase/messaging/dist/cjs/src/models")

},{"_process":162,"buffer":160}],92:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var CODES = {
    AVAILABLE_IN_WINDOW: 'only-available-in-window',
    AVAILABLE_IN_SW: 'only-available-in-sw',
    SHOULD_BE_INHERITED: 'should-be-overriden',
    BAD_SENDER_ID: 'bad-sender-id',
    INCORRECT_GCM_SENDER_ID: 'incorrect-gcm-sender-id',
    PERMISSION_DEFAULT: 'permission-default',
    PERMISSION_BLOCKED: 'permission-blocked',
    UNSUPPORTED_BROWSER: 'unsupported-browser',
    NOTIFICATIONS_BLOCKED: 'notifications-blocked',
    FAILED_DEFAULT_REGISTRATION: 'failed-serviceworker-registration',
    SW_REGISTRATION_EXPECTED: 'sw-registration-expected',
    GET_SUBSCRIPTION_FAILED: 'get-subscription-failed',
    INVALID_SAVED_TOKEN: 'invalid-saved-token',
    SW_REG_REDUNDANT: 'sw-reg-redundant',
    TOKEN_SUBSCRIBE_FAILED: 'token-subscribe-failed',
    TOKEN_SUBSCRIBE_NO_TOKEN: 'token-subscribe-no-token',
    TOKEN_SUBSCRIBE_NO_PUSH_SET: 'token-subscribe-no-push-set',
    USE_SW_BEFORE_GET_TOKEN: 'use-sw-before-get-token',
    INVALID_DELETE_TOKEN: 'invalid-delete-token',
    DELETE_TOKEN_NOT_FOUND: 'delete-token-not-found',
    DELETE_SCOPE_NOT_FOUND: 'delete-scope-not-found',
    BG_HANDLER_FUNCTION_EXPECTED: 'bg-handler-function-expected',
    NO_WINDOW_CLIENT_TO_MSG: 'no-window-client-to-msg',
    UNABLE_TO_RESUBSCRIBE: 'unable-to-resubscribe',
    NO_FCM_TOKEN_FOR_RESUBSCRIBE: 'no-fcm-token-for-resubscribe',
    FAILED_TO_DELETE_TOKEN: 'failed-to-delete-token',
    NO_SW_IN_REG: 'no-sw-in-reg',
    BAD_SCOPE: 'bad-scope',
    BAD_VAPID_KEY: 'bad-vapid-key',
    BAD_SUBSCRIPTION: 'bad-subscription',
    BAD_TOKEN: 'bad-token',
    BAD_PUSH_SET: 'bad-push-set',
    FAILED_DELETE_VAPID_KEY: 'failed-delete-vapid-key'
};
var ERROR_MAP = (_a = {},
    _a[CODES.AVAILABLE_IN_WINDOW] = 'This method is available in a Window context.',
    _a[CODES.AVAILABLE_IN_SW] = 'This method is available in a service worker ' + 'context.',
    _a[CODES.SHOULD_BE_INHERITED] = 'This method should be overriden by ' + 'extended classes.',
    _a[CODES.BAD_SENDER_ID] = "Please ensure that 'messagingSenderId' is set " +
        'correctly in the options passed into firebase.initializeApp().',
    _a[CODES.PERMISSION_DEFAULT] = 'The required permissions were not granted and ' + 'dismissed instead.',
    _a[CODES.PERMISSION_BLOCKED] = 'The required permissions were not granted and ' + 'blocked instead.',
    _a[CODES.UNSUPPORTED_BROWSER] = "This browser doesn't support the API's " +
        'required to use the firebase SDK.',
    _a[CODES.NOTIFICATIONS_BLOCKED] = 'Notifications have been blocked.',
    _a[CODES.FAILED_DEFAULT_REGISTRATION] = 'We are unable to register the ' +
        'default service worker. {$browserErrorMessage}',
    _a[CODES.SW_REGISTRATION_EXPECTED] = 'A service worker registration was the ' + 'expected input.',
    _a[CODES.GET_SUBSCRIPTION_FAILED] = 'There was an error when trying to get ' +
        'any existing Push Subscriptions.',
    _a[CODES.INVALID_SAVED_TOKEN] = 'Unable to access details of the saved token.',
    _a[CODES.SW_REG_REDUNDANT] = 'The service worker being used for push was made ' + 'redundant.',
    _a[CODES.TOKEN_SUBSCRIBE_FAILED] = 'A problem occured while subscribing the ' + 'user to FCM: {$message}',
    _a[CODES.TOKEN_SUBSCRIBE_NO_TOKEN] = 'FCM returned no token when subscribing ' + 'the user to push.',
    _a[CODES.TOKEN_SUBSCRIBE_NO_PUSH_SET] = 'FCM returned an invalid response ' + 'when getting an FCM token.',
    _a[CODES.USE_SW_BEFORE_GET_TOKEN] = 'You must call useServiceWorker() before ' +
        'calling getToken() to ensure your service worker is used.',
    _a[CODES.INVALID_DELETE_TOKEN] = 'You must pass a valid token into ' +
        'deleteToken(), i.e. the token from getToken().',
    _a[CODES.DELETE_TOKEN_NOT_FOUND] = 'The deletion attempt for token could not ' +
        'be performed as the token was not found.',
    _a[CODES.DELETE_SCOPE_NOT_FOUND] = 'The deletion attempt for service worker ' +
        'scope could not be performed as the scope was not found.',
    _a[CODES.BG_HANDLER_FUNCTION_EXPECTED] = 'The input to ' + 'setBackgroundMessageHandler() must be a function.',
    _a[CODES.NO_WINDOW_CLIENT_TO_MSG] = 'An attempt was made to message a ' + 'non-existant window client.',
    _a[CODES.UNABLE_TO_RESUBSCRIBE] = 'There was an error while re-subscribing ' +
        'the FCM token for push messaging. Will have to resubscribe the ' +
        'user on next visit. {$message}',
    _a[CODES.NO_FCM_TOKEN_FOR_RESUBSCRIBE] = 'Could not find an FCM token ' +
        'and as a result, unable to resubscribe. Will have to resubscribe the ' +
        'user on next visit.',
    _a[CODES.FAILED_TO_DELETE_TOKEN] = 'Unable to delete the currently saved token.',
    _a[CODES.NO_SW_IN_REG] = 'Even though the service worker registration was ' +
        'successful, there was a problem accessing the service worker itself.',
    _a[CODES.INCORRECT_GCM_SENDER_ID] = "Please change your web app manifest's " +
        "'gcm_sender_id' value to '103953800507' to use Firebase messaging.",
    _a[CODES.BAD_SCOPE] = 'The service worker scope must be a string with at ' +
        'least one character.',
    _a[CODES.BAD_VAPID_KEY] = 'The public VAPID key must be a string with at ' + 'least one character.',
    _a[CODES.BAD_SUBSCRIPTION] = 'The subscription must be a valid ' + 'PushSubscription.',
    _a[CODES.BAD_TOKEN] = 'The FCM Token used for storage / lookup was not ' +
        'a valid token string.',
    _a[CODES.BAD_PUSH_SET] = 'The FCM push set used for storage / lookup was not ' +
        'not a valid push set string.',
    _a[CODES.FAILED_DELETE_VAPID_KEY] = 'The VAPID key could not be deleted.',
    _a);
exports.default = {
    codes: CODES,
    map: ERROR_MAP
};
var _a;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/messaging/dist/cjs/src/models/errors.js","/node_modules/@firebase/messaging/dist/cjs/src/models")

},{"_process":162,"buffer":160}],93:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var FCM_APPLICATION_SERVER_KEY = [
    0x04,
    0x33,
    0x94,
    0xf7,
    0xdf,
    0xa1,
    0xeb,
    0xb1,
    0xdc,
    0x03,
    0xa2,
    0x5e,
    0x15,
    0x71,
    0xdb,
    0x48,
    0xd3,
    0x2e,
    0xed,
    0xed,
    0xb2,
    0x34,
    0xdb,
    0xb7,
    0x47,
    0x3a,
    0x0c,
    0x8f,
    0xc4,
    0xcc,
    0xe1,
    0x6f,
    0x3c,
    0x8c,
    0x84,
    0xdf,
    0xab,
    0xb6,
    0x66,
    0x3e,
    0xf2,
    0x0c,
    0xd4,
    0x8b,
    0xfe,
    0xe3,
    0xf9,
    0x76,
    0x2f,
    0x14,
    0x1c,
    0x63,
    0x08,
    0x6a,
    0x6f,
    0x2d,
    0xb1,
    0x1a,
    0x95,
    0xb0,
    0xce,
    0x37,
    0xc0,
    0x9c,
    0x6e
];
var SUBSCRIPTION_DETAILS = {
    userVisibleOnly: true,
    applicationServerKey: new Uint8Array(FCM_APPLICATION_SERVER_KEY)
};
exports.default = {
    ENDPOINT: 'https://fcm.googleapis.com',
    APPLICATION_SERVER_KEY: FCM_APPLICATION_SERVER_KEY,
    SUBSCRIPTION_OPTIONS: SUBSCRIPTION_DETAILS
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/messaging/dist/cjs/src/models/fcm-details.js","/node_modules/@firebase/messaging/dist/cjs/src/models")

},{"_process":162,"buffer":160}],94:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    granted: 'granted',
    default: 'default',
    denied: 'denied'
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/messaging/dist/cjs/src/models/notification-permission.js","/node_modules/@firebase/messaging/dist/cjs/src/models")

},{"_process":162,"buffer":160}],95:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@firebase/util");
var errors_1 = require("./errors");
var array_buffer_to_base64_1 = require("../helpers/array-buffer-to-base64");
var fcm_details_1 = require("./fcm-details");
var FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';
var FCM_TOKEN_DETAILS_DB_VERSION = 1;
var TokenManager = /** @class */ (function () {
    function TokenManager() {
        this.errorFactory_ = new util_1.ErrorFactory('messaging', 'Messaging', errors_1.default.map);
        this.openDbPromise_ = null;
    }
    /**
     * Get the indexedDB as a promsie.
     * @private
     * @return {Promise<IDBDatabase>} The IndexedDB database
     */
    TokenManager.prototype.openDatabase_ = function () {
        if (this.openDbPromise_) {
            return this.openDbPromise_;
        }
        this.openDbPromise_ = new Promise(function (resolve, reject) {
            var request = indexedDB.open(TokenManager.DB_NAME, FCM_TOKEN_DETAILS_DB_VERSION);
            request.onerror = function (event) {
                reject(event.target.error);
            };
            request.onsuccess = function (event) {
                resolve(event.target.result);
            };
            request.onupgradeneeded = function (event) {
                var db = event.target.result;
                var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {
                    keyPath: 'swScope'
                });
                // Make sure the sender ID can be searched
                objectStore.createIndex('fcmSenderId', 'fcmSenderId', {
                    unique: false
                });
                objectStore.createIndex('fcmToken', 'fcmToken', {
                    unique: true
                });
            };
        });
        return this.openDbPromise_;
    };
    /**
     * Close the currently open database.
     * @return {Promise<?>} Returns the result of the promise chain.
     */
    TokenManager.prototype.closeDatabase = function () {
        var _this = this;
        if (this.openDbPromise_) {
            return this.openDbPromise_.then(function (db) {
                db.close();
                _this.openDbPromise_ = null;
            });
        }
        return Promise.resolve();
    };
    /**
     * Given a token, this method will look up the details in indexedDB.
     * @public
     * @param {string} fcmToken
     * @return {Promise<Object>} The details associated with that token.
     */
    TokenManager.prototype.getTokenDetailsFromToken = function (fcmToken) {
        return this.openDatabase_().then(function (db) {
            return new Promise(function (resolve, reject) {
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var index = objectStore.index('fcmToken');
                var request = index.get(fcmToken);
                request.onerror = function (event) {
                    reject(event.target.error);
                };
                request.onsuccess = function (event) {
                    resolve(event.target.result);
                };
            });
        });
    };
    TokenManager.prototype.getTokenDetailsFromSWScope_ = function (swScope) {
        return this.openDatabase_().then(function (db) {
            return new Promise(function (resolve, reject) {
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var scopeRequest = objectStore.get(swScope);
                scopeRequest.onerror = function (event) {
                    reject(event.target.error);
                };
                scopeRequest.onsuccess = function (event) {
                    resolve(event.target.result);
                };
            });
        });
    };
    TokenManager.prototype.getAllTokenDetailsForSenderId_ = function (senderId) {
        return this.openDatabase_().then(function (db) {
            return new Promise(function (resolve, reject) {
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var senderIdTokens = [];
                var cursorRequest = objectStore.openCursor();
                cursorRequest.onerror = function (event) {
                    reject(event.target.error);
                };
                cursorRequest.onsuccess = function (event) {
                    var cursor = event.target.result;
                    if (cursor) {
                        if (cursor.value['fcmSenderId'] === senderId) {
                            senderIdTokens.push(cursor.value);
                        }
                        cursor.continue();
                    }
                    else {
                        resolve(senderIdTokens);
                    }
                };
            });
        });
    };
    /**
     * Given a PushSubscription and messagingSenderId, get an FCM token.
     * @public
     * @param  {string} senderId The 'messagingSenderId' to tie the token to.
     * @param  {PushSubscription} subscription The PushSusbcription to "federate".
     * @param  {string=} pushSet If defined this will swap the subscription for
     * matching FCM token.
     * @return {Promise<!Object>} Returns the FCM token to be used in place
     * of the PushSubscription.
     */
    TokenManager.prototype.subscribeToFCM = function (senderId, subscription, pushSet) {
        var _this = this;
        var p256dh = array_buffer_to_base64_1.default(subscription['getKey']('p256dh'));
        var auth = array_buffer_to_base64_1.default(subscription['getKey']('auth'));
        var fcmSubscribeBody = "authorized_entity=" + senderId + "&" +
            ("endpoint=" + subscription.endpoint + "&") +
            ("encryption_key=" + p256dh + "&") +
            ("encryption_auth=" + auth);
        if (pushSet) {
            fcmSubscribeBody += "&pushSet=" + pushSet;
        }
        var headers = new Headers();
        headers.append('Content-Type', 'application/x-www-form-urlencoded');
        var subscribeOptions = {
            method: 'POST',
            headers: headers,
            body: fcmSubscribeBody
        };
        return fetch(fcm_details_1.default.ENDPOINT + '/fcm/connect/subscribe', subscribeOptions)
            .then(function (response) { return response.json(); })
            .then(function (response) {
            var fcmTokenResponse = response;
            if (fcmTokenResponse['error']) {
                var message = fcmTokenResponse['error']['message'];
                throw _this.errorFactory_.create(errors_1.default.codes.TOKEN_SUBSCRIBE_FAILED, {
                    message: message
                });
            }
            if (!fcmTokenResponse['token']) {
                throw _this.errorFactory_.create(errors_1.default.codes.TOKEN_SUBSCRIBE_NO_TOKEN);
            }
            if (!fcmTokenResponse['pushSet']) {
                throw _this.errorFactory_.create(errors_1.default.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);
            }
            return {
                token: fcmTokenResponse['token'],
                pushSet: fcmTokenResponse['pushSet']
            };
        });
    };
    /**
     * Checks the that fields in the PushSubscription are equivalent to the
     * details stores in the masterTokenDetails.
     * @private
     * @param  {PushSubscription} subscription The push subscription we expect
     * the master token to match.
     * @param  {Object}  masterTokenDetails The saved details we wish to compare
     * with the PushSubscription
     * @return {boolean} true if the subscription and token details are
     * equivalent.
     */
    TokenManager.prototype.isSameSubscription_ = function (subscription, masterTokenDetails) {
        // getKey() isn't defined in the PushSubscription externs file, hence
        // subscription['getKey']('<key name>').
        return (subscription.endpoint === masterTokenDetails['endpoint'] &&
            array_buffer_to_base64_1.default(subscription['getKey']('auth')) ===
                masterTokenDetails['auth'] &&
            array_buffer_to_base64_1.default(subscription['getKey']('p256dh')) ===
                masterTokenDetails['p256dh']);
    };
    /**
     * Save the details for the fcm token for re-use at a later date.
     * @private
     * @param  {string} senderId The 'messagingSenderId' used for this project
     * @param  {ServiceWorkerRegistration} swRegistration The service worker
     * used to subscribe the user for web push
     * @param  {PushSubscription} subscription The push subscription passed to
     * FCM for the current token.
     * @param  {string} fcmToken The FCM token currently used on this
     * device.
     * @param  {string} fcmPushSet The FCM push tied to the fcm token.
     * @return {Promise<void>}
     */
    TokenManager.prototype.saveTokenDetails_ = function (senderId, swRegistration, subscription, fcmToken, fcmPushSet) {
        var details = {
            swScope: swRegistration.scope,
            endpoint: subscription.endpoint,
            auth: array_buffer_to_base64_1.default(subscription['getKey']('auth')),
            p256dh: array_buffer_to_base64_1.default(subscription['getKey']('p256dh')),
            fcmToken: fcmToken,
            fcmPushSet: fcmPushSet,
            fcmSenderId: senderId
        };
        return this.openDatabase_().then(function (db) {
            return new Promise(function (resolve, reject) {
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var request = objectStore.put(details);
                request.onerror = function (event) {
                    reject(event.target.error);
                };
                request.onsuccess = function (event) {
                    resolve();
                };
            });
        });
    };
    /**
     * Returns the saved FCM Token if one is available and still valid,
     * otherwise `null` is returned.
     * @param {string} senderId This should be the sender ID associated with the
     * FCM Token being retrieved.
     * @param {ServiceWorkerRegistration} swRegistration Registration to be used
     * to subscribe the user to push.
     * @return {Promise<string> | Promise} Returns the saved FCM Token if
     * avilable and valid.
     * @export
     */
    TokenManager.prototype.getSavedToken = function (senderId, swRegistration) {
        var _this = this;
        if (!(swRegistration instanceof ServiceWorkerRegistration)) {
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.SW_REGISTRATION_EXPECTED));
        }
        if (typeof senderId !== 'string' || senderId.length === 0) {
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_SENDER_ID));
        }
        return this.getAllTokenDetailsForSenderId_(senderId)
            .then(function (allTokenDetails) {
            if (allTokenDetails.length === 0) {
                return;
            }
            var index = allTokenDetails.findIndex(function (tokenDetails) {
                return (swRegistration.scope === tokenDetails['swScope'] &&
                    senderId === tokenDetails['fcmSenderId']);
            });
            if (index === -1) {
                return;
            }
            return allTokenDetails[index];
        })
            .then(function (tokenDetails) {
            if (!tokenDetails) {
                return;
            }
            return swRegistration.pushManager
                .getSubscription()
                .catch(function (err) {
                throw _this.errorFactory_.create(errors_1.default.codes.GET_SUBSCRIPTION_FAILED);
            })
                .then(function (subscription) {
                if (subscription &&
                    _this.isSameSubscription_(subscription, tokenDetails)) {
                    return tokenDetails['fcmToken'];
                }
            });
        });
    };
    /**
     * Creates a new FCM token.
     */
    TokenManager.prototype.createToken = function (senderId, swRegistration) {
        var _this = this;
        if (typeof senderId !== 'string' || senderId.length === 0) {
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.BAD_SENDER_ID));
        }
        if (!(swRegistration instanceof ServiceWorkerRegistration)) {
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.SW_REGISTRATION_EXPECTED));
        }
        // Check for existing subscription first
        var subscription;
        var fcmTokenDetails;
        return swRegistration.pushManager
            .getSubscription()
            .then(function (subscription) {
            if (subscription) {
                return subscription;
            }
            return swRegistration.pushManager.subscribe(fcm_details_1.default.SUBSCRIPTION_OPTIONS);
        })
            .then(function (sub) {
            subscription = sub;
            return _this.subscribeToFCM(senderId, subscription);
        })
            .then(function (tokenDetails) {
            fcmTokenDetails = tokenDetails;
            return _this.saveTokenDetails_(senderId, swRegistration, subscription, fcmTokenDetails['token'], fcmTokenDetails['pushSet']);
        })
            .then(function () { return fcmTokenDetails['token']; });
    };
    /**
     * This method deletes details of the current FCM token.
     * It's returning a promise in case we need to move to an async
     * method for deleting at a later date.
     * @param {string} token Token to be deleted
     * @return {Promise<Object>} Resolves once the FCM token details have been
     * deleted and returns the deleted details.
     */
    TokenManager.prototype.deleteToken = function (token) {
        var _this = this;
        if (typeof token !== 'string' || token.length === 0) {
            return Promise.reject(this.errorFactory_.create(errors_1.default.codes.INVALID_DELETE_TOKEN));
        }
        return this.getTokenDetailsFromToken(token).then(function (details) {
            if (!details) {
                throw _this.errorFactory_.create(errors_1.default.codes.DELETE_TOKEN_NOT_FOUND);
            }
            return _this.openDatabase_().then(function (db) {
                return new Promise(function (resolve, reject) {
                    var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');
                    var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                    var request = objectStore.delete(details['swScope']);
                    request.onerror = function (event) {
                        reject(event.target.error);
                    };
                    request.onsuccess = function (event) {
                        if (event.target.result === 0) {
                            reject(_this.errorFactory_.create(errors_1.default.codes.FAILED_TO_DELETE_TOKEN));
                            return;
                        }
                        resolve(details);
                    };
                });
            });
        });
    };
    return TokenManager;
}());
exports.default = TokenManager;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/messaging/dist/cjs/src/models/token-manager.js","/node_modules/@firebase/messaging/dist/cjs/src/models")

},{"../helpers/array-buffer-to-base64":90,"./errors":92,"./fcm-details":93,"@firebase/util":134,"_process":162,"buffer":160}],96:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// These fields are strings to prevent closure from thinking goog.getMsg
// should be used to initialise the values
var PARAMS = {
    TYPE_OF_MSG: 'firebase-messaging-msg-type',
    DATA: 'firebase-messaging-msg-data'
};
// This value isn't using the TYPE_OF_MSG short hand as closure
// expects the variable to be defined via goog.getMsg
var msgType = {
    PUSH_MSG_RECEIVED: 'push-msg-received',
    NOTIFICATION_CLICKED: 'notification-clicked'
};
var createNewMsg = function (msgType, msgData) {
    var message = (_a = {},
        _a[PARAMS.TYPE_OF_MSG] = msgType,
        _a[PARAMS.DATA] = msgData,
        _a);
    return message;
    var _a;
};
exports.default = {
    PARAMS: PARAMS,
    TYPES_OF_MSG: msgType,
    createNewMsg: createNewMsg
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/messaging/dist/cjs/src/models/worker-page-message.js","/node_modules/@firebase/messaging/dist/cjs/src/models")

},{"_process":162,"buffer":160}],97:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
require("./src/polyfills/promise");
require("./src/shims/find");
require("./src/shims/findIndex");



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/polyfill/dist/cjs/index.js","/node_modules/@firebase/polyfill/dist/cjs")

},{"./src/polyfills/promise":98,"./src/shims/find":99,"./src/shims/findIndex":100,"_process":162,"buffer":160}],98:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __global = (function () {
    if (typeof global !== 'undefined') {
        return global;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof self !== 'undefined') {
        return self;
    }
    throw new Error('unable to locate global object');
})();
// Polyfill Promise
if (typeof Promise === 'undefined') {
    // HACK: TS throws an error if I attempt to use 'dot-notation'
    __global['Promise'] = Promise = require('promise-polyfill');
}



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/polyfill/dist/cjs/src/polyfills/promise.js","/node_modules/@firebase/polyfill/dist/cjs/src/polyfills")

},{"_process":162,"buffer":160,"promise-polyfill":157}],99:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This is the Array.prototype.find polyfill from MDN
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * https://tc39.github.io/ecma262/#sec-array.prototype.find
 */
if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
        value: function (predicate) {
            // 1. Let O be ? ToObject(this value).
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            // 2. Let len be ? ToLength(? Get(O, "length")).
            var len = o.length >>> 0;
            // 3. If IsCallable(predicate) is false, throw a TypeError exception.
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
            var thisArg = arguments[1];
            // 5. Let k be 0.
            var k = 0;
            // 6. Repeat, while k < len
            while (k < len) {
                // a. Let Pk be ! ToString(k).
                // b. Let kValue be ? Get(O, Pk).
                // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
                // d. If testResult is true, return kValue.
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return kValue;
                }
                // e. Increase k by 1.
                k++;
            }
            // 7. Return undefined.
            return undefined;
        }
    });
}



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/polyfill/dist/cjs/src/shims/find.js","/node_modules/@firebase/polyfill/dist/cjs/src/shims")

},{"_process":162,"buffer":160}],100:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This is the Array.prototype.findIndex polyfill from MDN
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
 * https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
 */
if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, 'findIndex', {
        value: function (predicate) {
            // 1. Let O be ? ToObject(this value).
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            // 2. Let len be ? ToLength(? Get(O, "length")).
            var len = o.length >>> 0;
            // 3. If IsCallable(predicate) is false, throw a TypeError exception.
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
            var thisArg = arguments[1];
            // 5. Let k be 0.
            var k = 0;
            // 6. Repeat, while k < len
            while (k < len) {
                // a. Let Pk be ! ToString(k).
                // b. Let kValue be ? Get(O, Pk).
                // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
                // d. If testResult is true, return k.
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return k;
                }
                // e. Increase k by 1.
                k++;
            }
            // 7. Return -1.
            return -1;
        }
    });
}



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/polyfill/dist/cjs/src/shims/findIndex.js","/node_modules/@firebase/polyfill/dist/cjs/src/shims")

},{"_process":162,"buffer":160}],101:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var app_1 = require("@firebase/app");
var string_1 = require("./src/implementation/string");
var taskenums_1 = require("./src/implementation/taskenums");
var taskenums_2 = require("./src/implementation/taskenums");
var xhriopool_1 = require("./src/implementation/xhriopool");
var reference_1 = require("./src/reference");
var service_1 = require("./src/service");
/**
 * Type constant for Firebase Storage.
 */
var STORAGE_TYPE = 'storage';
function factory(app, unused, opt_url) {
    return new service_1.Service(app, new xhriopool_1.XhrIoPool(), opt_url);
}
function registerStorage(instance) {
    var namespaceExports = {
        // no-inline
        TaskState: taskenums_2.TaskState,
        TaskEvent: taskenums_1.TaskEvent,
        StringFormat: string_1.StringFormat,
        Storage: service_1.Service,
        Reference: reference_1.Reference
    };
    instance.INTERNAL.registerService(STORAGE_TYPE, factory, namespaceExports, undefined, 
    // Allow multiple storage instances per app.
    true);
}
exports.registerStorage = registerStorage;
registerStorage(app_1.default);



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/index.js","/node_modules/@firebase/storage/dist/cjs")

},{"./src/implementation/string":123,"./src/implementation/taskenums":124,"./src/implementation/xhriopool":129,"./src/reference":130,"./src/service":131,"@firebase/app":1,"_process":162,"buffer":160}],102:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var errorsExports = require("./error");
var MetadataUtils = require("./metadata");
var type = require("./type");
/**
 * @param name Name of the function.
 * @param specs Argument specs.
 * @param passed The actual arguments passed to the function.
 * @throws {fbs.Error} If the arguments are invalid.
 */
function validate(name, specs, passed) {
    var minArgs = specs.length;
    var maxArgs = specs.length;
    for (var i = 0; i < specs.length; i++) {
        if (specs[i].optional) {
            minArgs = i;
            break;
        }
    }
    var validLength = minArgs <= passed.length && passed.length <= maxArgs;
    if (!validLength) {
        throw errorsExports.invalidArgumentCount(minArgs, maxArgs, name, passed.length);
    }
    for (var i = 0; i < passed.length; i++) {
        try {
            specs[i].validator(passed[i]);
        }
        catch (e) {
            if (e instanceof Error) {
                throw errorsExports.invalidArgument(i, name, e.message);
            }
            else {
                throw errorsExports.invalidArgument(i, name, e);
            }
        }
    }
}
exports.validate = validate;
/**
 * @struct
 */
var ArgSpec = /** @class */ (function () {
    function ArgSpec(validator, opt_optional) {
        var self = this;
        this.validator = function (p) {
            if (self.optional && !type.isJustDef(p)) {
                return;
            }
            validator(p);
        };
        this.optional = !!opt_optional;
    }
    return ArgSpec;
}());
exports.ArgSpec = ArgSpec;
function and_(v1, v2) {
    return function (p) {
        v1(p);
        v2(p);
    };
}
exports.and_ = and_;
function stringSpec(opt_validator, opt_optional) {
    function stringValidator(p) {
        if (!type.isString(p)) {
            throw 'Expected string.';
        }
    }
    var validator;
    if (opt_validator) {
        validator = and_(stringValidator, opt_validator);
    }
    else {
        validator = stringValidator;
    }
    return new ArgSpec(validator, opt_optional);
}
exports.stringSpec = stringSpec;
function uploadDataSpec() {
    function validator(p) {
        var valid = p instanceof Uint8Array ||
            p instanceof ArrayBuffer ||
            (type.isNativeBlobDefined() && p instanceof Blob);
        if (!valid) {
            throw 'Expected Blob or File.';
        }
    }
    return new ArgSpec(validator);
}
exports.uploadDataSpec = uploadDataSpec;
function metadataSpec(opt_optional) {
    return new ArgSpec(MetadataUtils.metadataValidator, opt_optional);
}
exports.metadataSpec = metadataSpec;
function nonNegativeNumberSpec() {
    function validator(p) {
        var valid = type.isNumber(p) && p >= 0;
        if (!valid) {
            throw 'Expected a number 0 or greater.';
        }
    }
    return new ArgSpec(validator);
}
exports.nonNegativeNumberSpec = nonNegativeNumberSpec;
function looseObjectSpec(opt_validator, opt_optional) {
    function validator(p) {
        var isLooseObject = p === null || (type.isDef(p) && p instanceof Object);
        if (!isLooseObject) {
            throw 'Expected an Object.';
        }
        if (opt_validator !== undefined && opt_validator !== null) {
            opt_validator(p);
        }
    }
    return new ArgSpec(validator, opt_optional);
}
exports.looseObjectSpec = looseObjectSpec;
function nullFunctionSpec(opt_optional) {
    function validator(p) {
        var valid = p === null || type.isFunction(p);
        if (!valid) {
            throw 'Expected a Function.';
        }
    }
    return new ArgSpec(validator, opt_optional);
}
exports.nullFunctionSpec = nullFunctionSpec;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/args.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./error":109,"./metadata":114,"./type":125,"_process":162,"buffer":160}],103:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns true if the object is contained in the array (compared with ===).
 * @template T
 */
function contains(array, elem) {
    return array.indexOf(elem) !== -1;
}
exports.contains = contains;
/**
 * Returns a shallow copy of the array or array-like object (e.g. arguments).
 * @template T
 */
function clone(arraylike) {
    return Array.prototype.slice.call(arraylike);
}
exports.clone = clone;
/**
 * Removes the given element from the given array, if it is contained.
 * Directly modifies the passed-in array.
 * @template T
 */
function remove(array, elem) {
    var i = array.indexOf(elem);
    if (i !== -1) {
        array.splice(i, 1);
    }
}
exports.remove = remove;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/array.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"_process":162,"buffer":160}],104:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Method for invoking a callback asynchronously.
 */
var promiseimpl = require("./promise_external");
/**
 * Returns a function that invokes f with its arguments asynchronously as a
 * microtask, i.e. as soon as possible after the current script returns back
 * into browser code.
 */
function async(f) {
    return function () {
        var argsToForward = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            argsToForward[_i] = arguments[_i];
        }
        promiseimpl.resolve(true).then(function () {
            f.apply(null, argsToForward);
        });
    };
}
exports.async = async;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/async.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./promise_external":118,"_process":162,"buffer":160}],105:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var constants = require("./constants");
var errorsExports = require("./error");
var failrequest_1 = require("./failrequest");
var location_1 = require("./location");
var promiseimpl = require("./promise_external");
var requestmap_1 = require("./requestmap");
var type = require("./type");
/**
 * @param app If null, getAuthToken always resolves with null.
 * @param service The storage service associated with this auth wrapper.
 *     Untyped to avoid circular type dependencies.
 * @struct
 */
var AuthWrapper = /** @class */ (function () {
    function AuthWrapper(app, maker, requestMaker, service, pool) {
        this.bucket_ = null;
        this.deleted_ = false;
        this.app_ = app;
        if (this.app_ !== null) {
            var options = this.app_.options;
            if (type.isDef(options)) {
                this.bucket_ = AuthWrapper.extractBucket_(options);
            }
        }
        this.storageRefMaker_ = maker;
        this.requestMaker_ = requestMaker;
        this.pool_ = pool;
        this.service_ = service;
        this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;
        this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;
        this.requestMap_ = new requestmap_1.RequestMap();
    }
    AuthWrapper.extractBucket_ = function (config) {
        var bucketString = config[constants.configOption] || null;
        if (bucketString == null) {
            return null;
        }
        var loc = location_1.Location.makeFromBucketSpec(bucketString);
        return loc.bucket;
    };
    AuthWrapper.prototype.getAuthToken = function () {
        // TODO(andysoto): remove ifDef checks after firebase-app implements stubs
        // (b/28673818).
        if (this.app_ !== null &&
            type.isDef(this.app_.INTERNAL) &&
            type.isDef(this.app_.INTERNAL.getToken)) {
            return this.app_.INTERNAL.getToken().then(function (response) {
                if (response !== null) {
                    return response.accessToken;
                }
                else {
                    return null;
                }
            }, function (_error) {
                return null;
            });
        }
        else {
            return promiseimpl.resolve(null);
        }
    };
    AuthWrapper.prototype.bucket = function () {
        if (this.deleted_) {
            throw errorsExports.appDeleted();
        }
        else {
            return this.bucket_;
        }
    };
    /**
     * The service associated with this auth wrapper. Untyped to avoid circular
     * type dependencies.
     */
    AuthWrapper.prototype.service = function () {
        return this.service_;
    };
    /**
     * Returns a new firebaseStorage.Reference object referencing this AuthWrapper
     * at the given Location.
     * @param loc The Location.
     * @return Actually a firebaseStorage.Reference, typing not allowed
     *     because of circular dependency problems.
     */
    AuthWrapper.prototype.makeStorageReference = function (loc) {
        return this.storageRefMaker_(this, loc);
    };
    AuthWrapper.prototype.makeRequest = function (requestInfo, authToken) {
        if (!this.deleted_) {
            var request = this.requestMaker_(requestInfo, authToken, this.pool_);
            this.requestMap_.addRequest(request);
            return request;
        }
        else {
            return new failrequest_1.FailRequest(errorsExports.appDeleted());
        }
    };
    /**
     * Stop running requests and prevent more from being created.
     */
    AuthWrapper.prototype.deleteApp = function () {
        this.deleted_ = true;
        this.app_ = null;
        this.requestMap_.clear();
    };
    AuthWrapper.prototype.maxUploadRetryTime = function () {
        return this.maxUploadRetryTime_;
    };
    AuthWrapper.prototype.setMaxUploadRetryTime = function (time) {
        this.maxUploadRetryTime_ = time;
    };
    AuthWrapper.prototype.maxOperationRetryTime = function () {
        return this.maxOperationRetryTime_;
    };
    AuthWrapper.prototype.setMaxOperationRetryTime = function (time) {
        this.maxOperationRetryTime_ = time;
    };
    return AuthWrapper;
}());
exports.AuthWrapper = AuthWrapper;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/authwrapper.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./constants":108,"./error":109,"./failrequest":110,"./location":113,"./promise_external":118,"./requestmap":121,"./type":125,"_process":162,"buffer":160}],106:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @param f May be invoked
 *     before the function returns.
 * @param callback Get all the arguments passed to the function
 *     passed to f, including the initial boolean.
 */
function start(f, callback, timeout) {
    // TODO(andysoto): make this code cleaner (probably refactor into an actual
    // type instead of a bunch of functions with state shared in the closure)
    var waitSeconds = 1;
    // Would type this as "number" but that doesn't work for Node so ¯\_(ツ)_/¯
    var timeoutId = null;
    var hitTimeout = false;
    var cancelState = 0;
    function canceled() {
        return cancelState === 2;
    }
    var triggeredCallback = false;
    function triggerCallback() {
        if (!triggeredCallback) {
            triggeredCallback = true;
            callback.apply(null, arguments);
        }
    }
    function callWithDelay(millis) {
        timeoutId = setTimeout(function () {
            timeoutId = null;
            f(handler, canceled());
        }, millis);
    }
    function handler(success) {
        var var_args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            var_args[_i - 1] = arguments[_i];
        }
        if (triggeredCallback) {
            return;
        }
        if (success) {
            triggerCallback.apply(null, arguments);
            return;
        }
        var mustStop = canceled() || hitTimeout;
        if (mustStop) {
            triggerCallback.apply(null, arguments);
            return;
        }
        if (waitSeconds < 64) {
            /* TODO(andysoto): don't back off so quickly if we know we're offline. */
            waitSeconds *= 2;
        }
        var waitMillis;
        if (cancelState === 1) {
            cancelState = 2;
            waitMillis = 0;
        }
        else {
            waitMillis = (waitSeconds + Math.random()) * 1000;
        }
        callWithDelay(waitMillis);
    }
    var stopped = false;
    function stop(wasTimeout) {
        if (stopped) {
            return;
        }
        stopped = true;
        if (triggeredCallback) {
            return;
        }
        if (timeoutId !== null) {
            if (!wasTimeout) {
                cancelState = 2;
            }
            clearTimeout(timeoutId);
            callWithDelay(0);
        }
        else {
            if (!wasTimeout) {
                cancelState = 1;
            }
        }
    }
    callWithDelay(0);
    setTimeout(function () {
        hitTimeout = true;
        stop(true);
    }, timeout);
    return stop;
}
exports.start = start;
/**
 * Stops the retry loop from repeating.
 * If the function is currently "in between" retries, it is invoked immediately
 * with the second parameter as "true". Otherwise, it will be invoked once more
 * after the current invocation finishes iff the current invocation would have
 * triggered another retry.
 */
function stop(id) {
    id(false);
}
exports.stop = stop;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/backoff.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"_process":162,"buffer":160}],107:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @file Provides a Blob-like wrapper for various binary types (including the
 * native Blob type). This makes it possible to upload types like ArrayBuffers,
 * making uploads possible in environments without the native Blob type.
 */
var fs = require("./fs");
var string = require("./string");
var string_1 = require("./string");
var type = require("./type");
/**
 * @param opt_elideCopy If true, doesn't copy mutable input data
 *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be
 *     modified after this blob's construction.
 */
var FbsBlob = /** @class */ (function () {
    function FbsBlob(data, opt_elideCopy) {
        var size = 0;
        var blobType = '';
        if (type.isNativeBlob(data)) {
            this.data_ = data;
            size = data.size;
            blobType = data.type;
        }
        else if (data instanceof ArrayBuffer) {
            if (opt_elideCopy) {
                this.data_ = new Uint8Array(data);
            }
            else {
                this.data_ = new Uint8Array(data.byteLength);
                this.data_.set(new Uint8Array(data));
            }
            size = this.data_.length;
        }
        else if (data instanceof Uint8Array) {
            if (opt_elideCopy) {
                this.data_ = data;
            }
            else {
                this.data_ = new Uint8Array(data.length);
                this.data_.set(data);
            }
            size = data.length;
        }
        this.size_ = size;
        this.type_ = blobType;
    }
    FbsBlob.prototype.size = function () {
        return this.size_;
    };
    FbsBlob.prototype.type = function () {
        return this.type_;
    };
    FbsBlob.prototype.slice = function (startByte, endByte) {
        if (type.isNativeBlob(this.data_)) {
            var realBlob = this.data_;
            var sliced = fs.sliceBlob(realBlob, startByte, endByte);
            if (sliced === null) {
                return null;
            }
            return new FbsBlob(sliced);
        }
        else {
            var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
            return new FbsBlob(slice, true);
        }
    };
    FbsBlob.getBlob = function () {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            var_args[_i] = arguments[_i];
        }
        if (type.isNativeBlobDefined()) {
            var blobby = var_args.map(function (val) {
                if (val instanceof FbsBlob) {
                    return val.data_;
                }
                else {
                    return val;
                }
            });
            return new FbsBlob(fs.getBlob.apply(null, blobby));
        }
        else {
            var uint8Arrays = var_args.map(function (val) {
                if (type.isString(val)) {
                    return string.dataFromString(string_1.StringFormat.RAW, val).data;
                }
                else {
                    // Blobs don't exist, so this has to be a Uint8Array.
                    return val.data_;
                }
            });
            var finalLength_1 = 0;
            uint8Arrays.forEach(function (array) {
                finalLength_1 += array.byteLength;
            });
            var merged_1 = new Uint8Array(finalLength_1);
            var index_1 = 0;
            uint8Arrays.forEach(function (array) {
                for (var i = 0; i < array.length; i++) {
                    merged_1[index_1++] = array[i];
                }
            });
            return new FbsBlob(merged_1, true);
        }
    };
    FbsBlob.prototype.uploadData = function () {
        return this.data_;
    };
    return FbsBlob;
}());
exports.FbsBlob = FbsBlob;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/blob.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./fs":111,"./string":123,"./type":125,"_process":162,"buffer":160}],108:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Constants used in the Firebase Storage library.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Domain and scheme for API calls.
 */
exports.domainBase = 'https://firebasestorage.googleapis.com';
/**
 * Domain and scheme for object downloads.
 */
exports.downloadBase = 'https://firebasestorage.googleapis.com';
/**
 * Base URL for non-upload calls to the API.
 */
exports.apiBaseUrl = '/v0';
/**
 * Base URL for upload calls to the API.
 */
exports.apiUploadBaseUrl = '/v0';
function setDomainBase(domainBase) {
    domainBase = domainBase;
}
exports.setDomainBase = setDomainBase;
exports.configOption = 'storageBucket';
/**
 * 1 minute
 */
exports.shortMaxOperationRetryTime = 1 * 60 * 1000;
/**
 * 2 minutes
 */
exports.defaultMaxOperationRetryTime = 2 * 60 * 1000;
/**
 * 10 minutes
 */
exports.defaultMaxUploadRetryTime = 10 * 60 * 100;
/**
 * This is the value of Number.MIN_SAFE_INTEGER, which is not well supported
 * enough for us to use it directly.
 */
exports.minSafeInteger = -9007199254740991;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/constants.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"_process":162,"buffer":160}],109:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var constants_1 = require("./constants");
var FirebaseStorageError = /** @class */ (function () {
    function FirebaseStorageError(code, message) {
        this.code_ = prependCode(code);
        this.message_ = 'Firebase Storage: ' + message;
        this.serverResponse_ = null;
        this.name_ = 'FirebaseError';
    }
    FirebaseStorageError.prototype.codeProp = function () {
        return this.code;
    };
    FirebaseStorageError.prototype.codeEquals = function (code) {
        return prependCode(code) === this.codeProp();
    };
    FirebaseStorageError.prototype.serverResponseProp = function () {
        return this.serverResponse_;
    };
    FirebaseStorageError.prototype.setServerResponseProp = function (serverResponse) {
        this.serverResponse_ = serverResponse;
    };
    Object.defineProperty(FirebaseStorageError.prototype, "name", {
        get: function () {
            return this.name_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseStorageError.prototype, "code", {
        get: function () {
            return this.code_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseStorageError.prototype, "message", {
        get: function () {
            return this.message_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseStorageError.prototype, "serverResponse", {
        get: function () {
            return this.serverResponse_;
        },
        enumerable: true,
        configurable: true
    });
    return FirebaseStorageError;
}());
exports.FirebaseStorageError = FirebaseStorageError;
exports.errors = {};
exports.Code = {
    // Shared between all platforms
    UNKNOWN: 'unknown',
    OBJECT_NOT_FOUND: 'object-not-found',
    BUCKET_NOT_FOUND: 'bucket-not-found',
    PROJECT_NOT_FOUND: 'project-not-found',
    QUOTA_EXCEEDED: 'quota-exceeded',
    UNAUTHENTICATED: 'unauthenticated',
    UNAUTHORIZED: 'unauthorized',
    RETRY_LIMIT_EXCEEDED: 'retry-limit-exceeded',
    INVALID_CHECKSUM: 'invalid-checksum',
    CANCELED: 'canceled',
    // JS specific
    INVALID_EVENT_NAME: 'invalid-event-name',
    INVALID_URL: 'invalid-url',
    INVALID_DEFAULT_BUCKET: 'invalid-default-bucket',
    NO_DEFAULT_BUCKET: 'no-default-bucket',
    CANNOT_SLICE_BLOB: 'cannot-slice-blob',
    SERVER_FILE_WRONG_SIZE: 'server-file-wrong-size',
    NO_DOWNLOAD_URL: 'no-download-url',
    INVALID_ARGUMENT: 'invalid-argument',
    INVALID_ARGUMENT_COUNT: 'invalid-argument-count',
    APP_DELETED: 'app-deleted',
    INVALID_ROOT_OPERATION: 'invalid-root-operation',
    INVALID_FORMAT: 'invalid-format',
    INTERNAL_ERROR: 'internal-error'
};
function prependCode(code) {
    return 'storage/' + code;
}
exports.prependCode = prependCode;
function unknown() {
    var message = 'An unknown error occurred, please check the error payload for ' +
        'server response.';
    return new FirebaseStorageError(exports.Code.UNKNOWN, message);
}
exports.unknown = unknown;
function objectNotFound(path) {
    return new FirebaseStorageError(exports.Code.OBJECT_NOT_FOUND, "Object '" + path + "' does not exist.");
}
exports.objectNotFound = objectNotFound;
function bucketNotFound(bucket) {
    return new FirebaseStorageError(exports.Code.BUCKET_NOT_FOUND, "Bucket '" + bucket + "' does not exist.");
}
exports.bucketNotFound = bucketNotFound;
function projectNotFound(project) {
    return new FirebaseStorageError(exports.Code.PROJECT_NOT_FOUND, "Project '" + project + "' does not exist.");
}
exports.projectNotFound = projectNotFound;
function quotaExceeded(bucket) {
    return new FirebaseStorageError(exports.Code.QUOTA_EXCEEDED, "Quota for bucket '" +
        bucket +
        "' exceeded, please view quota on " +
        'https://firebase.google.com/pricing/.');
}
exports.quotaExceeded = quotaExceeded;
function unauthenticated() {
    var message = 'User is not authenticated, please authenticate using Firebase ' +
        'Authentication and try again.';
    return new FirebaseStorageError(exports.Code.UNAUTHENTICATED, message);
}
exports.unauthenticated = unauthenticated;
function unauthorized(path) {
    return new FirebaseStorageError(exports.Code.UNAUTHORIZED, "User does not have permission to access '" + path + "'.");
}
exports.unauthorized = unauthorized;
function retryLimitExceeded() {
    return new FirebaseStorageError(exports.Code.RETRY_LIMIT_EXCEEDED, 'Max retry time for operation exceeded, please try again.');
}
exports.retryLimitExceeded = retryLimitExceeded;
function invalidChecksum(path, checksum, calculated) {
    return new FirebaseStorageError(exports.Code.INVALID_CHECKSUM, "Uploaded/downloaded object '" +
        path +
        "' has checksum '" +
        checksum +
        "' which does not match '" +
        calculated +
        "'. Please retry the upload/download.");
}
exports.invalidChecksum = invalidChecksum;
function canceled() {
    return new FirebaseStorageError(exports.Code.CANCELED, 'User canceled the upload/download.');
}
exports.canceled = canceled;
function invalidEventName(name) {
    return new FirebaseStorageError(exports.Code.INVALID_EVENT_NAME, "Invalid event name '" + name + "'.");
}
exports.invalidEventName = invalidEventName;
function invalidUrl(url) {
    return new FirebaseStorageError(exports.Code.INVALID_URL, "Invalid URL '" + url + "'.");
}
exports.invalidUrl = invalidUrl;
function invalidDefaultBucket(bucket) {
    return new FirebaseStorageError(exports.Code.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + bucket + "'.");
}
exports.invalidDefaultBucket = invalidDefaultBucket;
function noDefaultBucket() {
    return new FirebaseStorageError(exports.Code.NO_DEFAULT_BUCKET, 'No default bucket ' +
        "found. Did you set the '" +
        constants_1.configOption +
        "' property when initializing the app?");
}
exports.noDefaultBucket = noDefaultBucket;
function cannotSliceBlob() {
    return new FirebaseStorageError(exports.Code.CANNOT_SLICE_BLOB, 'Cannot slice blob for upload. Please retry the upload.');
}
exports.cannotSliceBlob = cannotSliceBlob;
function serverFileWrongSize() {
    return new FirebaseStorageError(exports.Code.SERVER_FILE_WRONG_SIZE, 'Server recorded incorrect upload file size, please retry the upload.');
}
exports.serverFileWrongSize = serverFileWrongSize;
function noDownloadURL() {
    return new FirebaseStorageError(exports.Code.NO_DOWNLOAD_URL, 'The given file does not have any download URLs.');
}
exports.noDownloadURL = noDownloadURL;
function invalidArgument(index, fnName, message) {
    return new FirebaseStorageError(exports.Code.INVALID_ARGUMENT, 'Invalid argument in `' + fnName + '` at index ' + index + ': ' + message);
}
exports.invalidArgument = invalidArgument;
function invalidArgumentCount(argMin, argMax, fnName, real) {
    var countPart;
    var plural;
    if (argMin === argMax) {
        countPart = argMin;
        plural = argMin === 1 ? 'argument' : 'arguments';
    }
    else {
        countPart = 'between ' + argMin + ' and ' + argMax;
        plural = 'arguments';
    }
    return new FirebaseStorageError(exports.Code.INVALID_ARGUMENT_COUNT, 'Invalid argument count in `' +
        fnName +
        '`: Expected ' +
        countPart +
        ' ' +
        plural +
        ', received ' +
        real +
        '.');
}
exports.invalidArgumentCount = invalidArgumentCount;
function appDeleted() {
    return new FirebaseStorageError(exports.Code.APP_DELETED, 'The Firebase app was deleted.');
}
exports.appDeleted = appDeleted;
/**
 * @param name The name of the operation that was invalid.
 */
function invalidRootOperation(name) {
    return new FirebaseStorageError(exports.Code.INVALID_ROOT_OPERATION, "The operation '" +
        name +
        "' cannot be performed on a root reference, create a non-root " +
        "reference using child, such as .child('file.png').");
}
exports.invalidRootOperation = invalidRootOperation;
/**
 * @param format The format that was not valid.
 * @param message A message describing the format violation.
 */
function invalidFormat(format, message) {
    return new FirebaseStorageError(exports.Code.INVALID_FORMAT, "String does not match format '" + format + "': " + message);
}
exports.invalidFormat = invalidFormat;
/**
 * @param message A message describing the internal error.
 */
function internalError(message) {
    throw new FirebaseStorageError(exports.Code.INTERNAL_ERROR, 'Internal error: ' + message);
}
exports.internalError = internalError;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/error.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./constants":108,"_process":162,"buffer":160}],110:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var promiseimpl = require("./promise_external");
/**
 * A request whose promise always fails.
 * @struct
 * @template T
 */
var FailRequest = /** @class */ (function () {
    function FailRequest(error) {
        this.promise_ = promiseimpl.reject(error);
    }
    /** @inheritDoc */
    FailRequest.prototype.getPromise = function () {
        return this.promise_;
    };
    /** @inheritDoc */
    FailRequest.prototype.cancel = function (appDelete) {
        if (appDelete === void 0) { appDelete = false; }
    };
    return FailRequest;
}());
exports.FailRequest = FailRequest;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/failrequest.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./promise_external":118,"_process":162,"buffer":160}],111:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var type = require("./type");
function getBlobBuilder() {
    if (typeof BlobBuilder !== 'undefined') {
        return BlobBuilder;
    }
    else if (typeof WebKitBlobBuilder !== 'undefined') {
        return WebKitBlobBuilder;
    }
    else {
        return undefined;
    }
}
/**
 * Concatenates one or more values together and converts them to a Blob.
 *
 * @param var_args The values that will make up the resulting blob.
 * @return The blob.
 */
function getBlob() {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    var BlobBuilder = getBlobBuilder();
    if (BlobBuilder !== undefined) {
        var bb = new BlobBuilder();
        for (var i = 0; i < var_args.length; i++) {
            bb.append(var_args[i]);
        }
        return bb.getBlob();
    }
    else {
        if (type.isNativeBlobDefined()) {
            return new Blob(var_args);
        }
        else {
            throw Error("This browser doesn't seem to support creating Blobs");
        }
    }
}
exports.getBlob = getBlob;
/**
 * Slices the blob. The returned blob contains data from the start byte
 * (inclusive) till the end byte (exclusive). Negative indices cannot be used.
 *
 * @param blob The blob to be sliced.
 * @param start Index of the starting byte.
 * @param end Index of the ending byte.
 * @return The blob slice or null if not supported.
 */
function sliceBlob(blob, start, end) {
    if (blob.webkitSlice) {
        return blob.webkitSlice(start, end);
    }
    else if (blob.mozSlice) {
        return blob.mozSlice(start, end);
    }
    else if (blob.slice) {
        return blob.slice(start, end);
    }
    return null;
}
exports.sliceBlob = sliceBlob;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/fs.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./type":125,"_process":162,"buffer":160}],112:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var type = require("./type");
/**
 * Returns the Object resulting from parsing the given JSON, or null if the
 * given string does not represent a JSON object.
 */
function jsonObjectOrNull(s) {
    var obj;
    try {
        obj = JSON.parse(s);
    }
    catch (e) {
        return null;
    }
    if (type.isNonArrayObject(obj)) {
        return obj;
    }
    else {
        return null;
    }
}
exports.jsonObjectOrNull = jsonObjectOrNull;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/json.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./type":125,"_process":162,"buffer":160}],113:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Functionality related to the parsing/composition of bucket/
 * object location.
 */
var errorsExports = require("./error");
/**
 * @struct
 */
var Location = /** @class */ (function () {
    function Location(bucket, path) {
        this.bucket = bucket;
        this.path_ = path;
    }
    Object.defineProperty(Location.prototype, "path", {
        get: function () {
            return this.path_;
        },
        enumerable: true,
        configurable: true
    });
    Location.prototype.fullServerUrl = function () {
        var encode = encodeURIComponent;
        return '/b/' + encode(this.bucket) + '/o/' + encode(this.path);
    };
    Location.prototype.bucketOnlyServerUrl = function () {
        var encode = encodeURIComponent;
        return '/b/' + encode(this.bucket) + '/o';
    };
    Location.makeFromBucketSpec = function (bucketString) {
        var bucketLocation;
        try {
            bucketLocation = Location.makeFromUrl(bucketString);
        }
        catch (e) {
            // Not valid URL, use as-is. This lets you put bare bucket names in
            // config.
            return new Location(bucketString, '');
        }
        if (bucketLocation.path === '') {
            return bucketLocation;
        }
        else {
            throw errorsExports.invalidDefaultBucket(bucketString);
        }
    };
    Location.makeFromUrl = function (url) {
        var location = null;
        var bucketDomain = '([A-Za-z0-9.\\-]+)';
        function gsModify(loc) {
            if (loc.path.charAt(loc.path.length - 1) === '/') {
                loc.path_ = loc.path_.slice(0, -1);
            }
        }
        var gsPath = '(/(.*))?$';
        var path = '(/([^?#]*).*)?$';
        var gsRegex = new RegExp('^gs://' + bucketDomain + gsPath, 'i');
        var gsIndices = { bucket: 1, path: 3 };
        function httpModify(loc) {
            loc.path_ = decodeURIComponent(loc.path);
        }
        var version = 'v[A-Za-z0-9_]+';
        var httpRegex = new RegExp('^https?://firebasestorage\\.googleapis\\.com/' +
            version +
            '/b/' +
            bucketDomain +
            '/o' +
            path, 'i');
        var httpIndices = { bucket: 1, path: 3 };
        var groups = [
            { regex: gsRegex, indices: gsIndices, postModify: gsModify },
            { regex: httpRegex, indices: httpIndices, postModify: httpModify }
        ];
        for (var i = 0; i < groups.length; i++) {
            var group = groups[i];
            var captures = group.regex.exec(url);
            if (captures) {
                var bucketValue = captures[group.indices.bucket];
                var pathValue = captures[group.indices.path];
                if (!pathValue) {
                    pathValue = '';
                }
                location = new Location(bucketValue, pathValue);
                group.postModify(location);
                break;
            }
        }
        if (location == null) {
            throw errorsExports.invalidUrl(url);
        }
        return location;
    };
    return Location;
}());
exports.Location = Location;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/location.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./error":109,"_process":162,"buffer":160}],114:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var json = require("./json");
var location_1 = require("./location");
var path = require("./path");
var type = require("./type");
var UrlUtils = require("./url");
function noXform_(metadata, value) {
    return value;
}
exports.noXform_ = noXform_;
/**
 * @struct
 */
var Mapping = /** @class */ (function () {
    function Mapping(server, opt_local, opt_writable, opt_xform) {
        this.server = server;
        this.local = opt_local || server;
        this.writable = !!opt_writable;
        this.xform = opt_xform || noXform_;
    }
    return Mapping;
}());
exports.Mapping = Mapping;
var mappings_ = null;
function xformPath(fullPath) {
    var valid = type.isString(fullPath);
    if (!valid || fullPath.length < 2) {
        return fullPath;
    }
    else {
        fullPath = fullPath;
        return path.lastComponent(fullPath);
    }
}
exports.xformPath = xformPath;
function getMappings() {
    if (mappings_) {
        return mappings_;
    }
    var mappings = [];
    mappings.push(new Mapping('bucket'));
    mappings.push(new Mapping('generation'));
    mappings.push(new Mapping('metageneration'));
    mappings.push(new Mapping('name', 'fullPath', true));
    function mappingsXformPath(metadata, fullPath) {
        return xformPath(fullPath);
    }
    var nameMapping = new Mapping('name');
    nameMapping.xform = mappingsXformPath;
    mappings.push(nameMapping);
    /**
     * Coerces the second param to a number, if it is defined.
     */
    function xformSize(metadata, size) {
        if (type.isDef(size)) {
            return +size;
        }
        else {
            return size;
        }
    }
    var sizeMapping = new Mapping('size');
    sizeMapping.xform = xformSize;
    mappings.push(sizeMapping);
    mappings.push(new Mapping('timeCreated'));
    mappings.push(new Mapping('updated'));
    mappings.push(new Mapping('md5Hash', null, true));
    mappings.push(new Mapping('cacheControl', null, true));
    mappings.push(new Mapping('contentDisposition', null, true));
    mappings.push(new Mapping('contentEncoding', null, true));
    mappings.push(new Mapping('contentLanguage', null, true));
    mappings.push(new Mapping('contentType', null, true));
    mappings.push(new Mapping('metadata', 'customMetadata', true));
    /**
     * Transforms a comma-separated string of tokens into a list of download
     * URLs.
     */
    function xformTokens(metadata, tokens) {
        var valid = type.isString(tokens) && tokens.length > 0;
        if (!valid) {
            // This can happen if objects are uploaded through GCS and retrieved
            // through list, so we don't want to throw an Error.
            return [];
        }
        var encode = encodeURIComponent;
        var tokensList = tokens.split(',');
        var urls = tokensList.map(function (token) {
            var bucket = metadata['bucket'];
            var path = metadata['fullPath'];
            var urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);
            var base = UrlUtils.makeDownloadUrl(urlPart);
            var queryString = UrlUtils.makeQueryString({
                alt: 'media',
                token: token
            });
            return base + queryString;
        });
        return urls;
    }
    mappings.push(new Mapping('downloadTokens', 'downloadURLs', false, xformTokens));
    mappings_ = mappings;
    return mappings_;
}
exports.getMappings = getMappings;
function addRef(metadata, authWrapper) {
    function generateRef() {
        var bucket = metadata['bucket'];
        var path = metadata['fullPath'];
        var loc = new location_1.Location(bucket, path);
        return authWrapper.makeStorageReference(loc);
    }
    Object.defineProperty(metadata, 'ref', { get: generateRef });
}
exports.addRef = addRef;
function fromResource(authWrapper, resource, mappings) {
    var metadata = {};
    metadata['type'] = 'file';
    var len = mappings.length;
    for (var i = 0; i < len; i++) {
        var mapping = mappings[i];
        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
    }
    addRef(metadata, authWrapper);
    return metadata;
}
exports.fromResource = fromResource;
function fromResourceString(authWrapper, resourceString, mappings) {
    var obj = json.jsonObjectOrNull(resourceString);
    if (obj === null) {
        return null;
    }
    var resource = obj;
    return fromResource(authWrapper, resource, mappings);
}
exports.fromResourceString = fromResourceString;
function toResourceString(metadata, mappings) {
    var resource = {};
    var len = mappings.length;
    for (var i = 0; i < len; i++) {
        var mapping = mappings[i];
        if (mapping.writable) {
            resource[mapping.server] = metadata[mapping.local];
        }
    }
    return JSON.stringify(resource);
}
exports.toResourceString = toResourceString;
function metadataValidator(p) {
    var validType = p && type.isObject(p);
    if (!validType) {
        throw 'Expected Metadata object.';
    }
    for (var key in p) {
        var val = p[key];
        if (key === 'customMetadata') {
            if (!type.isObject(val)) {
                throw 'Expected object for \'customMetadata\' mapping.';
            }
        }
        else {
            if (type.isNonNullObject(val)) {
                throw "Mapping for '" + key + "' cannot be an object.";
            }
        }
    }
}
exports.metadataValidator = metadataValidator;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/metadata.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./json":112,"./location":113,"./path":117,"./type":125,"./url":126,"_process":162,"buffer":160}],115:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Contains methods for working with objects.
 */
function contains(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
exports.contains = contains;
function forEach(obj, f) {
    for (var key in obj) {
        if (contains(obj, key)) {
            f(key, obj[key]);
        }
    }
}
exports.forEach = forEach;
function clone(obj) {
    if (obj == null) {
        return {};
    }
    var c = {};
    forEach(obj, function (key, val) {
        c[key] = val;
    });
    return c;
}
exports.clone = clone;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/object.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"_process":162,"buffer":160}],116:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var type = require("./type");
/**
 * @struct
 */
var Observer = /** @class */ (function () {
    function Observer(nextOrObserver, opt_error, opt_complete) {
        var asFunctions = type.isFunction(nextOrObserver) ||
            type.isDef(opt_error) ||
            type.isDef(opt_complete);
        if (asFunctions) {
            this.next = nextOrObserver;
            this.error = opt_error || null;
            this.complete = opt_complete || null;
        }
        else {
            var observer = nextOrObserver;
            this.next = observer.next || null;
            this.error = observer.error || null;
            this.complete = observer.complete || null;
        }
    }
    return Observer;
}());
exports.Observer = Observer;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/observer.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./type":125,"_process":162,"buffer":160}],117:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Contains helper methods for manipulating paths.
 */
/**
 * @return Null if the path is already at the root.
 */
function parent(path) {
    if (path.length == 0) {
        return null;
    }
    var index = path.lastIndexOf('/');
    if (index === -1) {
        return '';
    }
    var newPath = path.slice(0, index);
    return newPath;
}
exports.parent = parent;
function child(path, childPath) {
    var canonicalChildPath = childPath
        .split('/')
        .filter(function (component) {
        return component.length > 0;
    })
        .join('/');
    if (path.length === 0) {
        return canonicalChildPath;
    }
    else {
        return path + '/' + canonicalChildPath;
    }
}
exports.child = child;
/**
 * Returns the last component of a path.
 * '/foo/bar' -> 'bar'
 * '/foo/bar/baz/' -> 'baz/'
 * '/a' -> 'a'
 */
function lastComponent(path) {
    var index = path.lastIndexOf('/', path.length - 2);
    if (index === -1) {
        return path;
    }
    else {
        return path.slice(index + 1);
    }
}
exports.lastComponent = lastComponent;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/path.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"_process":162,"buffer":160}],118:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Implements the promise abstraction interface for external
 * (public SDK) packaging, which just passes through to the firebase-app impl.
 */
/**
 * @template T
 * @param {function((function(T): void),
 *                  (function(!Error): void))} resolver
 */
function make(resolver) {
    return new Promise(resolver);
}
exports.make = make;
/**
 * @template T
 */
function resolve(value) {
    return Promise.resolve(value);
}
exports.resolve = resolve;
function reject(error) {
    return Promise.reject(error);
}
exports.reject = reject;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/promise_external.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"_process":162,"buffer":160}],119:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Defines methods used to actually send HTTP requests from
 * abstract representations.
 */
var app_1 = require("@firebase/app");
var array = require("./array");
var backoff = require("./backoff");
var errorsExports = require("./error");
var object = require("./object");
var promiseimpl = require("./promise_external");
var type = require("./type");
var UrlUtils = require("./url");
var XhrIoExports = require("./xhrio");
/**
 * @struct
 * @template T
 */
var NetworkRequest = /** @class */ (function () {
    function NetworkRequest(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {
        this.pendingXhr_ = null;
        this.backoffId_ = null;
        this.resolve_ = null;
        this.reject_ = null;
        this.canceled_ = false;
        this.appDelete_ = false;
        this.url_ = url;
        this.method_ = method;
        this.headers_ = headers;
        this.body_ = body;
        this.successCodes_ = successCodes.slice();
        this.additionalRetryCodes_ = additionalRetryCodes.slice();
        this.callback_ = callback;
        this.errorCallback_ = errorCallback;
        this.progressCallback_ = progressCallback;
        this.timeout_ = timeout;
        this.pool_ = pool;
        var self = this;
        this.promise_ = promiseimpl.make(function (resolve, reject) {
            self.resolve_ = resolve;
            self.reject_ = reject;
            self.start_();
        });
    }
    /**
     * Actually starts the retry loop.
     */
    NetworkRequest.prototype.start_ = function () {
        var self = this;
        function doTheRequest(backoffCallback, canceled) {
            if (canceled) {
                backoffCallback(false, new RequestEndStatus(false, null, true));
                return;
            }
            var xhr = self.pool_.createXhrIo();
            self.pendingXhr_ = xhr;
            function progressListener(progressEvent) {
                var loaded = progressEvent.loaded;
                var total = progressEvent.lengthComputable ? progressEvent.total : -1;
                if (self.progressCallback_ !== null) {
                    self.progressCallback_(loaded, total);
                }
            }
            if (self.progressCallback_ !== null) {
                xhr.addUploadProgressListener(progressListener);
            }
            xhr
                .send(self.url_, self.method_, self.body_, self.headers_)
                .then(function (xhr) {
                if (self.progressCallback_ !== null) {
                    xhr.removeUploadProgressListener(progressListener);
                }
                self.pendingXhr_ = null;
                xhr = xhr;
                var hitServer = xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;
                var status = xhr.getStatus();
                if (!hitServer || self.isRetryStatusCode_(status)) {
                    var wasCanceled = xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;
                    backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
                    return;
                }
                var successCode = array.contains(self.successCodes_, status);
                backoffCallback(true, new RequestEndStatus(successCode, xhr));
            });
        }
        /**
         * @param requestWentThrough True if the request eventually went
         *     through, false if it hit the retry limit or was canceled.
         */
        function backoffDone(requestWentThrough, status) {
            var resolve = self.resolve_;
            var reject = self.reject_;
            var xhr = status.xhr;
            if (status.wasSuccessCode) {
                try {
                    var result = self.callback_(xhr, xhr.getResponseText());
                    if (type.isJustDef(result)) {
                        resolve(result);
                    }
                    else {
                        resolve();
                    }
                }
                catch (e) {
                    reject(e);
                }
            }
            else {
                if (xhr !== null) {
                    var err = errorsExports.unknown();
                    err.setServerResponseProp(xhr.getResponseText());
                    if (self.errorCallback_) {
                        reject(self.errorCallback_(xhr, err));
                    }
                    else {
                        reject(err);
                    }
                }
                else {
                    if (status.canceled) {
                        var err = self.appDelete_
                            ? errorsExports.appDeleted()
                            : errorsExports.canceled();
                        reject(err);
                    }
                    else {
                        var err = errorsExports.retryLimitExceeded();
                        reject(err);
                    }
                }
            }
        }
        if (this.canceled_) {
            backoffDone(false, new RequestEndStatus(false, null, true));
        }
        else {
            this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);
        }
    };
    /** @inheritDoc */
    NetworkRequest.prototype.getPromise = function () {
        return this.promise_;
    };
    /** @inheritDoc */
    NetworkRequest.prototype.cancel = function (appDelete) {
        this.canceled_ = true;
        this.appDelete_ = appDelete || false;
        if (this.backoffId_ !== null) {
            backoff.stop(this.backoffId_);
        }
        if (this.pendingXhr_ !== null) {
            this.pendingXhr_.abort();
        }
    };
    NetworkRequest.prototype.isRetryStatusCode_ = function (status) {
        // The codes for which to retry came from this page:
        // https://cloud.google.com/storage/docs/exponential-backoff
        var isFiveHundredCode = status >= 500 && status < 600;
        var extraRetryCodes = [
            // Request Timeout: web server didn't receive full request in time.
            408,
            // Too Many Requests: you're getting rate-limited, basically.
            429
        ];
        var isExtraRetryCode = array.contains(extraRetryCodes, status);
        var isRequestSpecificRetryCode = array.contains(this.additionalRetryCodes_, status);
        return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
    };
    return NetworkRequest;
}());
/**
 * A collection of information about the result of a network request.
 * @param opt_canceled Defaults to false.
 * @struct
 */
var RequestEndStatus = /** @class */ (function () {
    function RequestEndStatus(wasSuccessCode, xhr, opt_canceled) {
        this.wasSuccessCode = wasSuccessCode;
        this.xhr = xhr;
        this.canceled = !!opt_canceled;
    }
    return RequestEndStatus;
}());
exports.RequestEndStatus = RequestEndStatus;
function addAuthHeader_(headers, authToken) {
    if (authToken !== null && authToken.length > 0) {
        headers['Authorization'] = 'Firebase ' + authToken;
    }
}
exports.addAuthHeader_ = addAuthHeader_;
function addVersionHeader_(headers) {
    var number = typeof app_1.default !== 'undefined' ? app_1.default.SDK_VERSION : 'AppManager';
    headers['X-Firebase-Storage-Version'] = 'webjs/' + number;
}
exports.addVersionHeader_ = addVersionHeader_;
/**
 * @template T
 */
function makeRequest(requestInfo, authToken, pool) {
    var queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);
    var url = requestInfo.url + queryPart;
    var headers = object.clone(requestInfo.headers);
    addAuthHeader_(headers, authToken);
    addVersionHeader_(headers);
    return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);
}
exports.makeRequest = makeRequest;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/request.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./array":103,"./backoff":106,"./error":109,"./object":115,"./promise_external":118,"./type":125,"./url":126,"./xhrio":127,"@firebase/app":1,"_process":162,"buffer":160}],120:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var RequestInfo = /** @class */ (function () {
    function RequestInfo(url, method, 
        /**
           * Returns the value with which to resolve the request's promise. Only called
           * if the request is successful. Throw from this function to reject the
           * returned Request's promise with the thrown error.
           * Note: The XhrIo passed to this function may be reused after this callback
           * returns. Do not keep a reference to it in any way.
           */
        handler, timeout) {
        this.url = url;
        this.method = method;
        this.handler = handler;
        this.timeout = timeout;
        this.urlParams = {};
        this.headers = {};
        this.body = null;
        this.errorHandler = null;
        /**
         * Called with the current number of bytes uploaded and total size (-1 if not
         * computable) of the request body (i.e. used to report upload progress).
         */
        this.progressCallback = null;
        this.successCodes = [200];
        this.additionalRetryCodes = [];
    }
    return RequestInfo;
}());
exports.RequestInfo = RequestInfo;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/requestinfo.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"_process":162,"buffer":160}],121:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var object = require("./object");
var constants = require("./constants");
/**
 * @struct
 */
var RequestMap = /** @class */ (function () {
    function RequestMap() {
        this.map_ = {};
        this.id_ = constants.minSafeInteger;
    }
    /**
     * Registers the given request with this map.
     * The request is unregistered when it completes.
     * @param r The request to register.
     */
    RequestMap.prototype.addRequest = function (r) {
        var id = this.id_;
        this.id_++;
        this.map_[id] = r;
        var self = this;
        function unmap() {
            delete self.map_[id];
        }
        r.getPromise().then(unmap, unmap);
    };
    /**
     * Cancels all registered requests.
     */
    RequestMap.prototype.clear = function () {
        object.forEach(this.map_, function (key, val) {
            if (val) {
                val.cancel(true);
            }
        });
        this.map_ = {};
    };
    return RequestMap;
}());
exports.RequestMap = RequestMap;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/requestmap.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./constants":108,"./object":115,"_process":162,"buffer":160}],122:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var array = require("./array");
var blob_1 = require("./blob");
var errorsExports = require("./error");
var MetadataUtils = require("./metadata");
var object = require("./object");
var requestinfo_1 = require("./requestinfo");
var type = require("./type");
var UrlUtils = require("./url");
/**
 * Throws the UNKNOWN FirebaseStorageError if cndn is false.
 */
function handlerCheck(cndn) {
    if (!cndn) {
        throw errorsExports.unknown();
    }
}
exports.handlerCheck = handlerCheck;
function metadataHandler(authWrapper, mappings) {
    function handler(xhr, text) {
        var metadata = MetadataUtils.fromResourceString(authWrapper, text, mappings);
        handlerCheck(metadata !== null);
        return metadata;
    }
    return handler;
}
exports.metadataHandler = metadataHandler;
function sharedErrorHandler(location) {
    function errorHandler(xhr, err) {
        var newErr;
        if (xhr.getStatus() === 401) {
            newErr = errorsExports.unauthenticated();
        }
        else {
            if (xhr.getStatus() === 402) {
                newErr = errorsExports.quotaExceeded(location.bucket);
            }
            else {
                if (xhr.getStatus() === 403) {
                    newErr = errorsExports.unauthorized(location.path);
                }
                else {
                    newErr = err;
                }
            }
        }
        newErr.setServerResponseProp(err.serverResponseProp());
        return newErr;
    }
    return errorHandler;
}
exports.sharedErrorHandler = sharedErrorHandler;
function objectErrorHandler(location) {
    var shared = sharedErrorHandler(location);
    function errorHandler(xhr, err) {
        var newErr = shared(xhr, err);
        if (xhr.getStatus() === 404) {
            newErr = errorsExports.objectNotFound(location.path);
        }
        newErr.setServerResponseProp(err.serverResponseProp());
        return newErr;
    }
    return errorHandler;
}
exports.objectErrorHandler = objectErrorHandler;
function getMetadata(authWrapper, location, mappings) {
    var urlPart = location.fullServerUrl();
    var url = UrlUtils.makeNormalUrl(urlPart);
    var method = 'GET';
    var timeout = authWrapper.maxOperationRetryTime();
    var requestInfo = new requestinfo_1.RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
}
exports.getMetadata = getMetadata;
function updateMetadata(authWrapper, location, metadata, mappings) {
    var urlPart = location.fullServerUrl();
    var url = UrlUtils.makeNormalUrl(urlPart);
    var method = 'PATCH';
    var body = MetadataUtils.toResourceString(metadata, mappings);
    var headers = { 'Content-Type': 'application/json; charset=utf-8' };
    var timeout = authWrapper.maxOperationRetryTime();
    var requestInfo = new requestinfo_1.RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);
    requestInfo.headers = headers;
    requestInfo.body = body;
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
}
exports.updateMetadata = updateMetadata;
function deleteObject(authWrapper, location) {
    var urlPart = location.fullServerUrl();
    var url = UrlUtils.makeNormalUrl(urlPart);
    var method = 'DELETE';
    var timeout = authWrapper.maxOperationRetryTime();
    function handler(xhr, text) { }
    var requestInfo = new requestinfo_1.RequestInfo(url, method, handler, timeout);
    requestInfo.successCodes = [200, 204];
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
}
exports.deleteObject = deleteObject;
function determineContentType_(metadata, blob) {
    return ((metadata && metadata['contentType']) ||
        (blob && blob.type()) ||
        'application/octet-stream');
}
exports.determineContentType_ = determineContentType_;
function metadataForUpload_(location, blob, opt_metadata) {
    var metadata = object.clone(opt_metadata);
    metadata['fullPath'] = location.path;
    metadata['size'] = blob.size();
    if (!metadata['contentType']) {
        metadata['contentType'] = determineContentType_(null, blob);
    }
    return metadata;
}
exports.metadataForUpload_ = metadataForUpload_;
function multipartUpload(authWrapper, location, mappings, blob, opt_metadata) {
    var urlPart = location.bucketOnlyServerUrl();
    var headers = {
        'X-Goog-Upload-Protocol': 'multipart'
    };
    function genBoundary() {
        var str = '';
        for (var i = 0; i < 2; i++) {
            str =
                str +
                    Math.random()
                        .toString()
                        .slice(2);
        }
        return str;
    }
    var boundary = genBoundary();
    headers['Content-Type'] = 'multipart/related; boundary=' + boundary;
    var metadata = metadataForUpload_(location, blob, opt_metadata);
    var metadataString = MetadataUtils.toResourceString(metadata, mappings);
    var preBlobPart = '--' +
        boundary +
        '\r\n' +
        'Content-Type: application/json; charset=utf-8\r\n\r\n' +
        metadataString +
        '\r\n--' +
        boundary +
        '\r\n' +
        'Content-Type: ' +
        metadata['contentType'] +
        '\r\n\r\n';
    var postBlobPart = '\r\n--' + boundary + '--';
    var body = blob_1.FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
    if (body === null) {
        throw errorsExports.cannotSliceBlob();
    }
    var urlParams = { name: metadata['fullPath'] };
    var url = UrlUtils.makeUploadUrl(urlPart);
    var method = 'POST';
    var timeout = authWrapper.maxUploadRetryTime();
    var requestInfo = new requestinfo_1.RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);
    requestInfo.urlParams = urlParams;
    requestInfo.headers = headers;
    requestInfo.body = body.uploadData();
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}
exports.multipartUpload = multipartUpload;
/**
 * @param current The number of bytes that have been uploaded so far.
 * @param total The total number of bytes in the upload.
 * @param opt_finalized True if the server has finished the upload.
 * @param opt_metadata The upload metadata, should
 *     only be passed if opt_finalized is true.
 * @struct
 */
var ResumableUploadStatus = /** @class */ (function () {
    function ResumableUploadStatus(current, total, finalized, metadata) {
        this.current = current;
        this.total = total;
        this.finalized = !!finalized;
        this.metadata = metadata || null;
    }
    return ResumableUploadStatus;
}());
exports.ResumableUploadStatus = ResumableUploadStatus;
function checkResumeHeader_(xhr, opt_allowed) {
    var status;
    try {
        status = xhr.getResponseHeader('X-Goog-Upload-Status');
    }
    catch (e) {
        handlerCheck(false);
    }
    var allowed = opt_allowed || ['active'];
    handlerCheck(array.contains(allowed, status));
    return status;
}
exports.checkResumeHeader_ = checkResumeHeader_;
function createResumableUpload(authWrapper, location, mappings, blob, opt_metadata) {
    var urlPart = location.bucketOnlyServerUrl();
    var metadata = metadataForUpload_(location, blob, opt_metadata);
    var urlParams = { name: metadata['fullPath'] };
    var url = UrlUtils.makeUploadUrl(urlPart);
    var method = 'POST';
    var headers = {
        'X-Goog-Upload-Protocol': 'resumable',
        'X-Goog-Upload-Command': 'start',
        'X-Goog-Upload-Header-Content-Length': blob.size(),
        'X-Goog-Upload-Header-Content-Type': metadata['contentType'],
        'Content-Type': 'application/json; charset=utf-8'
    };
    var body = MetadataUtils.toResourceString(metadata, mappings);
    var timeout = authWrapper.maxUploadRetryTime();
    function handler(xhr, text) {
        checkResumeHeader_(xhr);
        var url;
        try {
            url = xhr.getResponseHeader('X-Goog-Upload-URL');
        }
        catch (e) {
            handlerCheck(false);
        }
        handlerCheck(type.isString(url));
        return url;
    }
    var requestInfo = new requestinfo_1.RequestInfo(url, method, handler, timeout);
    requestInfo.urlParams = urlParams;
    requestInfo.headers = headers;
    requestInfo.body = body;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}
exports.createResumableUpload = createResumableUpload;
/**
 * @param url From a call to fbs.requests.createResumableUpload.
 */
function getResumableUploadStatus(authWrapper, location, url, blob) {
    var headers = { 'X-Goog-Upload-Command': 'query' };
    function handler(xhr, text) {
        var status = checkResumeHeader_(xhr, ['active', 'final']);
        var sizeString;
        try {
            sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');
        }
        catch (e) {
            handlerCheck(false);
        }
        var size = parseInt(sizeString, 10);
        handlerCheck(!isNaN(size));
        return new ResumableUploadStatus(size, blob.size(), status === 'final');
    }
    var method = 'POST';
    var timeout = authWrapper.maxUploadRetryTime();
    var requestInfo = new requestinfo_1.RequestInfo(url, method, handler, timeout);
    requestInfo.headers = headers;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}
exports.getResumableUploadStatus = getResumableUploadStatus;
/**
 * Any uploads via the resumable upload API must transfer a number of bytes
 * that is a multiple of this number.
 */
exports.resumableUploadChunkSize = 256 * 1024;
/**
 * @param url From a call to fbs.requests.createResumableUpload.
 * @param chunkSize Number of bytes to upload.
 * @param opt_status The previous status.
 *     If not passed or null, we start from the beginning.
 * @throws fbs.Error If the upload is already complete, the passed in status
 *     has a final size inconsistent with the blob, or the blob cannot be sliced
 *     for upload.
 */
function continueResumableUpload(location, authWrapper, url, blob, chunkSize, mappings, opt_status, opt_progressCallback) {
    // TODO(andysoto): standardize on internal asserts
    // assert(!(opt_status && opt_status.finalized));
    var status = new ResumableUploadStatus(0, 0);
    if (opt_status) {
        status.current = opt_status.current;
        status.total = opt_status.total;
    }
    else {
        status.current = 0;
        status.total = blob.size();
    }
    if (blob.size() !== status.total) {
        throw errorsExports.serverFileWrongSize();
    }
    var bytesLeft = status.total - status.current;
    var bytesToUpload = bytesLeft;
    if (chunkSize > 0) {
        bytesToUpload = Math.min(bytesToUpload, chunkSize);
    }
    var startByte = status.current;
    var endByte = startByte + bytesToUpload;
    var uploadCommand = bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';
    var headers = {
        'X-Goog-Upload-Command': uploadCommand,
        'X-Goog-Upload-Offset': status.current
    };
    var body = blob.slice(startByte, endByte);
    if (body === null) {
        throw errorsExports.cannotSliceBlob();
    }
    function handler(xhr, text) {
        // TODO(andysoto): Verify the MD5 of each uploaded range:
        // the 'x-range-md5' header comes back with status code 308 responses.
        // We'll only be able to bail out though, because you can't re-upload a
        // range that you previously uploaded.
        var uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);
        var newCurrent = status.current + bytesToUpload;
        var size = blob.size();
        var metadata;
        if (uploadStatus === 'final') {
            metadata = metadataHandler(authWrapper, mappings)(xhr, text);
        }
        else {
            metadata = null;
        }
        return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);
    }
    var method = 'POST';
    var timeout = authWrapper.maxUploadRetryTime();
    var requestInfo = new requestinfo_1.RequestInfo(url, method, handler, timeout);
    requestInfo.headers = headers;
    requestInfo.body = body.uploadData();
    requestInfo.progressCallback = opt_progressCallback || null;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}
exports.continueResumableUpload = continueResumableUpload;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/requests.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./array":103,"./blob":107,"./error":109,"./metadata":114,"./object":115,"./requestinfo":120,"./type":125,"./url":126,"_process":162,"buffer":160}],123:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var errorsExports = require("./error");
exports.StringFormat = {
    RAW: 'raw',
    BASE64: 'base64',
    BASE64URL: 'base64url',
    DATA_URL: 'data_url'
};
function formatValidator(stringFormat) {
    switch (stringFormat) {
        case exports.StringFormat.RAW:
        case exports.StringFormat.BASE64:
        case exports.StringFormat.BASE64URL:
        case exports.StringFormat.DATA_URL:
            return;
        default:
            throw 'Expected one of the event types: [' +
                exports.StringFormat.RAW +
                ', ' +
                exports.StringFormat.BASE64 +
                ', ' +
                exports.StringFormat.BASE64URL +
                ', ' +
                exports.StringFormat.DATA_URL +
                '].';
    }
}
exports.formatValidator = formatValidator;
/**
 * @struct
 */
var StringData = /** @class */ (function () {
    function StringData(data, opt_contentType) {
        this.data = data;
        this.contentType = opt_contentType || null;
    }
    return StringData;
}());
exports.StringData = StringData;
function dataFromString(format, string) {
    switch (format) {
        case exports.StringFormat.RAW:
            return new StringData(utf8Bytes_(string));
        case exports.StringFormat.BASE64:
        case exports.StringFormat.BASE64URL:
            return new StringData(base64Bytes_(format, string));
        case exports.StringFormat.DATA_URL:
            return new StringData(dataURLBytes_(string), dataURLContentType_(string));
    }
    // assert(false);
    throw errorsExports.unknown();
}
exports.dataFromString = dataFromString;
function utf8Bytes_(string) {
    var b = [];
    for (var i = 0; i < string.length; i++) {
        var c = string.charCodeAt(i);
        if (c <= 127) {
            b.push(c);
        }
        else {
            if (c <= 2047) {
                b.push(192 | (c >> 6), 128 | (c & 63));
            }
            else {
                if ((c & 64512) == 55296) {
                    // The start of a surrogate pair.
                    var valid = i < string.length - 1 &&
                        (string.charCodeAt(i + 1) & 64512) == 56320;
                    if (!valid) {
                        // The second surrogate wasn't there.
                        b.push(239, 191, 189);
                    }
                    else {
                        var hi = c;
                        var lo = string.charCodeAt(++i);
                        c = 65536 | ((hi & 1023) << 10) | (lo & 1023);
                        b.push(240 | (c >> 18), 128 | ((c >> 12) & 63), 128 | ((c >> 6) & 63), 128 | (c & 63));
                    }
                }
                else {
                    if ((c & 64512) == 56320) {
                        // Invalid low surrogate.
                        b.push(239, 191, 189);
                    }
                    else {
                        b.push(224 | (c >> 12), 128 | ((c >> 6) & 63), 128 | (c & 63));
                    }
                }
            }
        }
    }
    return new Uint8Array(b);
}
exports.utf8Bytes_ = utf8Bytes_;
function percentEncodedBytes_(string) {
    var decoded;
    try {
        decoded = decodeURIComponent(string);
    }
    catch (e) {
        throw errorsExports.invalidFormat(exports.StringFormat.DATA_URL, 'Malformed data URL.');
    }
    return utf8Bytes_(decoded);
}
exports.percentEncodedBytes_ = percentEncodedBytes_;
function base64Bytes_(format, string) {
    switch (format) {
        case exports.StringFormat.BASE64: {
            var hasMinus = string.indexOf('-') !== -1;
            var hasUnder = string.indexOf('_') !== -1;
            if (hasMinus || hasUnder) {
                var invalidChar = hasMinus ? '-' : '_';
                throw errorsExports.invalidFormat(format, "Invalid character '" +
                    invalidChar +
                    "' found: is it base64url encoded?");
            }
            break;
        }
        case exports.StringFormat.BASE64URL: {
            var hasPlus = string.indexOf('+') !== -1;
            var hasSlash = string.indexOf('/') !== -1;
            if (hasPlus || hasSlash) {
                var invalidChar = hasPlus ? '+' : '/';
                throw errorsExports.invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
            }
            string = string.replace(/-/g, '+').replace(/_/g, '/');
            break;
        }
    }
    var bytes;
    try {
        bytes = atob(string);
    }
    catch (e) {
        throw errorsExports.invalidFormat(format, 'Invalid character found');
    }
    var array = new Uint8Array(bytes.length);
    for (var i = 0; i < bytes.length; i++) {
        array[i] = bytes.charCodeAt(i);
    }
    return array;
}
exports.base64Bytes_ = base64Bytes_;
/**
 * @struct
 */
var DataURLParts = /** @class */ (function () {
    function DataURLParts(dataURL) {
        this.base64 = false;
        this.contentType = null;
        var matches = dataURL.match(/^data:([^,]+)?,/);
        if (matches === null) {
            throw errorsExports.invalidFormat(exports.StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
        }
        var middle = matches[1] || null;
        if (middle != null) {
            this.base64 = endsWith(middle, ';base64');
            this.contentType = this.base64
                ? middle.substring(0, middle.length - ';base64'.length)
                : middle;
        }
        this.rest = dataURL.substring(dataURL.indexOf(',') + 1);
    }
    return DataURLParts;
}());
function dataURLBytes_(string) {
    var parts = new DataURLParts(string);
    if (parts.base64) {
        return base64Bytes_(exports.StringFormat.BASE64, parts.rest);
    }
    else {
        return percentEncodedBytes_(parts.rest);
    }
}
exports.dataURLBytes_ = dataURLBytes_;
function dataURLContentType_(string) {
    var parts = new DataURLParts(string);
    return parts.contentType;
}
exports.dataURLContentType_ = dataURLContentType_;
function endsWith(s, end) {
    var longEnough = s.length >= end.length;
    if (!longEnough) {
        return false;
    }
    return s.substring(s.length - end.length) === end;
}



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/string.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./error":109,"_process":162,"buffer":160}],124:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskEvent = {
    /** Triggered whenever the task changes or progress is updated. */
    STATE_CHANGED: 'state_changed'
};
exports.InternalTaskState = {
    RUNNING: 'running',
    PAUSING: 'pausing',
    PAUSED: 'paused',
    SUCCESS: 'success',
    CANCELING: 'canceling',
    CANCELED: 'canceled',
    ERROR: 'error'
};
exports.TaskState = {
    /** The task is currently transferring data. */
    RUNNING: 'running',
    /** The task was paused by the user. */
    PAUSED: 'paused',
    /** The task completed successfully. */
    SUCCESS: 'success',
    /** The task was canceled. */
    CANCELED: 'canceled',
    /** The task failed with an error. */
    ERROR: 'error'
};
function taskStateFromInternalTaskState(state) {
    switch (state) {
        case exports.InternalTaskState.RUNNING:
        case exports.InternalTaskState.PAUSING:
        case exports.InternalTaskState.CANCELING:
            return exports.TaskState.RUNNING;
        case exports.InternalTaskState.PAUSED:
            return exports.TaskState.PAUSED;
        case exports.InternalTaskState.SUCCESS:
            return exports.TaskState.SUCCESS;
        case exports.InternalTaskState.CANCELED:
            return exports.TaskState.CANCELED;
        case exports.InternalTaskState.ERROR:
            return exports.TaskState.ERROR;
        default:
            // TODO(andysoto): assert(false);
            return exports.TaskState.ERROR;
    }
}
exports.taskStateFromInternalTaskState = taskStateFromInternalTaskState;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/taskenums.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"_process":162,"buffer":160}],125:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @return False if the object is undefined or null, true otherwise.
 */
function isDef(p) {
    return p != null;
}
exports.isDef = isDef;
function isJustDef(p) {
    return p !== void 0;
}
exports.isJustDef = isJustDef;
function isFunction(p) {
    return typeof p === 'function';
}
exports.isFunction = isFunction;
function isObject(p) {
    return typeof p === 'object';
}
exports.isObject = isObject;
function isNonNullObject(p) {
    return isObject(p) && p !== null;
}
exports.isNonNullObject = isNonNullObject;
function isNonArrayObject(p) {
    return isObject(p) && !Array.isArray(p);
}
exports.isNonArrayObject = isNonArrayObject;
function isString(p) {
    return typeof p === 'string' || p instanceof String;
}
exports.isString = isString;
function isNumber(p) {
    return typeof p === 'number' || p instanceof Number;
}
exports.isNumber = isNumber;
function isNativeBlob(p) {
    return isNativeBlobDefined() && p instanceof Blob;
}
exports.isNativeBlob = isNativeBlob;
function isNativeBlobDefined() {
    return typeof Blob !== 'undefined';
}
exports.isNativeBlobDefined = isNativeBlobDefined;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/type.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"_process":162,"buffer":160}],126:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Functions to create and manipulate URLs for the server API.
 */
var constants = require("./constants");
var object = require("./object");
function makeNormalUrl(urlPart) {
    return constants.domainBase + constants.apiBaseUrl + urlPart;
}
exports.makeNormalUrl = makeNormalUrl;
function makeDownloadUrl(urlPart) {
    return constants.downloadBase + constants.apiBaseUrl + urlPart;
}
exports.makeDownloadUrl = makeDownloadUrl;
function makeUploadUrl(urlPart) {
    return constants.domainBase + constants.apiUploadBaseUrl + urlPart;
}
exports.makeUploadUrl = makeUploadUrl;
function makeQueryString(params) {
    var encode = encodeURIComponent;
    var queryPart = '?';
    object.forEach(params, function (key, val) {
        var nextPart = encode(key) + '=' + encode(val);
        queryPart = queryPart + nextPart + '&';
    });
    // Chop off the extra '&' or '?' on the end
    queryPart = queryPart.slice(0, -1);
    return queryPart;
}
exports.makeQueryString = makeQueryString;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/url.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./constants":108,"./object":115,"_process":162,"buffer":160}],127:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @enum{number}
 */
var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["NO_ERROR"] = 0] = "NO_ERROR";
    ErrorCode[ErrorCode["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
    ErrorCode[ErrorCode["ABORT"] = 2] = "ABORT";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/xhrio.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"_process":162,"buffer":160}],128:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var errorsExports = require("./error");
var object = require("./object");
var promiseimpl = require("./promise_external");
var type = require("./type");
var XhrIoExports = require("./xhrio");
/**
 * We use this instead of goog.net.XhrIo because goog.net.XhrIo is hyuuuuge and
 * doesn't work in React Native on Android.
 */
var NetworkXhrIo = /** @class */ (function () {
    function NetworkXhrIo() {
        var _this = this;
        this.sent_ = false;
        this.xhr_ = new XMLHttpRequest();
        this.errorCode_ = XhrIoExports.ErrorCode.NO_ERROR;
        this.sendPromise_ = promiseimpl.make(function (resolve, reject) {
            _this.xhr_.addEventListener('abort', function (event) {
                _this.errorCode_ = XhrIoExports.ErrorCode.ABORT;
                resolve(_this);
            });
            _this.xhr_.addEventListener('error', function (event) {
                _this.errorCode_ = XhrIoExports.ErrorCode.NETWORK_ERROR;
                resolve(_this);
            });
            _this.xhr_.addEventListener('load', function (event) {
                resolve(_this);
            });
        });
    }
    /**
     * @override
     */
    NetworkXhrIo.prototype.send = function (url, method, opt_body, opt_headers) {
        var _this = this;
        if (this.sent_) {
            throw errorsExports.internalError('cannot .send() more than once');
        }
        this.sent_ = true;
        this.xhr_.open(method, url, true);
        if (type.isDef(opt_headers)) {
            var headers = opt_headers;
            object.forEach(headers, function (key, val) {
                _this.xhr_.setRequestHeader(key, val.toString());
            });
        }
        if (type.isDef(opt_body)) {
            this.xhr_.send(opt_body);
        }
        else {
            this.xhr_.send();
        }
        return this.sendPromise_;
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.getErrorCode = function () {
        if (!this.sent_) {
            throw errorsExports.internalError('cannot .getErrorCode() before sending');
        }
        return this.errorCode_;
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.getStatus = function () {
        if (!this.sent_) {
            throw errorsExports.internalError('cannot .getStatus() before sending');
        }
        try {
            return this.xhr_.status;
        }
        catch (e) {
            return -1;
        }
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.getResponseText = function () {
        if (!this.sent_) {
            throw errorsExports.internalError('cannot .getResponseText() before sending');
        }
        return this.xhr_.responseText;
    };
    /**
     * Aborts the request.
     * @override
     */
    NetworkXhrIo.prototype.abort = function () {
        this.xhr_.abort();
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.getResponseHeader = function (header) {
        return this.xhr_.getResponseHeader(header);
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.addUploadProgressListener = function (listener) {
        if (type.isDef(this.xhr_.upload)) {
            this.xhr_.upload.addEventListener('progress', listener);
        }
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.removeUploadProgressListener = function (listener) {
        if (type.isDef(this.xhr_.upload)) {
            this.xhr_.upload.removeEventListener('progress', listener);
        }
    };
    return NetworkXhrIo;
}());
exports.NetworkXhrIo = NetworkXhrIo;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/xhrio_network.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./error":109,"./object":115,"./promise_external":118,"./type":125,"./xhrio":127,"_process":162,"buffer":160}],129:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var xhrio_network_1 = require("./xhrio_network");
/**
 * Factory-like class for creating XhrIo instances.
 */
var XhrIoPool = /** @class */ (function () {
    function XhrIoPool() {
    }
    XhrIoPool.prototype.createXhrIo = function () {
        return new xhrio_network_1.NetworkXhrIo();
    };
    return XhrIoPool;
}());
exports.XhrIoPool = XhrIoPool;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/implementation/xhriopool.js","/node_modules/@firebase/storage/dist/cjs/src/implementation")

},{"./xhrio_network":128,"_process":162,"buffer":160}],130:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Defines the Firebase Storage Reference class.
 */
var args = require("./implementation/args");
var blob_1 = require("./implementation/blob");
var errorsExports = require("./implementation/error");
var location_1 = require("./implementation/location");
var metadata = require("./implementation/metadata");
var object = require("./implementation/object");
var path = require("./implementation/path");
var requests = require("./implementation/requests");
var fbsString = require("./implementation/string");
var string_1 = require("./implementation/string");
var type = require("./implementation/type");
var task_1 = require("./task");
/**
 * Provides methods to interact with a bucket in the Firebase Storage service.
 * @param location An fbs.location, or the URL at
 *     which to base this object, in one of the following forms:
 *         gs://<bucket>/<object-path>
 *         http[s]://firebasestorage.googleapis.com/
 *                     <api-version>/b/<bucket>/o/<object-path>
 *     Any query or fragment strings will be ignored in the http[s]
 *     format. If no value is passed, the storage object will use a URL based on
 *     the project ID of the base firebase.App instance.
 */
var Reference = /** @class */ (function () {
    function Reference(authWrapper, location) {
        this.authWrapper = authWrapper;
        if (location instanceof location_1.Location) {
            this.location = location;
        }
        else {
            this.location = location_1.Location.makeFromUrl(location);
        }
    }
    /**
     * @return The URL for the bucket and path this object references,
     *     in the form gs://<bucket>/<object-path>
     * @override
     */
    Reference.prototype.toString = function () {
        args.validate('toString', [], arguments);
        return 'gs://' + this.location.bucket + '/' + this.location.path;
    };
    Reference.prototype.newRef = function (authWrapper, location) {
        return new Reference(authWrapper, location);
    };
    Reference.prototype.mappings = function () {
        return metadata.getMappings();
    };
    /**
     * @return A reference to the object obtained by
     *     appending childPath, removing any duplicate, beginning, or trailing
     *     slashes.
     */
    Reference.prototype.child = function (childPath) {
        args.validate('child', [args.stringSpec()], arguments);
        var newPath = path.child(this.location.path, childPath);
        var location = new location_1.Location(this.location.bucket, newPath);
        return this.newRef(this.authWrapper, location);
    };
    Object.defineProperty(Reference.prototype, "parent", {
        /**
         * @return A reference to the parent of the
         *     current object, or null if the current object is the root.
         */
        get: function () {
            var newPath = path.parent(this.location.path);
            if (newPath === null) {
                return null;
            }
            var location = new location_1.Location(this.location.bucket, newPath);
            return this.newRef(this.authWrapper, location);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "root", {
        /**
         * @return An reference to the root of this
         *     object's bucket.
         */
        get: function () {
            var location = new location_1.Location(this.location.bucket, '');
            return this.newRef(this.authWrapper, location);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "bucket", {
        get: function () {
            return this.location.bucket;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "fullPath", {
        get: function () {
            return this.location.path;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "name", {
        get: function () {
            return path.lastComponent(this.location.path);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "storage", {
        get: function () {
            return this.authWrapper.service();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Uploads a blob to this object's location.
     * @param data The blob to upload.
     * @return An UploadTask that lets you control and
     *     observe the upload.
     */
    Reference.prototype.put = function (data, metadata) {
        if (metadata === void 0) { metadata = null; }
        args.validate('put', [args.uploadDataSpec(), args.metadataSpec(true)], arguments);
        this.throwIfRoot_('put');
        return new task_1.UploadTask(this, this.authWrapper, this.location, this.mappings(), new blob_1.FbsBlob(data), metadata);
    };
    /**
     * Uploads a string to this object's location.
     * @param string The string to upload.
     * @param opt_format The format of the string to upload.
     * @return An UploadTask that lets you control and
     *     observe the upload.
     */
    Reference.prototype.putString = function (string, format, opt_metadata) {
        if (format === void 0) { format = string_1.StringFormat.RAW; }
        args.validate('putString', [
            args.stringSpec(),
            args.stringSpec(fbsString.formatValidator, true),
            args.metadataSpec(true)
        ], arguments);
        this.throwIfRoot_('putString');
        var data = fbsString.dataFromString(format, string);
        var metadata = object.clone(opt_metadata);
        if (!type.isDef(metadata['contentType']) && type.isDef(data.contentType)) {
            metadata['contentType'] = data.contentType;
        }
        return new task_1.UploadTask(this, this.authWrapper, this.location, this.mappings(), new blob_1.FbsBlob(data.data, true), metadata);
    };
    /**
     * Deletes the object at this location.
     * @return A promise that resolves if the deletion succeeds.
     */
    Reference.prototype.delete = function () {
        args.validate('delete', [], arguments);
        this.throwIfRoot_('delete');
        var self = this;
        return this.authWrapper.getAuthToken().then(function (authToken) {
            var requestInfo = requests.deleteObject(self.authWrapper, self.location);
            return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        });
    };
    /**
     *     A promise that resolves with the metadata for this object. If this
     *     object doesn't exist or metadata cannot be retreived, the promise is
     *     rejected.
     */
    Reference.prototype.getMetadata = function () {
        args.validate('getMetadata', [], arguments);
        this.throwIfRoot_('getMetadata');
        var self = this;
        return this.authWrapper.getAuthToken().then(function (authToken) {
            var requestInfo = requests.getMetadata(self.authWrapper, self.location, self.mappings());
            return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        });
    };
    /**
     * Updates the metadata for this object.
     * @param metadata The new metadata for the object.
     *     Only values that have been explicitly set will be changed. Explicitly
     *     setting a value to null will remove the metadata.
     * @return A promise that resolves
     *     with the new metadata for this object.
     *     @see firebaseStorage.Reference.prototype.getMetadata
     */
    Reference.prototype.updateMetadata = function (metadata) {
        args.validate('updateMetadata', [args.metadataSpec()], arguments);
        this.throwIfRoot_('updateMetadata');
        var self = this;
        return this.authWrapper.getAuthToken().then(function (authToken) {
            var requestInfo = requests.updateMetadata(self.authWrapper, self.location, metadata, self.mappings());
            return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        });
    };
    /**
     * @return A promise that resolves with the download
     *     URL for this object.
     */
    Reference.prototype.getDownloadURL = function () {
        args.validate('getDownloadURL', [], arguments);
        this.throwIfRoot_('getDownloadURL');
        return this.getMetadata().then(function (metadata) {
            var url = metadata['downloadURLs'][0];
            if (type.isDef(url)) {
                return url;
            }
            else {
                throw errorsExports.noDownloadURL();
            }
        });
    };
    Reference.prototype.throwIfRoot_ = function (name) {
        if (this.location.path === '') {
            throw errorsExports.invalidRootOperation(name);
        }
    };
    return Reference;
}());
exports.Reference = Reference;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/reference.js","/node_modules/@firebase/storage/dist/cjs/src")

},{"./implementation/args":102,"./implementation/blob":107,"./implementation/error":109,"./implementation/location":113,"./implementation/metadata":114,"./implementation/object":115,"./implementation/path":117,"./implementation/requests":122,"./implementation/string":123,"./implementation/type":125,"./task":132,"_process":162,"buffer":160}],131:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var args = require("./implementation/args");
var authwrapper_1 = require("./implementation/authwrapper");
var location_1 = require("./implementation/location");
var fbsPromiseImpl = require("./implementation/promise_external");
var RequestExports = require("./implementation/request");
var reference_1 = require("./reference");
/**
 * A service that provides firebaseStorage.Reference instances.
 * @param opt_url gs:// url to a custom Storage Bucket
 *
 * @struct
 */
var Service = /** @class */ (function () {
    function Service(app, pool, url) {
        this.bucket_ = null;
        function maker(authWrapper, loc) {
            return new reference_1.Reference(authWrapper, loc);
        }
        this.authWrapper_ = new authwrapper_1.AuthWrapper(app, maker, RequestExports.makeRequest, this, pool);
        this.app_ = app;
        if (url != null) {
            this.bucket_ = location_1.Location.makeFromBucketSpec(url);
        }
        else {
            var authWrapperBucket = this.authWrapper_.bucket();
            if (authWrapperBucket != null) {
                this.bucket_ = new location_1.Location(authWrapperBucket, '');
            }
        }
        this.internals_ = new ServiceInternals(this);
    }
    /**
     * Returns a firebaseStorage.Reference for the given path in the default
     * bucket.
     */
    Service.prototype.ref = function (path) {
        function validator(path) {
            if (/^[A-Za-z]+:\/\//.test(path)) {
                throw 'Expected child path but got a URL, use refFromURL instead.';
            }
        }
        args.validate('ref', [args.stringSpec(validator, true)], arguments);
        if (this.bucket_ == null) {
            throw new Error('No Storage Bucket defined in Firebase Options.');
        }
        var ref = new reference_1.Reference(this.authWrapper_, this.bucket_);
        if (path != null) {
            return ref.child(path);
        }
        else {
            return ref;
        }
    };
    /**
     * Returns a firebaseStorage.Reference object for the given absolute URL,
     * which must be a gs:// or http[s]:// URL.
     */
    Service.prototype.refFromURL = function (url) {
        function validator(p) {
            if (!/^[A-Za-z]+:\/\//.test(p)) {
                throw 'Expected full URL but got a child path, use ref instead.';
            }
            try {
                location_1.Location.makeFromUrl(p);
            }
            catch (e) {
                throw 'Expected valid full URL but got an invalid one.';
            }
        }
        args.validate('refFromURL', [args.stringSpec(validator, false)], arguments);
        return new reference_1.Reference(this.authWrapper_, url);
    };
    Object.defineProperty(Service.prototype, "maxUploadRetryTime", {
        get: function () {
            return this.authWrapper_.maxUploadRetryTime();
        },
        enumerable: true,
        configurable: true
    });
    Service.prototype.setMaxUploadRetryTime = function (time) {
        args.validate('setMaxUploadRetryTime', [args.nonNegativeNumberSpec()], arguments);
        this.authWrapper_.setMaxUploadRetryTime(time);
    };
    Object.defineProperty(Service.prototype, "maxOperationRetryTime", {
        get: function () {
            return this.authWrapper_.maxOperationRetryTime();
        },
        enumerable: true,
        configurable: true
    });
    Service.prototype.setMaxOperationRetryTime = function (time) {
        args.validate('setMaxOperationRetryTime', [args.nonNegativeNumberSpec()], arguments);
        this.authWrapper_.setMaxOperationRetryTime(time);
    };
    Object.defineProperty(Service.prototype, "app", {
        get: function () {
            return this.app_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Service.prototype, "INTERNAL", {
        get: function () {
            return this.internals_;
        },
        enumerable: true,
        configurable: true
    });
    return Service;
}());
exports.Service = Service;
/**
 * @struct
 */
var ServiceInternals = /** @class */ (function () {
    function ServiceInternals(service) {
        this.service_ = service;
    }
    /**
     * Called when the associated app is deleted.
     * @see {!fbs.AuthWrapper.prototype.deleteApp}
     */
    ServiceInternals.prototype.delete = function () {
        this.service_.authWrapper_.deleteApp();
        return fbsPromiseImpl.resolve(undefined);
    };
    return ServiceInternals;
}());
exports.ServiceInternals = ServiceInternals;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/service.js","/node_modules/@firebase/storage/dist/cjs/src")

},{"./implementation/args":102,"./implementation/authwrapper":105,"./implementation/location":113,"./implementation/promise_external":118,"./implementation/request":119,"./reference":130,"_process":162,"buffer":160}],132:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Defines types for interacting with blob transfer tasks.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var taskenums_1 = require("./implementation/taskenums");
var observer_1 = require("./implementation/observer");
var taskenums_2 = require("./implementation/taskenums");
var tasksnapshot_1 = require("./tasksnapshot");
var fbsArgs = require("./implementation/args");
var fbsArray = require("./implementation/array");
var async_1 = require("./implementation/async");
var errors = require("./implementation/error");
var fbsPromiseimpl = require("./implementation/promise_external");
var fbsRequests = require("./implementation/requests");
var fbsTaskEnums = require("./implementation/taskenums");
var typeUtils = require("./implementation/type");
/**
 * Represents a blob being uploaded. Can be used to pause/resume/cancel the
 * upload and manage callbacks for various events.
 */
var UploadTask = /** @class */ (function () {
    /**
     * @param ref The firebaseStorage.Reference object this task came
     *     from, untyped to avoid cyclic dependencies.
     * @param blob The blob to upload.
     */
    function UploadTask(ref, authWrapper, location, mappings, blob, metadata) {
        if (metadata === void 0) { metadata = null; }
        var _this = this;
        this.transferred_ = 0;
        this.needToFetchStatus_ = false;
        this.needToFetchMetadata_ = false;
        this.observers_ = [];
        this.error_ = null;
        this.uploadUrl_ = null;
        this.request_ = null;
        this.chunkMultiplier_ = 1;
        this.resolve_ = null;
        this.reject_ = null;
        this.ref_ = ref;
        this.authWrapper_ = authWrapper;
        this.location_ = location;
        this.blob_ = blob;
        this.metadata_ = metadata;
        this.mappings_ = mappings;
        this.resumable_ = this.shouldDoResumable_(this.blob_);
        this.state_ = taskenums_1.InternalTaskState.RUNNING;
        this.errorHandler_ = function (error) {
            _this.request_ = null;
            _this.chunkMultiplier_ = 1;
            if (error.codeEquals(errors.Code.CANCELED)) {
                _this.needToFetchStatus_ = true;
                _this.completeTransitions_();
            }
            else {
                _this.error_ = error;
                _this.transition_(taskenums_1.InternalTaskState.ERROR);
            }
        };
        this.metadataErrorHandler_ = function (error) {
            _this.request_ = null;
            if (error.codeEquals(errors.Code.CANCELED)) {
                _this.completeTransitions_();
            }
            else {
                _this.error_ = error;
                _this.transition_(taskenums_1.InternalTaskState.ERROR);
            }
        };
        this.promise_ = fbsPromiseimpl.make(function (resolve, reject) {
            _this.resolve_ = resolve;
            _this.reject_ = reject;
            _this.start_();
        });
        // Prevent uncaught rejections on the internal promise from bubbling out
        // to the top level with a dummy handler.
        this.promise_.then(null, function () { });
    }
    UploadTask.prototype.makeProgressCallback_ = function () {
        var _this = this;
        var sizeBefore = this.transferred_;
        return function (loaded, total) {
            _this.updateProgress_(sizeBefore + loaded);
        };
    };
    UploadTask.prototype.shouldDoResumable_ = function (blob) {
        return blob.size() > 256 * 1024;
    };
    UploadTask.prototype.start_ = function () {
        if (this.state_ !== taskenums_1.InternalTaskState.RUNNING) {
            // This can happen if someone pauses us in a resume callback, for example.
            return;
        }
        if (this.request_ !== null) {
            return;
        }
        if (this.resumable_) {
            if (this.uploadUrl_ === null) {
                this.createResumable_();
            }
            else {
                if (this.needToFetchStatus_) {
                    this.fetchStatus_();
                }
                else {
                    if (this.needToFetchMetadata_) {
                        // Happens if we miss the metadata on upload completion.
                        this.fetchMetadata_();
                    }
                    else {
                        this.continueUpload_();
                    }
                }
            }
        }
        else {
            this.oneShotUpload_();
        }
    };
    UploadTask.prototype.resolveToken_ = function (callback) {
        var _this = this;
        this.authWrapper_.getAuthToken().then(function (authToken) {
            switch (_this.state_) {
                case taskenums_1.InternalTaskState.RUNNING:
                    callback(authToken);
                    break;
                case taskenums_1.InternalTaskState.CANCELING:
                    _this.transition_(taskenums_1.InternalTaskState.CANCELED);
                    break;
                case taskenums_1.InternalTaskState.PAUSING:
                    _this.transition_(taskenums_1.InternalTaskState.PAUSED);
                    break;
                default:
            }
        });
    };
    // TODO(andysoto): assert false
    UploadTask.prototype.createResumable_ = function () {
        var _this = this;
        this.resolveToken_(function (authToken) {
            var requestInfo = fbsRequests.createResumableUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);
            var createRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = createRequest;
            createRequest.getPromise().then(function (url) {
                _this.request_ = null;
                _this.uploadUrl_ = url;
                _this.needToFetchStatus_ = false;
                _this.completeTransitions_();
            }, _this.errorHandler_);
        });
    };
    UploadTask.prototype.fetchStatus_ = function () {
        var _this = this;
        // TODO(andysoto): assert(this.uploadUrl_ !== null);
        var url = this.uploadUrl_;
        this.resolveToken_(function (authToken) {
            var requestInfo = fbsRequests.getResumableUploadStatus(_this.authWrapper_, _this.location_, url, _this.blob_);
            var statusRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = statusRequest;
            statusRequest.getPromise().then(function (status) {
                status = status;
                _this.request_ = null;
                _this.updateProgress_(status.current);
                _this.needToFetchStatus_ = false;
                if (status.finalized) {
                    _this.needToFetchMetadata_ = true;
                }
                _this.completeTransitions_();
            }, _this.errorHandler_);
        });
    };
    UploadTask.prototype.continueUpload_ = function () {
        var _this = this;
        var chunkSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;
        var status = new fbsRequests.ResumableUploadStatus(this.transferred_, this.blob_.size());
        // TODO(andysoto): assert(this.uploadUrl_ !== null);
        var url = this.uploadUrl_;
        this.resolveToken_(function (authToken) {
            var requestInfo;
            try {
                requestInfo = fbsRequests.continueResumableUpload(_this.location_, _this.authWrapper_, url, _this.blob_, chunkSize, _this.mappings_, status, _this.makeProgressCallback_());
            }
            catch (e) {
                _this.error_ = e;
                _this.transition_(taskenums_1.InternalTaskState.ERROR);
                return;
            }
            var uploadRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = uploadRequest;
            uploadRequest
                .getPromise()
                .then(function (newStatus) {
                _this.increaseMultiplier_();
                _this.request_ = null;
                _this.updateProgress_(newStatus.current);
                if (newStatus.finalized) {
                    _this.metadata_ = newStatus.metadata;
                    _this.transition_(taskenums_1.InternalTaskState.SUCCESS);
                }
                else {
                    _this.completeTransitions_();
                }
            }, _this.errorHandler_);
        });
    };
    UploadTask.prototype.increaseMultiplier_ = function () {
        var currentSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;
        // Max chunk size is 32M.
        if (currentSize < 32 * 1024 * 1024) {
            this.chunkMultiplier_ *= 2;
        }
    };
    UploadTask.prototype.fetchMetadata_ = function () {
        var _this = this;
        this.resolveToken_(function (authToken) {
            var requestInfo = fbsRequests.getMetadata(_this.authWrapper_, _this.location_, _this.mappings_);
            var metadataRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = metadataRequest;
            metadataRequest.getPromise().then(function (metadata) {
                _this.request_ = null;
                _this.metadata_ = metadata;
                _this.transition_(taskenums_1.InternalTaskState.SUCCESS);
            }, _this.metadataErrorHandler_);
        });
    };
    UploadTask.prototype.oneShotUpload_ = function () {
        var _this = this;
        this.resolveToken_(function (authToken) {
            var requestInfo = fbsRequests.multipartUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);
            var multipartRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = multipartRequest;
            multipartRequest.getPromise().then(function (metadata) {
                _this.request_ = null;
                _this.metadata_ = metadata;
                _this.updateProgress_(_this.blob_.size());
                _this.transition_(taskenums_1.InternalTaskState.SUCCESS);
            }, _this.errorHandler_);
        });
    };
    UploadTask.prototype.updateProgress_ = function (transferred) {
        var old = this.transferred_;
        this.transferred_ = transferred;
        // A progress update can make the "transferred" value smaller (e.g. a
        // partial upload not completed by server, after which the "transferred"
        // value may reset to the value at the beginning of the request).
        if (this.transferred_ !== old) {
            this.notifyObservers_();
        }
    };
    UploadTask.prototype.transition_ = function (state) {
        if (this.state_ === state) {
            return;
        }
        switch (state) {
            case taskenums_1.InternalTaskState.CANCELING:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING);
                this.state_ = state;
                if (this.request_ !== null) {
                    this.request_.cancel();
                }
                break;
            case taskenums_1.InternalTaskState.PAUSING:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING);
                this.state_ = state;
                if (this.request_ !== null) {
                    this.request_.cancel();
                }
                break;
            case taskenums_1.InternalTaskState.RUNNING:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSED ||
                //        this.state_ === InternalTaskState.PAUSING);
                var wasPaused = this.state_ === taskenums_1.InternalTaskState.PAUSED;
                this.state_ = state;
                if (wasPaused) {
                    this.notifyObservers_();
                    this.start_();
                }
                break;
            case taskenums_1.InternalTaskState.PAUSED:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSING);
                this.state_ = state;
                this.notifyObservers_();
                break;
            case taskenums_1.InternalTaskState.CANCELED:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSED ||
                //        this.state_ === InternalTaskState.CANCELING);
                this.error_ = errors.canceled();
                this.state_ = state;
                this.notifyObservers_();
                break;
            case taskenums_1.InternalTaskState.ERROR:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING ||
                //        this.state_ === InternalTaskState.CANCELING);
                this.state_ = state;
                this.notifyObservers_();
                break;
            case taskenums_1.InternalTaskState.SUCCESS:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING ||
                //        this.state_ === InternalTaskState.CANCELING);
                this.state_ = state;
                this.notifyObservers_();
                break;
        }
    };
    UploadTask.prototype.completeTransitions_ = function () {
        switch (this.state_) {
            case taskenums_1.InternalTaskState.PAUSING:
                this.transition_(taskenums_1.InternalTaskState.PAUSED);
                break;
            case taskenums_1.InternalTaskState.CANCELING:
                this.transition_(taskenums_1.InternalTaskState.CANCELED);
                break;
            case taskenums_1.InternalTaskState.RUNNING:
                this.start_();
                break;
            default:
                // TODO(andysoto): assert(false);
                break;
        }
    };
    Object.defineProperty(UploadTask.prototype, "snapshot", {
        get: function () {
            var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);
            return new tasksnapshot_1.UploadTaskSnapshot(this.transferred_, this.blob_.size(), externalState, this.metadata_, this, this.ref_);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a callback for an event.
     * @param type The type of event to listen for.
     */
    UploadTask.prototype.on = function (type, nextOrObserver, error, completed) {
        if (nextOrObserver === void 0) { nextOrObserver = undefined; }
        if (error === void 0) { error = undefined; }
        if (completed === void 0) { completed = undefined; }
        function typeValidator(_p) {
            if (type !== taskenums_2.TaskEvent.STATE_CHANGED) {
                throw "Expected one of the event types: [" + taskenums_2.TaskEvent.STATE_CHANGED + "].";
            }
        }
        var nextOrObserverMessage = 'Expected a function or an Object with one of ' +
            '`next`, `error`, `complete` properties.';
        var nextValidator = fbsArgs.nullFunctionSpec(true).validator;
        var observerValidator = fbsArgs.looseObjectSpec(null, true).validator;
        function nextOrObserverValidator(p) {
            try {
                nextValidator(p);
                return;
            }
            catch (e) { }
            try {
                observerValidator(p);
                var anyDefined = typeUtils.isJustDef(p['next']) ||
                    typeUtils.isJustDef(p['error']) ||
                    typeUtils.isJustDef(p['complete']);
                if (!anyDefined) {
                    throw '';
                }
                return;
            }
            catch (e) {
                throw nextOrObserverMessage;
            }
        }
        var specs = [
            fbsArgs.stringSpec(typeValidator),
            fbsArgs.looseObjectSpec(nextOrObserverValidator, true),
            fbsArgs.nullFunctionSpec(true),
            fbsArgs.nullFunctionSpec(true)
        ];
        fbsArgs.validate('on', specs, arguments);
        var self = this;
        function makeBinder(specs) {
            function binder(nextOrObserver, error, opt_complete) {
                if (specs !== null) {
                    fbsArgs.validate('on', specs, arguments);
                }
                var observer = new observer_1.Observer(nextOrObserver, error, completed);
                self.addObserver_(observer);
                return function () {
                    self.removeObserver_(observer);
                };
            }
            return binder;
        }
        function binderNextOrObserverValidator(p) {
            if (p === null) {
                throw nextOrObserverMessage;
            }
            nextOrObserverValidator(p);
        }
        var binderSpecs = [
            fbsArgs.looseObjectSpec(binderNextOrObserverValidator),
            fbsArgs.nullFunctionSpec(true),
            fbsArgs.nullFunctionSpec(true)
        ];
        var typeOnly = !(typeUtils.isJustDef(nextOrObserver) ||
            typeUtils.isJustDef(error) ||
            typeUtils.isJustDef(completed));
        if (typeOnly) {
            return makeBinder(binderSpecs);
        }
        else {
            return makeBinder(null)(nextOrObserver, error, completed);
        }
    };
    /**
     * This object behaves like a Promise, and resolves with its snapshot data
     * when the upload completes.
     * @param onFulfilled The fulfillment callback. Promise chaining works as normal.
     * @param onRejected The rejection callback.
     */
    UploadTask.prototype.then = function (onFulfilled, onRejected) {
        // These casts are needed so that TypeScript can infer the types of the
        // resulting Promise.
        return this.promise_.then(onFulfilled, onRejected);
    };
    /**
     * Equivalent to calling `then(null, onRejected)`.
     */
    UploadTask.prototype.catch = function (onRejected) {
        return this.then(null, onRejected);
    };
    /**
     * Adds the given observer.
     */
    UploadTask.prototype.addObserver_ = function (observer) {
        this.observers_.push(observer);
        this.notifyObserver_(observer);
    };
    /**
     * Removes the given observer.
     */
    UploadTask.prototype.removeObserver_ = function (observer) {
        fbsArray.remove(this.observers_, observer);
    };
    UploadTask.prototype.notifyObservers_ = function () {
        var _this = this;
        this.finishPromise_();
        var observers = fbsArray.clone(this.observers_);
        observers.forEach(function (observer) {
            _this.notifyObserver_(observer);
        });
    };
    UploadTask.prototype.finishPromise_ = function () {
        if (this.resolve_ !== null) {
            var triggered = true;
            switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {
                case taskenums_2.TaskState.SUCCESS:
                    async_1.async(this.resolve_.bind(null, this.snapshot))();
                    break;
                case taskenums_2.TaskState.CANCELED:
                case taskenums_2.TaskState.ERROR:
                    var toCall = this.reject_;
                    async_1.async(toCall.bind(null, this.error_))();
                    break;
                default:
                    triggered = false;
                    break;
            }
            if (triggered) {
                this.resolve_ = null;
                this.reject_ = null;
            }
        }
    };
    UploadTask.prototype.notifyObserver_ = function (observer) {
        var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);
        switch (externalState) {
            case taskenums_2.TaskState.RUNNING:
            case taskenums_2.TaskState.PAUSED:
                if (observer.next !== null) {
                    async_1.async(observer.next.bind(observer, this.snapshot))();
                }
                break;
            case taskenums_2.TaskState.SUCCESS:
                if (observer.complete !== null) {
                    async_1.async(observer.complete.bind(observer))();
                }
                break;
            case taskenums_2.TaskState.CANCELED:
            case taskenums_2.TaskState.ERROR:
                if (observer.error !== null) {
                    async_1.async(observer.error.bind(observer, this.error_))();
                }
                break;
            default:
                // TODO(andysoto): assert(false);
                if (observer.error !== null) {
                    async_1.async(observer.error.bind(observer, this.error_))();
                }
        }
    };
    /**
     * Resumes a paused task. Has no effect on a currently running or failed task.
     * @return True if the operation took effect, false if ignored.
     */
    UploadTask.prototype.resume = function () {
        fbsArgs.validate('resume', [], arguments);
        var valid = this.state_ === taskenums_1.InternalTaskState.PAUSED ||
            this.state_ === taskenums_1.InternalTaskState.PAUSING;
        if (valid) {
            this.transition_(taskenums_1.InternalTaskState.RUNNING);
        }
        return valid;
    };
    /**
     * Pauses a currently running task. Has no effect on a paused or failed task.
     * @return True if the operation took effect, false if ignored.
     */
    UploadTask.prototype.pause = function () {
        fbsArgs.validate('pause', [], arguments);
        var valid = this.state_ === taskenums_1.InternalTaskState.RUNNING;
        if (valid) {
            this.transition_(taskenums_1.InternalTaskState.PAUSING);
        }
        return valid;
    };
    /**
     * Cancels a currently running or paused task. Has no effect on a complete or
     * failed task.
     * @return True if the operation took effect, false if ignored.
     */
    UploadTask.prototype.cancel = function () {
        fbsArgs.validate('cancel', [], arguments);
        var valid = this.state_ === taskenums_1.InternalTaskState.RUNNING ||
            this.state_ === taskenums_1.InternalTaskState.PAUSING;
        if (valid) {
            this.transition_(taskenums_1.InternalTaskState.CANCELING);
        }
        return valid;
    };
    return UploadTask;
}());
exports.UploadTask = UploadTask;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/task.js","/node_modules/@firebase/storage/dist/cjs/src")

},{"./implementation/args":102,"./implementation/array":103,"./implementation/async":104,"./implementation/error":109,"./implementation/observer":116,"./implementation/promise_external":118,"./implementation/requests":122,"./implementation/taskenums":124,"./implementation/type":125,"./tasksnapshot":133,"_process":162,"buffer":160}],133:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UploadTaskSnapshot = /** @class */ (function () {
    function UploadTaskSnapshot(bytesTransferred, totalBytes, state, metadata, task, ref) {
        this.bytesTransferred = bytesTransferred;
        this.totalBytes = totalBytes;
        this.state = state;
        this.metadata = metadata;
        this.task = task;
        this.ref = ref;
    }
    Object.defineProperty(UploadTaskSnapshot.prototype, "downloadURL", {
        get: function () {
            if (this.metadata !== null) {
                var urls = this.metadata['downloadURLs'];
                if (urls != null && urls[0] != null) {
                    return urls[0];
                }
                else {
                    return null;
                }
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    return UploadTaskSnapshot;
}());
exports.UploadTaskSnapshot = UploadTaskSnapshot;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/storage/dist/cjs/src/tasksnapshot.js","/node_modules/@firebase/storage/dist/cjs/src")

},{"_process":162,"buffer":160}],134:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./src/assert"));
__export(require("./src/crypt"));
__export(require("./src/constants"));
__export(require("./src/deepCopy"));
__export(require("./src/deferred"));
__export(require("./src/environment"));
__export(require("./src/errors"));
__export(require("./src/json"));
__export(require("./src/jwt"));
__export(require("./src/obj"));
__export(require("./src/query"));
__export(require("./src/sha1"));
__export(require("./src/subscribe"));
__export(require("./src/validation"));
__export(require("./src/utf8"));



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/index.js","/node_modules/@firebase/util/dist/cjs")

},{"./src/assert":135,"./src/constants":136,"./src/crypt":137,"./src/deepCopy":138,"./src/deferred":139,"./src/environment":140,"./src/errors":141,"./src/json":143,"./src/jwt":144,"./src/obj":145,"./src/query":146,"./src/sha1":147,"./src/subscribe":148,"./src/utf8":149,"./src/validation":150,"_process":162,"buffer":160}],135:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = require("./constants");
/**
 * Throws an error if the provided assertion is falsy
 * @param {*} assertion The assertion to be tested for falsiness
 * @param {!string} message The message to display if the check fails
 */
exports.assert = function (assertion, message) {
    if (!assertion) {
        throw exports.assertionError(message);
    }
};
/**
 * Returns an Error object suitable for throwing.
 * @param {string} message
 * @return {!Error}
 */
exports.assertionError = function (message) {
    return new Error('Firebase Database (' +
        constants_1.CONSTANTS.SDK_VERSION +
        ') INTERNAL ASSERT FAILED: ' +
        message);
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/assert.js","/node_modules/@firebase/util/dist/cjs/src")

},{"./constants":136,"_process":162,"buffer":160}],136:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.
 */
exports.CONSTANTS = {
    /**
     * @define {boolean} Whether this is the client Node.js SDK.
     */
    NODE_CLIENT: false,
    /**
     * @define {boolean} Whether this is the Admin Node.js SDK.
     */
    NODE_ADMIN: false,
    /**
     * Firebase SDK Version
     */
    SDK_VERSION: '${JSCORE_VERSION}'
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/constants.js","/node_modules/@firebase/util/dist/cjs/src")

},{"_process":162,"buffer":160}],137:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var stringToByteArray = function (str) {
    var output = [], p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        while (c > 255) {
            output[p++] = c & 255;
            c >>= 8;
        }
        output[p++] = c;
    }
    return output;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param {Array<number>} bytes Array of numbers representing characters.
 * @return {string} Stringification of the array.
 */
var byteArrayToString = function (bytes) {
    var CHUNK_SIZE = 8192;
    // Special-case the simple case for speed's sake.
    if (bytes.length < CHUNK_SIZE) {
        return String.fromCharCode.apply(null, bytes);
    }
    // The remaining logic splits conversion by chunks since
    // Function#apply() has a maximum parameter count.
    // See discussion: http://goo.gl/LrWmZ9
    var str = '';
    for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {
        var chunk = bytes.slice(i, i + CHUNK_SIZE);
        str += String.fromCharCode.apply(null, chunk);
    }
    return str;
};
// Static lookup maps, lazily populated by init_()
exports.base64 = {
    /**
     * Maps bytes to characters.
     * @type {Object}
     * @private
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @type {Object}
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     * @type {string}
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     * @type {string}
     */
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + '+/=';
    },
    /**
     * Our websafe alphabet.
     * @type {string}
     */
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + '-_.';
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     * @type {boolean}
     */
    HAS_NATIVE_SUPPORT: typeof atob === 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param {Array<number>|Uint8Array} input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param {boolean=} opt_webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return {string} The base64 encoded string.
     */
    encodeByteArray: function (input, opt_webSafe) {
        if (!Array.isArray(input)) {
            throw Error('encodeByteArray takes an array as a parameter');
        }
        this.init_();
        var byteToCharMap = opt_webSafe
            ? this.byteToCharMapWebSafe_
            : this.byteToCharMap_;
        var output = [];
        for (var i = 0; i < input.length; i += 3) {
            var byte1 = input[i];
            var haveByte2 = i + 1 < input.length;
            var byte2 = haveByte2 ? input[i + 1] : 0;
            var haveByte3 = i + 2 < input.length;
            var byte3 = haveByte3 ? input[i + 2] : 0;
            var outByte1 = byte1 >> 2;
            var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            var outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);
            var outByte4 = byte3 & 0x3f;
            if (!haveByte3) {
                outByte4 = 64;
                if (!haveByte2) {
                    outByte3 = 64;
                }
            }
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join('');
    },
    /**
     * Base64-encode a string.
     *
     * @param {string} input A string to encode.
     * @param {boolean=} opt_webSafe If true, we should use the
     *     alternative alphabet.
     * @return {string} The base64 encoded string.
     */
    encodeString: function (input, opt_webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {
            return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray(input), opt_webSafe);
    },
    /**
     * Base64-decode a string.
     *
     * @param {string} input to decode.
     * @param {boolean=} opt_webSafe True if we should use the
     *     alternative alphabet.
     * @return {string} string representing the decoded value.
     */
    decodeString: function (input, opt_webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {
            return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param {string} input Input to decode.
     * @param {boolean=} opt_webSafe True if we should use the web-safe alphabet.
     * @return {!Array<number>} bytes representing the decoded value.
     */
    decodeStringToByteArray: function (input, opt_webSafe) {
        this.init_();
        var charToByteMap = opt_webSafe
            ? this.charToByteMapWebSafe_
            : this.charToByteMap_;
        var output = [];
        for (var i = 0; i < input.length;) {
            var byte1 = charToByteMap[input.charAt(i++)];
            var haveByte2 = i < input.length;
            var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            var haveByte3 = i < input.length;
            var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            var haveByte4 = i < input.length;
            var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
                throw Error();
            }
            var outByte1 = (byte1 << 2) | (byte2 >> 4);
            output.push(outByte1);
            if (byte3 != 64) {
                var outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);
                output.push(outByte2);
                if (byte4 != 64) {
                    var outByte3 = ((byte3 << 6) & 0xc0) | byte4;
                    output.push(outByte3);
                }
            }
        }
        return output;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_: function () {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {};
            this.charToByteMap_ = {};
            this.byteToCharMapWebSafe_ = {};
            this.charToByteMapWebSafe_ = {};
            // We want quick mappings back and forth, so we precompute two maps.
            for (var i = 0; i < this.ENCODED_VALS.length; i++) {
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) {
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
                }
            }
        }
    }
};
/**
 * URL-safe base64 encoding
 * @param {!string} str
 * @return {!string}
 */
exports.base64Encode = function (str) {
    var utf8Bytes = stringToByteArray(str);
    return exports.base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param {string} str To be decoded
 * @return {?string} Decoded result, if possible
 */
exports.base64Decode = function (str) {
    try {
        return exports.base64.decodeString(str, true);
    }
    catch (e) {
        console.error('base64Decode failed: ', e);
    }
    return null;
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/crypt.js","/node_modules/@firebase/util/dist/cjs/src")

},{"_process":162,"buffer":160}],138:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Do a deep-copy of basic JavaScript Objects or Arrays.
 */
function deepCopy(value) {
    return deepExtend(undefined, value);
}
exports.deepCopy = deepCopy;
/**
 * Copy properties from source to target (recursively allows extension
 * of Objects and Arrays).  Scalar values in the target are over-written.
 * If target is undefined, an object of the appropriate type will be created
 * (and returned).
 *
 * We recursively copy all child properties of plain Objects in the source- so
 * that namespace- like dictionaries are merged.
 *
 * Note that the target can be a function, in which case the properties in
 * the source Object are copied onto it as static properties of the Function.
 */
function deepExtend(target, source) {
    if (!(source instanceof Object)) {
        return source;
    }
    switch (source.constructor) {
        case Date:
            // Treat Dates like scalars; if the target date object had any child
            // properties - they will be lost!
            var dateValue = source;
            return new Date(dateValue.getTime());
        case Object:
            if (target === undefined) {
                target = {};
            }
            break;
        case Array:
            // Always copy the array source and overwrite the target.
            target = [];
            break;
        default:
            // Not a plain Object - treat it as a scalar.
            return source;
    }
    for (var prop in source) {
        if (!source.hasOwnProperty(prop)) {
            continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
    }
    return target;
}
exports.deepExtend = deepExtend;
// TODO: Really needed (for JSCompiler type checking)?
function patchProperty(obj, prop, value) {
    obj[prop] = value;
}
exports.patchProperty = patchProperty;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/deepCopy.js","/node_modules/@firebase/util/dist/cjs/src")

},{"_process":162,"buffer":160}],139:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
    }
    /**
    * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
    * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
    * and returns a node-style callback which will resolve or reject the Deferred's promise.
    * @param {((?function(?(Error)): (?|undefined))| (?function(?(Error),?=): (?|undefined)))=} callback
    * @return {!function(?(Error), ?=)}
    */
    Deferred.prototype.wrapCallback = function (callback) {
        var _this = this;
        return function (error, value) {
            if (error) {
                _this.reject(error);
            }
            else {
                _this.resolve(value);
            }
            if (typeof callback === 'function') {
                // Attaching noop handler just in case developer wasn't expecting
                // promises
                _this.promise.catch(function () { });
                // Some of our callbacks don't expect a value and our own tests
                // assert that the parameter length is 1
                if (callback.length === 1) {
                    callback(error);
                }
                else {
                    callback(error, value);
                }
            }
        };
    };
    return Deferred;
}());
exports.Deferred = Deferred;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/deferred.js","/node_modules/@firebase/util/dist/cjs/src")

},{"_process":162,"buffer":160}],140:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = require("./constants");
/**
 * Returns navigator.userAgent string or '' if it's not defined.
 * @return {string} user agent string
 */
exports.getUA = function () {
    if (typeof navigator !== 'undefined' &&
        typeof navigator['userAgent'] === 'string') {
        return navigator['userAgent'];
    }
    else {
        return '';
    }
};
/**
 * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
 *
 * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap in the Ripple emulator) nor
 * Cordova `onDeviceReady`, which would normally wait for a callback.
 *
 * @return {boolean} isMobileCordova
 */
exports.isMobileCordova = function () {
    return (typeof window !== 'undefined' &&
        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&
        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(exports.getUA()));
};
/**
 * Detect React Native.
 *
 * @return {boolean} True if ReactNative environment is detected.
 */
exports.isReactNative = function () {
    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');
};
/**
 * Detect Node.js.
 *
 * @return {boolean} True if Node.js environment is detected.
 */
exports.isNodeSdk = function () {
    return constants_1.CONSTANTS.NODE_CLIENT === true || constants_1.CONSTANTS.NODE_ADMIN === true;
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/environment.js","/node_modules/@firebase/util/dist/cjs/src")

},{"./constants":136,"_process":162,"buffer":160}],141:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ERROR_NAME = 'FirebaseError';
var captureStackTrace = Error
    .captureStackTrace;
// Export for faking in tests
function patchCapture(captureFake) {
    var result = captureStackTrace;
    captureStackTrace = captureFake;
    return result;
}
exports.patchCapture = patchCapture;
var FirebaseError = /** @class */ (function () {
    function FirebaseError(code, message) {
        this.code = code;
        this.message = message;
        var stack;
        // We want the stack value, if implemented by Error
        if (captureStackTrace) {
            // Patches this.stack, omitted calls above ErrorFactory#create
            captureStackTrace(this, ErrorFactory.prototype.create);
        }
        else {
            var err_1 = Error.apply(this, arguments);
            this.name = ERROR_NAME;
            // Make non-enumerable getter for the property.
            Object.defineProperty(this, 'stack', {
                get: function () {
                    return err_1.stack;
                }
            });
        }
    }
    return FirebaseError;
}());
exports.FirebaseError = FirebaseError;
// Back-door inheritance
FirebaseError.prototype = Object.create(Error.prototype);
FirebaseError.prototype.constructor = FirebaseError;
FirebaseError.prototype.name = ERROR_NAME;
var ErrorFactory = /** @class */ (function () {
    function ErrorFactory(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
        // Matches {$name}, by default.
        this.pattern = /\{\$([^}]+)}/g;
        // empty
    }
    ErrorFactory.prototype.create = function (code, data) {
        if (data === undefined) {
            data = {};
        }
        var template = this.errors[code];
        var fullCode = this.service + '/' + code;
        var message;
        if (template === undefined) {
            message = 'Error';
        }
        else {
            message = template.replace(this.pattern, function (match, key) {
                var value = data[key];
                return value !== undefined ? value.toString() : '<' + key + '?>';
            });
        }
        // Service: Error message (service/code).
        message = this.serviceName + ': ' + message + ' (' + fullCode + ').';
        var err = new FirebaseError(fullCode, message);
        // Populate the Error object with message parts for programmatic
        // accesses (e.g., e.file).
        for (var prop in data) {
            if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {
                continue;
            }
            err[prop] = data[prop];
        }
        return err;
    };
    return ErrorFactory;
}());
exports.ErrorFactory = ErrorFactory;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/errors.js","/node_modules/@firebase/util/dist/cjs/src")

},{"_process":162,"buffer":160}],142:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Abstract cryptographic hash interface.
 *
 * See Sha1 and Md5 for sample implementations.
 *
 */
/**
 * Create a cryptographic hash instance.
 *
 * @constructor
 * @struct
 */
var Hash = /** @class */ (function () {
    function Hash() {
        /**
         * The block size for the hasher.
         * @type {number}
         */
        this.blockSize = -1;
    }
    return Hash;
}());
exports.Hash = Hash;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/hash.js","/node_modules/@firebase/util/dist/cjs/src")

},{"_process":162,"buffer":160}],143:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Evaluates a JSON string into a javascript object.
 *
 * @param {string} str A string containing JSON.
 * @return {*} The javascript object representing the specified JSON.
 */
function jsonEval(str) {
    return JSON.parse(str);
}
exports.jsonEval = jsonEval;
/**
 * Returns JSON representing a javascript object.
 * @param {*} data Javascript object to be stringified.
 * @return {string} The JSON contents of the object.
 */
function stringify(data) {
    return JSON.stringify(data);
}
exports.stringify = stringify;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/json.js","/node_modules/@firebase/util/dist/cjs/src")

},{"_process":162,"buffer":160}],144:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var crypt_1 = require("./crypt");
var json_1 = require("./json");
/**
 * Decodes a Firebase auth. token into constituent parts.
 *
 * Notes:
 * - May return with invalid / incomplete claims if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {{header: *, claims: *, data: *, signature: string}}
 */
exports.decode = function (token) {
    var header = {}, claims = {}, data = {}, signature = '';
    try {
        var parts = token.split('.');
        header = json_1.jsonEval(crypt_1.base64Decode(parts[0]) || '');
        claims = json_1.jsonEval(crypt_1.base64Decode(parts[1]) || '');
        signature = parts[2];
        data = claims['d'] || {};
        delete claims['d'];
    }
    catch (e) { }
    return {
        header: header,
        claims: claims,
        data: data,
        signature: signature
    };
};
/**
 * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the
 * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
exports.isValidTimestamp = function (token) {
    var claims = exports.decode(token).claims, now = Math.floor(new Date().getTime() / 1000), validSince, validUntil;
    if (typeof claims === 'object') {
        if (claims.hasOwnProperty('nbf')) {
            validSince = claims['nbf'];
        }
        else if (claims.hasOwnProperty('iat')) {
            validSince = claims['iat'];
        }
        if (claims.hasOwnProperty('exp')) {
            validUntil = claims['exp'];
        }
        else {
            // token will expire after 24h by default
            validUntil = validSince + 86400;
        }
    }
    return (now && validSince && validUntil && now >= validSince && now <= validUntil);
};
/**
 * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.
 *
 * Notes:
 * - May return null if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {?number}
 */
exports.issuedAtTime = function (token) {
    var claims = exports.decode(token).claims;
    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {
        return claims['iat'];
    }
    return null;
};
/**
 * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time and non-empty
 * signature.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
exports.isValidFormat = function (token) {
    var decoded = exports.decode(token), claims = decoded.claims;
    return (!!decoded.signature &&
        !!claims &&
        typeof claims === 'object' &&
        claims.hasOwnProperty('iat'));
};
/**
 * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
exports.isAdmin = function (token) {
    var claims = exports.decode(token).claims;
    return typeof claims === 'object' && claims['admin'] === true;
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/jwt.js","/node_modules/@firebase/util/dist/cjs/src")

},{"./crypt":137,"./json":143,"_process":162,"buffer":160}],145:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// See http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/
exports.contains = function (obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
};
exports.safeGet = function (obj, key) {
    if (Object.prototype.hasOwnProperty.call(obj, key))
        return obj[key];
    // else return undefined.
};
/**
 * Enumerates the keys/values in an object, excluding keys defined on the prototype.
 *
 * @param {?Object.<K,V>} obj Object to enumerate.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */
exports.forEach = function (obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn(key, obj[key]);
        }
    }
};
/**
 * Copies all the (own) properties from one object to another.
 * @param {!Object} objTo
 * @param {!Object} objFrom
 * @return {!Object} objTo
 */
exports.extend = function (objTo, objFrom) {
    exports.forEach(objFrom, function (key, value) {
        objTo[key] = value;
    });
    return objTo;
};
/**
 * Returns a clone of the specified object.
 * @param {!Object} obj
 * @return {!Object} cloned obj.
 */
exports.clone = function (obj) {
    return exports.extend({}, obj);
};
/**
 * Returns true if obj has typeof "object" and is not null.  Unlike goog.isObject(), does not return true
 * for functions.
 *
 * @param obj {*} A potential object.
 * @returns {boolean} True if it's an object.
 */
exports.isNonNullObject = function (obj) {
    return typeof obj === 'object' && obj !== null;
};
exports.isEmpty = function (obj) {
    for (var key in obj) {
        return false;
    }
    return true;
};
exports.getCount = function (obj) {
    var rv = 0;
    for (var key in obj) {
        rv++;
    }
    return rv;
};
exports.map = function (obj, f, opt_obj) {
    var res = {};
    for (var key in obj) {
        res[key] = f.call(opt_obj, obj[key], key, obj);
    }
    return res;
};
exports.findKey = function (obj, fn, opt_this) {
    for (var key in obj) {
        if (fn.call(opt_this, obj[key], key, obj)) {
            return key;
        }
    }
    return undefined;
};
exports.findValue = function (obj, fn, opt_this) {
    var key = exports.findKey(obj, fn, opt_this);
    return key && obj[key];
};
exports.getAnyKey = function (obj) {
    for (var key in obj) {
        return key;
    }
};
exports.getValues = function (obj) {
    var res = [];
    var i = 0;
    for (var key in obj) {
        res[i++] = obj[key];
    }
    return res;
};
/**
 * Tests whether every key/value pair in an object pass the test implemented
 * by the provided function
 *
 * @param {?Object.<K,V>} obj Object to test.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */
exports.every = function (obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            if (!fn(key, obj[key])) {
                return false;
            }
        }
    }
    return true;
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/obj.js","/node_modules/@firebase/util/dist/cjs/src")

},{"_process":162,"buffer":160}],146:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var obj_1 = require("./obj");
/**
 * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a params
 * object (e.g. {arg: 'val', arg2: 'val2'})
 * Note: You must prepend it with ? when adding it to a URL.
 *
 * @param {!Object} querystringParams
 * @return {string}
 */
exports.querystring = function (querystringParams) {
    var params = [];
    obj_1.forEach(querystringParams, function (key, value) {
        if (Array.isArray(value)) {
            value.forEach(function (arrayVal) {
                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));
            });
        }
        else {
            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        }
    });
    return params.length ? '&' + params.join('&') : '';
};
/**
 * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object (e.g. {arg: 'val', arg2: 'val2'})
 *
 * @param {string} querystring
 * @return {!Object}
 */
exports.querystringDecode = function (querystring) {
    var obj = {};
    var tokens = querystring.replace(/^\?/, '').split('&');
    tokens.forEach(function (token) {
        if (token) {
            var key = token.split('=');
            obj[key[0]] = key[1];
        }
    });
    return obj;
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/query.js","/node_modules/@firebase/util/dist/cjs/src")

},{"./obj":145,"_process":162,"buffer":160}],147:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var hash_1 = require("./hash");
/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */
/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @extends {Hash}
 * @final
 * @struct
 */
var Sha1 = /** @class */ (function (_super) {
    __extends(Sha1, _super);
    function Sha1() {
        var _this = _super.call(this) || this;
        /**
         * Holds the previous values of accumulated variables a-e in the compress_
         * function.
         * @type {!Array<number>}
         * @private
         */
        _this.chain_ = [];
        /**
         * A buffer holding the partially computed hash result.
         * @type {!Array<number>}
         * @private
         */
        _this.buf_ = [];
        /**
         * An array of 80 bytes, each a part of the message to be hashed.  Referred to
         * as the message schedule in the docs.
         * @type {!Array<number>}
         * @private
         */
        _this.W_ = [];
        /**
         * Contains data needed to pad messages less than 64 bytes.
         * @type {!Array<number>}
         * @private
         */
        _this.pad_ = [];
        /**
         * @private {number}
         */
        _this.inbuf_ = 0;
        /**
         * @private {number}
         */
        _this.total_ = 0;
        _this.blockSize = 512 / 8;
        _this.pad_[0] = 128;
        for (var i = 1; i < _this.blockSize; ++i) {
            _this.pad_[i] = 0;
        }
        _this.reset();
        return _this;
    }
    Sha1.prototype.reset = function () {
        this.chain_[0] = 0x67452301;
        this.chain_[1] = 0xefcdab89;
        this.chain_[2] = 0x98badcfe;
        this.chain_[3] = 0x10325476;
        this.chain_[4] = 0xc3d2e1f0;
        this.inbuf_ = 0;
        this.total_ = 0;
    };
    /**
     * Internal compress helper function.
     * @param {!Array<number>|!Uint8Array|string} buf Block to compress.
     * @param {number=} opt_offset Offset of the block in the buffer.
     * @private
     */
    Sha1.prototype.compress_ = function (buf, opt_offset) {
        if (!opt_offset) {
            opt_offset = 0;
        }
        var W = this.W_;
        // get 16 big endian words
        if (typeof buf === 'string') {
            for (var i = 0; i < 16; i++) {
                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS
                // have a bug that turns the post-increment ++ operator into pre-increment
                // during JIT compilation.  We have code that depends heavily on SHA-1 for
                // correctness and which is affected by this bug, so I've removed all uses
                // of post-increment ++ in which the result value is used.  We can revert
                // this change once the Safari bug
                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
                // most clients have been updated.
                W[i] =
                    (buf.charCodeAt(opt_offset) << 24) |
                        (buf.charCodeAt(opt_offset + 1) << 16) |
                        (buf.charCodeAt(opt_offset + 2) << 8) |
                        buf.charCodeAt(opt_offset + 3);
                opt_offset += 4;
            }
        }
        else {
            for (var i = 0; i < 16; i++) {
                W[i] =
                    (buf[opt_offset] << 24) |
                        (buf[opt_offset + 1] << 16) |
                        (buf[opt_offset + 2] << 8) |
                        buf[opt_offset + 3];
                opt_offset += 4;
            }
        }
        // expand to 80 words
        for (var i = 16; i < 80; i++) {
            var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;
        }
        var a = this.chain_[0];
        var b = this.chain_[1];
        var c = this.chain_[2];
        var d = this.chain_[3];
        var e = this.chain_[4];
        var f, k;
        // TODO(user): Try to unroll this loop to speed up the computation.
        for (var i = 0; i < 80; i++) {
            if (i < 40) {
                if (i < 20) {
                    f = d ^ (b & (c ^ d));
                    k = 0x5a827999;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0x6ed9eba1;
                }
            }
            else {
                if (i < 60) {
                    f = (b & c) | (d & (b | c));
                    k = 0x8f1bbcdc;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0xca62c1d6;
                }
            }
            var t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;
            e = d;
            d = c;
            c = ((b << 30) | (b >>> 2)) & 0xffffffff;
            b = a;
            a = t;
        }
        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;
        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;
        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;
        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;
        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;
    };
    Sha1.prototype.update = function (bytes, opt_length) {
        // TODO(johnlenz): tighten the function signature and remove this check
        if (bytes == null) {
            return;
        }
        if (opt_length === undefined) {
            opt_length = bytes.length;
        }
        var lengthMinusBlock = opt_length - this.blockSize;
        var n = 0;
        // Using local instead of member variables gives ~5% speedup on Firefox 16.
        var buf = this.buf_;
        var inbuf = this.inbuf_;
        // The outer while loop should execute at most twice.
        while (n < opt_length) {
            // When we have no data in the block to top up, we can directly process the
            // input buffer (assuming it contains sufficient data). This gives ~25%
            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
            // the data is provided in large chunks (or in multiples of 64 bytes).
            if (inbuf == 0) {
                while (n <= lengthMinusBlock) {
                    this.compress_(bytes, n);
                    n += this.blockSize;
                }
            }
            if (typeof bytes === 'string') {
                while (n < opt_length) {
                    buf[inbuf] = bytes.charCodeAt(n);
                    ++inbuf;
                    ++n;
                    if (inbuf == this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
            else {
                while (n < opt_length) {
                    buf[inbuf] = bytes[n];
                    ++inbuf;
                    ++n;
                    if (inbuf == this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
        }
        this.inbuf_ = inbuf;
        this.total_ += opt_length;
    };
    /** @override */
    Sha1.prototype.digest = function () {
        var digest = [];
        var totalBits = this.total_ * 8;
        // Add pad 0x80 0x00*.
        if (this.inbuf_ < 56) {
            this.update(this.pad_, 56 - this.inbuf_);
        }
        else {
            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        // Add # bits.
        for (var i = this.blockSize - 1; i >= 56; i--) {
            this.buf_[i] = totalBits & 255;
            totalBits /= 256; // Don't use bit-shifting here!
        }
        this.compress_(this.buf_);
        var n = 0;
        for (var i = 0; i < 5; i++) {
            for (var j = 24; j >= 0; j -= 8) {
                digest[n] = (this.chain_[i] >> j) & 255;
                ++n;
            }
        }
        return digest;
    };
    return Sha1;
}(hash_1.Hash));
exports.Sha1 = Sha1;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/sha1.js","/node_modules/@firebase/util/dist/cjs/src")

},{"./hash":142,"_process":162,"buffer":160}],148:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */
function createSubscribe(executor, onNoObservers) {
    var proxy = new ObserverProxy(executor, onNoObservers);
    return proxy.subscribe.bind(proxy);
}
exports.createSubscribe = createSubscribe;
/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */
var ObserverProxy = /** @class */ (function () {
    /**
     * @param executor Function which can make calls to a single Observer
     *     as a proxy.
     * @param onNoObservers Callback when count of Observers goes to zero.
     */
    function ObserverProxy(executor, onNoObservers) {
        var _this = this;
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        // Micro-task scheduling by calling task.then().
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        // Call the executor asynchronously so subscribers that are called
        // synchronously after the creation of the subscribe function
        // can still receive the very first value generated in the executor.
        this.task
            .then(function () {
            executor(_this);
        })
            .catch(function (e) {
            _this.error(e);
        });
    }
    ObserverProxy.prototype.next = function (value) {
        this.forEachObserver(function (observer) {
            observer.next(value);
        });
    };
    ObserverProxy.prototype.error = function (error) {
        this.forEachObserver(function (observer) {
            observer.error(error);
        });
        this.close(error);
    };
    ObserverProxy.prototype.complete = function () {
        this.forEachObserver(function (observer) {
            observer.complete();
        });
        this.close();
    };
    /**
     * Subscribe function that can be used to add an Observer to the fan-out list.
     *
     * - We require that no event is sent to a subscriber sychronously to their
     *   call to subscribe().
     */
    ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {
        var _this = this;
        var observer;
        if (nextOrObserver === undefined &&
            error === undefined &&
            complete === undefined) {
            throw new Error('Missing Observer.');
        }
        // Assemble an Observer object when passed as callback functions.
        if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {
            observer = nextOrObserver;
        }
        else {
            observer = {
                next: nextOrObserver,
                error: error,
                complete: complete
            };
        }
        if (observer.next === undefined) {
            observer.next = noop;
        }
        if (observer.error === undefined) {
            observer.error = noop;
        }
        if (observer.complete === undefined) {
            observer.complete = noop;
        }
        var unsub = this.unsubscribeOne.bind(this, this.observers.length);
        // Attempt to subscribe to a terminated Observable - we
        // just respond to the Observer with the final error or complete
        // event.
        if (this.finalized) {
            this.task.then(function () {
                try {
                    if (_this.finalError) {
                        observer.error(_this.finalError);
                    }
                    else {
                        observer.complete();
                    }
                }
                catch (e) {
                    // nothing
                }
                return;
            });
        }
        this.observers.push(observer);
        return unsub;
    };
    // Unsubscribe is synchronous - we guarantee that no events are sent to
    // any unsubscribed Observer.
    ObserverProxy.prototype.unsubscribeOne = function (i) {
        if (this.observers === undefined || this.observers[i] === undefined) {
            return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== undefined) {
            this.onNoObservers(this);
        }
    };
    ObserverProxy.prototype.forEachObserver = function (fn) {
        if (this.finalized) {
            // Already closed by previous event....just eat the additional values.
            return;
        }
        // Since sendOne calls asynchronously - there is no chance that
        // this.observers will become undefined.
        for (var i = 0; i < this.observers.length; i++) {
            this.sendOne(i, fn);
        }
    };
    // Call the Observer via one of it's callback function. We are careful to
    // confirm that the observe has not been unsubscribed since this asynchronous
    // function had been queued.
    ObserverProxy.prototype.sendOne = function (i, fn) {
        var _this = this;
        // Execute the callback asynchronously
        this.task.then(function () {
            if (_this.observers !== undefined && _this.observers[i] !== undefined) {
                try {
                    fn(_this.observers[i]);
                }
                catch (e) {
                    // Ignore exceptions raised in Observers or missing methods of an
                    // Observer.
                    // Log error to console. b/31404806
                    if (typeof console !== 'undefined' && console.error) {
                        console.error(e);
                    }
                }
            }
        });
    };
    ObserverProxy.prototype.close = function (err) {
        var _this = this;
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        if (err !== undefined) {
            this.finalError = err;
        }
        // Proxy is no longer needed - garbage collect references
        this.task.then(function () {
            _this.observers = undefined;
            _this.onNoObservers = undefined;
        });
    };
    return ObserverProxy;
}());
/** Turn synchronous function into one called asynchronously. */
function async(fn, onError) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        Promise.resolve(true)
            .then(function () {
            fn.apply(void 0, args);
        })
            .catch(function (error) {
            if (onError) {
                onError(error);
            }
        });
    };
}
exports.async = async;
/**
 * Return true if the object passed in implements any of the named methods.
 */
function implementsAnyMethods(obj, methods) {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in obj && typeof obj[method] === 'function') {
            return true;
        }
    }
    return false;
}
function noop() {
    // do nothing
}



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/subscribe.js","/node_modules/@firebase/util/dist/cjs/src")

},{"_process":162,"buffer":160}],149:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = require("./assert");
// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they
// automatically replaced '\r\n' with '\n', and they didn't handle surrogate pairs,
// so it's been modified.
// Note that not all Unicode characters appear as single characters in JavaScript strings.
// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters
// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first
// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate
// pair).
// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3
/**
 * @param {string} str
 * @return {Array}
 */
exports.stringToByteArray = function (str) {
    var out = [], p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        // Is this the lead surrogate in a surrogate pair?
        if (c >= 0xd800 && c <= 0xdbff) {
            var high = c - 0xd800; // the high 10 bits.
            i++;
            assert_1.assert(i < str.length, 'Surrogate pair missing trail surrogate.');
            var low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.
            c = 0x10000 + (high << 10) + low;
        }
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if (c < 65536) {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return out;
};
/**
 * Calculate length without actually converting; useful for doing cheaper validation.
 * @param {string} str
 * @return {number}
 */
exports.stringLength = function (str) {
    var p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
            p++;
        }
        else if (c < 2048) {
            p += 2;
        }
        else if (c >= 0xd800 && c <= 0xdbff) {
            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.
            p += 4;
            i++; // skip trail surrogate.
        }
        else {
            p += 3;
        }
    }
    return p;
};



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/utf8.js","/node_modules/@firebase/util/dist/cjs/src")

},{"./assert":135,"_process":162,"buffer":160}],150:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Check to make sure the appropriate number of arguments are provided for a public function.
 * Throws an error if it fails.
 *
 * @param {!string} fnName The function name
 * @param {!number} minCount The minimum number of arguments to allow for the function call
 * @param {!number} maxCount The maximum number of argument to allow for the function call
 * @param {!number} argCount The actual number of arguments provided.
 */
exports.validateArgCount = function (fnName, minCount, maxCount, argCount) {
    var argError;
    if (argCount < minCount) {
        argError = 'at least ' + minCount;
    }
    else if (argCount > maxCount) {
        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;
    }
    if (argError) {
        var error = fnName +
            ' failed: Was called with ' +
            argCount +
            (argCount === 1 ? ' argument.' : ' arguments.') +
            ' Expects ' +
            argError +
            '.';
        throw new Error(error);
    }
};
/**
 * Generates a string to prefix an error message about failed argument validation
 *
 * @param {!string} fnName The function name
 * @param {!number} argumentNumber The index of the argument
 * @param {boolean} optional Whether or not the argument is optional
 * @return {!string} The prefix to add to the error thrown for validation.
 */
function errorPrefix(fnName, argumentNumber, optional) {
    var argName = '';
    switch (argumentNumber) {
        case 1:
            argName = optional ? 'first' : 'First';
            break;
        case 2:
            argName = optional ? 'second' : 'Second';
            break;
        case 3:
            argName = optional ? 'third' : 'Third';
            break;
        case 4:
            argName = optional ? 'fourth' : 'Fourth';
            break;
        default:
            throw new Error('errorPrefix called with argumentNumber > 4.  Need to update it?');
    }
    var error = fnName + ' failed: ';
    error += argName + ' argument ';
    return error;
}
exports.errorPrefix = errorPrefix;
/**
 * @param {!string} fnName
 * @param {!number} argumentNumber
 * @param {!string} namespace
 * @param {boolean} optional
 */
function validateNamespace(fnName, argumentNumber, namespace, optional) {
    if (optional && !namespace)
        return;
    if (typeof namespace !== 'string') {
        //TODO: I should do more validation here. We only allow certain chars in namespaces.
        throw new Error(errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid firebase namespace.');
    }
}
exports.validateNamespace = validateNamespace;
function validateCallback(fnName, argumentNumber, callback, optional) {
    if (optional && !callback)
        return;
    if (typeof callback !== 'function')
        throw new Error(errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid function.');
}
exports.validateCallback = validateCallback;
function validateContextObject(fnName, argumentNumber, context, optional) {
    if (optional && !context)
        return;
    if (typeof context !== 'object' || context === null)
        throw new Error(errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid context object.');
}
exports.validateContextObject = validateContextObject;



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@firebase/util/dist/cjs/src/validation.js","/node_modules/@firebase/util/dist/cjs/src")

},{"_process":162,"buffer":160}],151:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('@firebase/polyfill');
module.exports = require('@firebase/app').default;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/firebase/app/index.js","/node_modules/firebase/app")

},{"@firebase/app":1,"@firebase/polyfill":97,"_process":162,"buffer":160}],152:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('@firebase/auth');

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/firebase/auth/index.js","/node_modules/firebase/auth")

},{"@firebase/auth":3,"_process":162,"buffer":160}],153:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = require('@firebase/database');

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/firebase/database/index.js","/node_modules/firebase/database")

},{"@firebase/database":4,"_process":162,"buffer":160}],154:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var firebase = require('./app');
require('./auth');
require('./database');
require('./messaging');
require('./storage');

module.exports = firebase;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/firebase/index.js","/node_modules/firebase")

},{"./app":151,"./auth":152,"./database":153,"./messaging":155,"./storage":156,"_process":162,"buffer":160}],155:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('@firebase/messaging');

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/firebase/messaging/index.js","/node_modules/firebase/messaging")

},{"@firebase/messaging":86,"_process":162,"buffer":160}],156:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('@firebase/storage');

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/firebase/storage/index.js","/node_modules/firebase/storage")

},{"@firebase/storage":101,"_process":162,"buffer":160}],157:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };
  
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }

})(this);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/promise-polyfill/promise.js","/node_modules/promise-polyfill")

},{"_process":162,"buffer":160}],158:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
const firebase = require('firebase');

class Roomchata {
    constructor() {
        firebase.initializeApp({
            apiKey: "AIzaSyDhMd2cZKMbh3V6pwmCX7hZ3GPxnJaLJ7Q",
            authDomain: "roomchata-9836e.firebaseapp.com",
            databaseURL: "https://roomchata-9836e.firebaseio.com",
            projectId: "roomchata-9836e",
            storageBucket: "roomchata-9836e.appspot.com",
            messagingSenderId: "592882928011"
        });
        this.auth = firebase.auth();
        this.storage = firebase.storage();
        this.database = firebase.database();
        this.auth.onAuthStateChanged(this.onAuthStateChanged().bind(this));
    }
}

window.onload = function() {
    window.roomchata = new Roomchata();
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/scripts/main.js","/src/scripts")

},{"_process":162,"buffer":160,"firebase":154}],159:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../../../../usr/local/lib/node_modules/browserify/node_modules/base64-js/index.js","/../../../../../usr/local/lib/node_modules/browserify/node_modules/base64-js")

},{"_process":162,"buffer":160}],160:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../../../../usr/local/lib/node_modules/browserify/node_modules/buffer/index.js","/../../../../../usr/local/lib/node_modules/browserify/node_modules/buffer")

},{"_process":162,"base64-js":159,"buffer":160,"ieee754":161}],161:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../../../../usr/local/lib/node_modules/browserify/node_modules/ieee754/index.js","/../../../../../usr/local/lib/node_modules/browserify/node_modules/ieee754")

},{"_process":162,"buffer":160}],162:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../../../../usr/local/lib/node_modules/browserify/node_modules/process/browser.js","/../../../../../usr/local/lib/node_modules/browserify/node_modules/process")

},{"_process":162,"buffer":160}]},{},[158])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvY2pzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvZGlzdC9janMvc3JjL2ZpcmViYXNlQXBwLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3QvYXV0aC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9hcGkvRGF0YVNuYXBzaG90LmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvYXBpL0RhdGFiYXNlLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvYXBpL1F1ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvYXBpL1JlZmVyZW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2FwaS9UcmFuc2FjdGlvblJlc3VsdC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2FwaS9pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2FwaS9vbkRpc2Nvbm5lY3QuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9hcGkvdGVzdF9hY2Nlc3MuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL0F1dGhUb2tlblByb3ZpZGVyLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9Db21wb3VuZFdyaXRlLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9QZXJzaXN0ZW50Q29ubmVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvUmVhZG9ubHlSZXN0Q2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9SZXBvLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9SZXBvSW5mby5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvUmVwb01hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL1JlcG9fdHJhbnNhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL1NlcnZlckFjdGlvbnMuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL1NuYXBzaG90SG9sZGVyLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9TcGFyc2VTbmFwc2hvdFRyZWUuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL1N5bmNQb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvU3luY1RyZWUuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL1dyaXRlVHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvb3BlcmF0aW9uL0Fja1VzZXJXcml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvb3BlcmF0aW9uL0xpc3RlbkNvbXBsZXRlLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9vcGVyYXRpb24vTWVyZ2UuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL29wZXJhdGlvbi9PcGVyYXRpb24uanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL29wZXJhdGlvbi9PdmVyd3JpdGUuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvQ2hpbGRyZW5Ob2RlLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL0luZGV4TWFwLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL0xlYWZOb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL05vZGUuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvY2hpbGRTZXQuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvY29tcGFyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvaW5kZXhlcy9JbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc25hcC9pbmRleGVzL0tleUluZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL2luZGV4ZXMvUGF0aEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc25hcC9pbmRleGVzL1ZhbHVlSW5kZXguanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvbm9kZUZyb21KU09OLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL3NuYXAuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3N0YXRzL1N0YXRzQ29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc3RhdHMvU3RhdHNMaXN0ZW5lci5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc3RhdHMvU3RhdHNNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zdGF0cy9TdGF0c1JlcG9ydGVyLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zdG9yYWdlL0RPTVN0b3JhZ2VXcmFwcGVyLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zdG9yYWdlL01lbW9yeVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3N0b3JhZ2Uvc3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9Db3VudGVkU2V0LmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS91dGlsL0V2ZW50RW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9JbW11dGFibGVUcmVlLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS91dGlsL05leHRQdXNoSWQuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvT25saW5lTW9uaXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9QYXRoLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS91dGlsL1NlcnZlclZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9Tb3J0ZWRNYXAuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvVHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9WaXNpYmlsaXR5TW9uaXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9saWJzL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS91dGlsL3ZhbGlkYXRpb24uanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvQ2FjaGVOb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L0NoYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9DaGlsZENoYW5nZUFjY3VtdWxhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L0NvbXBsZXRlQ2hpbGRTb3VyY2UuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvRXZlbnQuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvRXZlbnRHZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvRXZlbnRRdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9FdmVudFJlZ2lzdHJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9RdWVyeVBhcmFtcy5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9WaWV3LmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L1ZpZXdDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9WaWV3UHJvY2Vzc29yLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L2ZpbHRlci9JbmRleGVkRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L2ZpbHRlci9MaW1pdGVkRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L2ZpbHRlci9SYW5nZWRGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9yZWFsdGltZS9Ccm93c2VyUG9sbENvbm5lY3Rpb24uanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9yZWFsdGltZS9Db25uZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvcmVhbHRpbWUvQ29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvcmVhbHRpbWUvVHJhbnNwb3J0TWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL3JlYWx0aW1lL1dlYlNvY2tldENvbm5lY3Rpb24uanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9yZWFsdGltZS9wb2xsaW5nL1BhY2tldFJlY2VpdmVyLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2Nqcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci1pbnRlcmZhY2UuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2Nqcy9zcmMvY29udHJvbGxlcnMvc3ctY29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL2Rpc3QvY2pzL3NyYy9jb250cm9sbGVycy93aW5kb3ctY29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL2Rpc3QvY2pzL3NyYy9oZWxwZXJzL2FycmF5LWJ1ZmZlci10by1iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2Nqcy9zcmMvbW9kZWxzL2RlZmF1bHQtc3cuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2Nqcy9zcmMvbW9kZWxzL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL2Rpc3QvY2pzL3NyYy9tb2RlbHMvZmNtLWRldGFpbHMuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2Nqcy9zcmMvbW9kZWxzL25vdGlmaWNhdGlvbi1wZXJtaXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9janMvc3JjL21vZGVscy90b2tlbi1tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9janMvc3JjL21vZGVscy93b3JrZXItcGFnZS1tZXNzYWdlLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9wb2x5ZmlsbC9kaXN0L2Nqcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvcG9seWZpbGwvZGlzdC9janMvc3JjL3BvbHlmaWxscy9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9wb2x5ZmlsbC9kaXN0L2Nqcy9zcmMvc2hpbXMvZmluZC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvcG9seWZpbGwvZGlzdC9janMvc3JjL3NoaW1zL2ZpbmRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9zcmMvaW1wbGVtZW50YXRpb24vYXJncy5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9zcmMvaW1wbGVtZW50YXRpb24vYXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9janMvc3JjL2ltcGxlbWVudGF0aW9uL2FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvY2pzL3NyYy9pbXBsZW1lbnRhdGlvbi9hdXRod3JhcHBlci5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9zcmMvaW1wbGVtZW50YXRpb24vYmFja29mZi5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9zcmMvaW1wbGVtZW50YXRpb24vYmxvYi5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9zcmMvaW1wbGVtZW50YXRpb24vY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvY2pzL3NyYy9pbXBsZW1lbnRhdGlvbi9lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9zcmMvaW1wbGVtZW50YXRpb24vZmFpbHJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9janMvc3JjL2ltcGxlbWVudGF0aW9uL2ZzLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvY2pzL3NyYy9pbXBsZW1lbnRhdGlvbi9qc29uLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvY2pzL3NyYy9pbXBsZW1lbnRhdGlvbi9sb2NhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9zcmMvaW1wbGVtZW50YXRpb24vbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9janMvc3JjL2ltcGxlbWVudGF0aW9uL29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9zcmMvaW1wbGVtZW50YXRpb24vb2JzZXJ2ZXIuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9janMvc3JjL2ltcGxlbWVudGF0aW9uL3BhdGguanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9janMvc3JjL2ltcGxlbWVudGF0aW9uL3Byb21pc2VfZXh0ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9janMvc3JjL2ltcGxlbWVudGF0aW9uL3JlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9janMvc3JjL2ltcGxlbWVudGF0aW9uL3JlcXVlc3RpbmZvLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvY2pzL3NyYy9pbXBsZW1lbnRhdGlvbi9yZXF1ZXN0bWFwLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvY2pzL3NyYy9pbXBsZW1lbnRhdGlvbi9yZXF1ZXN0cy5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9zcmMvaW1wbGVtZW50YXRpb24vc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvY2pzL3NyYy9pbXBsZW1lbnRhdGlvbi90YXNrZW51bXMuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9janMvc3JjL2ltcGxlbWVudGF0aW9uL3R5cGUuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9janMvc3JjL2ltcGxlbWVudGF0aW9uL3VybC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9zcmMvaW1wbGVtZW50YXRpb24veGhyaW8uanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9janMvc3JjL2ltcGxlbWVudGF0aW9uL3hocmlvX25ldHdvcmsuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9janMvc3JjL2ltcGxlbWVudGF0aW9uL3hocmlvcG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2Nqcy9zcmMvcmVmZXJlbmNlLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvY2pzL3NyYy9zZXJ2aWNlLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvY2pzL3NyYy90YXNrLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvY2pzL3NyYy90YXNrc25hcHNob3QuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy9jcnlwdC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvZGVlcENvcHkuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL2RlZmVycmVkLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy9lbnZpcm9ubWVudC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy9qc29uLmpzIiwibm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy9qd3QuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL29iai5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvcXVlcnkuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL3NoYTEuanMiLCJub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL3N1YnNjcmliZS5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvdXRmOC5qcyIsIm5vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvdmFsaWRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9maXJlYmFzZS9hcHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmlyZWJhc2UvYXV0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9maXJlYmFzZS9kYXRhYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9maXJlYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9maXJlYmFzZS9tZXNzYWdpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmlyZWJhc2Uvc3RvcmFnZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlLXBvbHlmaWxsL3Byb21pc2UuanMiLCJzcmMvc2NyaXB0cy9tYWluLmpzIiwiLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDenlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbHBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNubEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDblFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDelRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBmaXJlYmFzZUFwcF8xID0gcmVxdWlyZShcIi4vc3JjL2ZpcmViYXNlQXBwXCIpO1xuZXhwb3J0cy5maXJlYmFzZSA9IGZpcmViYXNlQXBwXzEuY3JlYXRlRmlyZWJhc2VOYW1lc3BhY2UoKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZmlyZWJhc2U7XG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBjb250YWlucyA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufTtcbnZhciBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcbi8vIEFuIGFycmF5IHRvIGNhcHR1cmUgbGlzdGVuZXJzIGJlZm9yZSB0aGUgdHJ1ZSBhdXRoIGZ1bmN0aW9uc1xuLy8gZXhpc3RcbnZhciB0b2tlbkxpc3RlbmVycyA9IFtdO1xuLyoqXG4gKiBHbG9iYWwgY29udGV4dCBvYmplY3QgZm9yIGEgY29sbGVjdGlvbiBvZiBzZXJ2aWNlcyB1c2luZ1xuICogYSBzaGFyZWQgYXV0aGVudGljYXRpb24gc3RhdGUuXG4gKi9cbnZhciBGaXJlYmFzZUFwcEltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlyZWJhc2VBcHBJbXBsKG9wdGlvbnMsIG5hbWUsIGZpcmViYXNlXykge1xuICAgICAgICB0aGlzLmZpcmViYXNlXyA9IGZpcmViYXNlXztcbiAgICAgICAgdGhpcy5pc0RlbGV0ZWRfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VydmljZXNfID0ge307XG4gICAgICAgIHRoaXMubmFtZV8gPSBuYW1lO1xuICAgICAgICB0aGlzLm9wdGlvbnNfID0gdXRpbF8yLmRlZXBDb3B5KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLklOVEVSTkFMID0ge1xuICAgICAgICAgICAgZ2V0VWlkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZ2V0VG9rZW46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTsgfSxcbiAgICAgICAgICAgIGFkZEF1dGhUb2tlbkxpc3RlbmVyOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0b2tlbkxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgY2FsbGJhY2sgaXMgY2FsbGVkLCBhc3luY2hyb25vdXNseSwgaW4gdGhlIGFic2VuY2Ugb2YgdGhlIGF1dGggbW9kdWxlXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhudWxsKTsgfSwgMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlQXV0aFRva2VuTGlzdGVuZXI6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRva2VuTGlzdGVuZXJzID0gdG9rZW5MaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIgIT09IGNhbGxiYWNrOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZF8oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmlyZWJhc2VBcHBJbXBsLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkXygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIF90aGlzLmNoZWNrRGVzdHJveWVkXygpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZmlyZWJhc2VfLklOVEVSTkFMLnJlbW92ZUFwcChfdGhpcy5uYW1lXyk7XG4gICAgICAgICAgICB2YXIgc2VydmljZXMgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzLnNlcnZpY2VzXykuZm9yRWFjaChmdW5jdGlvbiAoc2VydmljZUtleSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzLnNlcnZpY2VzX1tzZXJ2aWNlS2V5XSkuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2VLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZXMucHVzaChfdGhpcy5zZXJ2aWNlc19bc2VydmljZUtleV1baW5zdGFuY2VLZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHNlcnZpY2VzLm1hcChmdW5jdGlvbiAoc2VydmljZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlLklOVEVSTkFMLmRlbGV0ZSgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaXNEZWxldGVkXyA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5zZXJ2aWNlc18gPSB7fTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzZXJ2aWNlIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFwcCAoY3JlYXRpbmcgaXRcbiAgICAgKiBvbiBkZW1hbmQpLCBpZGVudGlmaWVkIGJ5IHRoZSBwYXNzZWQgaW5zdGFuY2VJZGVudGlmaWVyLlxuICAgICAqXG4gICAgICogTk9URTogQ3VycmVudGx5IHN0b3JhZ2UgaXMgdGhlIG9ubHkgb25lIHRoYXQgaXMgbGV2ZXJhZ2luZyB0aGlzXG4gICAgICogZnVuY3Rpb25hbGl0eS4gVGhleSBpbnZva2UgaXQgYnkgY2FsbGluZzpcbiAgICAgKlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBmaXJlYmFzZS5hcHAoKS5zdG9yYWdlKCdTVE9SQUdFIEJVQ0tFVCBJRCcpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgc2VydmljZSBuYW1lIGlzIHBhc3NlZCB0byB0aGlzIGFscmVhZHlcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlLl9nZXRTZXJ2aWNlID0gZnVuY3Rpb24gKG5hbWUsIGluc3RhbmNlSWRlbnRpZmllcikge1xuICAgICAgICBpZiAoaW5zdGFuY2VJZGVudGlmaWVyID09PSB2b2lkIDApIHsgaW5zdGFuY2VJZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FOyB9XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWRfKCk7XG4gICAgICAgIGlmICghdGhpcy5zZXJ2aWNlc19bbmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZXNfW25hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2VzX1tuYW1lXVtpbnN0YW5jZUlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIGEgY3VzdG9tIGluc3RhbmNlIGhhcyBiZWVuIGRlZmluZWQgKGkuZS4gbm90ICdbREVGQVVMVF0nKVxuICAgICAgICAgICAgICogdGhlbiB3ZSB3aWxsIHBhc3MgdGhhdCBpbnN0YW5jZSBvbiwgb3RoZXJ3aXNlIHdlIHBhc3MgYG51bGxgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZVNwZWNpZmllciA9IGluc3RhbmNlSWRlbnRpZmllciAhPT0gREVGQVVMVF9FTlRSWV9OQU1FXG4gICAgICAgICAgICAgICAgPyBpbnN0YW5jZUlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBzZXJ2aWNlID0gdGhpcy5maXJlYmFzZV8uSU5URVJOQUwuZmFjdG9yaWVzW25hbWVdKHRoaXMsIHRoaXMuZXh0ZW5kQXBwLmJpbmQodGhpcyksIGluc3RhbmNlU3BlY2lmaWVyKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZXNfW25hbWVdW2luc3RhbmNlSWRlbnRpZmllcl0gPSBzZXJ2aWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2VzX1tuYW1lXVtpbnN0YW5jZUlkZW50aWZpZXJdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdXNlZCB0byBleHRlbmQgYW4gQXBwIGluc3RhbmNlIGF0IHRoZSB0aW1lXG4gICAgICogb2Ygc2VydmljZSBpbnN0YW5jZSBjcmVhdGlvbi5cbiAgICAgKi9cbiAgICBGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlLmV4dGVuZEFwcCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBDb3B5IHRoZSBvYmplY3Qgb250byB0aGUgRmlyZWJhc2VBcHBJbXBsIHByb3RvdHlwZVxuICAgICAgICB1dGlsXzIuZGVlcEV4dGVuZCh0aGlzLCBwcm9wcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgYXBwIGhhcyBvdmVyd3JpdHRlbiB0aGUgYWRkQXV0aFRva2VuTGlzdGVuZXIgc3R1YiwgZm9yd2FyZFxuICAgICAgICAgKiB0aGUgYWN0aXZlIHRva2VuIGxpc3RlbmVycyBvbiB0byB0aGUgdHJ1ZSBmeG4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRPRE86IFRoaXMgZnVuY3Rpb24gaXMgcmVxdWlyZWQgZHVlIHRvIG91ciBjdXJyZW50IG1vZHVsZVxuICAgICAgICAgKiBzdHJ1Y3R1cmUuIE9uY2Ugd2UgYXJlIGFibGUgdG8gcmVseSBzdHJpY3RseSB1cG9uIGEgc2luZ2xlIG1vZHVsZVxuICAgICAgICAgKiBpbXBsZW1lbnRhdGlvbiwgdGhpcyBjb2RlIHNob3VsZCBiZSByZWZhY3RvcmVkIGFuZCBBdXRoIHNob3VsZFxuICAgICAgICAgKiBwcm92aWRlIHRoZXNlIHN0dWJzIGFuZCB0aGUgdXBncmFkZSBsb2dpY1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHByb3BzLklOVEVSTkFMICYmIHByb3BzLklOVEVSTkFMLmFkZEF1dGhUb2tlbkxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0b2tlbkxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIF90aGlzLklOVEVSTkFMLmFkZEF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9rZW5MaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yIGlmIHRoZSBBcHAgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkIC1cbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cbiAgICAgKi9cbiAgICBGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlLmNoZWNrRGVzdHJveWVkXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkXykge1xuICAgICAgICAgICAgZXJyb3IoJ2FwcC1kZWxldGVkJywgeyBuYW1lOiB0aGlzLm5hbWVfIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmlyZWJhc2VBcHBJbXBsO1xufSgpKTtcbi8vIFByZXZlbnQgZGVhZC1jb2RlIGVsaW1pbmF0aW9uIG9mIHRoZXNlIG1ldGhvZHMgdy9vIGludmFsaWQgcHJvcGVydHlcbi8vIGNvcHlpbmcuXG4oRmlyZWJhc2VBcHBJbXBsLnByb3RvdHlwZS5uYW1lICYmIEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUub3B0aW9ucykgfHxcbiAgICBGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlLmRlbGV0ZSB8fFxuICAgIGNvbnNvbGUubG9nKCdkYycpO1xuLyoqXG4gKiBSZXR1cm4gYSBmaXJlYmFzZSBuYW1lc3BhY2Ugb2JqZWN0LlxuICpcbiAqIEluIHByb2R1Y3Rpb24sIHRoaXMgd2lsbCBiZSBjYWxsZWQgZXhhY3RseSBvbmNlIGFuZCB0aGUgcmVzdWx0XG4gKiBhc3NpZ25lZCB0byB0aGUgJ2ZpcmViYXNlJyBnbG9iYWwuICBJdCBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gKiBpbiB1bml0IHRlc3RzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaXJlYmFzZU5hbWVzcGFjZSgpIHtcbiAgICB2YXIgYXBwc18gPSB7fTtcbiAgICB2YXIgZmFjdG9yaWVzID0ge307XG4gICAgdmFyIGFwcEhvb2tzID0ge307XG4gICAgLy8gQSBuYW1lc3BhY2UgaXMgYSBwbGFpbiBKYXZhU2NyaXB0IE9iamVjdC5cbiAgICB2YXIgbmFtZXNwYWNlID0ge1xuICAgICAgICAvLyBIYWNrIHRvIHByZXZlbnQgQmFiZWwgZnJvbSBtb2RpZnlpbmcgdGhlIG9iamVjdCByZXR1cm5lZFxuICAgICAgICAvLyBhcyB0aGUgZmlyZWJhc2UgbmFtZXNwYWNlLlxuICAgICAgICBfX2VzTW9kdWxlOiB0cnVlLFxuICAgICAgICBpbml0aWFsaXplQXBwOiBpbml0aWFsaXplQXBwLFxuICAgICAgICBhcHA6IGFwcCxcbiAgICAgICAgYXBwczogbnVsbCxcbiAgICAgICAgUHJvbWlzZTogUHJvbWlzZSxcbiAgICAgICAgU0RLX1ZFUlNJT046ICc0LjYuMScsXG4gICAgICAgIElOVEVSTkFMOiB7XG4gICAgICAgICAgICByZWdpc3RlclNlcnZpY2U6IHJlZ2lzdGVyU2VydmljZSxcbiAgICAgICAgICAgIGNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlOiBjcmVhdGVGaXJlYmFzZU5hbWVzcGFjZSxcbiAgICAgICAgICAgIGV4dGVuZE5hbWVzcGFjZTogZXh0ZW5kTmFtZXNwYWNlLFxuICAgICAgICAgICAgY3JlYXRlU3Vic2NyaWJlOiB1dGlsXzEuY3JlYXRlU3Vic2NyaWJlLFxuICAgICAgICAgICAgRXJyb3JGYWN0b3J5OiB1dGlsXzIuRXJyb3JGYWN0b3J5LFxuICAgICAgICAgICAgcmVtb3ZlQXBwOiByZW1vdmVBcHAsXG4gICAgICAgICAgICBmYWN0b3JpZXM6IGZhY3RvcmllcyxcbiAgICAgICAgICAgIHVzZUFzU2VydmljZTogdXNlQXNTZXJ2aWNlLFxuICAgICAgICAgICAgUHJvbWlzZTogUHJvbWlzZSxcbiAgICAgICAgICAgIGRlZXBFeHRlbmQ6IHV0aWxfMi5kZWVwRXh0ZW5kXG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEluamVjdCBhIGNpcmN1bGFyIGRlZmF1bHQgZXhwb3J0IHRvIGFsbG93IEJhYmVsIHVzZXJzIHdobyB3ZXJlIHByZXZpb3VzbHlcbiAgICAvLyB1c2luZzpcbiAgICAvL1xuICAgIC8vICAgaW1wb3J0IGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlJztcbiAgICAvLyAgIHdoaWNoIGJlY29tZXM6IHZhciBmaXJlYmFzZSA9IHJlcXVpcmUoJ2ZpcmViYXNlJykuZGVmYXVsdDtcbiAgICAvL1xuICAgIC8vIGluc3RlYWQgb2ZcbiAgICAvL1xuICAgIC8vICAgaW1wb3J0ICogYXMgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UnO1xuICAgIC8vICAgd2hpY2ggYmVjb21lczogdmFyIGZpcmViYXNlID0gcmVxdWlyZSgnZmlyZWJhc2UnKTtcbiAgICB1dGlsXzIucGF0Y2hQcm9wZXJ0eShuYW1lc3BhY2UsICdkZWZhdWx0JywgbmFtZXNwYWNlKTtcbiAgICAvLyBmaXJlYmFzZS5hcHBzIGlzIGEgcmVhZC1vbmx5IGdldHRlci5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmFtZXNwYWNlLCAnYXBwcycsIHtcbiAgICAgICAgZ2V0OiBnZXRBcHBzXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IEFwcC5kZWxldGUoKSAtIGJ1dCBiZWZvcmUgYW55IHNlcnZpY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGUgQXBwXG4gICAgICogYXJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlQXBwKG5hbWUpIHtcbiAgICAgICAgdmFyIGFwcCA9IGFwcHNfW25hbWVdO1xuICAgICAgICBjYWxsQXBwSG9va3MoYXBwLCAnZGVsZXRlJyk7XG4gICAgICAgIGRlbGV0ZSBhcHBzX1tuYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBBcHAgb2JqZWN0IGZvciBhIGdpdmVuIG5hbWUgKG9yIERFRkFVTFQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFwcChuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lIHx8IERFRkFVTFRfRU5UUllfTkFNRTtcbiAgICAgICAgaWYgKCFjb250YWlucyhhcHBzXywgbmFtZSkpIHtcbiAgICAgICAgICAgIGVycm9yKCduby1hcHAnLCB7IG5hbWU6IG5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcHNfW25hbWVdO1xuICAgIH1cbiAgICB1dGlsXzIucGF0Y2hQcm9wZXJ0eShhcHAsICdBcHAnLCBGaXJlYmFzZUFwcEltcGwpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBBcHAgaW5zdGFuY2UgKG5hbWUgbXVzdCBiZSB1bmlxdWUpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVBcHAob3B0aW9ucywgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuYW1lID0gREVGQVVMVF9FTlRSWV9OQU1FO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lID09PSAnJykge1xuICAgICAgICAgICAgICAgIGVycm9yKCdiYWQtYXBwLW5hbWUnLCB7IG5hbWU6IG5hbWUgKyAnJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbnMoYXBwc18sIG5hbWUpKSB7XG4gICAgICAgICAgICBlcnJvcignZHVwbGljYXRlLWFwcCcsIHsgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXBwID0gbmV3IEZpcmViYXNlQXBwSW1wbChvcHRpb25zLCBuYW1lLCBuYW1lc3BhY2UpO1xuICAgICAgICBhcHBzX1tuYW1lXSA9IGFwcDtcbiAgICAgICAgY2FsbEFwcEhvb2tzKGFwcCwgJ2NyZWF0ZScpO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBhbGwgdGhlIG5vbi1kZWxldGVkIEZpcmViYXNlQXBwcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBcHBzKCkge1xuICAgICAgICAvLyBNYWtlIGEgY29weSBzbyBjYWxsZXIgY2Fubm90IG11dGF0ZSB0aGUgYXBwcyBsaXN0LlxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYXBwc18pLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gYXBwc19bbmFtZV07IH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFJlZ2lzdGVyIGEgRmlyZWJhc2UgU2VydmljZS5cbiAgICAgKlxuICAgICAqIGZpcmViYXNlLklOVEVSTkFMLnJlZ2lzdGVyU2VydmljZSgpXG4gICAgICpcbiAgICAgKiBUT0RPOiBJbXBsZW1lbnQgc2VydmljZVByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJTZXJ2aWNlKG5hbWUsIGNyZWF0ZVNlcnZpY2UsIHNlcnZpY2VQcm9wZXJ0aWVzLCBhcHBIb29rLCBhbGxvd011bHRpcGxlSW5zdGFuY2VzKSB7XG4gICAgICAgIC8vIENhbm5vdCByZS1yZWdpc3RlciBhIHNlcnZpY2UgdGhhdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBpZiAoZmFjdG9yaWVzW25hbWVdKSB7XG4gICAgICAgICAgICBlcnJvcignZHVwbGljYXRlLXNlcnZpY2UnLCB7IG5hbWU6IG5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FwdHVyZSB0aGUgc2VydmljZSBmYWN0b3J5IGZvciBsYXRlciBzZXJ2aWNlIGluc3RhbnRpYXRpb25cbiAgICAgICAgZmFjdG9yaWVzW25hbWVdID0gY3JlYXRlU2VydmljZTtcbiAgICAgICAgLy8gQ2FwdHVyZSB0aGUgYXBwSG9vaywgaWYgcGFzc2VkXG4gICAgICAgIGlmIChhcHBIb29rKSB7XG4gICAgICAgICAgICBhcHBIb29rc1tuYW1lXSA9IGFwcEhvb2s7XG4gICAgICAgICAgICAvLyBSdW4gdGhlICoqbmV3KiogYXBwIGhvb2sgb24gYWxsIGV4aXN0aW5nIGFwcHNcbiAgICAgICAgICAgIGdldEFwcHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChhcHApIHtcbiAgICAgICAgICAgICAgICBhcHBIb29rKCdjcmVhdGUnLCBhcHApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIFNlcnZpY2UgbmFtZXNwYWNlIGlzIGFuIGFjY2Vzc29yIGZ1bmN0aW9uIC4uLlxuICAgICAgICB2YXIgc2VydmljZU5hbWVzcGFjZSA9IGZ1bmN0aW9uIChhcHBBcmcpIHtcbiAgICAgICAgICAgIGlmIChhcHBBcmcgPT09IHZvaWQgMCkgeyBhcHBBcmcgPSBhcHAoKTsgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcHBBcmdbbmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGFyZ3VtZW50LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyBpbiB0aGUgZm9sbG93aW5nIGNhc2U6IGZpcmViYXNlLnN0b3JhZ2UoJ2dzOi8nKVxuICAgICAgICAgICAgICAgIGVycm9yKCdpbnZhbGlkLWFwcC1hcmd1bWVudCcsIHsgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvcndhcmQgc2VydmljZSBpbnN0YW5jZSBsb29rdXAgdG8gdGhlIEZpcmViYXNlQXBwLlxuICAgICAgICAgICAgcmV0dXJuIGFwcEFyZ1tuYW1lXSgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyAuLi4gYW5kIGEgY29udGFpbmVyIGZvciBzZXJ2aWNlLWxldmVsIHByb3BlcnRpZXMuXG4gICAgICAgIGlmIChzZXJ2aWNlUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1dGlsXzIuZGVlcEV4dGVuZChzZXJ2aWNlTmFtZXNwYWNlLCBzZXJ2aWNlUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTW9ua2V5LXBhdGNoIHRoZSBzZXJ2aWNlTmFtZXNwYWNlIG9udG8gdGhlIGZpcmViYXNlIG5hbWVzcGFjZVxuICAgICAgICBuYW1lc3BhY2VbbmFtZV0gPSBzZXJ2aWNlTmFtZXNwYWNlO1xuICAgICAgICAvLyBQYXRjaCB0aGUgRmlyZWJhc2VBcHBJbXBsIHByb3RvdHlwZVxuICAgICAgICBGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlcnZpY2VGeG4gPSB0aGlzLl9nZXRTZXJ2aWNlLmJpbmQodGhpcywgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gc2VydmljZUZ4bi5hcHBseSh0aGlzLCBhbGxvd011bHRpcGxlSW5zdGFuY2VzID8gYXJncyA6IFtdKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VOYW1lc3BhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdGNoIHRoZSB0b3AtbGV2ZWwgZmlyZWJhc2UgbmFtZXNwYWNlIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogZmlyZWJhc2UuSU5URVJOQUwuZXh0ZW5kTmFtZXNwYWNlKClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleHRlbmROYW1lc3BhY2UocHJvcHMpIHtcbiAgICAgICAgdXRpbF8yLmRlZXBFeHRlbmQobmFtZXNwYWNlLCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxBcHBIb29rcyhhcHAsIGV2ZW50TmFtZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhmYWN0b3JpZXMpLmZvckVhY2goZnVuY3Rpb24gKHNlcnZpY2VOYW1lKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdmlydHVhbCBzZXJ2aWNlc1xuICAgICAgICAgICAgdmFyIGZhY3RvcnlOYW1lID0gdXNlQXNTZXJ2aWNlKGFwcCwgc2VydmljZU5hbWUpO1xuICAgICAgICAgICAgaWYgKGZhY3RvcnlOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFwcEhvb2tzW2ZhY3RvcnlOYW1lXSkge1xuICAgICAgICAgICAgICAgIGFwcEhvb2tzW2ZhY3RvcnlOYW1lXShldmVudE5hbWUsIGFwcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBNYXAgdGhlIHJlcXVlc3RlZCBzZXJ2aWNlIHRvIGEgcmVnaXN0ZXJlZCBzZXJ2aWNlIG5hbWVcbiAgICAvLyAodXNlZCB0byBtYXAgYXV0aCB0byBzZXJ2ZXJBdXRoIHNlcnZpY2Ugd2hlbiBuZWVkZWQpLlxuICAgIGZ1bmN0aW9uIHVzZUFzU2VydmljZShhcHAsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzZXJ2ZXJBdXRoJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVzZVNlcnZpY2UgPSBuYW1lO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFwcC5vcHRpb25zO1xuICAgICAgICByZXR1cm4gdXNlU2VydmljZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzcGFjZTtcbn1cbmV4cG9ydHMuY3JlYXRlRmlyZWJhc2VOYW1lc3BhY2UgPSBjcmVhdGVGaXJlYmFzZU5hbWVzcGFjZTtcbmZ1bmN0aW9uIGVycm9yKGNvZGUsIGFyZ3MpIHtcbiAgICB0aHJvdyBhcHBFcnJvcnMuY3JlYXRlKGNvZGUsIGFyZ3MpO1xufVxuLy8gVHlwZVNjcmlwdCBkb2VzIG5vdCBzdXBwb3J0IG5vbi1zdHJpbmcgaW5kZXhlcyFcbi8vIGxldCBlcnJvcnM6IHtbY29kZTogQXBwRXJyb3I6IHN0cmluZ30gPSB7XG52YXIgZXJyb3JzID0ge1xuICAgICduby1hcHAnOiBcIk5vIEZpcmViYXNlIEFwcCAneyRuYW1lfScgaGFzIGJlZW4gY3JlYXRlZCAtIFwiICtcbiAgICAgICAgJ2NhbGwgRmlyZWJhc2UgQXBwLmluaXRpYWxpemVBcHAoKScsXG4gICAgJ2JhZC1hcHAtbmFtZSc6IFwiSWxsZWdhbCBBcHAgbmFtZTogJ3skbmFtZX1cIixcbiAgICAnZHVwbGljYXRlLWFwcCc6IFwiRmlyZWJhc2UgQXBwIG5hbWVkICd7JG5hbWV9JyBhbHJlYWR5IGV4aXN0c1wiLFxuICAgICdhcHAtZGVsZXRlZCc6IFwiRmlyZWJhc2UgQXBwIG5hbWVkICd7JG5hbWV9JyBhbHJlYWR5IGRlbGV0ZWRcIixcbiAgICAnZHVwbGljYXRlLXNlcnZpY2UnOiBcIkZpcmViYXNlIHNlcnZpY2UgbmFtZWQgJ3skbmFtZX0nIGFscmVhZHkgcmVnaXN0ZXJlZFwiLFxuICAgICdzYS1ub3Qtc3VwcG9ydGVkJzogJ0luaXRpYWxpemluZyB0aGUgRmlyZWJhc2UgU0RLIHdpdGggYSBzZXJ2aWNlICcgK1xuICAgICAgICAnYWNjb3VudCBpcyBvbmx5IGFsbG93ZWQgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50LiBPbiBjbGllbnQgJyArXG4gICAgICAgICdkZXZpY2VzLCB5b3Ugc2hvdWxkIGluc3RlYWQgaW5pdGlhbGl6ZSB0aGUgU0RLIHdpdGggYW4gYXBpIGtleSBhbmQgJyArXG4gICAgICAgICdhdXRoIGRvbWFpbicsXG4gICAgJ2ludmFsaWQtYXBwLWFyZ3VtZW50JzogJ2ZpcmViYXNlLnskbmFtZX0oKSB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnQgb3IgYSAnICtcbiAgICAgICAgJ0ZpcmViYXNlIEFwcCBpbnN0YW5jZS4nXG59O1xudmFyIGFwcEVycm9ycyA9IG5ldyB1dGlsXzIuRXJyb3JGYWN0b3J5KCdhcHAnLCAnRmlyZWJhc2UnLCBlcnJvcnMpO1xuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcmViYXNlQXBwLmpzLm1hcFxuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgZmlyZWJhc2UgPSByZXF1aXJlKCdAZmlyZWJhc2UvYXBwJykuZGVmYXVsdDtcbiAgdmFyIGgsYWE9YWF8fHt9LGs9dGhpcztmdW5jdGlvbiBtKGEpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhfWZ1bmN0aW9uIGJhKGEpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgYX1mdW5jdGlvbiBjYSgpe31cbmZ1bmN0aW9uIGRhKGEpe3ZhciBiPXR5cGVvZiBhO2lmKFwib2JqZWN0XCI9PWIpaWYoYSl7aWYoYSBpbnN0YW5jZW9mIEFycmF5KXJldHVyblwiYXJyYXlcIjtpZihhIGluc3RhbmNlb2YgT2JqZWN0KXJldHVybiBiO3ZhciBjPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKTtpZihcIltvYmplY3QgV2luZG93XVwiPT1jKXJldHVyblwib2JqZWN0XCI7aWYoXCJbb2JqZWN0IEFycmF5XVwiPT1jfHxcIm51bWJlclwiPT10eXBlb2YgYS5sZW5ndGgmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnNwbGljZSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUmJiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwic3BsaWNlXCIpKXJldHVyblwiYXJyYXlcIjtpZihcIltvYmplY3QgRnVuY3Rpb25dXCI9PWN8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLmNhbGwmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcImNhbGxcIikpcmV0dXJuXCJmdW5jdGlvblwifWVsc2UgcmV0dXJuXCJudWxsXCI7XG5lbHNlIGlmKFwiZnVuY3Rpb25cIj09YiYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIGEuY2FsbClyZXR1cm5cIm9iamVjdFwiO3JldHVybiBifWZ1bmN0aW9uIGVhKGEpe3JldHVybiBudWxsPT09YX1mdW5jdGlvbiBmYShhKXtyZXR1cm5cImFycmF5XCI9PWRhKGEpfWZ1bmN0aW9uIGhhKGEpe3ZhciBiPWRhKGEpO3JldHVyblwiYXJyYXlcIj09Ynx8XCJvYmplY3RcIj09YiYmXCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RofWZ1bmN0aW9uIHAoYSl7cmV0dXJuXCJmdW5jdGlvblwiPT1kYShhKX1mdW5jdGlvbiBxKGEpe3ZhciBiPXR5cGVvZiBhO3JldHVyblwib2JqZWN0XCI9PWImJm51bGwhPWF8fFwiZnVuY3Rpb25cIj09Yn12YXIgaWE9XCJjbG9zdXJlX3VpZF9cIisoMUU5Kk1hdGgucmFuZG9tKCk+Pj4wKSxqYT0wO2Z1bmN0aW9uIGthKGEsYixjKXtyZXR1cm4gYS5jYWxsLmFwcGx5KGEuYmluZCxhcmd1bWVudHMpfVxuZnVuY3Rpb24gbGEoYSxiLGMpe2lmKCFhKXRocm93IEVycm9yKCk7aWYoMjxhcmd1bWVudHMubGVuZ3RoKXt2YXIgZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjLGQpO3JldHVybiBhLmFwcGx5KGIsYyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGIsYXJndW1lbnRzKX19ZnVuY3Rpb24gcihhLGIsYyl7RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQmJi0xIT1GdW5jdGlvbi5wcm90b3R5cGUuYmluZC50b1N0cmluZygpLmluZGV4T2YoXCJuYXRpdmUgY29kZVwiKT9yPWthOnI9bGE7cmV0dXJuIHIuYXBwbHkobnVsbCxhcmd1bWVudHMpfVxuZnVuY3Rpb24gbWEoYSxiKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGI9Yy5zbGljZSgpO2IucHVzaC5hcHBseShiLGFyZ3VtZW50cyk7cmV0dXJuIGEuYXBwbHkodGhpcyxiKX19dmFyIG5hPURhdGUubm93fHxmdW5jdGlvbigpe3JldHVybituZXcgRGF0ZX07ZnVuY3Rpb24gdChhLGIpe2Z1bmN0aW9uIGMoKXt9Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGU7YS5pYj1iLnByb3RvdHlwZTthLnByb3RvdHlwZT1uZXcgYzthLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hO2EuTmM9ZnVuY3Rpb24oYSxjLGYpe2Zvcih2YXIgZD1BcnJheShhcmd1bWVudHMubGVuZ3RoLTIpLGU9MjtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKWRbZS0yXT1hcmd1bWVudHNbZV07cmV0dXJuIGIucHJvdG90eXBlW2NdLmFwcGx5KGEsZCl9fTtmdW5jdGlvbiB1KGEpe2lmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKUVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsdSk7ZWxzZXt2YXIgYj1FcnJvcigpLnN0YWNrO2ImJih0aGlzLnN0YWNrPWIpfWEmJih0aGlzLm1lc3NhZ2U9U3RyaW5nKGEpKX10KHUsRXJyb3IpO3UucHJvdG90eXBlLm5hbWU9XCJDdXN0b21FcnJvclwiO2Z1bmN0aW9uIG9hKGEsYil7Zm9yKHZhciBjPWEuc3BsaXQoXCIlc1wiKSxkPVwiXCIsZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7ZS5sZW5ndGgmJjE8Yy5sZW5ndGg7KWQrPWMuc2hpZnQoKStlLnNoaWZ0KCk7cmV0dXJuIGQrYy5qb2luKFwiJXNcIil9dmFyIHBhPVN0cmluZy5wcm90b3R5cGUudHJpbT9mdW5jdGlvbihhKXtyZXR1cm4gYS50cmltKCl9OmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UoL15bXFxzXFx4YTBdK3xbXFxzXFx4YTBdKyQvZyxcIlwiKX07XG5mdW5jdGlvbiBxYShhKXtpZighcmEudGVzdChhKSlyZXR1cm4gYTstMSE9YS5pbmRleE9mKFwiJlwiKSYmKGE9YS5yZXBsYWNlKHNhLFwiJmFtcDtcIikpOy0xIT1hLmluZGV4T2YoXCI8XCIpJiYoYT1hLnJlcGxhY2UodGEsXCImbHQ7XCIpKTstMSE9YS5pbmRleE9mKFwiPlwiKSYmKGE9YS5yZXBsYWNlKHVhLFwiJmd0O1wiKSk7LTEhPWEuaW5kZXhPZignXCInKSYmKGE9YS5yZXBsYWNlKHZhLFwiJnF1b3Q7XCIpKTstMSE9YS5pbmRleE9mKFwiJ1wiKSYmKGE9YS5yZXBsYWNlKHdhLFwiJiMzOTtcIikpOy0xIT1hLmluZGV4T2YoXCJcXHgwMFwiKSYmKGE9YS5yZXBsYWNlKHhhLFwiJiMwO1wiKSk7cmV0dXJuIGF9dmFyIHNhPS8mL2csdGE9LzwvZyx1YT0vPi9nLHZhPS9cIi9nLHdhPS8nL2cseGE9L1xceDAwL2cscmE9L1tcXHgwMCY8PlwiJ10vO2Z1bmN0aW9uIHYoYSxiKXtyZXR1cm4tMSE9YS5pbmRleE9mKGIpfWZ1bmN0aW9uIHlhKGEsYil7cmV0dXJuIGE8Yj8tMTphPmI/MTowfTtmdW5jdGlvbiB6YShhLGIpe2IudW5zaGlmdChhKTt1LmNhbGwodGhpcyxvYS5hcHBseShudWxsLGIpKTtiLnNoaWZ0KCl9dCh6YSx1KTt6YS5wcm90b3R5cGUubmFtZT1cIkFzc2VydGlvbkVycm9yXCI7ZnVuY3Rpb24gQWEoYSxiKXt0aHJvdyBuZXcgemEoXCJGYWlsdXJlXCIrKGE/XCI6IFwiK2E6XCJcIiksQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKTt9O3ZhciBCYT1BcnJheS5wcm90b3R5cGUuaW5kZXhPZj9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Yz1udWxsPT1jPzA6MD5jP01hdGgubWF4KDAsYS5sZW5ndGgrYyk6YztpZihtKGEpKXJldHVybiBtKGIpJiYxPT1iLmxlbmd0aD9hLmluZGV4T2YoYixjKTotMTtmb3IoO2M8YS5sZW5ndGg7YysrKWlmKGMgaW4gYSYmYVtjXT09PWIpcmV0dXJuIGM7cmV0dXJuLTF9LHc9QXJyYXkucHJvdG90eXBlLmZvckVhY2g/ZnVuY3Rpb24oYSxiLGMpe0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9bShhKT9hLnNwbGl0KFwiXCIpOmEsZj0wO2Y8ZDtmKyspZiBpbiBlJiZiLmNhbGwoYyxlW2ZdLGYsYSl9O1xuZnVuY3Rpb24gQ2EoYSxiKXt2YXIgYz1hLmxlbmd0aCxkPW0oYSk/YS5zcGxpdChcIlwiKTphO2ZvcigtLWM7MDw9YzstLWMpYyBpbiBkJiZiLmNhbGwodm9pZCAwLGRbY10sYyxhKX12YXIgRGE9QXJyYXkucHJvdG90eXBlLm1hcD9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1BcnJheShkKSxmPW0oYSk/YS5zcGxpdChcIlwiKTphLGc9MDtnPGQ7ZysrKWcgaW4gZiYmKGVbZ109Yi5jYWxsKGMsZltnXSxnLGEpKTtyZXR1cm4gZX0sRWE9QXJyYXkucHJvdG90eXBlLnNvbWU/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPW0oYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWlmKGYgaW4gZSYmYi5jYWxsKGMsZVtmXSxmLGEpKXJldHVybiEwO3JldHVybiExfTtcbmZ1bmN0aW9uIEZhKGEpe2E6e3ZhciBiPUdhO2Zvcih2YXIgYz1hLmxlbmd0aCxkPW0oYSk/YS5zcGxpdChcIlwiKTphLGU9MDtlPGM7ZSsrKWlmKGUgaW4gZCYmYi5jYWxsKHZvaWQgMCxkW2VdLGUsYSkpe2I9ZTticmVhayBhfWI9LTF9cmV0dXJuIDA+Yj9udWxsOm0oYSk/YS5jaGFyQXQoYik6YVtiXX1mdW5jdGlvbiBIYShhLGIpe3JldHVybiAwPD1CYShhLGIpfWZ1bmN0aW9uIElhKGEsYil7Yj1CYShhLGIpO3ZhciBjOyhjPTA8PWIpJiZBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYSxiLDEpO3JldHVybiBjfWZ1bmN0aW9uIEphKGEsYil7dmFyIGM9MDtDYShhLGZ1bmN0aW9uKGQsZSl7Yi5jYWxsKHZvaWQgMCxkLGUsYSkmJjE9PUFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhLGUsMSkubGVuZ3RoJiZjKyt9KX1mdW5jdGlvbiBLYShhKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSxhcmd1bWVudHMpfVxuZnVuY3Rpb24gTGEoYSl7dmFyIGI9YS5sZW5ndGg7aWYoMDxiKXtmb3IodmFyIGM9QXJyYXkoYiksZD0wO2Q8YjtkKyspY1tkXT1hW2RdO3JldHVybiBjfXJldHVybltdfTt2YXIgTWE7YTp7dmFyIE5hPWsubmF2aWdhdG9yO2lmKE5hKXt2YXIgT2E9TmEudXNlckFnZW50O2lmKE9hKXtNYT1PYTticmVhayBhfX1NYT1cIlwifWZ1bmN0aW9uIHgoYSl7cmV0dXJuIHYoTWEsYSl9O2Z1bmN0aW9uIFBhKGEsYil7Zm9yKHZhciBjIGluIGEpYi5jYWxsKHZvaWQgMCxhW2NdLGMsYSl9ZnVuY3Rpb24gUWEoYSl7dmFyIGI9W10sYz0wLGQ7Zm9yKGQgaW4gYSliW2MrK109YVtkXTtyZXR1cm4gYn1mdW5jdGlvbiBSYShhKXt2YXIgYj1bXSxjPTAsZDtmb3IoZCBpbiBhKWJbYysrXT1kO3JldHVybiBifWZ1bmN0aW9uIFNhKGEpe2Zvcih2YXIgYiBpbiBhKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIFRhKGEsYil7Zm9yKHZhciBjIGluIGEpaWYoIShjIGluIGIpfHxhW2NdIT09YltjXSlyZXR1cm4hMTtmb3IoYyBpbiBiKWlmKCEoYyBpbiBhKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBVYShhKXt2YXIgYj17fSxjO2ZvcihjIGluIGEpYltjXT1hW2NdO3JldHVybiBifXZhciBWYT1cImNvbnN0cnVjdG9yIGhhc093blByb3BlcnR5IGlzUHJvdG90eXBlT2YgcHJvcGVydHlJc0VudW1lcmFibGUgdG9Mb2NhbGVTdHJpbmcgdG9TdHJpbmcgdmFsdWVPZlwiLnNwbGl0KFwiIFwiKTtcbmZ1bmN0aW9uIFdhKGEsYil7Zm9yKHZhciBjLGQsZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe2Q9YXJndW1lbnRzW2VdO2ZvcihjIGluIGQpYVtjXT1kW2NdO2Zvcih2YXIgZj0wO2Y8VmEubGVuZ3RoO2YrKyljPVZhW2ZdLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkLGMpJiYoYVtjXT1kW2NdKX19O2Z1bmN0aW9uIFhhKGEpe1hhW1wiIFwiXShhKTtyZXR1cm4gYX1YYVtcIiBcIl09Y2E7ZnVuY3Rpb24gWWEoYSxiKXt2YXIgYz1aYTtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGMsYSk/Y1thXTpjW2FdPWIoYSl9O3ZhciAkYT14KFwiT3BlcmFcIikseT14KFwiVHJpZGVudFwiKXx8eChcIk1TSUVcIiksYWI9eChcIkVkZ2VcIiksYmI9YWJ8fHksY2I9eChcIkdlY2tvXCIpJiYhKHYoTWEudG9Mb3dlckNhc2UoKSxcIndlYmtpdFwiKSYmIXgoXCJFZGdlXCIpKSYmISh4KFwiVHJpZGVudFwiKXx8eChcIk1TSUVcIikpJiYheChcIkVkZ2VcIiksZGI9dihNYS50b0xvd2VyQ2FzZSgpLFwid2Via2l0XCIpJiYheChcIkVkZ2VcIik7ZnVuY3Rpb24gZWIoKXt2YXIgYT1rLmRvY3VtZW50O3JldHVybiBhP2EuZG9jdW1lbnRNb2RlOnZvaWQgMH12YXIgZmI7XG5hOnt2YXIgZ2I9XCJcIixoYj1mdW5jdGlvbigpe3ZhciBhPU1hO2lmKGNiKXJldHVybi9ydlxcOihbXlxcKTtdKykoXFwpfDspLy5leGVjKGEpO2lmKGFiKXJldHVybi9FZGdlXFwvKFtcXGRcXC5dKykvLmV4ZWMoYSk7aWYoeSlyZXR1cm4vXFxiKD86TVNJRXxydilbOiBdKFteXFwpO10rKShcXCl8OykvLmV4ZWMoYSk7aWYoZGIpcmV0dXJuL1dlYktpdFxcLyhcXFMrKS8uZXhlYyhhKTtpZigkYSlyZXR1cm4vKD86VmVyc2lvbilbIFxcL10/KFxcUyspLy5leGVjKGEpfSgpO2hiJiYoZ2I9aGI/aGJbMV06XCJcIik7aWYoeSl7dmFyIGliPWViKCk7aWYobnVsbCE9aWImJmliPnBhcnNlRmxvYXQoZ2IpKXtmYj1TdHJpbmcoaWIpO2JyZWFrIGF9fWZiPWdifXZhciBaYT17fTtcbmZ1bmN0aW9uIGpiKGEpe3JldHVybiBZYShhLGZ1bmN0aW9uKCl7Zm9yKHZhciBiPTAsYz1wYShTdHJpbmcoZmIpKS5zcGxpdChcIi5cIiksZD1wYShTdHJpbmcoYSkpLnNwbGl0KFwiLlwiKSxlPU1hdGgubWF4KGMubGVuZ3RoLGQubGVuZ3RoKSxmPTA7MD09YiYmZjxlO2YrKyl7dmFyIGc9Y1tmXXx8XCJcIixsPWRbZl18fFwiXCI7ZG97Zz0vKFxcZCopKFxcRCopKC4qKS8uZXhlYyhnKXx8W1wiXCIsXCJcIixcIlwiLFwiXCJdO2w9LyhcXGQqKShcXEQqKSguKikvLmV4ZWMobCl8fFtcIlwiLFwiXCIsXCJcIixcIlwiXTtpZigwPT1nWzBdLmxlbmd0aCYmMD09bFswXS5sZW5ndGgpYnJlYWs7Yj15YSgwPT1nWzFdLmxlbmd0aD8wOnBhcnNlSW50KGdbMV0sMTApLDA9PWxbMV0ubGVuZ3RoPzA6cGFyc2VJbnQobFsxXSwxMCkpfHx5YSgwPT1nWzJdLmxlbmd0aCwwPT1sWzJdLmxlbmd0aCl8fHlhKGdbMl0sbFsyXSk7Zz1nWzNdO2w9bFszXX13aGlsZSgwPT1iKX1yZXR1cm4gMDw9Yn0pfXZhciBrYjt2YXIgbGI9ay5kb2N1bWVudDtcbmtiPWxiJiZ5P2ViKCl8fChcIkNTUzFDb21wYXRcIj09bGIuY29tcGF0TW9kZT9wYXJzZUludChmYiwxMCk6NSk6dm9pZCAwO2Z1bmN0aW9uIG1iKGEpe2EucHJvdG90eXBlLnRoZW49YS5wcm90b3R5cGUudGhlbjthLnByb3RvdHlwZS4kZ29vZ19UaGVuYWJsZT0hMH1mdW5jdGlvbiBuYihhKXtpZighYSlyZXR1cm4hMTt0cnl7cmV0dXJuISFhLiRnb29nX1RoZW5hYmxlfWNhdGNoKGIpe3JldHVybiExfX07ZnVuY3Rpb24gb2IoYSxiLGMpe3RoaXMuZj1jO3RoaXMuYz1hO3RoaXMuZz1iO3RoaXMuYj0wO3RoaXMuYT1udWxsfW9iLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXtpZigwPHRoaXMuYil7dGhpcy5iLS07dmFyIGE9dGhpcy5hO3RoaXMuYT1hLm5leHQ7YS5uZXh0PW51bGx9ZWxzZSBhPXRoaXMuYygpO3JldHVybiBhfTtmdW5jdGlvbiBwYihhLGIpe2EuZyhiKTthLmI8YS5mJiYoYS5iKyssYi5uZXh0PWEuYSxhLmE9Yil9O3ZhciByYj1uZXcgb2IoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHFifSxmdW5jdGlvbihhKXthLnJlc2V0KCl9LDEwMCk7ZnVuY3Rpb24gc2IoKXt2YXIgYT10YixiPW51bGw7YS5hJiYoYj1hLmEsYS5hPWEuYS5uZXh0LGEuYXx8KGEuYj1udWxsKSxiLm5leHQ9bnVsbCk7cmV0dXJuIGJ9ZnVuY3Rpb24gcWIoKXt0aGlzLm5leHQ9dGhpcy5iPXRoaXMuYT1udWxsfXFiLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXt0aGlzLmE9YTt0aGlzLmI9Yjt0aGlzLm5leHQ9bnVsbH07cWIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5uZXh0PXRoaXMuYj10aGlzLmE9bnVsbH07ZnVuY3Rpb24gdWIoYSl7ay5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgYTt9LDApfXZhciB3YjtcbmZ1bmN0aW9uIHhiKCl7dmFyIGE9ay5NZXNzYWdlQ2hhbm5lbDtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cucG9zdE1lc3NhZ2UmJndpbmRvdy5hZGRFdmVudExpc3RlbmVyJiYheChcIlByZXN0b1wiKSYmKGE9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiSUZSQU1FXCIpO2Euc3R5bGUuZGlzcGxheT1cIm5vbmVcIjthLnNyYz1cIlwiO2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChhKTt2YXIgYj1hLmNvbnRlbnRXaW5kb3c7YT1iLmRvY3VtZW50O2Eub3BlbigpO2Eud3JpdGUoXCJcIik7YS5jbG9zZSgpO3ZhciBjPVwiY2FsbEltbWVkaWF0ZVwiK01hdGgucmFuZG9tKCksZD1cImZpbGU6XCI9PWIubG9jYXRpb24ucHJvdG9jb2w/XCIqXCI6Yi5sb2NhdGlvbi5wcm90b2NvbCtcIi8vXCIrYi5sb2NhdGlvbi5ob3N0O2E9cihmdW5jdGlvbihhKXtpZigoXCIqXCI9PWR8fGEub3JpZ2luPT1kKSYmYS5kYXRhPT1cbmMpdGhpcy5wb3J0MS5vbm1lc3NhZ2UoKX0sdGhpcyk7Yi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGEsITEpO3RoaXMucG9ydDE9e307dGhpcy5wb3J0Mj17cG9zdE1lc3NhZ2U6ZnVuY3Rpb24oKXtiLnBvc3RNZXNzYWdlKGMsZCl9fX0pO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYSYmIXgoXCJUcmlkZW50XCIpJiYheChcIk1TSUVcIikpe3ZhciBiPW5ldyBhLGM9e30sZD1jO2IucG9ydDEub25tZXNzYWdlPWZ1bmN0aW9uKCl7aWYodm9pZCAwIT09Yy5uZXh0KXtjPWMubmV4dDt2YXIgYT1jLnBiO2MucGI9bnVsbDthKCl9fTtyZXR1cm4gZnVuY3Rpb24oYSl7ZC5uZXh0PXtwYjphfTtkPWQubmV4dDtiLnBvcnQyLnBvc3RNZXNzYWdlKDApfX1yZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50JiZcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIlNDUklQVFwiKT9mdW5jdGlvbihhKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiU0NSSVBUXCIpO1xuYi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtiLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTtiPW51bGw7YSgpO2E9bnVsbH07ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGIpfTpmdW5jdGlvbihhKXtrLnNldFRpbWVvdXQoYSwwKX19O2Z1bmN0aW9uIHliKGEsYil7emJ8fEFiKCk7QmJ8fCh6YigpLEJiPSEwKTt2YXIgYz10YixkPXJiLmdldCgpO2Quc2V0KGEsYik7Yy5iP2MuYi5uZXh0PWQ6Yy5hPWQ7Yy5iPWR9dmFyIHpiO2Z1bmN0aW9uIEFiKCl7aWYoLTEhPVN0cmluZyhrLlByb21pc2UpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpKXt2YXIgYT1rLlByb21pc2UucmVzb2x2ZSh2b2lkIDApO3piPWZ1bmN0aW9uKCl7YS50aGVuKENiKX19ZWxzZSB6Yj1mdW5jdGlvbigpe3ZhciBhPUNiOyFwKGsuc2V0SW1tZWRpYXRlKXx8ay5XaW5kb3cmJmsuV2luZG93LnByb3RvdHlwZSYmIXgoXCJFZGdlXCIpJiZrLldpbmRvdy5wcm90b3R5cGUuc2V0SW1tZWRpYXRlPT1rLnNldEltbWVkaWF0ZT8od2J8fCh3Yj14YigpKSx3YihhKSk6ay5zZXRJbW1lZGlhdGUoYSl9fXZhciBCYj0hMSx0Yj1uZXcgZnVuY3Rpb24oKXt0aGlzLmI9dGhpcy5hPW51bGx9O1xuZnVuY3Rpb24gQ2IoKXtmb3IodmFyIGE7YT1zYigpOyl7dHJ5e2EuYS5jYWxsKGEuYil9Y2F0Y2goYil7dWIoYil9cGIocmIsYSl9QmI9ITF9O2Z1bmN0aW9uIHooYSxiKXt0aGlzLmE9RGI7dGhpcy5pPXZvaWQgMDt0aGlzLmY9dGhpcy5iPXRoaXMuYz1udWxsO3RoaXMuZz10aGlzLmg9ITE7aWYoYSE9Y2EpdHJ5e3ZhciBjPXRoaXM7YS5jYWxsKGIsZnVuY3Rpb24oYSl7RWIoYyxGYixhKX0sZnVuY3Rpb24oYSl7aWYoIShhIGluc3RhbmNlb2YgR2IpKXRyeXtpZihhIGluc3RhbmNlb2YgRXJyb3IpdGhyb3cgYTt0aHJvdyBFcnJvcihcIlByb21pc2UgcmVqZWN0ZWQuXCIpO31jYXRjaChlKXt9RWIoYyxIYixhKX0pfWNhdGNoKGQpe0ViKHRoaXMsSGIsZCl9fXZhciBEYj0wLEZiPTIsSGI9MztmdW5jdGlvbiBJYigpe3RoaXMubmV4dD10aGlzLmY9dGhpcy5iPXRoaXMuZz10aGlzLmE9bnVsbDt0aGlzLmM9ITF9SWIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5mPXRoaXMuYj10aGlzLmc9dGhpcy5hPW51bGw7dGhpcy5jPSExfTtcbnZhciBKYj1uZXcgb2IoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IElifSxmdW5jdGlvbihhKXthLnJlc2V0KCl9LDEwMCk7ZnVuY3Rpb24gS2IoYSxiLGMpe3ZhciBkPUpiLmdldCgpO2QuZz1hO2QuYj1iO2QuZj1jO3JldHVybiBkfWZ1bmN0aW9uIEEoYSl7aWYoYSBpbnN0YW5jZW9mIHopcmV0dXJuIGE7dmFyIGI9bmV3IHooY2EpO0ViKGIsRmIsYSk7cmV0dXJuIGJ9ZnVuY3Rpb24gQihhKXtyZXR1cm4gbmV3IHooZnVuY3Rpb24oYixjKXtjKGEpfSl9ZnVuY3Rpb24gTGIoYSxiLGMpe01iKGEsYixjLG51bGwpfHx5YihtYShiLGEpKX1mdW5jdGlvbiBOYihhKXtyZXR1cm4gbmV3IHooZnVuY3Rpb24oYixjKXt2YXIgZD1hLmxlbmd0aCxlPVtdO2lmKGQpZm9yKHZhciBmPWZ1bmN0aW9uKGEsYyl7ZC0tO2VbYV09YzswPT1kJiZiKGUpfSxnPWZ1bmN0aW9uKGEpe2MoYSl9LGw9MCxuO2w8YS5sZW5ndGg7bCsrKW49YVtsXSxMYihuLG1hKGYsbCksZyk7ZWxzZSBiKGUpfSl9XG5mdW5jdGlvbiBPYihhKXtyZXR1cm4gbmV3IHooZnVuY3Rpb24oYil7dmFyIGM9YS5sZW5ndGgsZD1bXTtpZihjKWZvcih2YXIgZT1mdW5jdGlvbihhLGUsZil7Yy0tO2RbYV09ZT97UWI6ITAsdmFsdWU6Zn06e1FiOiExLHJlYXNvbjpmfTswPT1jJiZiKGQpfSxmPTAsZztmPGEubGVuZ3RoO2YrKylnPWFbZl0sTGIoZyxtYShlLGYsITApLG1hKGUsZiwhMSkpO2Vsc2UgYihkKX0pfXoucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBQYih0aGlzLHAoYSk/YTpudWxsLHAoYik/YjpudWxsLGMpfTttYih6KTtmdW5jdGlvbiBRYihhLGIpe2I9S2IoYixiLHZvaWQgMCk7Yi5jPSEwO1JiKGEsYik7cmV0dXJuIGF9aD16LnByb3RvdHlwZTtoLnM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUGIodGhpcyxudWxsLGEsYil9O2guY2FuY2VsPWZ1bmN0aW9uKGEpe3RoaXMuYT09RGImJnliKGZ1bmN0aW9uKCl7dmFyIGI9bmV3IEdiKGEpO1NiKHRoaXMsYil9LHRoaXMpfTtcbmZ1bmN0aW9uIFNiKGEsYil7aWYoYS5hPT1EYilpZihhLmMpe3ZhciBjPWEuYztpZihjLmIpe2Zvcih2YXIgZD0wLGU9bnVsbCxmPW51bGwsZz1jLmI7ZyYmKGcuY3x8KGQrKyxnLmE9PWEmJihlPWcpLCEoZSYmMTxkKSkpO2c9Zy5uZXh0KWV8fChmPWcpO2UmJihjLmE9PURiJiYxPT1kP1NiKGMsYik6KGY/KGQ9ZixkLm5leHQ9PWMuZiYmKGMuZj1kKSxkLm5leHQ9ZC5uZXh0Lm5leHQpOlRiKGMpLFViKGMsZSxIYixiKSkpfWEuYz1udWxsfWVsc2UgRWIoYSxIYixiKX1mdW5jdGlvbiBSYihhLGIpe2EuYnx8YS5hIT1GYiYmYS5hIT1IYnx8VmIoYSk7YS5mP2EuZi5uZXh0PWI6YS5iPWI7YS5mPWJ9XG5mdW5jdGlvbiBQYihhLGIsYyxkKXt2YXIgZT1LYihudWxsLG51bGwsbnVsbCk7ZS5hPW5ldyB6KGZ1bmN0aW9uKGEsZyl7ZS5nPWI/ZnVuY3Rpb24oYyl7dHJ5e3ZhciBlPWIuY2FsbChkLGMpO2EoZSl9Y2F0Y2goRCl7ZyhEKX19OmE7ZS5iPWM/ZnVuY3Rpb24oYil7dHJ5e3ZhciBlPWMuY2FsbChkLGIpO3ZvaWQgMD09PWUmJmIgaW5zdGFuY2VvZiBHYj9nKGIpOmEoZSl9Y2F0Y2goRCl7ZyhEKX19Omd9KTtlLmEuYz1hO1JiKGEsZSk7cmV0dXJuIGUuYX1oLndjPWZ1bmN0aW9uKGEpe3RoaXMuYT1EYjtFYih0aGlzLEZiLGEpfTtoLnhjPWZ1bmN0aW9uKGEpe3RoaXMuYT1EYjtFYih0aGlzLEhiLGEpfTtcbmZ1bmN0aW9uIEViKGEsYixjKXthLmE9PURiJiYoYT09PWMmJihiPUhiLGM9bmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2Fubm90IHJlc29sdmUgdG8gaXRzZWxmXCIpKSxhLmE9MSxNYihjLGEud2MsYS54YyxhKXx8KGEuaT1jLGEuYT1iLGEuYz1udWxsLFZiKGEpLGIhPUhifHxjIGluc3RhbmNlb2YgR2J8fFdiKGEsYykpKX1mdW5jdGlvbiBNYihhLGIsYyxkKXtpZihhIGluc3RhbmNlb2YgeilyZXR1cm4gUmIoYSxLYihifHxjYSxjfHxudWxsLGQpKSwhMDtpZihuYihhKSlyZXR1cm4gYS50aGVuKGIsYyxkKSwhMDtpZihxKGEpKXRyeXt2YXIgZT1hLnRoZW47aWYocChlKSlyZXR1cm4gWGIoYSxlLGIsYyxkKSwhMH1jYXRjaChmKXtyZXR1cm4gYy5jYWxsKGQsZiksITB9cmV0dXJuITF9XG5mdW5jdGlvbiBYYihhLGIsYyxkLGUpe2Z1bmN0aW9uIGYoYSl7bHx8KGw9ITAsZC5jYWxsKGUsYSkpfWZ1bmN0aW9uIGcoYSl7bHx8KGw9ITAsYy5jYWxsKGUsYSkpfXZhciBsPSExO3RyeXtiLmNhbGwoYSxnLGYpfWNhdGNoKG4pe2Yobil9fWZ1bmN0aW9uIFZiKGEpe2EuaHx8KGEuaD0hMCx5YihhLk1iLGEpKX1mdW5jdGlvbiBUYihhKXt2YXIgYj1udWxsO2EuYiYmKGI9YS5iLGEuYj1iLm5leHQsYi5uZXh0PW51bGwpO2EuYnx8KGEuZj1udWxsKTtyZXR1cm4gYn1oLk1iPWZ1bmN0aW9uKCl7Zm9yKHZhciBhO2E9VGIodGhpcyk7KVViKHRoaXMsYSx0aGlzLmEsdGhpcy5pKTt0aGlzLmg9ITF9O1xuZnVuY3Rpb24gVWIoYSxiLGMsZCl7aWYoYz09SGImJmIuYiYmIWIuYylmb3IoO2EmJmEuZzthPWEuYylhLmc9ITE7aWYoYi5hKWIuYS5jPW51bGwsWWIoYixjLGQpO2Vsc2UgdHJ5e2IuYz9iLmcuY2FsbChiLmYpOlliKGIsYyxkKX1jYXRjaChlKXtaYi5jYWxsKG51bGwsZSl9cGIoSmIsYil9ZnVuY3Rpb24gWWIoYSxiLGMpe2I9PUZiP2EuZy5jYWxsKGEuZixjKTphLmImJmEuYi5jYWxsKGEuZixjKX1mdW5jdGlvbiBXYihhLGIpe2EuZz0hMDt5YihmdW5jdGlvbigpe2EuZyYmWmIuY2FsbChudWxsLGIpfSl9dmFyIFpiPXViO2Z1bmN0aW9uIEdiKGEpe3UuY2FsbCh0aGlzLGEpfXQoR2IsdSk7R2IucHJvdG90eXBlLm5hbWU9XCJjYW5jZWxcIjt2YXIgJGI9IXl8fDk8PU51bWJlcihrYik7ZnVuY3Rpb24gYWMoKXt0aGlzLmE9XCJcIjt0aGlzLmI9YmN9YWMucHJvdG90eXBlLmxhPSEwO2FjLnByb3RvdHlwZS5qYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmF9O2FjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiQ29uc3R7XCIrdGhpcy5hK1wifVwifTtmdW5jdGlvbiBjYyhhKXtpZihhIGluc3RhbmNlb2YgYWMmJmEuY29uc3RydWN0b3I9PT1hYyYmYS5iPT09YmMpcmV0dXJuIGEuYTtBYShcImV4cGVjdGVkIG9iamVjdCBvZiB0eXBlIENvbnN0LCBnb3QgJ1wiK2ErXCInXCIpO3JldHVyblwidHlwZV9lcnJvcjpDb25zdFwifXZhciBiYz17fTtmdW5jdGlvbiBkYyhhKXt2YXIgYj1uZXcgYWM7Yi5hPWE7cmV0dXJuIGJ9ZGMoXCJcIik7ZnVuY3Rpb24gZWMoKXt0aGlzLmE9XCJcIjt0aGlzLmI9ZmN9ZWMucHJvdG90eXBlLmxhPSEwO2VjLnByb3RvdHlwZS5qYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmF9O2VjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiVHJ1c3RlZFJlc291cmNlVXJse1wiK3RoaXMuYStcIn1cIn07ZnVuY3Rpb24gZ2MoYSl7aWYoYSBpbnN0YW5jZW9mIGVjJiZhLmNvbnN0cnVjdG9yPT09ZWMmJmEuYj09PWZjKXJldHVybiBhLmE7QWEoXCJleHBlY3RlZCBvYmplY3Qgb2YgdHlwZSBUcnVzdGVkUmVzb3VyY2VVcmwsIGdvdCAnXCIrYStcIicgb2YgdHlwZSBcIitkYShhKSk7cmV0dXJuXCJ0eXBlX2Vycm9yOlRydXN0ZWRSZXNvdXJjZVVybFwifWZ1bmN0aW9uIGhjKGEsYil7YT1pYyhhLGIpO2I9bmV3IGVjO2IuYT1hO3JldHVybiBifVxuZnVuY3Rpb24gaWMoYSxiKXt2YXIgYz1jYyhhKTtpZighamMudGVzdChjKSl0aHJvdyBFcnJvcihcIkludmFsaWQgVHJ1c3RlZFJlc291cmNlVXJsIGZvcm1hdDogXCIrYyk7cmV0dXJuIGMucmVwbGFjZShrYyxmdW5jdGlvbihhLGUpe2lmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYixlKSl0aHJvdyBFcnJvcignRm91bmQgbWFya2VyLCBcIicrZSsnXCIsIGluIGZvcm1hdCBzdHJpbmcsIFwiJytjKydcIiwgYnV0IG5vIHZhbGlkIGxhYmVsIG1hcHBpbmcgZm91bmQgaW4gYXJnczogJytKU09OLnN0cmluZ2lmeShiKSk7YT1iW2VdO3JldHVybiBhIGluc3RhbmNlb2YgYWM/Y2MoYSk6ZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhKSl9KX12YXIga2M9LyV7KFxcdyspfS9nLGpjPS9eKD86aHR0cHM6KT9cXC9cXC9bMC05YS16LjpbXFxdLV0rXFwvfF5cXC9bXlxcL1xcXFxdfF5hYm91dDpibGFuaygjfCQpL2ksZmM9e307ZnVuY3Rpb24gbGMoKXt0aGlzLmE9XCJcIjt0aGlzLmI9bWN9bGMucHJvdG90eXBlLmxhPSEwO2xjLnByb3RvdHlwZS5qYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmF9O2xjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiU2FmZVVybHtcIit0aGlzLmErXCJ9XCJ9O2Z1bmN0aW9uIG5jKGEpe2lmKGEgaW5zdGFuY2VvZiBsYyYmYS5jb25zdHJ1Y3Rvcj09PWxjJiZhLmI9PT1tYylyZXR1cm4gYS5hO0FhKFwiZXhwZWN0ZWQgb2JqZWN0IG9mIHR5cGUgU2FmZVVybCwgZ290ICdcIithK1wiJyBvZiB0eXBlIFwiK2RhKGEpKTtyZXR1cm5cInR5cGVfZXJyb3I6U2FmZVVybFwifXZhciBvYz0vXig/Oig/Omh0dHBzP3xtYWlsdG98ZnRwKTp8W146Lz8jXSooPzpbLz8jXXwkKSkvaTtcbmZ1bmN0aW9uIHBjKGEpe2lmKGEgaW5zdGFuY2VvZiBsYylyZXR1cm4gYTthPWEubGE/YS5qYSgpOlN0cmluZyhhKTtvYy50ZXN0KGEpfHwoYT1cImFib3V0OmludmFsaWQjekNsb3N1cmV6XCIpO3JldHVybiBxYyhhKX12YXIgbWM9e307ZnVuY3Rpb24gcWMoYSl7dmFyIGI9bmV3IGxjO2IuYT1hO3JldHVybiBifXFjKFwiYWJvdXQ6YmxhbmtcIik7ZnVuY3Rpb24gcmMoKXt0aGlzLmE9XCJcIjt0aGlzLmI9c2N9cmMucHJvdG90eXBlLmxhPSEwO3JjLnByb3RvdHlwZS5qYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmF9O3JjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiU2FmZUh0bWx7XCIrdGhpcy5hK1wifVwifTtmdW5jdGlvbiB1YyhhKXtpZihhIGluc3RhbmNlb2YgcmMmJmEuY29uc3RydWN0b3I9PT1yYyYmYS5iPT09c2MpcmV0dXJuIGEuYTtBYShcImV4cGVjdGVkIG9iamVjdCBvZiB0eXBlIFNhZmVIdG1sLCBnb3QgJ1wiK2ErXCInIG9mIHR5cGUgXCIrZGEoYSkpO3JldHVyblwidHlwZV9lcnJvcjpTYWZlSHRtbFwifXZhciBzYz17fTtmdW5jdGlvbiB2YyhhKXt2YXIgYj1uZXcgcmM7Yi5hPWE7cmV0dXJuIGJ9dmMoXCI8IURPQ1RZUEUgaHRtbD5cIik7dmMoXCJcIik7dmMoXCI8YnI+XCIpO2Z1bmN0aW9uIHdjKGEpe3ZhciBiPWRvY3VtZW50O3JldHVybiBtKGEpP2IuZ2V0RWxlbWVudEJ5SWQoYSk6YX1mdW5jdGlvbiB4YyhhLGIpe1BhKGIsZnVuY3Rpb24oYixkKXtiJiZiLmxhJiYoYj1iLmphKCkpO1wic3R5bGVcIj09ZD9hLnN0eWxlLmNzc1RleHQ9YjpcImNsYXNzXCI9PWQ/YS5jbGFzc05hbWU9YjpcImZvclwiPT1kP2EuaHRtbEZvcj1iOnljLmhhc093blByb3BlcnR5KGQpP2Euc2V0QXR0cmlidXRlKHljW2RdLGIpOjA9PWQubGFzdEluZGV4T2YoXCJhcmlhLVwiLDApfHwwPT1kLmxhc3RJbmRleE9mKFwiZGF0YS1cIiwwKT9hLnNldEF0dHJpYnV0ZShkLGIpOmFbZF09Yn0pfVxudmFyIHljPXtjZWxscGFkZGluZzpcImNlbGxQYWRkaW5nXCIsY2VsbHNwYWNpbmc6XCJjZWxsU3BhY2luZ1wiLGNvbHNwYW46XCJjb2xTcGFuXCIsZnJhbWVib3JkZXI6XCJmcmFtZUJvcmRlclwiLGhlaWdodDpcImhlaWdodFwiLG1heGxlbmd0aDpcIm1heExlbmd0aFwiLG5vbmNlOlwibm9uY2VcIixyb2xlOlwicm9sZVwiLHJvd3NwYW46XCJyb3dTcGFuXCIsdHlwZTpcInR5cGVcIix1c2VtYXA6XCJ1c2VNYXBcIix2YWxpZ246XCJ2QWxpZ25cIix3aWR0aDpcIndpZHRoXCJ9O1xuZnVuY3Rpb24gemMoYSxiLGMpe3ZhciBkPWFyZ3VtZW50cyxlPWRvY3VtZW50LGY9U3RyaW5nKGRbMF0pLGc9ZFsxXTtpZighJGImJmcmJihnLm5hbWV8fGcudHlwZSkpe2Y9W1wiPFwiLGZdO2cubmFtZSYmZi5wdXNoKCcgbmFtZT1cIicscWEoZy5uYW1lKSwnXCInKTtpZihnLnR5cGUpe2YucHVzaCgnIHR5cGU9XCInLHFhKGcudHlwZSksJ1wiJyk7dmFyIGw9e307V2EobCxnKTtkZWxldGUgbC50eXBlO2c9bH1mLnB1c2goXCI+XCIpO2Y9Zi5qb2luKFwiXCIpfWY9ZS5jcmVhdGVFbGVtZW50KGYpO2cmJihtKGcpP2YuY2xhc3NOYW1lPWc6ZmEoZyk/Zi5jbGFzc05hbWU9Zy5qb2luKFwiIFwiKTp4YyhmLGcpKTsyPGQubGVuZ3RoJiZBYyhlLGYsZCk7cmV0dXJuIGZ9XG5mdW5jdGlvbiBBYyhhLGIsYyl7ZnVuY3Rpb24gZChjKXtjJiZiLmFwcGVuZENoaWxkKG0oYyk/YS5jcmVhdGVUZXh0Tm9kZShjKTpjKX1mb3IodmFyIGU9MjtlPGMubGVuZ3RoO2UrKyl7dmFyIGY9Y1tlXTshaGEoZil8fHEoZikmJjA8Zi5ub2RlVHlwZT9kKGYpOncoQmMoZik/TGEoZik6ZixkKX19ZnVuY3Rpb24gQmMoYSl7aWYoYSYmXCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RoKXtpZihxKGEpKXJldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGEuaXRlbXx8XCJzdHJpbmdcIj09dHlwZW9mIGEuaXRlbTtpZihwKGEpKXJldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGEuaXRlbX1yZXR1cm4hMX07ZnVuY3Rpb24gQ2MoYSl7dmFyIGI9W107RGMobmV3IEVjLGEsYik7cmV0dXJuIGIuam9pbihcIlwiKX1mdW5jdGlvbiBFYygpe31cbmZ1bmN0aW9uIERjKGEsYixjKXtpZihudWxsPT1iKWMucHVzaChcIm51bGxcIik7ZWxzZXtpZihcIm9iamVjdFwiPT10eXBlb2YgYil7aWYoZmEoYikpe3ZhciBkPWI7Yj1kLmxlbmd0aDtjLnB1c2goXCJbXCIpO2Zvcih2YXIgZT1cIlwiLGY9MDtmPGI7ZisrKWMucHVzaChlKSxEYyhhLGRbZl0sYyksZT1cIixcIjtjLnB1c2goXCJdXCIpO3JldHVybn1pZihiIGluc3RhbmNlb2YgU3RyaW5nfHxiIGluc3RhbmNlb2YgTnVtYmVyfHxiIGluc3RhbmNlb2YgQm9vbGVhbiliPWIudmFsdWVPZigpO2Vsc2V7Yy5wdXNoKFwie1wiKTtlPVwiXCI7Zm9yKGQgaW4gYilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYixkKSYmKGY9YltkXSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmJiYoYy5wdXNoKGUpLEZjKGQsYyksYy5wdXNoKFwiOlwiKSxEYyhhLGYsYyksZT1cIixcIikpO2MucHVzaChcIn1cIik7cmV0dXJufX1zd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJzdHJpbmdcIjpGYyhiLGMpO2JyZWFrO2Nhc2UgXCJudW1iZXJcIjpjLnB1c2goaXNGaW5pdGUoYikmJlxuIWlzTmFOKGIpP1N0cmluZyhiKTpcIm51bGxcIik7YnJlYWs7Y2FzZSBcImJvb2xlYW5cIjpjLnB1c2goU3RyaW5nKGIpKTticmVhaztjYXNlIFwiZnVuY3Rpb25cIjpjLnB1c2goXCJudWxsXCIpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiK3R5cGVvZiBiKTt9fX12YXIgR2M9eydcIic6J1xcXFxcIicsXCJcXFxcXCI6XCJcXFxcXFxcXFwiLFwiL1wiOlwiXFxcXC9cIixcIlxcYlwiOlwiXFxcXGJcIixcIlxcZlwiOlwiXFxcXGZcIixcIlxcblwiOlwiXFxcXG5cIixcIlxcclwiOlwiXFxcXHJcIixcIlxcdFwiOlwiXFxcXHRcIixcIlxceDBCXCI6XCJcXFxcdTAwMGJcIn0sSGM9L1xcdWZmZmYvLnRlc3QoXCJcXHVmZmZmXCIpPy9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxcdWZmZmZdL2c6L1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4ZmZdL2c7XG5mdW5jdGlvbiBGYyhhLGIpe2IucHVzaCgnXCInLGEucmVwbGFjZShIYyxmdW5jdGlvbihhKXt2YXIgYj1HY1thXTtifHwoYj1cIlxcXFx1XCIrKGEuY2hhckNvZGVBdCgwKXw2NTUzNikudG9TdHJpbmcoMTYpLnN1YnN0cigxKSxHY1thXT1iKTtyZXR1cm4gYn0pLCdcIicpfTtmdW5jdGlvbiBJYygpezAhPUpjJiYoS2NbdGhpc1tpYV18fCh0aGlzW2lhXT0rK2phKV09dGhpcyk7dGhpcy5vYT10aGlzLm9hO3RoaXMuRmE9dGhpcy5GYX12YXIgSmM9MCxLYz17fTtJYy5wcm90b3R5cGUub2E9ITE7ZnVuY3Rpb24gTGMoYSl7YS5vYXx8KGEub2E9ITAsYS50YSgpLDAhPUpjJiYoYT1hW2lhXXx8KGFbaWFdPSsramEpLGRlbGV0ZSBLY1thXSkpfUljLnByb3RvdHlwZS50YT1mdW5jdGlvbigpe2lmKHRoaXMuRmEpZm9yKDt0aGlzLkZhLmxlbmd0aDspdGhpcy5GYS5zaGlmdCgpKCl9O3ZhciBNYz1PYmplY3QuZnJlZXplfHxmdW5jdGlvbihhKXtyZXR1cm4gYX07dmFyIE5jPSF5fHw5PD1OdW1iZXIoa2IpLE9jPXkmJiFqYihcIjlcIiksUGM9ZnVuY3Rpb24oKXtpZighay5hZGRFdmVudExpc3RlbmVyfHwhT2JqZWN0LmRlZmluZVByb3BlcnR5KXJldHVybiExO3ZhciBhPSExLGI9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LFwicGFzc2l2ZVwiLHtnZXQ6ZnVuY3Rpb24oKXthPSEwfX0pO2suYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIixjYSxiKTtrLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsY2EsYik7cmV0dXJuIGF9KCk7ZnVuY3Rpb24gQyhhLGIpe3RoaXMudHlwZT1hO3RoaXMuYj10aGlzLnRhcmdldD1iO3RoaXMuQWI9ITB9Qy5wcm90b3R5cGUuYz1mdW5jdGlvbigpe3RoaXMuQWI9ITF9O2Z1bmN0aW9uIFFjKGEsYil7Qy5jYWxsKHRoaXMsYT9hLnR5cGU6XCJcIik7dGhpcy5yZWxhdGVkVGFyZ2V0PXRoaXMuYj10aGlzLnRhcmdldD1udWxsO3RoaXMuYnV0dG9uPXRoaXMuc2NyZWVuWT10aGlzLnNjcmVlblg9dGhpcy5jbGllbnRZPXRoaXMuY2xpZW50WD0wO3RoaXMua2V5PVwiXCI7dGhpcy5tZXRhS2V5PXRoaXMuc2hpZnRLZXk9dGhpcy5hbHRLZXk9dGhpcy5jdHJsS2V5PSExO3RoaXMucG9pbnRlcklkPTA7dGhpcy5wb2ludGVyVHlwZT1cIlwiO3RoaXMuYT1udWxsO2lmKGEpe3ZhciBjPXRoaXMudHlwZT1hLnR5cGUsZD1hLmNoYW5nZWRUb3VjaGVzP2EuY2hhbmdlZFRvdWNoZXNbMF06bnVsbDt0aGlzLnRhcmdldD1hLnRhcmdldHx8YS5zcmNFbGVtZW50O3RoaXMuYj1iO2lmKGI9YS5yZWxhdGVkVGFyZ2V0KXtpZihjYil7YTp7dHJ5e1hhKGIubm9kZU5hbWUpO3ZhciBlPSEwO2JyZWFrIGF9Y2F0Y2goZil7fWU9ITF9ZXx8KGI9bnVsbCl9fWVsc2VcIm1vdXNlb3ZlclwiPT1jP2I9XG5hLmZyb21FbGVtZW50OlwibW91c2VvdXRcIj09YyYmKGI9YS50b0VsZW1lbnQpO3RoaXMucmVsYXRlZFRhcmdldD1iO251bGw9PT1kPyh0aGlzLmNsaWVudFg9dm9pZCAwIT09YS5jbGllbnRYP2EuY2xpZW50WDphLnBhZ2VYLHRoaXMuY2xpZW50WT12b2lkIDAhPT1hLmNsaWVudFk/YS5jbGllbnRZOmEucGFnZVksdGhpcy5zY3JlZW5YPWEuc2NyZWVuWHx8MCx0aGlzLnNjcmVlblk9YS5zY3JlZW5ZfHwwKToodGhpcy5jbGllbnRYPXZvaWQgMCE9PWQuY2xpZW50WD9kLmNsaWVudFg6ZC5wYWdlWCx0aGlzLmNsaWVudFk9dm9pZCAwIT09ZC5jbGllbnRZP2QuY2xpZW50WTpkLnBhZ2VZLHRoaXMuc2NyZWVuWD1kLnNjcmVlblh8fDAsdGhpcy5zY3JlZW5ZPWQuc2NyZWVuWXx8MCk7dGhpcy5idXR0b249YS5idXR0b247dGhpcy5rZXk9YS5rZXl8fFwiXCI7dGhpcy5jdHJsS2V5PWEuY3RybEtleTt0aGlzLmFsdEtleT1hLmFsdEtleTt0aGlzLnNoaWZ0S2V5PWEuc2hpZnRLZXk7dGhpcy5tZXRhS2V5PVxuYS5tZXRhS2V5O3RoaXMucG9pbnRlcklkPWEucG9pbnRlcklkfHwwO3RoaXMucG9pbnRlclR5cGU9bShhLnBvaW50ZXJUeXBlKT9hLnBvaW50ZXJUeXBlOlJjW2EucG9pbnRlclR5cGVdfHxcIlwiO3RoaXMuYT1hO2EuZGVmYXVsdFByZXZlbnRlZCYmdGhpcy5jKCl9fXQoUWMsQyk7dmFyIFJjPU1jKHsyOlwidG91Y2hcIiwzOlwicGVuXCIsNDpcIm1vdXNlXCJ9KTtRYy5wcm90b3R5cGUuYz1mdW5jdGlvbigpe1FjLmliLmMuY2FsbCh0aGlzKTt2YXIgYT10aGlzLmE7aWYoYS5wcmV2ZW50RGVmYXVsdClhLnByZXZlbnREZWZhdWx0KCk7ZWxzZSBpZihhLnJldHVyblZhbHVlPSExLE9jKXRyeXtpZihhLmN0cmxLZXl8fDExMjw9YS5rZXlDb2RlJiYxMjM+PWEua2V5Q29kZSlhLmtleUNvZGU9LTF9Y2F0Y2goYil7fX07UWMucHJvdG90eXBlLmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hfTt2YXIgU2M9XCJjbG9zdXJlX2xpc3RlbmFibGVfXCIrKDFFNipNYXRoLnJhbmRvbSgpfDApLFRjPTA7ZnVuY3Rpb24gVWMoYSxiLGMsZCxlKXt0aGlzLmxpc3RlbmVyPWE7dGhpcy5hPW51bGw7dGhpcy5zcmM9Yjt0aGlzLnR5cGU9Yzt0aGlzLmNhcHR1cmU9ISFkO3RoaXMuTGE9ZTt0aGlzLmtleT0rK1RjO3RoaXMubWE9dGhpcy5IYT0hMX1mdW5jdGlvbiBWYyhhKXthLm1hPSEwO2EubGlzdGVuZXI9bnVsbDthLmE9bnVsbDthLnNyYz1udWxsO2EuTGE9bnVsbH07ZnVuY3Rpb24gV2MoYSl7dGhpcy5zcmM9YTt0aGlzLmE9e307dGhpcy5iPTB9ZnVuY3Rpb24gWGMoYSxiLGMsZCxlLGYpe3ZhciBnPWIudG9TdHJpbmcoKTtiPWEuYVtnXTtifHwoYj1hLmFbZ109W10sYS5iKyspO3ZhciBsPVljKGIsYyxlLGYpOy0xPGw/KGE9YltsXSxkfHwoYS5IYT0hMSkpOihhPW5ldyBVYyhjLGEuc3JjLGcsISFlLGYpLGEuSGE9ZCxiLnB1c2goYSkpO3JldHVybiBhfWZ1bmN0aW9uIFpjKGEsYil7dmFyIGM9Yi50eXBlO2MgaW4gYS5hJiZJYShhLmFbY10sYikmJihWYyhiKSwwPT1hLmFbY10ubGVuZ3RoJiYoZGVsZXRlIGEuYVtjXSxhLmItLSkpfWZ1bmN0aW9uIFljKGEsYixjLGQpe2Zvcih2YXIgZT0wO2U8YS5sZW5ndGg7KytlKXt2YXIgZj1hW2VdO2lmKCFmLm1hJiZmLmxpc3RlbmVyPT1iJiZmLmNhcHR1cmU9PSEhYyYmZi5MYT09ZClyZXR1cm4gZX1yZXR1cm4tMX07dmFyICRjPVwiY2xvc3VyZV9sbV9cIisoMUU2Kk1hdGgucmFuZG9tKCl8MCksYWQ9e30sYmQ9MDtmdW5jdGlvbiBjZChhLGIsYyxkLGUpe2lmKGQmJmQub25jZSlkZChhLGIsYyxkLGUpO2Vsc2UgaWYoZmEoYikpZm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKyspY2QoYSxiW2ZdLGMsZCxlKTtlbHNlIGM9ZWQoYyksYSYmYVtTY10/ZmQoYSxiLGMscShkKT8hIWQuY2FwdHVyZTohIWQsZSk6Z2QoYSxiLGMsITEsZCxlKX1cbmZ1bmN0aW9uIGdkKGEsYixjLGQsZSxmKXtpZighYil0aHJvdyBFcnJvcihcIkludmFsaWQgZXZlbnQgdHlwZVwiKTt2YXIgZz1xKGUpPyEhZS5jYXB0dXJlOiEhZSxsPWhkKGEpO2x8fChhWyRjXT1sPW5ldyBXYyhhKSk7Yz1YYyhsLGIsYyxkLGcsZik7aWYoIWMuYSl7ZD1pZCgpO2MuYT1kO2Quc3JjPWE7ZC5saXN0ZW5lcj1jO2lmKGEuYWRkRXZlbnRMaXN0ZW5lcilQY3x8KGU9Zyksdm9pZCAwPT09ZSYmKGU9ITEpLGEuYWRkRXZlbnRMaXN0ZW5lcihiLnRvU3RyaW5nKCksZCxlKTtlbHNlIGlmKGEuYXR0YWNoRXZlbnQpYS5hdHRhY2hFdmVudChqZChiLnRvU3RyaW5nKCkpLGQpO2Vsc2UgdGhyb3cgRXJyb3IoXCJhZGRFdmVudExpc3RlbmVyIGFuZCBhdHRhY2hFdmVudCBhcmUgdW5hdmFpbGFibGUuXCIpO2JkKyt9fVxuZnVuY3Rpb24gaWQoKXt2YXIgYT1rZCxiPU5jP2Z1bmN0aW9uKGMpe3JldHVybiBhLmNhbGwoYi5zcmMsYi5saXN0ZW5lcixjKX06ZnVuY3Rpb24oYyl7Yz1hLmNhbGwoYi5zcmMsYi5saXN0ZW5lcixjKTtpZighYylyZXR1cm4gY307cmV0dXJuIGJ9ZnVuY3Rpb24gZGQoYSxiLGMsZCxlKXtpZihmYShiKSlmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrKylkZChhLGJbZl0sYyxkLGUpO2Vsc2UgYz1lZChjKSxhJiZhW1NjXT9sZChhLGIsYyxxKGQpPyEhZC5jYXB0dXJlOiEhZCxlKTpnZChhLGIsYywhMCxkLGUpfVxuZnVuY3Rpb24gRShhLGIsYyxkLGUpe2lmKGZhKGIpKWZvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7ZisrKUUoYSxiW2ZdLGMsZCxlKTtlbHNlKGQ9cShkKT8hIWQuY2FwdHVyZTohIWQsYz1lZChjKSxhJiZhW1NjXSk/KGE9YS51LGI9U3RyaW5nKGIpLnRvU3RyaW5nKCksYiBpbiBhLmEmJihmPWEuYVtiXSxjPVljKGYsYyxkLGUpLC0xPGMmJihWYyhmW2NdKSxBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoZixjLDEpLDA9PWYubGVuZ3RoJiYoZGVsZXRlIGEuYVtiXSxhLmItLSkpKSk6YSYmKGE9aGQoYSkpJiYoYj1hLmFbYi50b1N0cmluZygpXSxhPS0xLGImJihhPVljKGIsYyxkLGUpKSwoYz0tMTxhP2JbYV06bnVsbCkmJm1kKGMpKX1cbmZ1bmN0aW9uIG1kKGEpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBhJiZhJiYhYS5tYSl7dmFyIGI9YS5zcmM7aWYoYiYmYltTY10pWmMoYi51LGEpO2Vsc2V7dmFyIGM9YS50eXBlLGQ9YS5hO2IucmVtb3ZlRXZlbnRMaXN0ZW5lcj9iLnJlbW92ZUV2ZW50TGlzdGVuZXIoYyxkLGEuY2FwdHVyZSk6Yi5kZXRhY2hFdmVudCYmYi5kZXRhY2hFdmVudChqZChjKSxkKTtiZC0tOyhjPWhkKGIpKT8oWmMoYyxhKSwwPT1jLmImJihjLnNyYz1udWxsLGJbJGNdPW51bGwpKTpWYyhhKX19fWZ1bmN0aW9uIGpkKGEpe3JldHVybiBhIGluIGFkP2FkW2FdOmFkW2FdPVwib25cIithfWZ1bmN0aW9uIG5kKGEsYixjLGQpe3ZhciBlPSEwO2lmKGE9aGQoYSkpaWYoYj1hLmFbYi50b1N0cmluZygpXSlmb3IoYj1iLmNvbmNhdCgpLGE9MDthPGIubGVuZ3RoO2ErKyl7dmFyIGY9YlthXTtmJiZmLmNhcHR1cmU9PWMmJiFmLm1hJiYoZj1vZChmLGQpLGU9ZSYmITEhPT1mKX1yZXR1cm4gZX1cbmZ1bmN0aW9uIG9kKGEsYil7dmFyIGM9YS5saXN0ZW5lcixkPWEuTGF8fGEuc3JjO2EuSGEmJm1kKGEpO3JldHVybiBjLmNhbGwoZCxiKX1cbmZ1bmN0aW9uIGtkKGEsYil7aWYoYS5tYSlyZXR1cm4hMDtpZighTmMpe2lmKCFiKWE6e2I9W1wid2luZG93XCIsXCJldmVudFwiXTtmb3IodmFyIGM9ayxkPTA7ZDxiLmxlbmd0aDtkKyspaWYoYz1jW2JbZF1dLG51bGw9PWMpe2I9bnVsbDticmVhayBhfWI9Y31kPWI7Yj1uZXcgUWMoZCx0aGlzKTtjPSEwO2lmKCEoMD5kLmtleUNvZGV8fHZvaWQgMCE9ZC5yZXR1cm5WYWx1ZSkpe2E6e3ZhciBlPSExO2lmKDA9PWQua2V5Q29kZSl0cnl7ZC5rZXlDb2RlPS0xO2JyZWFrIGF9Y2F0Y2goZyl7ZT0hMH1pZihlfHx2b2lkIDA9PWQucmV0dXJuVmFsdWUpZC5yZXR1cm5WYWx1ZT0hMH1kPVtdO2ZvcihlPWIuYjtlO2U9ZS5wYXJlbnROb2RlKWQucHVzaChlKTthPWEudHlwZTtmb3IoZT1kLmxlbmd0aC0xOzA8PWU7ZS0tKXtiLmI9ZFtlXTt2YXIgZj1uZChkW2VdLGEsITAsYik7Yz1jJiZmfWZvcihlPTA7ZTxkLmxlbmd0aDtlKyspYi5iPWRbZV0sZj1uZChkW2VdLGEsITEsYiksYz1jJiZmfXJldHVybiBjfXJldHVybiBvZChhLFxubmV3IFFjKGIsdGhpcykpfWZ1bmN0aW9uIGhkKGEpe2E9YVskY107cmV0dXJuIGEgaW5zdGFuY2VvZiBXYz9hOm51bGx9dmFyIHBkPVwiX19jbG9zdXJlX2V2ZW50c19mbl9cIisoMUU5Kk1hdGgucmFuZG9tKCk+Pj4wKTtmdW5jdGlvbiBlZChhKXtpZihwKGEpKXJldHVybiBhO2FbcGRdfHwoYVtwZF09ZnVuY3Rpb24oYil7cmV0dXJuIGEuaGFuZGxlRXZlbnQoYil9KTtyZXR1cm4gYVtwZF19O2Z1bmN0aW9uIEYoKXtJYy5jYWxsKHRoaXMpO3RoaXMudT1uZXcgV2ModGhpcyk7dGhpcy5FYj10aGlzO3RoaXMuUmE9bnVsbH10KEYsSWMpO0YucHJvdG90eXBlW1NjXT0hMDtGLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGEsYixjLGQpe0UodGhpcyxhLGIsYyxkKX07XG5mdW5jdGlvbiBHKGEsYil7dmFyIGMsZD1hLlJhO2lmKGQpZm9yKGM9W107ZDtkPWQuUmEpYy5wdXNoKGQpO2E9YS5FYjtkPWIudHlwZXx8YjtpZihtKGIpKWI9bmV3IEMoYixhKTtlbHNlIGlmKGIgaW5zdGFuY2VvZiBDKWIudGFyZ2V0PWIudGFyZ2V0fHxhO2Vsc2V7dmFyIGU9YjtiPW5ldyBDKGQsYSk7V2EoYixlKX1lPSEwO2lmKGMpZm9yKHZhciBmPWMubGVuZ3RoLTE7MDw9ZjtmLS0pe3ZhciBnPWIuYj1jW2ZdO2U9cWQoZyxkLCEwLGIpJiZlfWc9Yi5iPWE7ZT1xZChnLGQsITAsYikmJmU7ZT1xZChnLGQsITEsYikmJmU7aWYoYylmb3IoZj0wO2Y8Yy5sZW5ndGg7ZisrKWc9Yi5iPWNbZl0sZT1xZChnLGQsITEsYikmJmV9XG5GLnByb3RvdHlwZS50YT1mdW5jdGlvbigpe0YuaWIudGEuY2FsbCh0aGlzKTtpZih0aGlzLnUpe3ZhciBhPXRoaXMudSxiPTAsYztmb3IoYyBpbiBhLmEpe2Zvcih2YXIgZD1hLmFbY10sZT0wO2U8ZC5sZW5ndGg7ZSsrKSsrYixWYyhkW2VdKTtkZWxldGUgYS5hW2NdO2EuYi0tfX10aGlzLlJhPW51bGx9O2Z1bmN0aW9uIGZkKGEsYixjLGQsZSl7WGMoYS51LFN0cmluZyhiKSxjLCExLGQsZSl9ZnVuY3Rpb24gbGQoYSxiLGMsZCxlKXtYYyhhLnUsU3RyaW5nKGIpLGMsITAsZCxlKX1mdW5jdGlvbiBxZChhLGIsYyxkKXtiPWEudS5hW1N0cmluZyhiKV07aWYoIWIpcmV0dXJuITA7Yj1iLmNvbmNhdCgpO2Zvcih2YXIgZT0hMCxmPTA7ZjxiLmxlbmd0aDsrK2Ype3ZhciBnPWJbZl07aWYoZyYmIWcubWEmJmcuY2FwdHVyZT09Yyl7dmFyIGw9Zy5saXN0ZW5lcixuPWcuTGF8fGcuc3JjO2cuSGEmJlpjKGEudSxnKTtlPSExIT09bC5jYWxsKG4sZCkmJmV9fXJldHVybiBlJiYwIT1kLkFifTtmdW5jdGlvbiByZChhLGIsYyl7aWYocChhKSljJiYoYT1yKGEsYykpO2Vsc2UgaWYoYSYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5oYW5kbGVFdmVudClhPXIoYS5oYW5kbGVFdmVudCxhKTtlbHNlIHRocm93IEVycm9yKFwiSW52YWxpZCBsaXN0ZW5lciBhcmd1bWVudFwiKTtyZXR1cm4gMjE0NzQ4MzY0NzxOdW1iZXIoYik/LTE6ay5zZXRUaW1lb3V0KGEsYnx8MCl9ZnVuY3Rpb24gc2QoYSl7dmFyIGI9bnVsbDtyZXR1cm4obmV3IHooZnVuY3Rpb24oYyxkKXtiPXJkKGZ1bmN0aW9uKCl7Yyh2b2lkIDApfSxhKTstMT09YiYmZChFcnJvcihcIkZhaWxlZCB0byBzY2hlZHVsZSB0aW1lci5cIikpfSkpLnMoZnVuY3Rpb24oYSl7ay5jbGVhclRpbWVvdXQoYik7dGhyb3cgYTt9KX07ZnVuY3Rpb24gdGQoYSxiLGMsZCxlKXt0aGlzLnJlc2V0KGEsYixjLGQsZSl9dGQucHJvdG90eXBlLmE9bnVsbDt2YXIgdWQ9MDt0ZC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXtcIm51bWJlclwiPT10eXBlb2YgZXx8dWQrKztkfHxuYSgpO3RoaXMuYj1iO2RlbGV0ZSB0aGlzLmF9O2Z1bmN0aW9uIHZkKGEpe3RoaXMuZj1hO3RoaXMuYj10aGlzLmM9dGhpcy5hPW51bGx9ZnVuY3Rpb24gd2QoYSxiKXt0aGlzLm5hbWU9YTt0aGlzLnZhbHVlPWJ9d2QucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZX07dmFyIHhkPW5ldyB3ZChcIlNFVkVSRVwiLDFFMykseWQ9bmV3IHdkKFwiQ09ORklHXCIsNzAwKSx6ZD1uZXcgd2QoXCJGSU5FXCIsNTAwKTtmdW5jdGlvbiBBZChhKXtpZihhLmMpcmV0dXJuIGEuYztpZihhLmEpcmV0dXJuIEFkKGEuYSk7QWEoXCJSb290IGxvZ2dlciBoYXMgbm8gbGV2ZWwgc2V0LlwiKTtyZXR1cm4gbnVsbH1cbnZkLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oYSxiLGMpe2lmKGEudmFsdWU+PUFkKHRoaXMpLnZhbHVlKWZvcihwKGIpJiYoYj1iKCkpLGE9bmV3IHRkKGEsU3RyaW5nKGIpLHRoaXMuZiksYyYmKGEuYT1jKSxjPVwibG9nOlwiK2EuYiwoYT1rLmNvbnNvbGUpJiZhLnRpbWVTdGFtcCYmYS50aW1lU3RhbXAoYyksKGE9ay5tc1dyaXRlUHJvZmlsZXJNYXJrKSYmYShjKSxjPXRoaXM7YzspYz1jLmF9O3ZhciBCZD17fSxDZD1udWxsO2Z1bmN0aW9uIERkKGEpe0NkfHwoQ2Q9bmV3IHZkKFwiXCIpLEJkW1wiXCJdPUNkLENkLmM9eWQpO3ZhciBiO2lmKCEoYj1CZFthXSkpe2I9bmV3IHZkKGEpO3ZhciBjPWEubGFzdEluZGV4T2YoXCIuXCIpLGQ9YS5zdWJzdHIoYysxKTtjPURkKGEuc3Vic3RyKDAsYykpO2MuYnx8KGMuYj17fSk7Yy5iW2RdPWI7Yi5hPWM7QmRbYV09Yn1yZXR1cm4gYn07ZnVuY3Rpb24gRWQoYSxiKXt0aGlzLmI9e307dGhpcy5hPVtdO3RoaXMuYz0wO3ZhciBjPWFyZ3VtZW50cy5sZW5ndGg7aWYoMTxjKXtpZihjJTIpdGhyb3cgRXJyb3IoXCJVbmV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50c1wiKTtmb3IodmFyIGQ9MDtkPGM7ZCs9Mil0aGlzLnNldChhcmd1bWVudHNbZF0sYXJndW1lbnRzW2QrMV0pfWVsc2UgaWYoYSl7YSBpbnN0YW5jZW9mIEVkPyhjPWEuUygpLGQ9YS5QKCkpOihjPVJhKGEpLGQ9UWEoYSkpO2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKXRoaXMuc2V0KGNbZV0sZFtlXSl9fWg9RWQucHJvdG90eXBlO2guUD1mdW5jdGlvbigpe0ZkKHRoaXMpO2Zvcih2YXIgYT1bXSxiPTA7Yjx0aGlzLmEubGVuZ3RoO2IrKylhLnB1c2godGhpcy5iW3RoaXMuYVtiXV0pO3JldHVybiBhfTtoLlM9ZnVuY3Rpb24oKXtGZCh0aGlzKTtyZXR1cm4gdGhpcy5hLmNvbmNhdCgpfTtcbmguY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmI9e307dGhpcy5jPXRoaXMuYS5sZW5ndGg9MH07ZnVuY3Rpb24gRmQoYSl7aWYoYS5jIT1hLmEubGVuZ3RoKXtmb3IodmFyIGI9MCxjPTA7YjxhLmEubGVuZ3RoOyl7dmFyIGQ9YS5hW2JdO0dkKGEuYixkKSYmKGEuYVtjKytdPWQpO2IrK31hLmEubGVuZ3RoPWN9aWYoYS5jIT1hLmEubGVuZ3RoKXt2YXIgZT17fTtmb3IoYz1iPTA7YjxhLmEubGVuZ3RoOylkPWEuYVtiXSxHZChlLGQpfHwoYS5hW2MrK109ZCxlW2RdPTEpLGIrKzthLmEubGVuZ3RoPWN9fWguZ2V0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIEdkKHRoaXMuYixhKT90aGlzLmJbYV06Yn07aC5zZXQ9ZnVuY3Rpb24oYSxiKXtHZCh0aGlzLmIsYSl8fCh0aGlzLmMrKyx0aGlzLmEucHVzaChhKSk7dGhpcy5iW2FdPWJ9O1xuaC5mb3JFYWNoPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuUygpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXSxmPXRoaXMuZ2V0KGUpO2EuY2FsbChiLGYsZSx0aGlzKX19O2Z1bmN0aW9uIEdkKGEsYil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGIpfTtmdW5jdGlvbiBIKGEsYil7YSYmYS5sb2coemQsYix2b2lkIDApfTtmdW5jdGlvbiBIZChhKXtyZXR1cm4gRGEoYSxmdW5jdGlvbihhKXthPWEudG9TdHJpbmcoMTYpO3JldHVybiAxPGEubGVuZ3RoP2E6XCIwXCIrYX0pLmpvaW4oXCJcIil9O3ZhciBJZD1udWxsLEpkPW51bGw7ZnVuY3Rpb24gS2QoYSl7dmFyIGI9XCJcIjtMZChhLGZ1bmN0aW9uKGEpe2IrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSl9KTtyZXR1cm4gYn1mdW5jdGlvbiBMZChhLGIpe2Z1bmN0aW9uIGMoYil7Zm9yKDtkPGEubGVuZ3RoOyl7dmFyIGM9YS5jaGFyQXQoZCsrKSxlPUpkW2NdO2lmKG51bGwhPWUpcmV0dXJuIGU7aWYoIS9eW1xcc1xceGEwXSokLy50ZXN0KGMpKXRocm93IEVycm9yKFwiVW5rbm93biBiYXNlNjQgZW5jb2RpbmcgYXQgY2hhcjogXCIrYyk7fXJldHVybiBifU1kKCk7Zm9yKHZhciBkPTA7Oyl7dmFyIGU9YygtMSksZj1jKDApLGc9Yyg2NCksbD1jKDY0KTtpZig2ND09PWwmJi0xPT09ZSlicmVhaztiKGU8PDJ8Zj4+NCk7NjQhPWcmJihiKGY8PDQmMjQwfGc+PjIpLDY0IT1sJiZiKGc8PDYmMTkyfGwpKX19XG5mdW5jdGlvbiBNZCgpe2lmKCFJZCl7SWQ9e307SmQ9e307Zm9yKHZhciBhPTA7NjU+YTthKyspSWRbYV09XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLmNoYXJBdChhKSxKZFtJZFthXV09YSw2Mjw9YSYmKEpkW1wiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXy5cIi5jaGFyQXQoYSldPWEpfX07LypcbiBQb3J0aW9ucyBvZiB0aGlzIGNvZGUgYXJlIGZyb20gTW9jaGlLaXQsIHJlY2VpdmVkIGJ5XG4gVGhlIENsb3N1cmUgQXV0aG9ycyB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIEFsbCBvdGhlciBjb2RlIGlzIENvcHlyaWdodFxuIDIwMDUtMjAwOSBUaGUgQ2xvc3VyZSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuKi9cbmZ1bmN0aW9uIE5kKGEsYil7dGhpcy5nPVtdO3RoaXMudj1hO3RoaXMubz1ifHxudWxsO3RoaXMuZj10aGlzLmE9ITE7dGhpcy5jPXZvaWQgMDt0aGlzLnU9dGhpcy53PXRoaXMuaT0hMTt0aGlzLmg9MDt0aGlzLmI9bnVsbDt0aGlzLmw9MH1OZC5wcm90b3R5cGUuY2FuY2VsPWZ1bmN0aW9uKGEpe2lmKHRoaXMuYSl0aGlzLmMgaW5zdGFuY2VvZiBOZCYmdGhpcy5jLmNhbmNlbCgpO2Vsc2V7aWYodGhpcy5iKXt2YXIgYj10aGlzLmI7ZGVsZXRlIHRoaXMuYjthP2IuY2FuY2VsKGEpOihiLmwtLSwwPj1iLmwmJmIuY2FuY2VsKCkpfXRoaXMudj90aGlzLnYuY2FsbCh0aGlzLm8sdGhpcyk6dGhpcy51PSEwO3RoaXMuYXx8KGE9bmV3IE9kLFBkKHRoaXMpLFFkKHRoaXMsITEsYSkpfX07TmQucHJvdG90eXBlLm09ZnVuY3Rpb24oYSxiKXt0aGlzLmk9ITE7UWQodGhpcyxhLGIpfTtmdW5jdGlvbiBRZChhLGIsYyl7YS5hPSEwO2EuYz1jO2EuZj0hYjtSZChhKX1cbmZ1bmN0aW9uIFBkKGEpe2lmKGEuYSl7aWYoIWEudSl0aHJvdyBuZXcgU2Q7YS51PSExfX1OZC5wcm90b3R5cGUuQT1mdW5jdGlvbihhKXtQZCh0aGlzKTtRZCh0aGlzLCEwLGEpfTtmdW5jdGlvbiBUZChhLGIpe1VkKGEsbnVsbCxiLHZvaWQgMCl9ZnVuY3Rpb24gVWQoYSxiLGMsZCl7YS5nLnB1c2goW2IsYyxkXSk7YS5hJiZSZChhKX1OZC5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPW5ldyB6KGZ1bmN0aW9uKGEsYil7ZD1hO2U9Yn0pO1VkKHRoaXMsZCxmdW5jdGlvbihhKXthIGluc3RhbmNlb2YgT2Q/Zi5jYW5jZWwoKTplKGEpfSk7cmV0dXJuIGYudGhlbihhLGIsYyl9O21iKE5kKTtmdW5jdGlvbiBWZChhKXtyZXR1cm4gRWEoYS5nLGZ1bmN0aW9uKGEpe3JldHVybiBwKGFbMV0pfSl9XG5mdW5jdGlvbiBSZChhKXtpZihhLmgmJmEuYSYmVmQoYSkpe3ZhciBiPWEuaCxjPVdkW2JdO2MmJihrLmNsZWFyVGltZW91dChjLmEpLGRlbGV0ZSBXZFtiXSk7YS5oPTB9YS5iJiYoYS5iLmwtLSxkZWxldGUgYS5iKTtiPWEuYztmb3IodmFyIGQ9Yz0hMTthLmcubGVuZ3RoJiYhYS5pOyl7dmFyIGU9YS5nLnNoaWZ0KCksZj1lWzBdLGc9ZVsxXTtlPWVbMl07aWYoZj1hLmY/ZzpmKXRyeXt2YXIgbD1mLmNhbGwoZXx8YS5vLGIpO3ZvaWQgMCE9PWwmJihhLmY9YS5mJiYobD09Ynx8bCBpbnN0YW5jZW9mIEVycm9yKSxhLmM9Yj1sKTtpZihuYihiKXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGsuUHJvbWlzZSYmYiBpbnN0YW5jZW9mIGsuUHJvbWlzZSlkPSEwLGEuaT0hMH1jYXRjaChuKXtiPW4sYS5mPSEwLFZkKGEpfHwoYz0hMCl9fWEuYz1iO2QmJihsPXIoYS5tLGEsITApLGQ9cihhLm0sYSwhMSksYiBpbnN0YW5jZW9mIE5kPyhVZChiLGwsZCksYi53PSEwKTpiLnRoZW4obCxkKSk7YyYmKGI9XG5uZXcgWGQoYiksV2RbYi5hXT1iLGEuaD1iLmEpfWZ1bmN0aW9uIFNkKCl7dS5jYWxsKHRoaXMpfXQoU2QsdSk7U2QucHJvdG90eXBlLm1lc3NhZ2U9XCJEZWZlcnJlZCBoYXMgYWxyZWFkeSBmaXJlZFwiO1NkLnByb3RvdHlwZS5uYW1lPVwiQWxyZWFkeUNhbGxlZEVycm9yXCI7ZnVuY3Rpb24gT2QoKXt1LmNhbGwodGhpcyl9dChPZCx1KTtPZC5wcm90b3R5cGUubWVzc2FnZT1cIkRlZmVycmVkIHdhcyBjYW5jZWxlZFwiO09kLnByb3RvdHlwZS5uYW1lPVwiQ2FuY2VsZWRFcnJvclwiO2Z1bmN0aW9uIFhkKGEpe3RoaXMuYT1rLnNldFRpbWVvdXQocih0aGlzLmMsdGhpcyksMCk7dGhpcy5iPWF9WGQucHJvdG90eXBlLmM9ZnVuY3Rpb24oKXtkZWxldGUgV2RbdGhpcy5hXTt0aHJvdyB0aGlzLmI7fTt2YXIgV2Q9e307ZnVuY3Rpb24gWWQoKXt0aGlzLmI9LTF9O2Z1bmN0aW9uIFpkKGEsYil7dGhpcy5iPS0xO3RoaXMuYj0kZDt0aGlzLmY9ay5VaW50OEFycmF5P25ldyBVaW50OEFycmF5KHRoaXMuYik6QXJyYXkodGhpcy5iKTt0aGlzLmc9dGhpcy5jPTA7dGhpcy5hPVtdO3RoaXMuaT1hO3RoaXMuaD1iO3RoaXMubD1rLkludDMyQXJyYXk/bmV3IEludDMyQXJyYXkoNjQpOkFycmF5KDY0KTthZXx8KGsuSW50MzJBcnJheT9hZT1uZXcgSW50MzJBcnJheShiZSk6YWU9YmUpO3RoaXMucmVzZXQoKX12YXIgYWU7dChaZCxZZCk7Zm9yKHZhciAkZD02NCxjZT0kZC0xLGRlPVtdLGVlPTA7ZWU8Y2U7ZWUrKylkZVtlZV09MDt2YXIgZmU9S2EoMTI4LGRlKTtaZC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmc9dGhpcy5jPTA7dGhpcy5hPWsuSW50MzJBcnJheT9uZXcgSW50MzJBcnJheSh0aGlzLmgpOkxhKHRoaXMuaCl9O1xuZnVuY3Rpb24gZ2UoYSl7Zm9yKHZhciBiPWEuZixjPWEubCxkPTAsZT0wO2U8Yi5sZW5ndGg7KWNbZCsrXT1iW2VdPDwyNHxiW2UrMV08PDE2fGJbZSsyXTw8OHxiW2UrM10sZT00KmQ7Zm9yKGI9MTY7NjQ+YjtiKyspe2U9Y1tiLTE1XXwwO2Q9Y1tiLTJdfDA7dmFyIGY9KGNbYi0xNl18MCkrKChlPj4+N3xlPDwyNSleKGU+Pj4xOHxlPDwxNCleZT4+PjMpfDAsZz0oY1tiLTddfDApKygoZD4+PjE3fGQ8PDE1KV4oZD4+PjE5fGQ8PDEzKV5kPj4+MTApfDA7Y1tiXT1mK2d8MH1kPWEuYVswXXwwO2U9YS5hWzFdfDA7dmFyIGw9YS5hWzJdfDAsbj1hLmFbM118MCxEPWEuYVs0XXwwLHZiPWEuYVs1XXwwLHRjPWEuYVs2XXwwO2Y9YS5hWzddfDA7Zm9yKGI9MDs2ND5iO2IrKyl7dmFyIEJqPSgoZD4+PjJ8ZDw8MzApXihkPj4+MTN8ZDw8MTkpXihkPj4+MjJ8ZDw8MTApKSsoZCZlXmQmbF5lJmwpfDA7Zz1EJnZiXn5EJnRjO2Y9ZisoKEQ+Pj42fEQ8PDI2KV4oRD4+PjExfEQ8PDIxKV4oRD4+PlxuMjV8RDw8NykpfDA7Zz1nKyhhZVtiXXwwKXwwO2c9ZisoZysoY1tiXXwwKXwwKXwwO2Y9dGM7dGM9dmI7dmI9RDtEPW4rZ3wwO249bDtsPWU7ZT1kO2Q9ZytCanwwfWEuYVswXT1hLmFbMF0rZHwwO2EuYVsxXT1hLmFbMV0rZXwwO2EuYVsyXT1hLmFbMl0rbHwwO2EuYVszXT1hLmFbM10rbnwwO2EuYVs0XT1hLmFbNF0rRHwwO2EuYVs1XT1hLmFbNV0rdmJ8MDthLmFbNl09YS5hWzZdK3RjfDA7YS5hWzddPWEuYVs3XStmfDB9XG5mdW5jdGlvbiBoZShhLGIsYyl7dm9pZCAwPT09YyYmKGM9Yi5sZW5ndGgpO3ZhciBkPTAsZT1hLmM7aWYobShiKSlmb3IoO2Q8YzspYS5mW2UrK109Yi5jaGFyQ29kZUF0KGQrKyksZT09YS5iJiYoZ2UoYSksZT0wKTtlbHNlIGlmKGhhKGIpKWZvcig7ZDxjOyl7dmFyIGY9YltkKytdO2lmKCEoXCJudW1iZXJcIj09dHlwZW9mIGYmJjA8PWYmJjI1NT49ZiYmZj09KGZ8MCkpKXRocm93IEVycm9yKFwibWVzc2FnZSBtdXN0IGJlIGEgYnl0ZSBhcnJheVwiKTthLmZbZSsrXT1mO2U9PWEuYiYmKGdlKGEpLGU9MCl9ZWxzZSB0aHJvdyBFcnJvcihcIm1lc3NhZ2UgbXVzdCBiZSBzdHJpbmcgb3IgYXJyYXlcIik7YS5jPWU7YS5nKz1jfVxudmFyIGJlPVsxMTE2MzUyNDA4LDE4OTk0NDc0NDEsMzA0OTMyMzQ3MSwzOTIxMDA5NTczLDk2MTk4NzE2MywxNTA4OTcwOTkzLDI0NTM2MzU3NDgsMjg3MDc2MzIyMSwzNjI0MzgxMDgwLDMxMDU5ODQwMSw2MDcyMjUyNzgsMTQyNjg4MTk4NywxOTI1MDc4Mzg4LDIxNjIwNzgyMDYsMjYxNDg4ODEwMywzMjQ4MjIyNTgwLDM4MzUzOTA0MDEsNDAyMjIyNDc3NCwyNjQzNDcwNzgsNjA0ODA3NjI4LDc3MDI1NTk4MywxMjQ5MTUwMTIyLDE1NTUwODE2OTIsMTk5NjA2NDk4NiwyNTU0MjIwODgyLDI4MjE4MzQzNDksMjk1Mjk5NjgwOCwzMjEwMzEzNjcxLDMzMzY1NzE4OTEsMzU4NDUyODcxMSwxMTM5MjY5OTMsMzM4MjQxODk1LDY2NjMwNzIwNSw3NzM1Mjk5MTIsMTI5NDc1NzM3MiwxMzk2MTgyMjkxLDE2OTUxODM3MDAsMTk4NjY2MTA1MSwyMTc3MDI2MzUwLDI0NTY5NTYwMzcsMjczMDQ4NTkyMSwyODIwMzAyNDExLDMyNTk3MzA4MDAsMzM0NTc2NDc3MSwzNTE2MDY1ODE3LDM2MDAzNTI4MDQsXG40MDk0NTcxOTA5LDI3NTQyMzM0NCw0MzAyMjc3MzQsNTA2OTQ4NjE2LDY1OTA2MDU1Niw4ODM5OTc4NzcsOTU4MTM5NTcxLDEzMjI4MjIyMTgsMTUzNzAwMjA2MywxNzQ3ODczNzc5LDE5NTU1NjIyMjIsMjAyNDEwNDgxNSwyMjI3NzMwNDUyLDIzNjE4NTI0MjQsMjQyODQzNjQ3NCwyNzU2NzM0MTg3LDMyMDQwMzE0NzksMzMyOTMyNTI5OF07ZnVuY3Rpb24gaWUoKXtaZC5jYWxsKHRoaXMsOCxqZSl9dChpZSxaZCk7dmFyIGplPVsxNzc5MDMzNzAzLDMxNDQxMzQyNzcsMTAxMzkwNDI0MiwyNzczNDgwNzYyLDEzNTk4OTMxMTksMjYwMDgyMjkyNCw1Mjg3MzQ2MzUsMTU0MTQ1OTIyNV07ZnVuY3Rpb24ga2UoYSl7aWYoYS5QJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLlApcmV0dXJuIGEuUCgpO2lmKG0oYSkpcmV0dXJuIGEuc3BsaXQoXCJcIik7aWYoaGEoYSkpe2Zvcih2YXIgYj1bXSxjPWEubGVuZ3RoLGQ9MDtkPGM7ZCsrKWIucHVzaChhW2RdKTtyZXR1cm4gYn1yZXR1cm4gUWEoYSl9ZnVuY3Rpb24gbGUoYSl7aWYoYS5TJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLlMpcmV0dXJuIGEuUygpO2lmKCFhLlB8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGEuUCl7aWYoaGEoYSl8fG0oYSkpe3ZhciBiPVtdO2E9YS5sZW5ndGg7Zm9yKHZhciBjPTA7YzxhO2MrKyliLnB1c2goYyk7cmV0dXJuIGJ9cmV0dXJuIFJhKGEpfX1cbmZ1bmN0aW9uIG1lKGEsYil7aWYoYS5mb3JFYWNoJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLmZvckVhY2gpYS5mb3JFYWNoKGIsdm9pZCAwKTtlbHNlIGlmKGhhKGEpfHxtKGEpKXcoYSxiLHZvaWQgMCk7ZWxzZSBmb3IodmFyIGM9bGUoYSksZD1rZShhKSxlPWQubGVuZ3RoLGY9MDtmPGU7ZisrKWIuY2FsbCh2b2lkIDAsZFtmXSxjJiZjW2ZdLGEpfTt2YXIgbmU9L14oPzooW146Lz8jLl0rKTopPyg/OlxcL1xcLyg/OihbXi8/I10qKUApPyhbXi8jP10qPykoPzo6KFswLTldKykpPyg/PVsvIz9dfCQpKT8oW14/I10rKT8oPzpcXD8oW14jXSopKT8oPzojKFtcXHNcXFNdKikpPyQvO2Z1bmN0aW9uIG9lKGEsYil7aWYoYSl7YT1hLnNwbGl0KFwiJlwiKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YVtjXS5pbmRleE9mKFwiPVwiKSxlPW51bGw7aWYoMDw9ZCl7dmFyIGY9YVtjXS5zdWJzdHJpbmcoMCxkKTtlPWFbY10uc3Vic3RyaW5nKGQrMSl9ZWxzZSBmPWFbY107YihmLGU/ZGVjb2RlVVJJQ29tcG9uZW50KGUucmVwbGFjZSgvXFwrL2csXCIgXCIpKTpcIlwiKX19fTtmdW5jdGlvbiBwZShhLGIpe3RoaXMuYj10aGlzLmw9dGhpcy5jPVwiXCI7dGhpcy5pPW51bGw7dGhpcy5oPXRoaXMuZz1cIlwiO3RoaXMuZj0hMTtpZihhIGluc3RhbmNlb2YgcGUpe3RoaXMuZj12b2lkIDAhPT1iP2I6YS5mO3FlKHRoaXMsYS5jKTt0aGlzLmw9YS5sO3RoaXMuYj1hLmI7cmUodGhpcyxhLmkpO3RoaXMuZz1hLmc7Yj1hLmE7dmFyIGM9bmV3IHNlO2MuYz1iLmM7Yi5hJiYoYy5hPW5ldyBFZChiLmEpLGMuYj1iLmIpO3RlKHRoaXMsYyk7dGhpcy5oPWEuaH1lbHNlIGEmJihjPVN0cmluZyhhKS5tYXRjaChuZSkpPyh0aGlzLmY9ISFiLHFlKHRoaXMsY1sxXXx8XCJcIiwhMCksdGhpcy5sPXVlKGNbMl18fFwiXCIpLHRoaXMuYj11ZShjWzNdfHxcIlwiLCEwKSxyZSh0aGlzLGNbNF0pLHRoaXMuZz11ZShjWzVdfHxcIlwiLCEwKSx0ZSh0aGlzLGNbNl18fFwiXCIsITApLHRoaXMuaD11ZShjWzddfHxcIlwiKSk6KHRoaXMuZj0hIWIsdGhpcy5hPW5ldyBzZShudWxsLDAsdGhpcy5mKSl9XG5wZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT1bXSxiPXRoaXMuYztiJiZhLnB1c2godmUoYix3ZSwhMCksXCI6XCIpO3ZhciBjPXRoaXMuYjtpZihjfHxcImZpbGVcIj09YilhLnB1c2goXCIvL1wiKSwoYj10aGlzLmwpJiZhLnB1c2godmUoYix3ZSwhMCksXCJAXCIpLGEucHVzaChlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGMpKS5yZXBsYWNlKC8lMjUoWzAtOWEtZkEtRl17Mn0pL2csXCIlJDFcIikpLGM9dGhpcy5pLG51bGwhPWMmJmEucHVzaChcIjpcIixTdHJpbmcoYykpO2lmKGM9dGhpcy5nKXRoaXMuYiYmXCIvXCIhPWMuY2hhckF0KDApJiZhLnB1c2goXCIvXCIpLGEucHVzaCh2ZShjLFwiL1wiPT1jLmNoYXJBdCgwKT94ZTp5ZSwhMCkpOyhjPXRoaXMuYS50b1N0cmluZygpKSYmYS5wdXNoKFwiP1wiLGMpOyhjPXRoaXMuaCkmJmEucHVzaChcIiNcIix2ZShjLHplKSk7cmV0dXJuIGEuam9pbihcIlwiKX07XG5mdW5jdGlvbiBxZShhLGIsYyl7YS5jPWM/dWUoYiwhMCk6YjthLmMmJihhLmM9YS5jLnJlcGxhY2UoLzokLyxcIlwiKSl9ZnVuY3Rpb24gcmUoYSxiKXtpZihiKXtiPU51bWJlcihiKTtpZihpc05hTihiKXx8MD5iKXRocm93IEVycm9yKFwiQmFkIHBvcnQgbnVtYmVyIFwiK2IpO2EuaT1ifWVsc2UgYS5pPW51bGx9ZnVuY3Rpb24gdGUoYSxiLGMpe2IgaW5zdGFuY2VvZiBzZT8oYS5hPWIsQWUoYS5hLGEuZikpOihjfHwoYj12ZShiLEJlKSksYS5hPW5ldyBzZShiLDAsYS5mKSl9ZnVuY3Rpb24gSShhLGIsYyl7YS5hLnNldChiLGMpfWZ1bmN0aW9uIENlKGEsYil7cmV0dXJuIGEuYS5nZXQoYil9ZnVuY3Rpb24gRGUoYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBwZT9uZXcgcGUoYSk6bmV3IHBlKGEsdm9pZCAwKX1mdW5jdGlvbiBFZShhLGIpe3ZhciBjPW5ldyBwZShudWxsLHZvaWQgMCk7cWUoYyxcImh0dHBzXCIpO2EmJihjLmI9YSk7YiYmKGMuZz1iKTtyZXR1cm4gY31cbmZ1bmN0aW9uIHVlKGEsYil7cmV0dXJuIGE/Yj9kZWNvZGVVUkkoYS5yZXBsYWNlKC8lMjUvZyxcIiUyNTI1XCIpKTpkZWNvZGVVUklDb21wb25lbnQoYSk6XCJcIn1mdW5jdGlvbiB2ZShhLGIsYyl7cmV0dXJuIG0oYSk/KGE9ZW5jb2RlVVJJKGEpLnJlcGxhY2UoYixGZSksYyYmKGE9YS5yZXBsYWNlKC8lMjUoWzAtOWEtZkEtRl17Mn0pL2csXCIlJDFcIikpLGEpOm51bGx9ZnVuY3Rpb24gRmUoYSl7YT1hLmNoYXJDb2RlQXQoMCk7cmV0dXJuXCIlXCIrKGE+PjQmMTUpLnRvU3RyaW5nKDE2KSsoYSYxNSkudG9TdHJpbmcoMTYpfXZhciB3ZT0vWyNcXC9cXD9AXS9nLHllPS9bXFwjXFw/Ol0vZyx4ZT0vW1xcI1xcP10vZyxCZT0vW1xcI1xcP0BdL2csemU9LyMvZztmdW5jdGlvbiBzZShhLGIsYyl7dGhpcy5iPXRoaXMuYT1udWxsO3RoaXMuYz1hfHxudWxsO3RoaXMuZj0hIWN9XG5mdW5jdGlvbiBHZShhKXthLmF8fChhLmE9bmV3IEVkLGEuYj0wLGEuYyYmb2UoYS5jLGZ1bmN0aW9uKGIsYyl7SGUoYSxkZWNvZGVVUklDb21wb25lbnQoYi5yZXBsYWNlKC9cXCsvZyxcIiBcIikpLGMpfSkpfWZ1bmN0aW9uIEllKGEpe3ZhciBiPWxlKGEpO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBiKXRocm93IEVycm9yKFwiS2V5cyBhcmUgdW5kZWZpbmVkXCIpO3ZhciBjPW5ldyBzZShudWxsLDAsdm9pZCAwKTthPWtlKGEpO2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZT1iW2RdLGY9YVtkXTtmYShmKT9KZShjLGUsZik6SGUoYyxlLGYpfXJldHVybiBjfWZ1bmN0aW9uIEhlKGEsYixjKXtHZShhKTthLmM9bnVsbDtiPUtlKGEsYik7dmFyIGQ9YS5hLmdldChiKTtkfHxhLmEuc2V0KGIsZD1bXSk7ZC5wdXNoKGMpO2EuYis9MX1cbmZ1bmN0aW9uIExlKGEsYil7R2UoYSk7Yj1LZShhLGIpO0dkKGEuYS5iLGIpJiYoYS5jPW51bGwsYS5iLT1hLmEuZ2V0KGIpLmxlbmd0aCxhPWEuYSxHZChhLmIsYikmJihkZWxldGUgYS5iW2JdLGEuYy0tLGEuYS5sZW5ndGg+MiphLmMmJkZkKGEpKSl9aD1zZS5wcm90b3R5cGU7aC5jbGVhcj1mdW5jdGlvbigpe3RoaXMuYT10aGlzLmM9bnVsbDt0aGlzLmI9MH07ZnVuY3Rpb24gTWUoYSxiKXtHZShhKTtiPUtlKGEsYik7cmV0dXJuIEdkKGEuYS5iLGIpfWguZm9yRWFjaD1mdW5jdGlvbihhLGIpe0dlKHRoaXMpO3RoaXMuYS5mb3JFYWNoKGZ1bmN0aW9uKGMsZCl7dyhjLGZ1bmN0aW9uKGMpe2EuY2FsbChiLGMsZCx0aGlzKX0sdGhpcyl9LHRoaXMpfTtoLlM9ZnVuY3Rpb24oKXtHZSh0aGlzKTtmb3IodmFyIGE9dGhpcy5hLlAoKSxiPXRoaXMuYS5TKCksYz1bXSxkPTA7ZDxiLmxlbmd0aDtkKyspZm9yKHZhciBlPWFbZF0sZj0wO2Y8ZS5sZW5ndGg7ZisrKWMucHVzaChiW2RdKTtyZXR1cm4gY307XG5oLlA9ZnVuY3Rpb24oYSl7R2UodGhpcyk7dmFyIGI9W107aWYobShhKSlNZSh0aGlzLGEpJiYoYj1LYShiLHRoaXMuYS5nZXQoS2UodGhpcyxhKSkpKTtlbHNle2E9dGhpcy5hLlAoKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyliPUthKGIsYVtjXSl9cmV0dXJuIGJ9O2guc2V0PWZ1bmN0aW9uKGEsYil7R2UodGhpcyk7dGhpcy5jPW51bGw7YT1LZSh0aGlzLGEpO01lKHRoaXMsYSkmJih0aGlzLmItPXRoaXMuYS5nZXQoYSkubGVuZ3RoKTt0aGlzLmEuc2V0KGEsW2JdKTt0aGlzLmIrPTE7cmV0dXJuIHRoaXN9O2guZ2V0PWZ1bmN0aW9uKGEsYil7YT1hP3RoaXMuUChhKTpbXTtyZXR1cm4gMDxhLmxlbmd0aD9TdHJpbmcoYVswXSk6Yn07ZnVuY3Rpb24gSmUoYSxiLGMpe0xlKGEsYik7MDxjLmxlbmd0aCYmKGEuYz1udWxsLGEuYS5zZXQoS2UoYSxiKSxMYShjKSksYS5iKz1jLmxlbmd0aCl9XG5oLnRvU3RyaW5nPWZ1bmN0aW9uKCl7aWYodGhpcy5jKXJldHVybiB0aGlzLmM7aWYoIXRoaXMuYSlyZXR1cm5cIlwiO2Zvcih2YXIgYT1bXSxiPXRoaXMuYS5TKCksYz0wO2M8Yi5sZW5ndGg7YysrKXt2YXIgZD1iW2NdLGU9ZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhkKSk7ZD10aGlzLlAoZCk7Zm9yKHZhciBmPTA7ZjxkLmxlbmd0aDtmKyspe3ZhciBnPWU7XCJcIiE9PWRbZl0mJihnKz1cIj1cIitlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGRbZl0pKSk7YS5wdXNoKGcpfX1yZXR1cm4gdGhpcy5jPWEuam9pbihcIiZcIil9O2Z1bmN0aW9uIEtlKGEsYil7Yj1TdHJpbmcoYik7YS5mJiYoYj1iLnRvTG93ZXJDYXNlKCkpO3JldHVybiBifWZ1bmN0aW9uIEFlKGEsYil7YiYmIWEuZiYmKEdlKGEpLGEuYz1udWxsLGEuYS5mb3JFYWNoKGZ1bmN0aW9uKGEsYil7dmFyIGM9Yi50b0xvd2VyQ2FzZSgpO2IhPWMmJihMZSh0aGlzLGIpLEplKHRoaXMsYyxhKSl9LGEpKTthLmY9Yn07ZnVuY3Rpb24gTmUoKXt9TmUucHJvdG90eXBlLmM9bnVsbDtmdW5jdGlvbiBPZShhKXtyZXR1cm4gYS5jfHwoYS5jPWEuYigpKX07dmFyIFBlO2Z1bmN0aW9uIFFlKCl7fXQoUWUsTmUpO1FlLnByb3RvdHlwZS5hPWZ1bmN0aW9uKCl7dmFyIGE9UmUodGhpcyk7cmV0dXJuIGE/bmV3IEFjdGl2ZVhPYmplY3QoYSk6bmV3IFhNTEh0dHBSZXF1ZXN0fTtRZS5wcm90b3R5cGUuYj1mdW5jdGlvbigpe3ZhciBhPXt9O1JlKHRoaXMpJiYoYVswXT0hMCxhWzFdPSEwKTtyZXR1cm4gYX07XG5mdW5jdGlvbiBSZShhKXtpZighYS5mJiZcInVuZGVmaW5lZFwiPT10eXBlb2YgWE1MSHR0cFJlcXVlc3QmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBBY3RpdmVYT2JqZWN0KXtmb3IodmFyIGI9W1wiTVNYTUwyLlhNTEhUVFAuNi4wXCIsXCJNU1hNTDIuWE1MSFRUUC4zLjBcIixcIk1TWE1MMi5YTUxIVFRQXCIsXCJNaWNyb3NvZnQuWE1MSFRUUFwiXSxjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWJbY107dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChkKSxhLmY9ZH1jYXRjaChlKXt9fXRocm93IEVycm9yKFwiQ291bGQgbm90IGNyZWF0ZSBBY3RpdmVYT2JqZWN0LiBBY3RpdmVYIG1pZ2h0IGJlIGRpc2FibGVkLCBvciBNU1hNTCBtaWdodCBub3QgYmUgaW5zdGFsbGVkXCIpO31yZXR1cm4gYS5mfVBlPW5ldyBRZTtmdW5jdGlvbiBTZShhKXtGLmNhbGwodGhpcyk7dGhpcy5oZWFkZXJzPW5ldyBFZDt0aGlzLnc9YXx8bnVsbDt0aGlzLmI9ITE7dGhpcy52PXRoaXMuYT1udWxsO3RoaXMuZz10aGlzLkk9dGhpcy5pPVwiXCI7dGhpcy5jPXRoaXMuRz10aGlzLmg9dGhpcy5BPSExO3RoaXMuZj0wO3RoaXMubT1udWxsO3RoaXMubD1UZTt0aGlzLm89dGhpcy5OPSExfXQoU2UsRik7dmFyIFRlPVwiXCIsVWU9U2UucHJvdG90eXBlLFZlPURkKFwiZ29vZy5uZXQuWGhySW9cIik7VWUuSj1WZTt2YXIgV2U9L15odHRwcz8kL2ksWGU9W1wiUE9TVFwiLFwiUFVUXCJdO1xuZnVuY3Rpb24gWWUoYSxiLGMsZCxlKXtpZihhLmEpdGhyb3cgRXJyb3IoXCJbZ29vZy5uZXQuWGhySW9dIE9iamVjdCBpcyBhY3RpdmUgd2l0aCBhbm90aGVyIHJlcXVlc3Q9XCIrYS5pK1wiOyBuZXdVcmk9XCIrYik7Yz1jP2MudG9VcHBlckNhc2UoKTpcIkdFVFwiO2EuaT1iO2EuZz1cIlwiO2EuST1jO2EuQT0hMTthLmI9ITA7YS5hPWEudz9hLncuYSgpOlBlLmEoKTthLnY9YS53P09lKGEudyk6T2UoUGUpO2EuYS5vbnJlYWR5c3RhdGVjaGFuZ2U9cihhLnpiLGEpO3RyeXtIKGEuSixaZShhLFwiT3BlbmluZyBYaHJcIikpLGEuRz0hMCxhLmEub3BlbihjLFN0cmluZyhiKSwhMCksYS5HPSExfWNhdGNoKGcpe0goYS5KLFplKGEsXCJFcnJvciBvcGVuaW5nIFhocjogXCIrZy5tZXNzYWdlKSk7JGUoYSxnKTtyZXR1cm59Yj1kfHxcIlwiO3ZhciBmPW5ldyBFZChhLmhlYWRlcnMpO2UmJm1lKGUsZnVuY3Rpb24oYSxiKXtmLnNldChiLGEpfSk7ZT1GYShmLlMoKSk7ZD1rLkZvcm1EYXRhJiZiIGluc3RhbmNlb2ZcbmsuRm9ybURhdGE7IUhhKFhlLGMpfHxlfHxkfHxmLnNldChcIkNvbnRlbnQtVHlwZVwiLFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLThcIik7Zi5mb3JFYWNoKGZ1bmN0aW9uKGEsYil7dGhpcy5hLnNldFJlcXVlc3RIZWFkZXIoYixhKX0sYSk7YS5sJiYoYS5hLnJlc3BvbnNlVHlwZT1hLmwpO1wid2l0aENyZWRlbnRpYWxzXCJpbiBhLmEmJmEuYS53aXRoQ3JlZGVudGlhbHMhPT1hLk4mJihhLmEud2l0aENyZWRlbnRpYWxzPWEuTik7dHJ5e2FmKGEpLDA8YS5mJiYoYS5vPWJmKGEuYSksSChhLkosWmUoYSxcIldpbGwgYWJvcnQgYWZ0ZXIgXCIrYS5mK1wibXMgaWYgaW5jb21wbGV0ZSwgeGhyMiBcIithLm8pKSxhLm8/KGEuYS50aW1lb3V0PWEuZixhLmEub250aW1lb3V0PXIoYS5FYSxhKSk6YS5tPXJkKGEuRWEsYS5mLGEpKSxIKGEuSixaZShhLFwiU2VuZGluZyByZXF1ZXN0XCIpKSxhLmg9ITAsYS5hLnNlbmQoYiksYS5oPSExfWNhdGNoKGcpe0goYS5KLFplKGEsXG5cIlNlbmQgZXJyb3I6IFwiK2cubWVzc2FnZSkpLCRlKGEsZyl9fWZ1bmN0aW9uIGJmKGEpe3JldHVybiB5JiZqYig5KSYmXCJudW1iZXJcIj09dHlwZW9mIGEudGltZW91dCYmdm9pZCAwIT09YS5vbnRpbWVvdXR9ZnVuY3Rpb24gR2EoYSl7cmV0dXJuXCJjb250ZW50LXR5cGVcIj09YS50b0xvd2VyQ2FzZSgpfWg9U2UucHJvdG90eXBlO2guRWE9ZnVuY3Rpb24oKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgYWEmJnRoaXMuYSYmKHRoaXMuZz1cIlRpbWVkIG91dCBhZnRlciBcIit0aGlzLmYrXCJtcywgYWJvcnRpbmdcIixIKHRoaXMuSixaZSh0aGlzLHRoaXMuZykpLEcodGhpcyxcInRpbWVvdXRcIiksdGhpcy5hYm9ydCg4KSl9O2Z1bmN0aW9uICRlKGEsYil7YS5iPSExO2EuYSYmKGEuYz0hMCxhLmEuYWJvcnQoKSxhLmM9ITEpO2EuZz1iO2NmKGEpO2RmKGEpfWZ1bmN0aW9uIGNmKGEpe2EuQXx8KGEuQT0hMCxHKGEsXCJjb21wbGV0ZVwiKSxHKGEsXCJlcnJvclwiKSl9XG5oLmFib3J0PWZ1bmN0aW9uKCl7dGhpcy5hJiZ0aGlzLmImJihIKHRoaXMuSixaZSh0aGlzLFwiQWJvcnRpbmdcIikpLHRoaXMuYj0hMSx0aGlzLmM9ITAsdGhpcy5hLmFib3J0KCksdGhpcy5jPSExLEcodGhpcyxcImNvbXBsZXRlXCIpLEcodGhpcyxcImFib3J0XCIpLGRmKHRoaXMpKX07aC50YT1mdW5jdGlvbigpe3RoaXMuYSYmKHRoaXMuYiYmKHRoaXMuYj0hMSx0aGlzLmM9ITAsdGhpcy5hLmFib3J0KCksdGhpcy5jPSExKSxkZih0aGlzLCEwKSk7U2UuaWIudGEuY2FsbCh0aGlzKX07aC56Yj1mdW5jdGlvbigpe3RoaXMub2F8fCh0aGlzLkd8fHRoaXMuaHx8dGhpcy5jP2VmKHRoaXMpOnRoaXMuZmMoKSl9O2guZmM9ZnVuY3Rpb24oKXtlZih0aGlzKX07XG5mdW5jdGlvbiBlZihhKXtpZihhLmImJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhYSlpZihhLnZbMV0mJjQ9PWZmKGEpJiYyPT1nZihhKSlIKGEuSixaZShhLFwiTG9jYWwgcmVxdWVzdCBlcnJvciBkZXRlY3RlZCBhbmQgaWdub3JlZFwiKSk7ZWxzZSBpZihhLmgmJjQ9PWZmKGEpKXJkKGEuemIsMCxhKTtlbHNlIGlmKEcoYSxcInJlYWR5c3RhdGVjaGFuZ2VcIiksND09ZmYoYSkpe0goYS5KLFplKGEsXCJSZXF1ZXN0IGNvbXBsZXRlXCIpKTthLmI9ITE7dHJ5e3ZhciBiPWdmKGEpO2E6c3dpdGNoKGIpe2Nhc2UgMjAwOmNhc2UgMjAxOmNhc2UgMjAyOmNhc2UgMjA0OmNhc2UgMjA2OmNhc2UgMzA0OmNhc2UgMTIyMzp2YXIgYz0hMDticmVhayBhO2RlZmF1bHQ6Yz0hMX12YXIgZDtpZighKGQ9Yykpe3ZhciBlO2lmKGU9MD09PWIpe3ZhciBmPVN0cmluZyhhLmkpLm1hdGNoKG5lKVsxXXx8bnVsbDtpZighZiYmay5zZWxmJiZrLnNlbGYubG9jYXRpb24pe3ZhciBnPWsuc2VsZi5sb2NhdGlvbi5wcm90b2NvbDtcbmY9Zy5zdWJzdHIoMCxnLmxlbmd0aC0xKX1lPSFXZS50ZXN0KGY/Zi50b0xvd2VyQ2FzZSgpOlwiXCIpfWQ9ZX1pZihkKUcoYSxcImNvbXBsZXRlXCIpLEcoYSxcInN1Y2Nlc3NcIik7ZWxzZXt0cnl7dmFyIGw9MjxmZihhKT9hLmEuc3RhdHVzVGV4dDpcIlwifWNhdGNoKG4pe0goYS5KLFwiQ2FuIG5vdCBnZXQgc3RhdHVzOiBcIituLm1lc3NhZ2UpLGw9XCJcIn1hLmc9bCtcIiBbXCIrZ2YoYSkrXCJdXCI7Y2YoYSl9fWZpbmFsbHl7ZGYoYSl9fX1mdW5jdGlvbiBkZihhLGIpe2lmKGEuYSl7YWYoYSk7dmFyIGM9YS5hLGQ9YS52WzBdP2NhOm51bGw7YS5hPW51bGw7YS52PW51bGw7Ynx8RyhhLFwicmVhZHlcIik7dHJ5e2Mub25yZWFkeXN0YXRlY2hhbmdlPWR9Y2F0Y2goZSl7KGE9YS5KKSYmYS5sb2coeGQsXCJQcm9ibGVtIGVuY291bnRlcmVkIHJlc2V0dGluZyBvbnJlYWR5c3RhdGVjaGFuZ2U6IFwiK2UubWVzc2FnZSx2b2lkIDApfX19XG5mdW5jdGlvbiBhZihhKXthLmEmJmEubyYmKGEuYS5vbnRpbWVvdXQ9bnVsbCk7XCJudW1iZXJcIj09dHlwZW9mIGEubSYmKGsuY2xlYXJUaW1lb3V0KGEubSksYS5tPW51bGwpfWZ1bmN0aW9uIGZmKGEpe3JldHVybiBhLmE/YS5hLnJlYWR5U3RhdGU6MH1mdW5jdGlvbiBnZihhKXt0cnl7cmV0dXJuIDI8ZmYoYSk/YS5hLnN0YXR1czotMX1jYXRjaChiKXtyZXR1cm4tMX19ZnVuY3Rpb24gaGYoYSl7dHJ5e3JldHVybiBhLmE/YS5hLnJlc3BvbnNlVGV4dDpcIlwifWNhdGNoKGIpe3JldHVybiBIKGEuSixcIkNhbiBub3QgZ2V0IHJlc3BvbnNlVGV4dDogXCIrYi5tZXNzYWdlKSxcIlwifX1cbmguZ2V0UmVzcG9uc2U9ZnVuY3Rpb24oKXt0cnl7aWYoIXRoaXMuYSlyZXR1cm4gbnVsbDtpZihcInJlc3BvbnNlXCJpbiB0aGlzLmEpcmV0dXJuIHRoaXMuYS5yZXNwb25zZTtzd2l0Y2godGhpcy5sKXtjYXNlIFRlOmNhc2UgXCJ0ZXh0XCI6cmV0dXJuIHRoaXMuYS5yZXNwb25zZVRleHQ7Y2FzZSBcImFycmF5YnVmZmVyXCI6aWYoXCJtb3pSZXNwb25zZUFycmF5QnVmZmVyXCJpbiB0aGlzLmEpcmV0dXJuIHRoaXMuYS5tb3pSZXNwb25zZUFycmF5QnVmZmVyfXZhciBhPXRoaXMuSjthJiZhLmxvZyh4ZCxcIlJlc3BvbnNlIHR5cGUgXCIrdGhpcy5sK1wiIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyXCIsdm9pZCAwKTtyZXR1cm4gbnVsbH1jYXRjaChiKXtyZXR1cm4gSCh0aGlzLkosXCJDYW4gbm90IGdldCByZXNwb25zZTogXCIrYi5tZXNzYWdlKSxudWxsfX07ZnVuY3Rpb24gWmUoYSxiKXtyZXR1cm4gYitcIiBbXCIrYS5JK1wiIFwiK2EuaStcIiBcIitnZihhKStcIl1cIn07dmFyIGpmPS9eWythLXpBLVowLTlfLiEjJCUmJypcXC89P15ge3x9fi1dK0AoW2EtekEtWjAtOS1dK1xcLikrW2EtekEtWjAtOV17Miw2M30kLztmdW5jdGlvbiBrZihhKXt2YXIgYj17fSxjPWIuZG9jdW1lbnR8fGRvY3VtZW50LGQ9Z2MoYSksZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiU0NSSVBUXCIpLGY9e0JiOmUsRWE6dm9pZCAwfSxnPW5ldyBOZChsZixmKSxsPW51bGwsbj1udWxsIT1iLnRpbWVvdXQ/Yi50aW1lb3V0OjVFMzswPG4mJihsPXdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bWYoZSwhMCk7dmFyIGE9bmV3IG5mKG9mLFwiVGltZW91dCByZWFjaGVkIGZvciBsb2FkaW5nIHNjcmlwdCBcIitkKTtQZChnKTtRZChnLCExLGEpfSxuKSxmLkVhPWwpO2Uub25sb2FkPWUub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7ZS5yZWFkeVN0YXRlJiZcImxvYWRlZFwiIT1lLnJlYWR5U3RhdGUmJlwiY29tcGxldGVcIiE9ZS5yZWFkeVN0YXRlfHwobWYoZSxiLk9jfHwhMSxsKSxnLkEobnVsbCkpfTtlLm9uZXJyb3I9ZnVuY3Rpb24oKXttZihlLCEwLGwpO3ZhciBhPW5ldyBuZihwZixcIkVycm9yIHdoaWxlIGxvYWRpbmcgc2NyaXB0IFwiK1xuZCk7UGQoZyk7UWQoZywhMSxhKX07Zj1iLmF0dHJpYnV0ZXN8fHt9O1dhKGYse3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIixjaGFyc2V0OlwiVVRGLThcIn0pO3hjKGUsZik7ZS5zcmM9Z2MoYSk7cWYoYykuYXBwZW5kQ2hpbGQoZSk7cmV0dXJuIGd9ZnVuY3Rpb24gcWYoYSl7dmFyIGI7cmV0dXJuKGI9KGF8fGRvY3VtZW50KS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkhFQURcIikpJiYwIT1iLmxlbmd0aD9iWzBdOmEuZG9jdW1lbnRFbGVtZW50fWZ1bmN0aW9uIGxmKCl7aWYodGhpcyYmdGhpcy5CYil7dmFyIGE9dGhpcy5CYjthJiZcIlNDUklQVFwiPT1hLnRhZ05hbWUmJm1mKGEsITAsdGhpcy5FYSl9fVxuZnVuY3Rpb24gbWYoYSxiLGMpe251bGwhPWMmJmsuY2xlYXJUaW1lb3V0KGMpO2Eub25sb2FkPWNhO2Eub25lcnJvcj1jYTthLm9ucmVhZHlzdGF0ZWNoYW5nZT1jYTtiJiZ3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe2EmJmEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfSwwKX12YXIgcGY9MCxvZj0xO2Z1bmN0aW9uIG5mKGEsYil7dmFyIGM9XCJKc2xvYWRlciBlcnJvciAoY29kZSAjXCIrYStcIilcIjtiJiYoYys9XCI6IFwiK2IpO3UuY2FsbCh0aGlzLGMpO3RoaXMuY29kZT1hfXQobmYsdSk7ZnVuY3Rpb24gcmYoKXt9dChyZixOZSk7cmYucHJvdG90eXBlLmE9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgWE1MSHR0cFJlcXVlc3Q7aWYoXCJ3aXRoQ3JlZGVudGlhbHNcImluIGEpcmV0dXJuIGE7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFhEb21haW5SZXF1ZXN0KXJldHVybiBuZXcgc2Y7dGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBicm93c2VyXCIpO307cmYucHJvdG90eXBlLmI9ZnVuY3Rpb24oKXtyZXR1cm57fX07XG5mdW5jdGlvbiBzZigpe3RoaXMuYT1uZXcgWERvbWFpblJlcXVlc3Q7dGhpcy5yZWFkeVN0YXRlPTA7dGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbDt0aGlzLnJlc3BvbnNlVGV4dD1cIlwiO3RoaXMuc3RhdHVzPS0xO3RoaXMuc3RhdHVzVGV4dD10aGlzLnJlc3BvbnNlWE1MPW51bGw7dGhpcy5hLm9ubG9hZD1yKHRoaXMuU2IsdGhpcyk7dGhpcy5hLm9uZXJyb3I9cih0aGlzLndiLHRoaXMpO3RoaXMuYS5vbnByb2dyZXNzPXIodGhpcy5UYix0aGlzKTt0aGlzLmEub250aW1lb3V0PXIodGhpcy5VYix0aGlzKX1oPXNmLnByb3RvdHlwZTtoLm9wZW49ZnVuY3Rpb24oYSxiLGMpe2lmKG51bGwhPWMmJiFjKXRocm93IEVycm9yKFwiT25seSBhc3luYyByZXF1ZXN0cyBhcmUgc3VwcG9ydGVkLlwiKTt0aGlzLmEub3BlbihhLGIpfTtcbmguc2VuZD1mdW5jdGlvbihhKXtpZihhKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXRoaXMuYS5zZW5kKGEpO2Vsc2UgdGhyb3cgRXJyb3IoXCJPbmx5IHN0cmluZyBkYXRhIGlzIHN1cHBvcnRlZFwiKTtlbHNlIHRoaXMuYS5zZW5kKCl9O2guYWJvcnQ9ZnVuY3Rpb24oKXt0aGlzLmEuYWJvcnQoKX07aC5zZXRSZXF1ZXN0SGVhZGVyPWZ1bmN0aW9uKCl7fTtoLmdldFJlc3BvbnNlSGVhZGVyPWZ1bmN0aW9uKGEpe3JldHVyblwiY29udGVudC10eXBlXCI9PWEudG9Mb3dlckNhc2UoKT90aGlzLmEuY29udGVudFR5cGU6XCJcIn07aC5TYj1mdW5jdGlvbigpe3RoaXMuc3RhdHVzPTIwMDt0aGlzLnJlc3BvbnNlVGV4dD10aGlzLmEucmVzcG9uc2VUZXh0O3RmKHRoaXMsNCl9O2gud2I9ZnVuY3Rpb24oKXt0aGlzLnN0YXR1cz01MDA7dGhpcy5yZXNwb25zZVRleHQ9XCJcIjt0Zih0aGlzLDQpfTtoLlViPWZ1bmN0aW9uKCl7dGhpcy53YigpfTtcbmguVGI9ZnVuY3Rpb24oKXt0aGlzLnN0YXR1cz0yMDA7dGYodGhpcywxKX07ZnVuY3Rpb24gdGYoYSxiKXthLnJlYWR5U3RhdGU9YjtpZihhLm9ucmVhZHlzdGF0ZWNoYW5nZSlhLm9ucmVhZHlzdGF0ZWNoYW5nZSgpfWguZ2V0QWxsUmVzcG9uc2VIZWFkZXJzPWZ1bmN0aW9uKCl7cmV0dXJuXCJjb250ZW50LXR5cGU6IFwiK3RoaXMuYS5jb250ZW50VHlwZX07ZnVuY3Rpb24gdWYoKXt2YXIgYT1KKCk7cmV0dXJuIHkmJiEha2ImJjExPT1rYnx8L0VkZ2VcXC9cXGQrLy50ZXN0KGEpfWZ1bmN0aW9uIHZmKCl7cmV0dXJuIGsud2luZG93JiZrLndpbmRvdy5sb2NhdGlvbi5ocmVmfHxcIlwifWZ1bmN0aW9uIHdmKGEsYil7Yj1ifHxrLndpbmRvdzt2YXIgYz1cImFib3V0OmJsYW5rXCI7YSYmKGM9bmMocGMoYSkpKTtiLmxvY2F0aW9uLmhyZWY9Y31mdW5jdGlvbiB4ZihhLGIpe3ZhciBjPVtdLGQ7Zm9yKGQgaW4gYSlkIGluIGI/dHlwZW9mIGFbZF0hPXR5cGVvZiBiW2RdP2MucHVzaChkKTpmYShhW2RdKT9UYShhW2RdLGJbZF0pfHxjLnB1c2goZCk6XCJvYmplY3RcIj09dHlwZW9mIGFbZF0mJm51bGwhPWFbZF0mJm51bGwhPWJbZF0/MDx4ZihhW2RdLGJbZF0pLmxlbmd0aCYmYy5wdXNoKGQpOmFbZF0hPT1iW2RdJiZjLnB1c2goZCk6Yy5wdXNoKGQpO2ZvcihkIGluIGIpZCBpbiBhfHxjLnB1c2goZCk7cmV0dXJuIGN9XG5mdW5jdGlvbiB5Zigpe3ZhciBhPUooKTthPXpmKGEpIT1BZj9udWxsOihhPWEubWF0Y2goL1xcc0Nocm9tZVxcLyhcXGQrKS9pKSkmJjI9PWEubGVuZ3RoP3BhcnNlSW50KGFbMV0sMTApOm51bGw7cmV0dXJuIGEmJjMwPmE/ITE6IXl8fCFrYnx8OTxrYn1mdW5jdGlvbiBCZihhKXthPShhfHxKKCkpLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGEubWF0Y2goL2FuZHJvaWQvKXx8YS5tYXRjaCgvd2Vib3MvKXx8YS5tYXRjaCgvaXBob25lfGlwYWR8aXBvZC8pfHxhLm1hdGNoKC9ibGFja2JlcnJ5Lyl8fGEubWF0Y2goL3dpbmRvd3MgcGhvbmUvKXx8YS5tYXRjaCgvaWVtb2JpbGUvKT8hMDohMX1mdW5jdGlvbiBDZihhKXthPWF8fGsud2luZG93O3RyeXthLmNsb3NlKCl9Y2F0Y2goYil7fX1cbmZ1bmN0aW9uIERmKGEsYixjKXt2YXIgZD1NYXRoLmZsb29yKDFFOSpNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpO2I9Ynx8NTAwO2M9Y3x8NjAwO3ZhciBlPSh3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0LWMpLzIsZj0od2luZG93LnNjcmVlbi5hdmFpbFdpZHRoLWIpLzI7Yj17d2lkdGg6YixoZWlnaHQ6Yyx0b3A6MDxlP2U6MCxsZWZ0OjA8Zj9mOjAsbG9jYXRpb246ITAscmVzaXphYmxlOiEwLHN0YXR1c2JhcjohMCx0b29sYmFyOiExfTtjPUooKS50b0xvd2VyQ2FzZSgpO2QmJihiLnRhcmdldD1kLHYoYyxcImNyaW9zL1wiKSYmKGIudGFyZ2V0PVwiX2JsYW5rXCIpKTt6ZihKKCkpPT1FZiYmKGE9YXx8XCJodHRwOi8vbG9jYWxob3N0XCIsYi5zY3JvbGxiYXJzPSEwKTtjPWF8fFwiXCI7KGQ9Yil8fChkPXt9KTthPXdpbmRvdztiPWMgaW5zdGFuY2VvZiBsYz9jOnBjKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBjLmhyZWY/Yy5ocmVmOlN0cmluZyhjKSk7Yz1kLnRhcmdldHx8Yy50YXJnZXQ7ZT1bXTtcbmZvcihnIGluIGQpc3dpdGNoKGcpe2Nhc2UgXCJ3aWR0aFwiOmNhc2UgXCJoZWlnaHRcIjpjYXNlIFwidG9wXCI6Y2FzZSBcImxlZnRcIjplLnB1c2goZytcIj1cIitkW2ddKTticmVhaztjYXNlIFwidGFyZ2V0XCI6Y2FzZSBcIm5vcmVmZXJyZXJcIjpicmVhaztkZWZhdWx0OmUucHVzaChnK1wiPVwiKyhkW2ddPzE6MCkpfXZhciBnPWUuam9pbihcIixcIik7KHgoXCJpUGhvbmVcIikmJiF4KFwiaVBvZFwiKSYmIXgoXCJpUGFkXCIpfHx4KFwiaVBhZFwiKXx8eChcImlQb2RcIikpJiZhLm5hdmlnYXRvciYmYS5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSYmYyYmXCJfc2VsZlwiIT1jPyhnPWEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkFcIiksYiBpbnN0YW5jZW9mIGxjfHxiIGluc3RhbmNlb2YgbGN8fChiPWIubGE/Yi5qYSgpOlN0cmluZyhiKSxvYy50ZXN0KGIpfHwoYj1cImFib3V0OmludmFsaWQjekNsb3N1cmV6XCIpLGI9cWMoYikpLGcuaHJlZj1uYyhiKSxnLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLGMpLGQubm9yZWZlcnJlciYmZy5zZXRBdHRyaWJ1dGUoXCJyZWxcIixcblwibm9yZWZlcnJlclwiKSxkPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKSxkLmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwhMCwhMCxhLDEpLGcuZGlzcGF0Y2hFdmVudChkKSxnPXt9KTpkLm5vcmVmZXJyZXI/KGc9YS5vcGVuKFwiXCIsYyxnKSxhPW5jKGIpLGcmJihiYiYmdihhLFwiO1wiKSYmKGE9XCInXCIrYS5yZXBsYWNlKC8nL2csXCIlMjdcIikrXCInXCIpLGcub3BlbmVyPW51bGwsZGMoXCJiLzEyMDE0NDEyLCBtZXRhIHRhZyB3aXRoIHNhbml0aXplZCBVUkxcIiksYT0nPE1FVEEgSFRUUC1FUVVJVj1cInJlZnJlc2hcIiBjb250ZW50PVwiMDsgdXJsPScrcWEoYSkrJ1wiPicsYT12YyhhKSxnLmRvY3VtZW50LndyaXRlKHVjKGEpKSxnLmRvY3VtZW50LmNsb3NlKCkpKTpnPWEub3BlbihuYyhiKSxjLGcpO2lmKGcpdHJ5e2cuZm9jdXMoKX1jYXRjaChsKXt9cmV0dXJuIGd9XG5mdW5jdGlvbiBGZihhKXtyZXR1cm4gbmV3IHooZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3NkKDJFMykudGhlbihmdW5jdGlvbigpe2lmKCFhfHxhLmNsb3NlZCliKCk7ZWxzZSByZXR1cm4gYygpfSl9cmV0dXJuIGMoKX0pfXZhciBHZj0vXlxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfVxcLlxcZHsxLDN9JC87ZnVuY3Rpb24gSGYoKXt2YXIgYT1udWxsO3JldHVybihuZXcgeihmdW5jdGlvbihiKXtcImNvbXBsZXRlXCI9PWsuZG9jdW1lbnQucmVhZHlTdGF0ZT9iKCk6KGE9ZnVuY3Rpb24oKXtiKCl9LGRkKHdpbmRvdyxcImxvYWRcIixhKSl9KSkucyhmdW5jdGlvbihiKXtFKHdpbmRvdyxcImxvYWRcIixhKTt0aHJvdyBiO30pfVxuZnVuY3Rpb24gSWYoKXtyZXR1cm4gSmYodm9pZCAwKT9IZigpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHooZnVuY3Rpb24oYSxiKXt2YXIgYz1rLmRvY3VtZW50LGQ9c2V0VGltZW91dChmdW5jdGlvbigpe2IoRXJyb3IoXCJDb3Jkb3ZhIGZyYW1ld29yayBpcyBub3QgcmVhZHkuXCIpKX0sMUUzKTtjLmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2VyZWFkeVwiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGQpO2EoKX0sITEpfSl9KTpCKEVycm9yKFwiQ29yZG92YSBtdXN0IHJ1biBpbiBhbiBBbmRyb2lkIG9yIGlPUyBmaWxlIHNjaGVtZS5cIikpfWZ1bmN0aW9uIEpmKGEpe2E9YXx8SigpO3JldHVybiEoXCJmaWxlOlwiIT09S2YoKXx8IWEudG9Mb3dlckNhc2UoKS5tYXRjaCgvaXBob25lfGlwYWR8aXBvZHxhbmRyb2lkLykpfWZ1bmN0aW9uIExmKCl7dmFyIGE9ay53aW5kb3c7dHJ5e3JldHVybiEoIWF8fGE9PWEudG9wKX1jYXRjaChiKXtyZXR1cm4hMX19XG5mdW5jdGlvbiBLKCl7cmV0dXJuIGZpcmViYXNlLklOVEVSTkFMLmhhc093blByb3BlcnR5KFwicmVhY3ROYXRpdmVcIik/XCJSZWFjdE5hdGl2ZVwiOmZpcmViYXNlLklOVEVSTkFMLmhhc093blByb3BlcnR5KFwibm9kZVwiKT9cIk5vZGVcIjpcIkJyb3dzZXJcIn1mdW5jdGlvbiBNZigpe3ZhciBhPUsoKTtyZXR1cm5cIlJlYWN0TmF0aXZlXCI9PT1hfHxcIk5vZGVcIj09PWF9dmFyIEVmPVwiRmlyZWZveFwiLEFmPVwiQ2hyb21lXCI7XG5mdW5jdGlvbiB6ZihhKXt2YXIgYj1hLnRvTG93ZXJDYXNlKCk7aWYodihiLFwib3BlcmEvXCIpfHx2KGIsXCJvcHIvXCIpfHx2KGIsXCJvcGlvcy9cIikpcmV0dXJuXCJPcGVyYVwiO2lmKHYoYixcImllbW9iaWxlXCIpKXJldHVyblwiSUVNb2JpbGVcIjtpZih2KGIsXCJtc2llXCIpfHx2KGIsXCJ0cmlkZW50L1wiKSlyZXR1cm5cIklFXCI7aWYodihiLFwiZWRnZS9cIikpcmV0dXJuXCJFZGdlXCI7aWYodihiLFwiZmlyZWZveC9cIikpcmV0dXJuIEVmO2lmKHYoYixcInNpbGsvXCIpKXJldHVyblwiU2lsa1wiO2lmKHYoYixcImJsYWNrYmVycnlcIikpcmV0dXJuXCJCbGFja2JlcnJ5XCI7aWYodihiLFwid2Vib3NcIikpcmV0dXJuXCJXZWJvc1wiO2lmKCF2KGIsXCJzYWZhcmkvXCIpfHx2KGIsXCJjaHJvbWUvXCIpfHx2KGIsXCJjcmlvcy9cIil8fHYoYixcImFuZHJvaWRcIikpaWYoIXYoYixcImNocm9tZS9cIikmJiF2KGIsXCJjcmlvcy9cIil8fHYoYixcImVkZ2UvXCIpKXtpZih2KGIsXCJhbmRyb2lkXCIpKXJldHVyblwiQW5kcm9pZFwiO2lmKChhPWEubWF0Y2goLyhbYS16QS1aXFxkXFwuXSspXFwvW2EtekEtWlxcZFxcLl0qJC8pKSYmXG4yPT1hLmxlbmd0aClyZXR1cm4gYVsxXX1lbHNlIHJldHVybiBBZjtlbHNlIHJldHVyblwiU2FmYXJpXCI7cmV0dXJuXCJPdGhlclwifXZhciBOZj17Q2M6XCJGaXJlYmFzZUNvcmUtd2ViXCIsRWM6XCJGaXJlYmFzZVVJLXdlYlwifTtmdW5jdGlvbiBPZihhLGIpe2I9Ynx8W107dmFyIGM9W10sZD17fSxlO2ZvcihlIGluIE5mKWRbTmZbZV1dPSEwO2ZvcihlPTA7ZTxiLmxlbmd0aDtlKyspXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkW2JbZV1dJiYoZGVsZXRlIGRbYltlXV0sYy5wdXNoKGJbZV0pKTtjLnNvcnQoKTtiPWM7Yi5sZW5ndGh8fChiPVtcIkZpcmViYXNlQ29yZS13ZWJcIl0pO2M9SygpO2Q9XCJcIjtcIkJyb3dzZXJcIj09PWM/ZD16ZihKKCkpOmQ9YztyZXR1cm4gZCtcIi9Kc0NvcmUvXCIrYStcIi9cIitiLmpvaW4oXCIsXCIpfWZ1bmN0aW9uIEooKXtyZXR1cm4gay5uYXZpZ2F0b3ImJmsubmF2aWdhdG9yLnVzZXJBZ2VudHx8XCJcIn1cbmZ1bmN0aW9uIEwoYSxiKXthPWEuc3BsaXQoXCIuXCIpO2I9Ynx8aztmb3IodmFyIGM9MDtjPGEubGVuZ3RoJiZcIm9iamVjdFwiPT10eXBlb2YgYiYmbnVsbCE9YjtjKyspYj1iW2FbY11dO2MhPWEubGVuZ3RoJiYoYj12b2lkIDApO3JldHVybiBifWZ1bmN0aW9uIFBmKCl7dHJ5e3ZhciBhPWsubG9jYWxTdG9yYWdlLGI9UWYoKTtpZihhKXJldHVybiBhLnNldEl0ZW0oYixcIjFcIiksYS5yZW1vdmVJdGVtKGIpLHVmKCk/ISFrLmluZGV4ZWREQjohMH1jYXRjaChjKXt9cmV0dXJuITF9ZnVuY3Rpb24gUmYoKXtyZXR1cm4oU2YoKXx8XCJjaHJvbWUtZXh0ZW5zaW9uOlwiPT09S2YoKXx8SmYoKSkmJiFNZigpJiZQZigpfWZ1bmN0aW9uIFNmKCl7cmV0dXJuXCJodHRwOlwiPT09S2YoKXx8XCJodHRwczpcIj09PUtmKCl9ZnVuY3Rpb24gS2YoKXtyZXR1cm4gay5sb2NhdGlvbiYmay5sb2NhdGlvbi5wcm90b2NvbHx8bnVsbH1cbmZ1bmN0aW9uIFRmKGEpe2E9YXx8SigpO3JldHVybiBCZihhKXx8emYoYSk9PUVmPyExOiEwfWZ1bmN0aW9uIFVmKGEpe3JldHVyblwidW5kZWZpbmVkXCI9PT10eXBlb2YgYT9udWxsOkNjKGEpfWZ1bmN0aW9uIFZmKGEpe3ZhciBiPXt9LGM7Zm9yKGMgaW4gYSlhLmhhc093blByb3BlcnR5KGMpJiZudWxsIT09YVtjXSYmdm9pZCAwIT09YVtjXSYmKGJbY109YVtjXSk7cmV0dXJuIGJ9ZnVuY3Rpb24gV2YoYSl7aWYobnVsbCE9PWEpcmV0dXJuIEpTT04ucGFyc2UoYSl9ZnVuY3Rpb24gUWYoYSl7cmV0dXJuIGE/YTpcIlwiK01hdGguZmxvb3IoMUU5Kk1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCl9ZnVuY3Rpb24gWGYoYSl7YT1hfHxKKCk7cmV0dXJuXCJTYWZhcmlcIj09emYoYSl8fGEudG9Mb3dlckNhc2UoKS5tYXRjaCgvaXBob25lfGlwYWR8aXBvZC8pPyExOiEwfVxuZnVuY3Rpb24gWWYoKXt2YXIgYT1rLl9fX2pzbDtpZihhJiZhLkgpZm9yKHZhciBiIGluIGEuSClpZihhLkhbYl0ucj1hLkhbYl0ucnx8W10sYS5IW2JdLkw9YS5IW2JdLkx8fFtdLGEuSFtiXS5yPWEuSFtiXS5MLmNvbmNhdCgpLGEuQ1ApZm9yKHZhciBjPTA7YzxhLkNQLmxlbmd0aDtjKyspYS5DUFtjXT1udWxsfWZ1bmN0aW9uIFpmKCl7dmFyIGE9ay5uYXZpZ2F0b3I7cmV0dXJuIGEmJlwiYm9vbGVhblwiPT09dHlwZW9mIGEub25MaW5lJiYoU2YoKXx8XCJjaHJvbWUtZXh0ZW5zaW9uOlwiPT09S2YoKXx8XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhLmNvbm5lY3Rpb24pP2Eub25MaW5lOiEwfWZ1bmN0aW9uICRmKGEsYixjLGQpe2lmKGE+Yil0aHJvdyBFcnJvcihcIlNob3J0IGRlbGF5IHNob3VsZCBiZSBsZXNzIHRoYW4gbG9uZyBkZWxheSFcIik7dGhpcy5jPWE7dGhpcy5iPWI7YT1jfHxKKCk7ZD1kfHxLKCk7dGhpcy5hPUJmKGEpfHxcIlJlYWN0TmF0aXZlXCI9PT1kfVxuJGYucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmE/dGhpcy5iOnRoaXMuY307ZnVuY3Rpb24gYWcoKXt2YXIgYT1rLmRvY3VtZW50O3JldHVybiBhJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGEudmlzaWJpbGl0eVN0YXRlP1widmlzaWJsZVwiPT1hLnZpc2liaWxpdHlTdGF0ZTohMH1mdW5jdGlvbiBiZygpe3ZhciBhPWsuZG9jdW1lbnQsYj1udWxsO3JldHVybiBhZygpfHwhYT9BKCk6KG5ldyB6KGZ1bmN0aW9uKGMpe2I9ZnVuY3Rpb24oKXthZygpJiYoYS5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLGIsITEpLGMoKSl9O2EuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixiLCExKX0pKS5zKGZ1bmN0aW9uKGMpe2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixiLCExKTt0aHJvdyBjO30pfVxuZnVuY3Rpb24gY2coYSl7dHJ5e3ZhciBiPW5ldyBEYXRlKHBhcnNlSW50KGEsMTApKTtpZighaXNOYU4oYi5nZXRUaW1lKCkpJiYhL1teMC05XS8udGVzdChhKSlyZXR1cm4gYi50b1VUQ1N0cmluZygpfWNhdGNoKGMpe31yZXR1cm4gbnVsbH07dmFyIGRnPXt9O3ZhciBlZzt0cnl7dmFyIGZnPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShmZyxcImFiY2RcIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6MX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShmZyxcImFiY2RcIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6Mn0pO2VnPTI9PWZnLmFiY2R9Y2F0Y2goYSl7ZWc9ITF9ZnVuY3Rpb24gTShhLGIsYyl7ZWc/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6Y30pOmFbYl09Y31mdW5jdGlvbiBnZyhhLGIpe2lmKGIpZm9yKHZhciBjIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShjKSYmTShhLGMsYltjXSl9ZnVuY3Rpb24gaGcoYSl7dmFyIGI9e307Z2coYixhKTtyZXR1cm4gYn1mdW5jdGlvbiBpZyhhKXt2YXIgYj17fSxjO2ZvcihjIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShjKSYmKGJbY109YVtjXSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBqZyhhLGIpe2lmKCFifHwhYi5sZW5ndGgpcmV0dXJuITA7aWYoIWEpcmV0dXJuITE7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWFbYltjXV07aWYodm9pZCAwPT09ZHx8bnVsbD09PWR8fFwiXCI9PT1kKXJldHVybiExfXJldHVybiEwfWZ1bmN0aW9uIGtnKGEpe3ZhciBiPWE7aWYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm51bGwhPWEpe2I9XCJsZW5ndGhcImluIGE/W106e307Zm9yKHZhciBjIGluIGEpTShiLGMsa2coYVtjXSkpfXJldHVybiBifTtmdW5jdGlvbiBsZyhhKXt2YXIgYj17fSxjPWFbbWddLGQ9YVtuZ107YT1hW29nXTtpZighY3x8IWEpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHByb3ZpZGVyIHVzZXIgaW5mbyFcIik7YltwZ109ZHx8bnVsbDtiW3FnXT1jO00odGhpcyxyZyxhKTtNKHRoaXMsc2csa2coYikpfXZhciBtZz1cImVtYWlsXCIsbmc9XCJuZXdFbWFpbFwiLG9nPVwicmVxdWVzdFR5cGVcIixxZz1cImVtYWlsXCIscGc9XCJmcm9tRW1haWxcIixzZz1cImRhdGFcIixyZz1cIm9wZXJhdGlvblwiO2Z1bmN0aW9uIE4oYSxiKXt0aGlzLmNvZGU9dGcrYTt0aGlzLm1lc3NhZ2U9Ynx8dWdbYV18fFwiXCJ9dChOLEVycm9yKTtOLnByb3RvdHlwZS5CPWZ1bmN0aW9uKCl7cmV0dXJue2NvZGU6dGhpcy5jb2RlLG1lc3NhZ2U6dGhpcy5tZXNzYWdlfX07Ti5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQigpfTtmdW5jdGlvbiB2ZyhhKXt2YXIgYj1hJiZhLmNvZGU7cmV0dXJuIGI/bmV3IE4oYi5zdWJzdHJpbmcodGcubGVuZ3RoKSxhLm1lc3NhZ2UpOm51bGx9XG52YXIgdGc9XCJhdXRoL1wiLHVnPXtcImFyZ3VtZW50LWVycm9yXCI6XCJcIixcImFwcC1ub3QtYXV0aG9yaXplZFwiOlwiVGhpcyBhcHAsIGlkZW50aWZpZWQgYnkgdGhlIGRvbWFpbiB3aGVyZSBpdCdzIGhvc3RlZCwgaXMgbm90IGF1dGhvcml6ZWQgdG8gdXNlIEZpcmViYXNlIEF1dGhlbnRpY2F0aW9uIHdpdGggdGhlIHByb3ZpZGVkIEFQSSBrZXkuIFJldmlldyB5b3VyIGtleSBjb25maWd1cmF0aW9uIGluIHRoZSBHb29nbGUgQVBJIGNvbnNvbGUuXCIsXCJhcHAtbm90LWluc3RhbGxlZFwiOlwiVGhlIHJlcXVlc3RlZCBtb2JpbGUgYXBwbGljYXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgaWRlbnRpZmllciAoQW5kcm9pZCBwYWNrYWdlIG5hbWUgb3IgaU9TIGJ1bmRsZSBJRCkgcHJvdmlkZWQgaXMgbm90IGluc3RhbGxlZCBvbiB0aGlzIGRldmljZS5cIixcImNhcHRjaGEtY2hlY2stZmFpbGVkXCI6XCJUaGUgcmVDQVBUQ0hBIHJlc3BvbnNlIHRva2VuIHByb3ZpZGVkIGlzIGVpdGhlciBpbnZhbGlkLCBleHBpcmVkLCBhbHJlYWR5IHVzZWQgb3IgdGhlIGRvbWFpbiBhc3NvY2lhdGVkIHdpdGggaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGxpc3Qgb2Ygd2hpdGVsaXN0ZWQgZG9tYWlucy5cIixcblwiY29kZS1leHBpcmVkXCI6XCJUaGUgU01TIGNvZGUgaGFzIGV4cGlyZWQuIFBsZWFzZSByZS1zZW5kIHRoZSB2ZXJpZmljYXRpb24gY29kZSB0byB0cnkgYWdhaW4uXCIsXCJjb3Jkb3ZhLW5vdC1yZWFkeVwiOlwiQ29yZG92YSBmcmFtZXdvcmsgaXMgbm90IHJlYWR5LlwiLFwiY29ycy11bnN1cHBvcnRlZFwiOlwiVGhpcyBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuXCIsXCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCI6XCJUaGlzIGNyZWRlbnRpYWwgaXMgYWxyZWFkeSBhc3NvY2lhdGVkIHdpdGggYSBkaWZmZXJlbnQgdXNlciBhY2NvdW50LlwiLFwiY3VzdG9tLXRva2VuLW1pc21hdGNoXCI6XCJUaGUgY3VzdG9tIHRva2VuIGNvcnJlc3BvbmRzIHRvIGEgZGlmZmVyZW50IGF1ZGllbmNlLlwiLFwicmVxdWlyZXMtcmVjZW50LWxvZ2luXCI6XCJUaGlzIG9wZXJhdGlvbiBpcyBzZW5zaXRpdmUgYW5kIHJlcXVpcmVzIHJlY2VudCBhdXRoZW50aWNhdGlvbi4gTG9nIGluIGFnYWluIGJlZm9yZSByZXRyeWluZyB0aGlzIHJlcXVlc3QuXCIsXG5cImR5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkXCI6XCJQbGVhc2UgYWN0aXZhdGUgRHluYW1pYyBMaW5rcyBpbiB0aGUgRmlyZWJhc2UgQ29uc29sZSBhbmQgYWdyZWUgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zLlwiLFwiZW1haWwtYWxyZWFkeS1pbi11c2VcIjpcIlRoZSBlbWFpbCBhZGRyZXNzIGlzIGFscmVhZHkgaW4gdXNlIGJ5IGFub3RoZXIgYWNjb3VudC5cIixcImV4cGlyZWQtYWN0aW9uLWNvZGVcIjpcIlRoZSBhY3Rpb24gY29kZSBoYXMgZXhwaXJlZC4gXCIsXCJjYW5jZWxsZWQtcG9wdXAtcmVxdWVzdFwiOlwiVGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gY2FuY2VsbGVkIGR1ZSB0byBhbm90aGVyIGNvbmZsaWN0aW5nIHBvcHVwIGJlaW5nIG9wZW5lZC5cIixcImludGVybmFsLWVycm9yXCI6XCJBbiBpbnRlcm5hbCBlcnJvciBoYXMgb2NjdXJyZWQuXCIsXCJpbnZhbGlkLWFwcC1jcmVkZW50aWFsXCI6XCJUaGUgcGhvbmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgY29udGFpbnMgYW4gaW52YWxpZCBhcHBsaWNhdGlvbiB2ZXJpZmllci4gVGhlIHJlQ0FQVENIQSB0b2tlbiByZXNwb25zZSBpcyBlaXRoZXIgaW52YWxpZCBvciBleHBpcmVkLlwiLFxuXCJpbnZhbGlkLWFwcC1pZFwiOlwiVGhlIG1vYmlsZSBhcHAgaWRlbnRpZmllciBpcyBub3QgcmVnaXN0ZWQgZm9yIHRoZSBjdXJyZW50IHByb2plY3QuXCIsXCJpbnZhbGlkLXVzZXItdG9rZW5cIjpcIlRoZSB1c2VyJ3MgY3JlZGVudGlhbCBpcyBubyBsb25nZXIgdmFsaWQuIFRoZSB1c2VyIG11c3Qgc2lnbiBpbiBhZ2Fpbi5cIixcImludmFsaWQtYXV0aC1ldmVudFwiOlwiQW4gaW50ZXJuYWwgZXJyb3IgaGFzIG9jY3VycmVkLlwiLFwiaW52YWxpZC12ZXJpZmljYXRpb24tY29kZVwiOlwiVGhlIFNNUyB2ZXJpZmljYXRpb24gY29kZSB1c2VkIHRvIGNyZWF0ZSB0aGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIGlzIGludmFsaWQuIFBsZWFzZSByZXNlbmQgdGhlIHZlcmlmaWNhdGlvbiBjb2RlIHNtcyBhbmQgYmUgc3VyZSB1c2UgdGhlIHZlcmlmaWNhdGlvbiBjb2RlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLlwiLFwiaW52YWxpZC1jb250aW51ZS11cmlcIjpcIlRoZSBjb250aW51ZSBVUkwgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QgaXMgaW52YWxpZC5cIixcblwiaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIjpcIlRoZSBmb2xsb3dpbmcgQ29yZG92YSBwbHVnaW5zIG11c3QgYmUgaW5zdGFsbGVkIHRvIGVuYWJsZSBPQXV0aCBzaWduLWluOiBjb3Jkb3ZhLXBsdWdpbi1idWlsZGluZm8sIGNvcmRvdmEtdW5pdmVyc2FsLWxpbmtzLXBsdWdpbiwgY29yZG92YS1wbHVnaW4tYnJvd3NlcnRhYiwgY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyIGFuZCBjb3Jkb3ZhLXBsdWdpbi1jdXN0b211cmxzY2hlbWUuXCIsXCJpbnZhbGlkLWN1c3RvbS10b2tlblwiOlwiVGhlIGN1c3RvbSB0b2tlbiBmb3JtYXQgaXMgaW5jb3JyZWN0LiBQbGVhc2UgY2hlY2sgdGhlIGRvY3VtZW50YXRpb24uXCIsXCJpbnZhbGlkLWVtYWlsXCI6XCJUaGUgZW1haWwgYWRkcmVzcyBpcyBiYWRseSBmb3JtYXR0ZWQuXCIsXCJpbnZhbGlkLWFwaS1rZXlcIjpcIllvdXIgQVBJIGtleSBpcyBpbnZhbGlkLCBwbGVhc2UgY2hlY2sgeW91IGhhdmUgY29waWVkIGl0IGNvcnJlY3RseS5cIixcImludmFsaWQtY2VydC1oYXNoXCI6XCJUaGUgU0hBLTEgY2VydGlmaWNhdGUgaGFzaCBwcm92aWRlZCBpcyBpbnZhbGlkLlwiLFxuXCJpbnZhbGlkLWNyZWRlbnRpYWxcIjpcIlRoZSBzdXBwbGllZCBhdXRoIGNyZWRlbnRpYWwgaXMgbWFsZm9ybWVkIG9yIGhhcyBleHBpcmVkLlwiLFwiaW52YWxpZC1wZXJzaXN0ZW5jZS10eXBlXCI6XCJUaGUgc3BlY2lmaWVkIHBlcnNpc3RlbmNlIHR5cGUgaXMgaW52YWxpZC4gSXQgY2FuIG9ubHkgYmUgbG9jYWwsIHNlc3Npb24gb3Igbm9uZS5cIixcImludmFsaWQtbWVzc2FnZS1wYXlsb2FkXCI6XCJUaGUgZW1haWwgdGVtcGxhdGUgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gaXRzIG1lc3NhZ2UuIFBsZWFzZSBmaXggYnkgZ29pbmcgdG8gdGhlIEF1dGggZW1haWwgdGVtcGxhdGVzIHNlY3Rpb24gaW4gdGhlIEZpcmViYXNlIENvbnNvbGUuXCIsXCJpbnZhbGlkLW9hdXRoLXByb3ZpZGVyXCI6XCJFbWFpbEF1dGhQcm92aWRlciBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIG9wZXJhdGlvbi4gVGhpcyBvcGVyYXRpb24gb25seSBzdXBwb3J0cyBPQXV0aCBwcm92aWRlcnMuXCIsXG5cImludmFsaWQtb2F1dGgtY2xpZW50LWlkXCI6XCJUaGUgT0F1dGggY2xpZW50IElEIHByb3ZpZGVkIGlzIGVpdGhlciBpbnZhbGlkIG9yIGRvZXMgbm90IG1hdGNoIHRoZSBzcGVjaWZpZWQgQVBJIGtleS5cIixcInVuYXV0aG9yaXplZC1kb21haW5cIjpcIlRoaXMgZG9tYWluIGlzIG5vdCBhdXRob3JpemVkIGZvciBPQXV0aCBvcGVyYXRpb25zIGZvciB5b3VyIEZpcmViYXNlIHByb2plY3QuIEVkaXQgdGhlIGxpc3Qgb2YgYXV0aG9yaXplZCBkb21haW5zIGZyb20gdGhlIEZpcmViYXNlIGNvbnNvbGUuXCIsXCJpbnZhbGlkLWFjdGlvbi1jb2RlXCI6XCJUaGUgYWN0aW9uIGNvZGUgaXMgaW52YWxpZC4gVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBjb2RlIGlzIG1hbGZvcm1lZCwgZXhwaXJlZCwgb3IgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiLFwid3JvbmctcGFzc3dvcmRcIjpcIlRoZSBwYXNzd29yZCBpcyBpbnZhbGlkIG9yIHRoZSB1c2VyIGRvZXMgbm90IGhhdmUgYSBwYXNzd29yZC5cIixcImludmFsaWQtcGhvbmUtbnVtYmVyXCI6XCJUaGUgZm9ybWF0IG9mIHRoZSBwaG9uZSBudW1iZXIgcHJvdmlkZWQgaXMgaW5jb3JyZWN0LiBQbGVhc2UgZW50ZXIgdGhlIHBob25lIG51bWJlciBpbiBhIGZvcm1hdCB0aGF0IGNhbiBiZSBwYXJzZWQgaW50byBFLjE2NCBmb3JtYXQuIEUuMTY0IHBob25lIG51bWJlcnMgYXJlIHdyaXR0ZW4gaW4gdGhlIGZvcm1hdCBbK11bY291bnRyeSBjb2RlXVtzdWJzY3JpYmVyIG51bWJlciBpbmNsdWRpbmcgYXJlYSBjb2RlXS5cIixcblwiaW52YWxpZC1yZWNpcGllbnQtZW1haWxcIjpcIlRoZSBlbWFpbCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYWN0aW9uIGZhaWxlZCB0byBzZW5kIGFzIHRoZSBwcm92aWRlZCByZWNpcGllbnQgZW1haWwgYWRkcmVzcyBpcyBpbnZhbGlkLlwiLFwiaW52YWxpZC1zZW5kZXJcIjpcIlRoZSBlbWFpbCB0ZW1wbGF0ZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYWN0aW9uIGNvbnRhaW5zIGFuIGludmFsaWQgc2VuZGVyIGVtYWlsIG9yIG5hbWUuIFBsZWFzZSBmaXggYnkgZ29pbmcgdG8gdGhlIEF1dGggZW1haWwgdGVtcGxhdGVzIHNlY3Rpb24gaW4gdGhlIEZpcmViYXNlIENvbnNvbGUuXCIsXCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1pZFwiOlwiVGhlIHZlcmlmaWNhdGlvbiBJRCB1c2VkIHRvIGNyZWF0ZSB0aGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIGlzIGludmFsaWQuXCIsXCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIjpcIkFuIEFuZHJvaWQgUGFja2FnZSBOYW1lIG11c3QgYmUgcHJvdmlkZWQgaWYgdGhlIEFuZHJvaWQgQXBwIGlzIHJlcXVpcmVkIHRvIGJlIGluc3RhbGxlZC5cIixcblwiYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkXCI6XCJCZSBzdXJlIHRvIGluY2x1ZGUgYXV0aERvbWFpbiB3aGVuIGNhbGxpbmcgZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcCgpLCBieSBmb2xsb3dpbmcgdGhlIGluc3RydWN0aW9ucyBpbiB0aGUgRmlyZWJhc2UgY29uc29sZS5cIixcIm1pc3NpbmctYXBwLWNyZWRlbnRpYWxcIjpcIlRoZSBwaG9uZSB2ZXJpZmljYXRpb24gcmVxdWVzdCBpcyBtaXNzaW5nIGFuIGFwcGxpY2F0aW9uIHZlcmlmaWVyIGFzc2VydGlvbi4gQSByZUNBUFRDSEEgcmVzcG9uc2UgdG9rZW4gbmVlZHMgdG8gYmUgcHJvdmlkZWQuXCIsXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlXCI6XCJUaGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIHdhcyBjcmVhdGVkIHdpdGggYW4gZW1wdHkgU01TIHZlcmlmaWNhdGlvbiBjb2RlLlwiLFwibWlzc2luZy1jb250aW51ZS11cmlcIjpcIkEgY29udGludWUgVVJMIG11c3QgYmUgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QuXCIsXCJtaXNzaW5nLWlmcmFtZS1zdGFydFwiOlwiQW4gaW50ZXJuYWwgZXJyb3IgaGFzIG9jY3VycmVkLlwiLFxuXCJtaXNzaW5nLWlvcy1idW5kbGUtaWRcIjpcIkFuIGlPUyBCdW5kbGUgSUQgbXVzdCBiZSBwcm92aWRlZCBpZiBhbiBBcHAgU3RvcmUgSUQgaXMgcHJvdmlkZWQuXCIsXCJtaXNzaW5nLXBob25lLW51bWJlclwiOlwiVG8gc2VuZCB2ZXJpZmljYXRpb24gY29kZXMsIHByb3ZpZGUgYSBwaG9uZSBudW1iZXIgZm9yIHRoZSByZWNpcGllbnQuXCIsXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1pZFwiOlwiVGhlIHBob25lIGF1dGggY3JlZGVudGlhbCB3YXMgY3JlYXRlZCB3aXRoIGFuIGVtcHR5IHZlcmlmaWNhdGlvbiBJRC5cIixcImFwcC1kZWxldGVkXCI6XCJUaGlzIGluc3RhbmNlIG9mIEZpcmViYXNlQXBwIGhhcyBiZWVuIGRlbGV0ZWQuXCIsXCJhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsXCI6XCJBbiBhY2NvdW50IGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIHNhbWUgZW1haWwgYWRkcmVzcyBidXQgZGlmZmVyZW50IHNpZ24taW4gY3JlZGVudGlhbHMuIFNpZ24gaW4gdXNpbmcgYSBwcm92aWRlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBlbWFpbCBhZGRyZXNzLlwiLFxuXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCI6XCJBIG5ldHdvcmsgZXJyb3IgKHN1Y2ggYXMgdGltZW91dCwgaW50ZXJydXB0ZWQgY29ubmVjdGlvbiBvciB1bnJlYWNoYWJsZSBob3N0KSBoYXMgb2NjdXJyZWQuXCIsXCJuby1hdXRoLWV2ZW50XCI6XCJBbiBpbnRlcm5hbCBlcnJvciBoYXMgb2NjdXJyZWQuXCIsXCJuby1zdWNoLXByb3ZpZGVyXCI6XCJVc2VyIHdhcyBub3QgbGlua2VkIHRvIGFuIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gcHJvdmlkZXIuXCIsXCJvcGVyYXRpb24tbm90LWFsbG93ZWRcIjpcIlRoZSBnaXZlbiBzaWduLWluIHByb3ZpZGVyIGlzIGRpc2FibGVkIGZvciB0aGlzIEZpcmViYXNlIHByb2plY3QuIEVuYWJsZSBpdCBpbiB0aGUgRmlyZWJhc2UgY29uc29sZSwgdW5kZXIgdGhlIHNpZ24taW4gbWV0aG9kIHRhYiBvZiB0aGUgQXV0aCBzZWN0aW9uLlwiLFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiOidUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBlbnZpcm9ubWVudCB0aGlzIGFwcGxpY2F0aW9uIGlzIHJ1bm5pbmcgb24uIFwibG9jYXRpb24ucHJvdG9jb2xcIiBtdXN0IGJlIGh0dHAsIGh0dHBzIG9yIGNocm9tZS1leHRlbnNpb24gYW5kIHdlYiBzdG9yYWdlIG11c3QgYmUgZW5hYmxlZC4nLFxuXCJwb3B1cC1ibG9ja2VkXCI6XCJVbmFibGUgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBwb3B1cC4gSXQgbWF5IGhhdmUgYmVlbiBibG9ja2VkIGJ5IHRoZSBicm93c2VyLlwiLFwicG9wdXAtY2xvc2VkLWJ5LXVzZXJcIjpcIlRoZSBwb3B1cCBoYXMgYmVlbiBjbG9zZWQgYnkgdGhlIHVzZXIgYmVmb3JlIGZpbmFsaXppbmcgdGhlIG9wZXJhdGlvbi5cIixcInByb3ZpZGVyLWFscmVhZHktbGlua2VkXCI6XCJVc2VyIGNhbiBvbmx5IGJlIGxpbmtlZCB0byBvbmUgaWRlbnRpdHkgZm9yIHRoZSBnaXZlbiBwcm92aWRlci5cIixcInF1b3RhLWV4Y2VlZGVkXCI6XCJUaGUgcHJvamVjdCdzIHF1b3RhIGZvciB0aGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBleGNlZWRlZC5cIixcInJlZGlyZWN0LWNhbmNlbGxlZC1ieS11c2VyXCI6XCJUaGUgcmVkaXJlY3Qgb3BlcmF0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCBieSB0aGUgdXNlciBiZWZvcmUgZmluYWxpemluZy5cIixcInJlZGlyZWN0LW9wZXJhdGlvbi1wZW5kaW5nXCI6XCJBIHJlZGlyZWN0IHNpZ24taW4gb3BlcmF0aW9uIGlzIGFscmVhZHkgcGVuZGluZy5cIixcbnRpbWVvdXQ6XCJUaGUgb3BlcmF0aW9uIGhhcyB0aW1lZCBvdXQuXCIsXCJ1c2VyLXRva2VuLWV4cGlyZWRcIjpcIlRoZSB1c2VyJ3MgY3JlZGVudGlhbCBpcyBubyBsb25nZXIgdmFsaWQuIFRoZSB1c2VyIG11c3Qgc2lnbiBpbiBhZ2Fpbi5cIixcInRvby1tYW55LXJlcXVlc3RzXCI6XCJXZSBoYXZlIGJsb2NrZWQgYWxsIHJlcXVlc3RzIGZyb20gdGhpcyBkZXZpY2UgZHVlIHRvIHVudXN1YWwgYWN0aXZpdHkuIFRyeSBhZ2FpbiBsYXRlci5cIixcInVuYXV0aG9yaXplZC1jb250aW51ZS11cmlcIjpcIlRoZSBkb21haW4gb2YgdGhlIGNvbnRpbnVlIFVSTCBpcyBub3Qgd2hpdGVsaXN0ZWQuICBQbGVhc2Ugd2hpdGVsaXN0IHRoZSBkb21haW4gaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUuXCIsXCJ1bnN1cHBvcnRlZC1wZXJzaXN0ZW5jZS10eXBlXCI6XCJUaGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzcGVjaWZpZWQgcGVyc2lzdGVuY2UgdHlwZS5cIixcInVzZXItY2FuY2VsbGVkXCI6XCJVc2VyIGRpZCBub3QgZ3JhbnQgeW91ciBhcHBsaWNhdGlvbiB0aGUgcGVybWlzc2lvbnMgaXQgcmVxdWVzdGVkLlwiLFxuXCJ1c2VyLW5vdC1mb3VuZFwiOlwiVGhlcmUgaXMgbm8gdXNlciByZWNvcmQgY29ycmVzcG9uZGluZyB0byB0aGlzIGlkZW50aWZpZXIuIFRoZSB1c2VyIG1heSBoYXZlIGJlZW4gZGVsZXRlZC5cIixcInVzZXItZGlzYWJsZWRcIjpcIlRoZSB1c2VyIGFjY291bnQgaGFzIGJlZW4gZGlzYWJsZWQgYnkgYW4gYWRtaW5pc3RyYXRvci5cIixcInVzZXItbWlzbWF0Y2hcIjpcIlRoZSBzdXBwbGllZCBjcmVkZW50aWFscyBkbyBub3QgY29ycmVzcG9uZCB0byB0aGUgcHJldmlvdXNseSBzaWduZWQgaW4gdXNlci5cIixcInVzZXItc2lnbmVkLW91dFwiOlwiXCIsXCJ3ZWFrLXBhc3N3b3JkXCI6XCJUaGUgcGFzc3dvcmQgbXVzdCBiZSA2IGNoYXJhY3RlcnMgbG9uZyBvciBtb3JlLlwiLFwid2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWRcIjpcIlRoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkIG9yIDNyZCBwYXJ0eSBjb29raWVzIGFuZCBkYXRhIG1heSBiZSBkaXNhYmxlZC5cIn07ZnVuY3Rpb24gd2coYSl7dmFyIGI9YVt4Z107aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiKXRocm93IG5ldyBOKFwibWlzc2luZy1jb250aW51ZS11cmlcIik7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBifHxcInN0cmluZ1wiPT09dHlwZW9mIGImJiFiLmxlbmd0aCl0aHJvdyBuZXcgTihcImludmFsaWQtY29udGludWUtdXJpXCIpO3RoaXMuaD1iO3RoaXMuYz10aGlzLmE9bnVsbDt0aGlzLmc9ITE7dmFyIGM9YVt5Z107aWYoYyYmXCJvYmplY3RcIj09PXR5cGVvZiBjKXtiPWNbemddO3ZhciBkPWNbQWddO2M9Y1tCZ107aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBiJiZiLmxlbmd0aCl7dGhpcy5hPWI7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkJiZcImJvb2xlYW5cIiE9PXR5cGVvZiBkKXRocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixBZytcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgYm9vbGVhbiB3aGVuIHNwZWNpZmllZC5cIik7dGhpcy5nPSEhZDtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGMmJihcInN0cmluZ1wiIT09XG50eXBlb2YgY3x8XCJzdHJpbmdcIj09PXR5cGVvZiBjJiYhYy5sZW5ndGgpKXRocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixCZytcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZyB3aGVuIHNwZWNpZmllZC5cIik7dGhpcy5jPWN8fG51bGx9ZWxzZXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGIpdGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLHpnK1wiIHByb3BlcnR5IG11c3QgYmUgYSBub24gZW1wdHkgc3RyaW5nIHdoZW4gc3BlY2lmaWVkLlwiKTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGR8fFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYyl0aHJvdyBuZXcgTihcIm1pc3NpbmctYW5kcm9pZC1wa2ctbmFtZVwiKTt9fWVsc2UgaWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjKXRocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIix5ZytcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uIG51bGwgb2JqZWN0IHdoZW4gc3BlY2lmaWVkLlwiKTt0aGlzLmI9bnVsbDtpZigoYj1hW0NnXSkmJlwib2JqZWN0XCI9PT1cbnR5cGVvZiBiKWlmKGI9YltEZ10sXCJzdHJpbmdcIj09PXR5cGVvZiBiJiZiLmxlbmd0aCl0aGlzLmI9YjtlbHNle2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYil0aHJvdyBuZXcgTihcImFyZ3VtZW50LWVycm9yXCIsRGcrXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmcgd2hlbiBzcGVjaWZpZWQuXCIpO31lbHNlIGlmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYil0aHJvdyBuZXcgTihcImFyZ3VtZW50LWVycm9yXCIsQ2crXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbiBudWxsIG9iamVjdCB3aGVuIHNwZWNpZmllZC5cIik7YT1hW0VnXTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGEmJlwiYm9vbGVhblwiIT09dHlwZW9mIGEpdGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLEVnK1wiIHByb3BlcnR5IG11c3QgYmUgYSBib29sZWFuIHdoZW4gc3BlY2lmaWVkLlwiKTtpZigodGhpcy5mPSEhYSkmJiF0aGlzLmImJiF0aGlzLmEpdGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLEVnK1wiIHByb3BlcnR5IGNhbid0IGJlIHRydWUgd2hlbiBubyBtb2JpbGUgYXBwbGljYXRpb24gaXMgcHJvdmlkZWQuXCIpO1xufXZhciB5Zz1cImFuZHJvaWRcIixFZz1cImhhbmRsZUNvZGVJbkFwcFwiLENnPVwiaU9TXCIseGc9XCJ1cmxcIixBZz1cImluc3RhbGxBcHBcIixCZz1cIm1pbmltdW1WZXJzaW9uXCIsemc9XCJwYWNrYWdlTmFtZVwiLERnPVwiYnVuZGxlSWRcIjtmdW5jdGlvbiBGZyhhKXt2YXIgYj17fTtiLmNvbnRpbnVlVXJsPWEuaDtiLmNhbkhhbmRsZUNvZGVJbkFwcD1hLmY7aWYoYi5hbmRyb2lkUGFja2FnZU5hbWU9YS5hKWIuYW5kcm9pZE1pbmltdW1WZXJzaW9uPWEuYyxiLmFuZHJvaWRJbnN0YWxsQXBwPWEuZztiLmlPU0J1bmRsZUlkPWEuYjtmb3IodmFyIGMgaW4gYiludWxsPT09YltjXSYmZGVsZXRlIGJbY107cmV0dXJuIGJ9O2Z1bmN0aW9uIEdnKGEpe3RoaXMuYj1hLnN1YjtuYSgpO3RoaXMuYT1hLnByb3ZpZGVyX2lkfHxhLmZpcmViYXNlJiZhLmZpcmViYXNlLnNpZ25faW5fcHJvdmlkZXJ8fG51bGx9ZnVuY3Rpb24gSGcoYSl7YT1hLnNwbGl0KFwiLlwiKTtpZigzIT1hLmxlbmd0aClyZXR1cm4gbnVsbDthPWFbMV07Zm9yKHZhciBiPSg0LWEubGVuZ3RoJTQpJTQsYz0wO2M8YjtjKyspYSs9XCIuXCI7dHJ5e3ZhciBkPUpTT04ucGFyc2UoS2QoYSkpO2lmKGQuc3ViJiZkLmlzcyYmZC5hdWQmJmQuZXhwKXJldHVybiBuZXcgR2coZCl9Y2F0Y2goZSl7fXJldHVybiBudWxsfTt2YXIgSWc9XCJvYXV0aF9jb25zdW1lcl9rZXkgb2F1dGhfbm9uY2Ugb2F1dGhfc2lnbmF0dXJlIG9hdXRoX3NpZ25hdHVyZV9tZXRob2Qgb2F1dGhfdGltZXN0YW1wIG9hdXRoX3Rva2VuIG9hdXRoX3ZlcnNpb25cIi5zcGxpdChcIiBcIiksSmc9W1wiY2xpZW50X2lkXCIsXCJyZXNwb25zZV90eXBlXCIsXCJzY29wZVwiLFwicmVkaXJlY3RfdXJpXCIsXCJzdGF0ZVwiXSxLZz17RGM6e01hOlwibG9jYWxlXCIsemE6NTAwLHlhOjYwMCxOYTpcImZhY2Vib29rLmNvbVwiLCRhOkpnfSxGYzp7TWE6bnVsbCx6YTo1MDAseWE6NjIwLE5hOlwiZ2l0aHViLmNvbVwiLCRhOkpnfSxHYzp7TWE6XCJobFwiLHphOjUxNSx5YTo2ODAsTmE6XCJnb29nbGUuY29tXCIsJGE6Smd9LE1jOntNYTpcImxhbmdcIix6YTo0ODUseWE6NzA1LE5hOlwidHdpdHRlci5jb21cIiwkYTpJZ319O2Z1bmN0aW9uIExnKGEpe2Zvcih2YXIgYiBpbiBLZylpZihLZ1tiXS5OYT09YSlyZXR1cm4gS2dbYl07cmV0dXJuIG51bGx9O2Z1bmN0aW9uIE1nKGEpe3ZhciBiPXt9O2JbXCJmYWNlYm9vay5jb21cIl09Tmc7YltcImdvb2dsZS5jb21cIl09T2c7YltcImdpdGh1Yi5jb21cIl09UGc7YltcInR3aXR0ZXIuY29tXCJdPVFnO3ZhciBjPWEmJmFbUmddO3RyeXtpZihjKXJldHVybiBiW2NdP25ldyBiW2NdKGEpOm5ldyBTZyhhKTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGFbVGddKXJldHVybiBuZXcgVWcoYSl9Y2F0Y2goZCl7fXJldHVybiBudWxsfXZhciBUZz1cImlkVG9rZW5cIixSZz1cInByb3ZpZGVySWRcIjtmdW5jdGlvbiBVZyhhKXt2YXIgYj1hW1JnXTtpZighYiYmYVtUZ10pe3ZhciBjPUhnKGFbVGddKTtjJiZjLmEmJihiPWMuYSl9aWYoIWIpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGFkZGl0aW9uYWwgdXNlciBpbmZvIVwiKTthPSEhYS5pc05ld1VzZXI7TSh0aGlzLFwicHJvdmlkZXJJZFwiLGIpO00odGhpcyxcImlzTmV3VXNlclwiLGEpfVxuZnVuY3Rpb24gU2coYSl7VWcuY2FsbCh0aGlzLGEpO2E9V2YoYS5yYXdVc2VySW5mb3x8XCJ7fVwiKTtNKHRoaXMsXCJwcm9maWxlXCIsa2coYXx8e30pKX10KFNnLFVnKTtmdW5jdGlvbiBOZyhhKXtTZy5jYWxsKHRoaXMsYSk7aWYoXCJmYWNlYm9vay5jb21cIiE9dGhpcy5wcm92aWRlcklkKXRocm93IEVycm9yKFwiSW52YWxpZCBwcm92aWRlciBJRCFcIik7fXQoTmcsU2cpO2Z1bmN0aW9uIFBnKGEpe1NnLmNhbGwodGhpcyxhKTtpZihcImdpdGh1Yi5jb21cIiE9dGhpcy5wcm92aWRlcklkKXRocm93IEVycm9yKFwiSW52YWxpZCBwcm92aWRlciBJRCFcIik7TSh0aGlzLFwidXNlcm5hbWVcIix0aGlzLnByb2ZpbGUmJnRoaXMucHJvZmlsZS5sb2dpbnx8bnVsbCl9dChQZyxTZyk7ZnVuY3Rpb24gT2coYSl7U2cuY2FsbCh0aGlzLGEpO2lmKFwiZ29vZ2xlLmNvbVwiIT10aGlzLnByb3ZpZGVySWQpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHByb3ZpZGVyIElEIVwiKTt9dChPZyxTZyk7XG5mdW5jdGlvbiBRZyhhKXtTZy5jYWxsKHRoaXMsYSk7aWYoXCJ0d2l0dGVyLmNvbVwiIT10aGlzLnByb3ZpZGVySWQpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHByb3ZpZGVyIElEIVwiKTtNKHRoaXMsXCJ1c2VybmFtZVwiLGEuc2NyZWVuTmFtZXx8bnVsbCl9dChRZyxTZyk7ZnVuY3Rpb24gVmcoYSxiKXtyZXR1cm4gYS50aGVuKGZ1bmN0aW9uKGEpe2lmKGFbT10pe3ZhciBjPUhnKGFbT10pO2lmKCFjfHxiIT1jLmIpdGhyb3cgbmV3IE4oXCJ1c2VyLW1pc21hdGNoXCIpO3JldHVybiBhfXRocm93IG5ldyBOKFwidXNlci1taXNtYXRjaFwiKTt9KS5zKGZ1bmN0aW9uKGEpe3Rocm93IGEmJmEuY29kZSYmYS5jb2RlPT10ZytcInVzZXItbm90LWZvdW5kXCI/bmV3IE4oXCJ1c2VyLW1pc21hdGNoXCIpOmE7fSl9XG5mdW5jdGlvbiBXZyhhLGIpe2lmKGIuaWRUb2tlbnx8Yi5hY2Nlc3NUb2tlbiliLmlkVG9rZW4mJk0odGhpcyxcImlkVG9rZW5cIixiLmlkVG9rZW4pLGIuYWNjZXNzVG9rZW4mJk0odGhpcyxcImFjY2Vzc1Rva2VuXCIsYi5hY2Nlc3NUb2tlbik7ZWxzZSBpZihiLm9hdXRoVG9rZW4mJmIub2F1dGhUb2tlblNlY3JldClNKHRoaXMsXCJhY2Nlc3NUb2tlblwiLGIub2F1dGhUb2tlbiksTSh0aGlzLFwic2VjcmV0XCIsYi5vYXV0aFRva2VuU2VjcmV0KTtlbHNlIHRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIixcImZhaWxlZCB0byBjb25zdHJ1Y3QgYSBjcmVkZW50aWFsXCIpO00odGhpcyxcInByb3ZpZGVySWRcIixhKX1XZy5wcm90b3R5cGUud2E9ZnVuY3Rpb24oYSl7cmV0dXJuIFhnKGEsWWcodGhpcykpfTtXZy5wcm90b3R5cGUuYj1mdW5jdGlvbihhLGIpe3ZhciBjPVlnKHRoaXMpO2MuaWRUb2tlbj1iO3JldHVybiBaZyhhLGMpfTtcbldnLnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEsYil7dmFyIGM9WWcodGhpcyk7cmV0dXJuIFZnKCRnKGEsYyksYil9O2Z1bmN0aW9uIFlnKGEpe3ZhciBiPXt9O2EuaWRUb2tlbiYmKGIuaWRfdG9rZW49YS5pZFRva2VuKTthLmFjY2Vzc1Rva2VuJiYoYi5hY2Nlc3NfdG9rZW49YS5hY2Nlc3NUb2tlbik7YS5zZWNyZXQmJihiLm9hdXRoX3Rva2VuX3NlY3JldD1hLnNlY3JldCk7Yi5wcm92aWRlcklkPWEucHJvdmlkZXJJZDtyZXR1cm57cG9zdEJvZHk6SWUoYikudG9TdHJpbmcoKSxyZXF1ZXN0VXJpOlwiaHR0cDovL2xvY2FsaG9zdFwifX1cbldnLnByb3RvdHlwZS5CPWZ1bmN0aW9uKCl7dmFyIGE9e3Byb3ZpZGVySWQ6dGhpcy5wcm92aWRlcklkfTt0aGlzLmlkVG9rZW4mJihhLm9hdXRoSWRUb2tlbj10aGlzLmlkVG9rZW4pO3RoaXMuYWNjZXNzVG9rZW4mJihhLm9hdXRoQWNjZXNzVG9rZW49dGhpcy5hY2Nlc3NUb2tlbik7dGhpcy5zZWNyZXQmJihhLm9hdXRoVG9rZW5TZWNyZXQ9dGhpcy5zZWNyZXQpO3JldHVybiBhfTtmdW5jdGlvbiBhaChhLGIpe3RoaXMubmM9Ynx8W107Z2codGhpcyx7cHJvdmlkZXJJZDphLGlzT0F1dGhQcm92aWRlcjohMH0pO3RoaXMucWI9e307dGhpcy5XYT0oTGcoYSl8fHt9KS5NYXx8bnVsbDt0aGlzLlVhPW51bGx9YWgucHJvdG90eXBlLkJhPWZ1bmN0aW9uKGEpe3RoaXMucWI9VWEoYSk7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIFAoYSl7YWguY2FsbCh0aGlzLGEsSmcpO3RoaXMuYT1bXX10KFAsYWgpO1xuUC5wcm90b3R5cGUuc2E9ZnVuY3Rpb24oYSl7SGEodGhpcy5hLGEpfHx0aGlzLmEucHVzaChhKTtyZXR1cm4gdGhpc307UC5wcm90b3R5cGUudmI9ZnVuY3Rpb24oKXtyZXR1cm4gTGEodGhpcy5hKX07UC5wcm90b3R5cGUuY3JlZGVudGlhbD1mdW5jdGlvbihhLGIpe2lmKCFhJiYhYil0aHJvdyBuZXcgTihcImFyZ3VtZW50LWVycm9yXCIsXCJjcmVkZW50aWFsIGZhaWxlZDogbXVzdCBwcm92aWRlIHRoZSBJRCB0b2tlbiBhbmQvb3IgdGhlIGFjY2VzcyB0b2tlbi5cIik7cmV0dXJuIG5ldyBXZyh0aGlzLnByb3ZpZGVySWQse2lkVG9rZW46YXx8bnVsbCxhY2Nlc3NUb2tlbjpifHxudWxsfSl9O2Z1bmN0aW9uIGJoKCl7UC5jYWxsKHRoaXMsXCJmYWNlYm9vay5jb21cIil9dChiaCxQKTtNKGJoLFwiUFJPVklERVJfSURcIixcImZhY2Vib29rLmNvbVwiKTtcbmZ1bmN0aW9uIGNoKGEpe2lmKCFhKXRocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixcImNyZWRlbnRpYWwgZmFpbGVkOiBleHBlY3RlZCAxIGFyZ3VtZW50ICh0aGUgT0F1dGggYWNjZXNzIHRva2VuKS5cIik7dmFyIGI9YTtxKGEpJiYoYj1hLmFjY2Vzc1Rva2VuKTtyZXR1cm4obmV3IGJoKS5jcmVkZW50aWFsKG51bGwsYil9ZnVuY3Rpb24gZGgoKXtQLmNhbGwodGhpcyxcImdpdGh1Yi5jb21cIil9dChkaCxQKTtNKGRoLFwiUFJPVklERVJfSURcIixcImdpdGh1Yi5jb21cIik7ZnVuY3Rpb24gZWgoYSl7aWYoIWEpdGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLFwiY3JlZGVudGlhbCBmYWlsZWQ6IGV4cGVjdGVkIDEgYXJndW1lbnQgKHRoZSBPQXV0aCBhY2Nlc3MgdG9rZW4pLlwiKTt2YXIgYj1hO3EoYSkmJihiPWEuYWNjZXNzVG9rZW4pO3JldHVybihuZXcgZGgpLmNyZWRlbnRpYWwobnVsbCxiKX1cbmZ1bmN0aW9uIGZoKCl7UC5jYWxsKHRoaXMsXCJnb29nbGUuY29tXCIpO3RoaXMuc2EoXCJwcm9maWxlXCIpfXQoZmgsUCk7TShmaCxcIlBST1ZJREVSX0lEXCIsXCJnb29nbGUuY29tXCIpO2Z1bmN0aW9uIGdoKGEsYil7dmFyIGM9YTtxKGEpJiYoYz1hLmlkVG9rZW4sYj1hLmFjY2Vzc1Rva2VuKTtyZXR1cm4obmV3IGZoKS5jcmVkZW50aWFsKGMsYil9ZnVuY3Rpb24gaGgoKXthaC5jYWxsKHRoaXMsXCJ0d2l0dGVyLmNvbVwiLElnKX10KGhoLGFoKTtNKGhoLFwiUFJPVklERVJfSURcIixcInR3aXR0ZXIuY29tXCIpO1xuZnVuY3Rpb24gaWgoYSxiKXt2YXIgYz1hO3EoYyl8fChjPXtvYXV0aFRva2VuOmEsb2F1dGhUb2tlblNlY3JldDpifSk7aWYoIWMub2F1dGhUb2tlbnx8IWMub2F1dGhUb2tlblNlY3JldCl0aHJvdyBuZXcgTihcImFyZ3VtZW50LWVycm9yXCIsXCJjcmVkZW50aWFsIGZhaWxlZDogZXhwZWN0ZWQgMiBhcmd1bWVudHMgKHRoZSBPQXV0aCBhY2Nlc3MgdG9rZW4gYW5kIHNlY3JldCkuXCIpO3JldHVybiBuZXcgV2coXCJ0d2l0dGVyLmNvbVwiLGMpfWZ1bmN0aW9uIGpoKGEsYil7dGhpcy5hPWE7dGhpcy5mPWI7TSh0aGlzLFwicHJvdmlkZXJJZFwiLFwicGFzc3dvcmRcIil9amgucHJvdG90eXBlLndhPWZ1bmN0aW9uKGEpe3JldHVybiBRKGEsa2gse2VtYWlsOnRoaXMuYSxwYXNzd29yZDp0aGlzLmZ9KX07amgucHJvdG90eXBlLmI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUShhLGxoLHtpZFRva2VuOmIsZW1haWw6dGhpcy5hLHBhc3N3b3JkOnRoaXMuZn0pfTtcbmpoLnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFZnKHRoaXMud2EoYSksYil9O2poLnByb3RvdHlwZS5CPWZ1bmN0aW9uKCl7cmV0dXJue2VtYWlsOnRoaXMuYSxwYXNzd29yZDp0aGlzLmZ9fTtmdW5jdGlvbiBtaCgpe2dnKHRoaXMse3Byb3ZpZGVySWQ6XCJwYXNzd29yZFwiLGlzT0F1dGhQcm92aWRlcjohMX0pfWdnKG1oLHtQUk9WSURFUl9JRDpcInBhc3N3b3JkXCJ9KTtmdW5jdGlvbiBuaChhKXtpZighKGEuUGEmJmEuT2F8fGEuRGEmJmEuWSkpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt0aGlzLmE9YTtNKHRoaXMsXCJwcm92aWRlcklkXCIsXCJwaG9uZVwiKX1uaC5wcm90b3R5cGUud2E9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuUWEob2godGhpcykpfTtuaC5wcm90b3R5cGUuYj1mdW5jdGlvbihhLGIpe3ZhciBjPW9oKHRoaXMpO2MuaWRUb2tlbj1iO3JldHVybiBRKGEscGgsYyl9O1xubmgucHJvdG90eXBlLmM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1vaCh0aGlzKTtjLm9wZXJhdGlvbj1cIlJFQVVUSFwiO2E9UShhLHFoLGMpO3JldHVybiBWZyhhLGIpfTtuaC5wcm90b3R5cGUuQj1mdW5jdGlvbigpe3ZhciBhPXtwcm92aWRlcklkOlwicGhvbmVcIn07dGhpcy5hLlBhJiYoYS52ZXJpZmljYXRpb25JZD10aGlzLmEuUGEpO3RoaXMuYS5PYSYmKGEudmVyaWZpY2F0aW9uQ29kZT10aGlzLmEuT2EpO3RoaXMuYS5EYSYmKGEudGVtcG9yYXJ5UHJvb2Y9dGhpcy5hLkRhKTt0aGlzLmEuWSYmKGEucGhvbmVOdW1iZXI9dGhpcy5hLlkpO3JldHVybiBhfTtmdW5jdGlvbiBvaChhKXtyZXR1cm4gYS5hLkRhJiZhLmEuWT97dGVtcG9yYXJ5UHJvb2Y6YS5hLkRhLHBob25lTnVtYmVyOmEuYS5ZfTp7c2Vzc2lvbkluZm86YS5hLlBhLGNvZGU6YS5hLk9hfX1cbmZ1bmN0aW9uIHJoKGEpe3RyeXt0aGlzLmE9YXx8ZmlyZWJhc2UuYXV0aCgpfWNhdGNoKGIpe3Rocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixcIkVpdGhlciBhbiBpbnN0YW5jZSBvZiBmaXJlYmFzZS5hdXRoLkF1dGggbXVzdCBiZSBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIGZpcmViYXNlLmF1dGguUGhvbmVBdXRoUHJvdmlkZXIgY29uc3RydWN0b3IsIG9yIHRoZSBkZWZhdWx0IGZpcmViYXNlIEFwcCBpbnN0YW5jZSBtdXN0IGJlIGluaXRpYWxpemVkIHZpYSBmaXJlYmFzZS5pbml0aWFsaXplQXBwKCkuXCIpO31nZyh0aGlzLHtwcm92aWRlcklkOlwicGhvbmVcIixpc09BdXRoUHJvdmlkZXI6ITF9KX1cbnJoLnByb3RvdHlwZS5RYT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuYS5jO3JldHVybiBBKGIudmVyaWZ5KCkpLnRoZW4oZnVuY3Rpb24oZCl7aWYoIW0oZCkpdGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLFwiQW4gaW1wbGVtZW50YXRpb24gb2YgZmlyZWJhc2UuYXV0aC5BcHBsaWNhdGlvblZlcmlmaWVyLnByb3RvdHlwZS52ZXJpZnkoKSBtdXN0IHJldHVybiBhIGZpcmViYXNlLlByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgc3RyaW5nLlwiKTtzd2l0Y2goYi50eXBlKXtjYXNlIFwicmVjYXB0Y2hhXCI6cmV0dXJuIHNoKGMse3Bob25lTnVtYmVyOmEscmVjYXB0Y2hhVG9rZW46ZH0pLnRoZW4oZnVuY3Rpb24oYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIGIucmVzZXQmJmIucmVzZXQoKTtyZXR1cm4gYX0sZnVuY3Rpb24oYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIGIucmVzZXQmJmIucmVzZXQoKTt0aHJvdyBhO30pO2RlZmF1bHQ6dGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLFxuJ09ubHkgZmlyZWJhc2UuYXV0aC5BcHBsaWNhdGlvblZlcmlmaWVycyB3aXRoIHR5cGU9XCJyZWNhcHRjaGFcIiBhcmUgY3VycmVudGx5IHN1cHBvcnRlZC4nKTt9fSl9O2Z1bmN0aW9uIHRoKGEsYil7aWYoIWEpdGhyb3cgbmV3IE4oXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1pZFwiKTtpZighYil0aHJvdyBuZXcgTihcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWNvZGVcIik7cmV0dXJuIG5ldyBuaCh7UGE6YSxPYTpifSl9Z2cocmgse1BST1ZJREVSX0lEOlwicGhvbmVcIn0pO1xuZnVuY3Rpb24gdWgoYSl7aWYoYS50ZW1wb3JhcnlQcm9vZiYmYS5waG9uZU51bWJlcilyZXR1cm4gbmV3IG5oKHtEYTphLnRlbXBvcmFyeVByb29mLFk6YS5waG9uZU51bWJlcn0pO3ZhciBiPWEmJmEucHJvdmlkZXJJZDtpZighYnx8XCJwYXNzd29yZFwiPT09YilyZXR1cm4gbnVsbDt2YXIgYz1hJiZhLm9hdXRoQWNjZXNzVG9rZW4sZD1hJiZhLm9hdXRoVG9rZW5TZWNyZXQ7YT1hJiZhLm9hdXRoSWRUb2tlbjt0cnl7c3dpdGNoKGIpe2Nhc2UgXCJnb29nbGUuY29tXCI6cmV0dXJuIGdoKGEsYyk7Y2FzZSBcImZhY2Vib29rLmNvbVwiOnJldHVybiBjaChjKTtjYXNlIFwiZ2l0aHViLmNvbVwiOnJldHVybiBlaChjKTtjYXNlIFwidHdpdHRlci5jb21cIjpyZXR1cm4gaWgoYyxkKTtkZWZhdWx0OnJldHVybihuZXcgUChiKSkuY3JlZGVudGlhbChhLGMpfX1jYXRjaChlKXtyZXR1cm4gbnVsbH19XG5mdW5jdGlvbiB2aChhKXtpZighYS5pc09BdXRoUHJvdmlkZXIpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLW9hdXRoLXByb3ZpZGVyXCIpO307ZnVuY3Rpb24gd2goYSxiLGMsZCxlKXt0aGlzLmI9YTt0aGlzLmM9Ynx8bnVsbDt0aGlzLmY9Y3x8bnVsbDt0aGlzLmc9ZHx8bnVsbDt0aGlzLmE9ZXx8bnVsbDtpZih0aGlzLmZ8fHRoaXMuYSl7aWYodGhpcy5mJiZ0aGlzLmEpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWF1dGgtZXZlbnRcIik7aWYodGhpcy5mJiYhdGhpcy5nKXRocm93IG5ldyBOKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpO31lbHNlIHRocm93IG5ldyBOKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpO313aC5wcm90b3R5cGUuQj1mdW5jdGlvbigpe3JldHVybnt0eXBlOnRoaXMuYixldmVudElkOnRoaXMuYyx1cmxSZXNwb25zZTp0aGlzLmYsc2Vzc2lvbklkOnRoaXMuZyxlcnJvcjp0aGlzLmEmJnRoaXMuYS5CKCl9fTtmdW5jdGlvbiB4aChhKXthPWF8fHt9O3JldHVybiBhLnR5cGU/bmV3IHdoKGEudHlwZSxhLmV2ZW50SWQsYS51cmxSZXNwb25zZSxhLnNlc3Npb25JZCxhLmVycm9yJiZ2ZyhhLmVycm9yKSk6bnVsbH07ZnVuY3Rpb24geWgoYSl7dmFyIGI9XCJ1bmF1dGhvcml6ZWQtZG9tYWluXCIsYz12b2lkIDAsZD1EZShhKTthPWQuYjtkPWQuYztcImNocm9tZS1leHRlbnNpb25cIj09ZD9jPW9hKFwiVGhpcyBjaHJvbWUgZXh0ZW5zaW9uIElEIChjaHJvbWUtZXh0ZW5zaW9uOi8vJXMpIGlzIG5vdCBhdXRob3JpemVkIHRvIHJ1biB0aGlzIG9wZXJhdGlvbi4gQWRkIGl0IHRvIHRoZSBPQXV0aCByZWRpcmVjdCBkb21haW5zIGxpc3QgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUgLT4gQXV0aCBzZWN0aW9uIC0+IFNpZ24gaW4gbWV0aG9kIHRhYi5cIixhKTpcImh0dHBcIj09ZHx8XCJodHRwc1wiPT1kP2M9b2EoXCJUaGlzIGRvbWFpbiAoJXMpIGlzIG5vdCBhdXRob3JpemVkIHRvIHJ1biB0aGlzIG9wZXJhdGlvbi4gQWRkIGl0IHRvIHRoZSBPQXV0aCByZWRpcmVjdCBkb21haW5zIGxpc3QgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUgLT4gQXV0aCBzZWN0aW9uIC0+IFNpZ24gaW4gbWV0aG9kIHRhYi5cIixhKTpiPVwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiO1xuTi5jYWxsKHRoaXMsYixjKX10KHloLE4pO2Z1bmN0aW9uIHpoKGEsYixjKXtOLmNhbGwodGhpcyxhLGMpO2E9Ynx8e307YS5yYiYmTSh0aGlzLFwiZW1haWxcIixhLnJiKTthLlkmJk0odGhpcyxcInBob25lTnVtYmVyXCIsYS5ZKTthLmNyZWRlbnRpYWwmJk0odGhpcyxcImNyZWRlbnRpYWxcIixhLmNyZWRlbnRpYWwpfXQoemgsTik7emgucHJvdG90eXBlLkI9ZnVuY3Rpb24oKXt2YXIgYT17Y29kZTp0aGlzLmNvZGUsbWVzc2FnZTp0aGlzLm1lc3NhZ2V9O3RoaXMuZW1haWwmJihhLmVtYWlsPXRoaXMuZW1haWwpO3RoaXMucGhvbmVOdW1iZXImJihhLnBob25lTnVtYmVyPXRoaXMucGhvbmVOdW1iZXIpO3ZhciBiPXRoaXMuY3JlZGVudGlhbCYmdGhpcy5jcmVkZW50aWFsLkIoKTtiJiZXYShhLGIpO3JldHVybiBhfTt6aC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQigpfTtcbmZ1bmN0aW9uIEFoKGEpe2lmKGEuY29kZSl7dmFyIGI9YS5jb2RlfHxcIlwiOzA9PWIuaW5kZXhPZih0ZykmJihiPWIuc3Vic3RyaW5nKHRnLmxlbmd0aCkpO3ZhciBjPXtjcmVkZW50aWFsOnVoKGEpfTtpZihhLmVtYWlsKWMucmI9YS5lbWFpbDtlbHNlIGlmKGEucGhvbmVOdW1iZXIpYy5ZPWEucGhvbmVOdW1iZXI7ZWxzZSByZXR1cm4gbmV3IE4oYixhLm1lc3NhZ2V8fHZvaWQgMCk7cmV0dXJuIG5ldyB6aChiLGMsYS5tZXNzYWdlKX1yZXR1cm4gbnVsbH07ZnVuY3Rpb24gQmgoYSl7dGhpcy5mPWF9dChCaCxOZSk7QmgucHJvdG90eXBlLmE9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHRoaXMuZn07QmgucHJvdG90eXBlLmI9ZnVuY3Rpb24oKXtyZXR1cm57fX07XG5mdW5jdGlvbiBDaChhLGIsYyl7dmFyIGQ9XCJOb2RlXCI9PUsoKTtkPWsuWE1MSHR0cFJlcXVlc3R8fGQmJmZpcmViYXNlLklOVEVSTkFMLm5vZGUmJmZpcmViYXNlLklOVEVSTkFMLm5vZGUuWE1MSHR0cFJlcXVlc3Q7aWYoIWQpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiLFwiVGhlIFhNTEh0dHBSZXF1ZXN0IGNvbXBhdGliaWxpdHkgbGlicmFyeSB3YXMgbm90IGZvdW5kLlwiKTt0aGlzLmI9YTthPWJ8fHt9O3RoaXMuaT1hLnNlY3VyZVRva2VuRW5kcG9pbnR8fFwiaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGVhcGlzLmNvbS92MS90b2tlblwiO3RoaXMubD1hLnNlY3VyZVRva2VuVGltZW91dHx8RGg7dGhpcy5jPVVhKGEuc2VjdXJlVG9rZW5IZWFkZXJzfHxFaCk7dGhpcy5nPWEuZmlyZWJhc2VFbmRwb2ludHx8XCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9pZGVudGl0eXRvb2xraXQvdjMvcmVseWluZ3BhcnR5L1wiO3RoaXMuaD1hLmZpcmViYXNlVGltZW91dHx8Rmg7dGhpcy5hPVxuVWEoYS5maXJlYmFzZUhlYWRlcnN8fEdoKTtjJiYodGhpcy5hW1wiWC1DbGllbnQtVmVyc2lvblwiXT1jLHRoaXMuY1tcIlgtQ2xpZW50LVZlcnNpb25cIl09Yyk7dGhpcy5mPW5ldyByZjt0aGlzLm89bmV3IEJoKGQpfXZhciBIaCxPPVwiaWRUb2tlblwiLERoPW5ldyAkZigzRTQsNkU0KSxFaD17XCJDb250ZW50LVR5cGVcIjpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwifSxGaD1uZXcgJGYoM0U0LDZFNCksR2g9e1wiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uXCJ9O2Z1bmN0aW9uIEloKGEsYil7Yj9hLmFbXCJYLUZpcmViYXNlLUxvY2FsZVwiXT1iOmRlbGV0ZSBhLmFbXCJYLUZpcmViYXNlLUxvY2FsZVwiXX1mdW5jdGlvbiBKaChhLGIpe2I/KGEuYVtcIlgtQ2xpZW50LVZlcnNpb25cIl09YixhLmNbXCJYLUNsaWVudC1WZXJzaW9uXCJdPWIpOihkZWxldGUgYS5hW1wiWC1DbGllbnQtVmVyc2lvblwiXSxkZWxldGUgYS5jW1wiWC1DbGllbnQtVmVyc2lvblwiXSl9XG5mdW5jdGlvbiBLaChhLGIsYyxkLGUsZixnKXtaZigpPyh5ZigpP2E9cihhLm0sYSk6KEhofHwoSGg9bmV3IHooZnVuY3Rpb24oYSxiKXtMaChhLGIpfSkpLGE9cihhLnUsYSkpLGEoYixjLGQsZSxmLGcpKTpjJiZjKG51bGwpfVxuQ2gucHJvdG90eXBlLm09ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPVwiTm9kZVwiPT1LKCksbD1NZigpP2c/bmV3IFNlKHRoaXMubyk6bmV3IFNlOm5ldyBTZSh0aGlzLmYpO2lmKGYpe2wuZj1NYXRoLm1heCgwLGYpO3ZhciBuPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtHKGwsXCJ0aW1lb3V0XCIpfSxmKX1mZChsLFwiY29tcGxldGVcIixmdW5jdGlvbigpe24mJmNsZWFyVGltZW91dChuKTt2YXIgYT1udWxsO3RyeXthPUpTT04ucGFyc2UoaGYodGhpcykpfHxudWxsfWNhdGNoKHZiKXthPW51bGx9YiYmYihhKX0pO2xkKGwsXCJyZWFkeVwiLGZ1bmN0aW9uKCl7biYmY2xlYXJUaW1lb3V0KG4pO0xjKHRoaXMpfSk7bGQobCxcInRpbWVvdXRcIixmdW5jdGlvbigpe24mJmNsZWFyVGltZW91dChuKTtMYyh0aGlzKTtiJiZiKG51bGwpfSk7WWUobCxhLGMsZCxlKX07XG52YXIgTWg9ZGMoXCJodHRwczovL2FwaXMuZ29vZ2xlLmNvbS9qcy9jbGllbnQuanM/b25sb2FkPSV7b25sb2FkfVwiKSxOaD1cIl9fZmNiXCIrTWF0aC5mbG9vcigxRTYqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoKTtmdW5jdGlvbiBMaChhLGIpe2lmKCgod2luZG93LmdhcGl8fHt9KS5jbGllbnR8fHt9KS5yZXF1ZXN0KWEoKTtlbHNle2tbTmhdPWZ1bmN0aW9uKCl7KCh3aW5kb3cuZ2FwaXx8e30pLmNsaWVudHx8e30pLnJlcXVlc3Q/YSgpOmIoRXJyb3IoXCJDT1JTX1VOU1VQUE9SVEVEXCIpKX07dmFyIGM9aGMoTWgse29ubG9hZDpOaH0pO1RkKGtmKGMpLGZ1bmN0aW9uKCl7YihFcnJvcihcIkNPUlNfVU5TVVBQT1JURURcIikpfSl9fVxuQ2gucHJvdG90eXBlLnU9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzO0hoLnRoZW4oZnVuY3Rpb24oKXt3aW5kb3cuZ2FwaS5jbGllbnQuc2V0QXBpS2V5KGYuYik7dmFyIGc9d2luZG93LmdhcGkuYXV0aC5nZXRUb2tlbigpO3dpbmRvdy5nYXBpLmF1dGguc2V0VG9rZW4obnVsbCk7d2luZG93LmdhcGkuY2xpZW50LnJlcXVlc3Qoe3BhdGg6YSxtZXRob2Q6Yyxib2R5OmQsaGVhZGVyczplLGF1dGhUeXBlOlwibm9uZVwiLGNhbGxiYWNrOmZ1bmN0aW9uKGEpe3dpbmRvdy5nYXBpLmF1dGguc2V0VG9rZW4oZyk7YiYmYihhKX19KX0pLnMoZnVuY3Rpb24oYSl7YiYmYih7ZXJyb3I6e21lc3NhZ2U6YSYmYS5tZXNzYWdlfHxcIkNPUlNfVU5TVVBQT1JURURcIn19KX0pfTtcbmZ1bmN0aW9uIE9oKGEsYil7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGMsZCl7XCJyZWZyZXNoX3Rva2VuXCI9PWIuZ3JhbnRfdHlwZSYmYi5yZWZyZXNoX3Rva2VufHxcImF1dGhvcml6YXRpb25fY29kZVwiPT1iLmdyYW50X3R5cGUmJmIuY29kZT9LaChhLGEuaStcIj9rZXk9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGEuYiksZnVuY3Rpb24oYSl7YT9hLmVycm9yP2QoUGgoYSkpOmEuYWNjZXNzX3Rva2VuJiZhLnJlZnJlc2hfdG9rZW4/YyhhKTpkKG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIikpOmQobmV3IE4oXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIpKX0sXCJQT1NUXCIsSWUoYikudG9TdHJpbmcoKSxhLmMsYS5sLmdldCgpKTpkKG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIikpfSl9XG5mdW5jdGlvbiBRaChhLGIsYyxkLGUsZil7dmFyIGc9RGUoYS5nK2IpO0koZyxcImtleVwiLGEuYik7ZiYmSShnLFwiY2JcIixuYSgpLnRvU3RyaW5nKCkpO3ZhciBsPVwiR0VUXCI9PWM7aWYobClmb3IodmFyIG4gaW4gZClkLmhhc093blByb3BlcnR5KG4pJiZJKGcsbixkW25dKTtyZXR1cm4gbmV3IHooZnVuY3Rpb24oYixmKXtLaChhLGcudG9TdHJpbmcoKSxmdW5jdGlvbihhKXthP2EuZXJyb3I/ZihQaChhLGV8fHt9KSk6YihhKTpmKG5ldyBOKFwibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiKSl9LGMsbD92b2lkIDA6Q2MoVmYoZCkpLGEuYSxhLmguZ2V0KCkpfSl9ZnVuY3Rpb24gUmgoYSl7aWYoIWpmLnRlc3QoYS5lbWFpbCkpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWVtYWlsXCIpO31mdW5jdGlvbiBTaChhKXtcImVtYWlsXCJpbiBhJiZSaChhKX1cbmZ1bmN0aW9uIFRoKGEsYil7cmV0dXJuIFEoYSxVaCx7aWRlbnRpZmllcjpiLGNvbnRpbnVlVXJpOlNmKCk/dmYoKTpcImh0dHA6Ly9sb2NhbGhvc3RcIn0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEuYWxsUHJvdmlkZXJzfHxbXX0pfWZ1bmN0aW9uIFZoKGEpe3JldHVybiBRKGEsV2gse30pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEuYXV0aG9yaXplZERvbWFpbnN8fFtdfSl9ZnVuY3Rpb24gWGgoYSl7aWYoIWFbT10pdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9XG5mdW5jdGlvbiBZaChhKXtpZihhLnBob25lTnVtYmVyfHxhLnRlbXBvcmFyeVByb29mKXtpZighYS5waG9uZU51bWJlcnx8IWEudGVtcG9yYXJ5UHJvb2YpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9ZWxzZXtpZighYS5zZXNzaW9uSW5mbyl0aHJvdyBuZXcgTihcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWlkXCIpO2lmKCFhLmNvZGUpdGhyb3cgbmV3IE4oXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlXCIpO319Q2gucHJvdG90eXBlLmdiPWZ1bmN0aW9uKCl7cmV0dXJuIFEodGhpcyxaaCx7fSl9O0NoLnByb3RvdHlwZS5rYj1mdW5jdGlvbihhLGIpe3JldHVybiBRKHRoaXMsJGgse2lkVG9rZW46YSxlbWFpbDpifSl9O0NoLnByb3RvdHlwZS5sYj1mdW5jdGlvbihhLGIpe3JldHVybiBRKHRoaXMsbGgse2lkVG9rZW46YSxwYXNzd29yZDpifSl9O3ZhciBhaT17ZGlzcGxheU5hbWU6XCJESVNQTEFZX05BTUVcIixwaG90b1VybDpcIlBIT1RPX1VSTFwifTtoPUNoLnByb3RvdHlwZTtcbmgubWI9ZnVuY3Rpb24oYSxiKXt2YXIgYz17aWRUb2tlbjphfSxkPVtdO1BhKGFpLGZ1bmN0aW9uKGEsZil7dmFyIGU9YltmXTtudWxsPT09ZT9kLnB1c2goYSk6ZiBpbiBiJiYoY1tmXT1lKX0pO2QubGVuZ3RoJiYoYy5kZWxldGVBdHRyaWJ1dGU9ZCk7cmV0dXJuIFEodGhpcywkaCxjKX07aC5jYj1mdW5jdGlvbihhLGIpe2E9e3JlcXVlc3RUeXBlOlwiUEFTU1dPUkRfUkVTRVRcIixlbWFpbDphfTtXYShhLGIpO3JldHVybiBRKHRoaXMsYmksYSl9O2guYmI9ZnVuY3Rpb24oYSxiKXthPXtyZXF1ZXN0VHlwZTpcIlZFUklGWV9FTUFJTFwiLGlkVG9rZW46YX07V2EoYSxiKTtyZXR1cm4gUSh0aGlzLGNpLGEpfTtmdW5jdGlvbiBzaChhLGIpe3JldHVybiBRKGEsZGksYil9aC5RYT1mdW5jdGlvbihhKXtyZXR1cm4gUSh0aGlzLGVpLGEpfTtmdW5jdGlvbiBmaShhLGIsYyl7cmV0dXJuIFEoYSxnaSx7aWRUb2tlbjpiLGRlbGV0ZVByb3ZpZGVyOmN9KX1cbmZ1bmN0aW9uIGhpKGEpe2lmKCFhLnJlcXVlc3RVcml8fCFhLnNlc3Npb25JZCYmIWEucG9zdEJvZHkpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9ZnVuY3Rpb24gaWkoYSl7dmFyIGI9bnVsbDthLm5lZWRDb25maXJtYXRpb24/KGEuY29kZT1cImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIixiPUFoKGEpKTpcIkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEXCI9PWEuZXJyb3JNZXNzYWdlPyhhLmNvZGU9XCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCIsYj1BaChhKSk6XCJFTUFJTF9FWElTVFNcIj09YS5lcnJvck1lc3NhZ2U/KGEuY29kZT1cImVtYWlsLWFscmVhZHktaW4tdXNlXCIsYj1BaChhKSk6YS5lcnJvck1lc3NhZ2UmJihiPWppKGEuZXJyb3JNZXNzYWdlKSk7aWYoYil0aHJvdyBiO2lmKCFhW09dKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7fVxuZnVuY3Rpb24gWGcoYSxiKXtiLnJldHVybklkcENyZWRlbnRpYWw9ITA7cmV0dXJuIFEoYSxraSxiKX1mdW5jdGlvbiBaZyhhLGIpe2IucmV0dXJuSWRwQ3JlZGVudGlhbD0hMDtyZXR1cm4gUShhLGxpLGIpfWZ1bmN0aW9uICRnKGEsYil7Yi5yZXR1cm5JZHBDcmVkZW50aWFsPSEwO2IuYXV0b0NyZWF0ZT0hMTtyZXR1cm4gUShhLG1pLGIpfWZ1bmN0aW9uIG5pKGEpe2lmKCFhLm9vYkNvZGUpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWFjdGlvbi1jb2RlXCIpO31oLlRhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFEodGhpcyxvaSx7b29iQ29kZTphLG5ld1Bhc3N3b3JkOmJ9KX07aC5JYT1mdW5jdGlvbihhKXtyZXR1cm4gUSh0aGlzLHBpLHtvb2JDb2RlOmF9KX07aC5TYT1mdW5jdGlvbihhKXtyZXR1cm4gUSh0aGlzLHFpLHtvb2JDb2RlOmF9KX07XG52YXIgcWk9e2VuZHBvaW50Olwic2V0QWNjb3VudEluZm9cIixEOm5pLGdhOlwiZW1haWxcIn0scGk9e2VuZHBvaW50OlwicmVzZXRQYXNzd29yZFwiLEQ6bmksTzpmdW5jdGlvbihhKXtpZighYS5lbWFpbHx8IWEucmVxdWVzdFR5cGUpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9fSxyaT17ZW5kcG9pbnQ6XCJzaWdudXBOZXdVc2VyXCIsRDpmdW5jdGlvbihhKXtSaChhKTtpZighYS5wYXNzd29yZCl0aHJvdyBuZXcgTihcIndlYWstcGFzc3dvcmRcIik7fSxPOlhoLFQ6ITB9LFVoPXtlbmRwb2ludDpcImNyZWF0ZUF1dGhVcmlcIn0sc2k9e2VuZHBvaW50OlwiZGVsZXRlQWNjb3VudFwiLGVhOltcImlkVG9rZW5cIl19LGdpPXtlbmRwb2ludDpcInNldEFjY291bnRJbmZvXCIsZWE6W1wiaWRUb2tlblwiLFwiZGVsZXRlUHJvdmlkZXJcIl0sRDpmdW5jdGlvbihhKXtpZighZmEoYS5kZWxldGVQcm92aWRlcikpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9fSx0aT17ZW5kcG9pbnQ6XCJnZXRBY2NvdW50SW5mb1wifSxcbmNpPXtlbmRwb2ludDpcImdldE9vYkNvbmZpcm1hdGlvbkNvZGVcIixlYTpbXCJpZFRva2VuXCIsXCJyZXF1ZXN0VHlwZVwiXSxEOmZ1bmN0aW9uKGEpe2lmKFwiVkVSSUZZX0VNQUlMXCIhPWEucmVxdWVzdFR5cGUpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9LGdhOlwiZW1haWxcIn0sYmk9e2VuZHBvaW50OlwiZ2V0T29iQ29uZmlybWF0aW9uQ29kZVwiLGVhOltcInJlcXVlc3RUeXBlXCJdLEQ6ZnVuY3Rpb24oYSl7aWYoXCJQQVNTV09SRF9SRVNFVFwiIT1hLnJlcXVlc3RUeXBlKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7UmgoYSl9LGdhOlwiZW1haWxcIn0sV2g9e25iOiEwLGVuZHBvaW50OlwiZ2V0UHJvamVjdENvbmZpZ1wiLHliOlwiR0VUXCJ9LHVpPXtuYjohMCxlbmRwb2ludDpcImdldFJlY2FwdGNoYVBhcmFtXCIseWI6XCJHRVRcIixPOmZ1bmN0aW9uKGEpe2lmKCFhLnJlY2FwdGNoYVNpdGVLZXkpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9fSxvaT17ZW5kcG9pbnQ6XCJyZXNldFBhc3N3b3JkXCIsXG5EOm5pLGdhOlwiZW1haWxcIn0sZGk9e2VuZHBvaW50Olwic2VuZFZlcmlmaWNhdGlvbkNvZGVcIixlYTpbXCJwaG9uZU51bWJlclwiLFwicmVjYXB0Y2hhVG9rZW5cIl0sZ2E6XCJzZXNzaW9uSW5mb1wifSwkaD17ZW5kcG9pbnQ6XCJzZXRBY2NvdW50SW5mb1wiLGVhOltcImlkVG9rZW5cIl0sRDpTaCxUOiEwfSxsaD17ZW5kcG9pbnQ6XCJzZXRBY2NvdW50SW5mb1wiLGVhOltcImlkVG9rZW5cIl0sRDpmdW5jdGlvbihhKXtTaChhKTtpZighYS5wYXNzd29yZCl0aHJvdyBuZXcgTihcIndlYWstcGFzc3dvcmRcIik7fSxPOlhoLFQ6ITB9LFpoPXtlbmRwb2ludDpcInNpZ251cE5ld1VzZXJcIixPOlhoLFQ6ITB9LGtpPXtlbmRwb2ludDpcInZlcmlmeUFzc2VydGlvblwiLEQ6aGksTzppaSxUOiEwfSxtaT17ZW5kcG9pbnQ6XCJ2ZXJpZnlBc3NlcnRpb25cIixEOmhpLE86ZnVuY3Rpb24oYSl7aWYoYS5lcnJvck1lc3NhZ2UmJlwiVVNFUl9OT1RfRk9VTkRcIj09YS5lcnJvck1lc3NhZ2UpdGhyb3cgbmV3IE4oXCJ1c2VyLW5vdC1mb3VuZFwiKTtcbmlmKGEuZXJyb3JNZXNzYWdlKXRocm93IGppKGEuZXJyb3JNZXNzYWdlKTtpZighYVtPXSl0aHJvdyBuZXcgTihcImludGVybmFsLWVycm9yXCIpO30sVDohMH0sbGk9e2VuZHBvaW50OlwidmVyaWZ5QXNzZXJ0aW9uXCIsRDpmdW5jdGlvbihhKXtoaShhKTtpZighYS5pZFRva2VuKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7fSxPOmlpLFQ6ITB9LHZpPXtlbmRwb2ludDpcInZlcmlmeUN1c3RvbVRva2VuXCIsRDpmdW5jdGlvbihhKXtpZighYS50b2tlbil0aHJvdyBuZXcgTihcImludmFsaWQtY3VzdG9tLXRva2VuXCIpO30sTzpYaCxUOiEwfSxraD17ZW5kcG9pbnQ6XCJ2ZXJpZnlQYXNzd29yZFwiLEQ6ZnVuY3Rpb24oYSl7UmgoYSk7aWYoIWEucGFzc3dvcmQpdGhyb3cgbmV3IE4oXCJ3cm9uZy1wYXNzd29yZFwiKTt9LE86WGgsVDohMH0sZWk9e2VuZHBvaW50OlwidmVyaWZ5UGhvbmVOdW1iZXJcIixEOlloLE86WGh9LHBoPXtlbmRwb2ludDpcInZlcmlmeVBob25lTnVtYmVyXCIsRDpmdW5jdGlvbihhKXtpZighYS5pZFRva2VuKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7XG5ZaChhKX0sTzpmdW5jdGlvbihhKXtpZihhLnRlbXBvcmFyeVByb29mKXRocm93IGEuY29kZT1cImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIixBaChhKTtYaChhKX19LHFoPXtMYjp7VVNFUl9OT1RfRk9VTkQ6XCJ1c2VyLW5vdC1mb3VuZFwifSxlbmRwb2ludDpcInZlcmlmeVBob25lTnVtYmVyXCIsRDpZaCxPOlhofTtcbmZ1bmN0aW9uIFEoYSxiLGMpe2lmKCFqZyhjLGIuZWEpKXJldHVybiBCKG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIikpO3ZhciBkPWIueWJ8fFwiUE9TVFwiLGU7cmV0dXJuIEEoYykudGhlbihiLkQpLnRoZW4oZnVuY3Rpb24oKXtiLlQmJihjLnJldHVyblNlY3VyZVRva2VuPSEwKTtyZXR1cm4gUWgoYSxiLmVuZHBvaW50LGQsYyxiLkxiLGIubmJ8fCExKX0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGU9YX0pLnRoZW4oYi5PKS50aGVuKGZ1bmN0aW9uKCl7aWYoIWIuZ2EpcmV0dXJuIGU7aWYoIShiLmdhIGluIGUpKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7cmV0dXJuIGVbYi5nYV19KX1mdW5jdGlvbiBqaShhKXtyZXR1cm4gUGgoe2Vycm9yOntlcnJvcnM6W3ttZXNzYWdlOmF9XSxjb2RlOjQwMCxtZXNzYWdlOmF9fSl9XG5mdW5jdGlvbiBQaChhLGIpe3ZhciBjPShhLmVycm9yJiZhLmVycm9yLmVycm9ycyYmYS5lcnJvci5lcnJvcnNbMF18fHt9KS5yZWFzb258fFwiXCI7dmFyIGQ9e2tleUludmFsaWQ6XCJpbnZhbGlkLWFwaS1rZXlcIixpcFJlZmVyZXJCbG9ja2VkOlwiYXBwLW5vdC1hdXRob3JpemVkXCJ9O2lmKGM9ZFtjXT9uZXcgTihkW2NdKTpudWxsKXJldHVybiBjO2M9YS5lcnJvciYmYS5lcnJvci5tZXNzYWdlfHxcIlwiO2Q9e0lOVkFMSURfQ1VTVE9NX1RPS0VOOlwiaW52YWxpZC1jdXN0b20tdG9rZW5cIixDUkVERU5USUFMX01JU01BVENIOlwiY3VzdG9tLXRva2VuLW1pc21hdGNoXCIsTUlTU0lOR19DVVNUT01fVE9LRU46XCJpbnRlcm5hbC1lcnJvclwiLElOVkFMSURfSURFTlRJRklFUjpcImludmFsaWQtZW1haWxcIixNSVNTSU5HX0NPTlRJTlVFX1VSSTpcImludGVybmFsLWVycm9yXCIsSU5WQUxJRF9FTUFJTDpcImludmFsaWQtZW1haWxcIixJTlZBTElEX1BBU1NXT1JEOlwid3JvbmctcGFzc3dvcmRcIixVU0VSX0RJU0FCTEVEOlwidXNlci1kaXNhYmxlZFwiLFxuTUlTU0lOR19QQVNTV09SRDpcImludGVybmFsLWVycm9yXCIsRU1BSUxfRVhJU1RTOlwiZW1haWwtYWxyZWFkeS1pbi11c2VcIixQQVNTV09SRF9MT0dJTl9ESVNBQkxFRDpcIm9wZXJhdGlvbi1ub3QtYWxsb3dlZFwiLElOVkFMSURfSURQX1JFU1BPTlNFOlwiaW52YWxpZC1jcmVkZW50aWFsXCIsRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRUQ6XCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCIsSU5WQUxJRF9NRVNTQUdFX1BBWUxPQUQ6XCJpbnZhbGlkLW1lc3NhZ2UtcGF5bG9hZFwiLElOVkFMSURfUkVDSVBJRU5UX0VNQUlMOlwiaW52YWxpZC1yZWNpcGllbnQtZW1haWxcIixJTlZBTElEX1NFTkRFUjpcImludmFsaWQtc2VuZGVyXCIsRU1BSUxfTk9UX0ZPVU5EOlwidXNlci1ub3QtZm91bmRcIixFWFBJUkVEX09PQl9DT0RFOlwiZXhwaXJlZC1hY3Rpb24tY29kZVwiLElOVkFMSURfT09CX0NPREU6XCJpbnZhbGlkLWFjdGlvbi1jb2RlXCIsTUlTU0lOR19PT0JfQ09ERTpcImludGVybmFsLWVycm9yXCIsQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOOlwicmVxdWlyZXMtcmVjZW50LWxvZ2luXCIsXG5JTlZBTElEX0lEX1RPS0VOOlwiaW52YWxpZC11c2VyLXRva2VuXCIsVE9LRU5fRVhQSVJFRDpcInVzZXItdG9rZW4tZXhwaXJlZFwiLFVTRVJfTk9UX0ZPVU5EOlwidXNlci10b2tlbi1leHBpcmVkXCIsQ09SU19VTlNVUFBPUlRFRDpcImNvcnMtdW5zdXBwb3J0ZWRcIixEWU5BTUlDX0xJTktfTk9UX0FDVElWQVRFRDpcImR5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkXCIsSU5WQUxJRF9BUFBfSUQ6XCJpbnZhbGlkLWFwcC1pZFwiLFRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUjpcInRvby1tYW55LXJlcXVlc3RzXCIsV0VBS19QQVNTV09SRDpcIndlYWstcGFzc3dvcmRcIixPUEVSQVRJT05fTk9UX0FMTE9XRUQ6XCJvcGVyYXRpb24tbm90LWFsbG93ZWRcIixVU0VSX0NBTkNFTExFRDpcInVzZXItY2FuY2VsbGVkXCIsQ0FQVENIQV9DSEVDS19GQUlMRUQ6XCJjYXB0Y2hhLWNoZWNrLWZhaWxlZFwiLElOVkFMSURfQVBQX0NSRURFTlRJQUw6XCJpbnZhbGlkLWFwcC1jcmVkZW50aWFsXCIsSU5WQUxJRF9DT0RFOlwiaW52YWxpZC12ZXJpZmljYXRpb24tY29kZVwiLFxuSU5WQUxJRF9QSE9ORV9OVU1CRVI6XCJpbnZhbGlkLXBob25lLW51bWJlclwiLElOVkFMSURfU0VTU0lPTl9JTkZPOlwiaW52YWxpZC12ZXJpZmljYXRpb24taWRcIixJTlZBTElEX1RFTVBPUkFSWV9QUk9PRjpcImludmFsaWQtY3JlZGVudGlhbFwiLE1JU1NJTkdfQVBQX0NSRURFTlRJQUw6XCJtaXNzaW5nLWFwcC1jcmVkZW50aWFsXCIsTUlTU0lOR19DT0RFOlwibWlzc2luZy12ZXJpZmljYXRpb24tY29kZVwiLE1JU1NJTkdfUEhPTkVfTlVNQkVSOlwibWlzc2luZy1waG9uZS1udW1iZXJcIixNSVNTSU5HX1NFU1NJT05fSU5GTzpcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWlkXCIsUVVPVEFfRVhDRUVERUQ6XCJxdW90YS1leGNlZWRlZFwiLFNFU1NJT05fRVhQSVJFRDpcImNvZGUtZXhwaXJlZFwiLElOVkFMSURfQ09OVElOVUVfVVJJOlwiaW52YWxpZC1jb250aW51ZS11cmlcIixNSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FOlwibWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lXCIsTUlTU0lOR19JT1NfQlVORExFX0lEOlwibWlzc2luZy1pb3MtYnVuZGxlLWlkXCIsXG5VTkFVVEhPUklaRURfRE9NQUlOOlwidW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaVwiLElOVkFMSURfT0FVVEhfQ0xJRU5UX0lEOlwiaW52YWxpZC1vYXV0aC1jbGllbnQtaWRcIixJTlZBTElEX0NFUlRfSEFTSDpcImludmFsaWQtY2VydC1oYXNoXCJ9O1dhKGQsYnx8e30pO2I9KGI9Yy5tYXRjaCgvXlteXFxzXStcXHMqOlxccyooLiopJC8pKSYmMTxiLmxlbmd0aD9iWzFdOnZvaWQgMDtmb3IodmFyIGUgaW4gZClpZigwPT09Yy5pbmRleE9mKGUpKXJldHVybiBuZXcgTihkW2VdLGIpOyFiJiZhJiYoYj1VZihhKSk7cmV0dXJuIG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIixiKX07dmFyIHdpPXtJYzp7VmE6XCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9pZGVudGl0eXRvb2xraXQvdjMvcmVseWluZ3BhcnR5L1wiLGFiOlwiaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGVhcGlzLmNvbS92MS90b2tlblwiLGlkOlwicFwifSxLYzp7VmE6XCJodHRwczovL3N0YWdpbmctd3d3LnNhbmRib3guZ29vZ2xlYXBpcy5jb20vaWRlbnRpdHl0b29sa2l0L3YzL3JlbHlpbmdwYXJ0eS9cIixhYjpcImh0dHBzOi8vc3RhZ2luZy1zZWN1cmV0b2tlbi5zYW5kYm94Lmdvb2dsZWFwaXMuY29tL3YxL3Rva2VuXCIsaWQ6XCJzXCJ9LExjOntWYTpcImh0dHBzOi8vd3d3LWdvb2dsZWFwaXMtdGVzdC5zYW5kYm94Lmdvb2dsZS5jb20vaWRlbnRpdHl0b29sa2l0L3YzL3JlbHlpbmdwYXJ0eS9cIixhYjpcImh0dHBzOi8vdGVzdC1zZWN1cmV0b2tlbi5zYW5kYm94Lmdvb2dsZWFwaXMuY29tL3YxL3Rva2VuXCIsaWQ6XCJ0XCJ9fTtcbmZ1bmN0aW9uIHhpKGEpe2Zvcih2YXIgYiBpbiB3aSlpZih3aVtiXS5pZD09PWEpcmV0dXJuIGE9d2lbYl0se2ZpcmViYXNlRW5kcG9pbnQ6YS5WYSxzZWN1cmVUb2tlbkVuZHBvaW50OmEuYWJ9O3JldHVybiBudWxsfXZhciB5aTt5aT14aShcIl9fRUlEX19cIik/XCJfX0VJRF9fXCI6dm9pZCAwO2Z1bmN0aW9uIHppKGEpe3RoaXMuYj1hO3RoaXMuYT1udWxsO3RoaXMuWWE9QWkodGhpcyl9XG5mdW5jdGlvbiBBaShhKXtyZXR1cm4gQmkoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGIsYyl7TChcImdhcGkuaWZyYW1lcy5nZXRDb250ZXh0XCIpKCkub3Blbih7d2hlcmU6ZG9jdW1lbnQuYm9keSx1cmw6YS5iLG1lc3NhZ2VIYW5kbGVyc0ZpbHRlcjpMKFwiZ2FwaS5pZnJhbWVzLkNST1NTX09SSUdJTl9JRlJBTUVTX0ZJTFRFUlwiKSxhdHRyaWJ1dGVzOntzdHlsZTp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIi0xMDBweFwiLHdpZHRoOlwiMXB4XCIsaGVpZ2h0OlwiMXB4XCJ9fSxkb250Y2xlYXI6ITB9LGZ1bmN0aW9uKGQpe2Z1bmN0aW9uIGUoKXtjbGVhclRpbWVvdXQoZik7YigpfWEuYT1kO2EuYS5yZXN0eWxlKHtzZXRIaWRlT25MZWF2ZTohMX0pO3ZhciBmPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtjKEVycm9yKFwiTmV0d29yayBFcnJvclwiKSl9LENpLmdldCgpKTtkLnBpbmcoZSkudGhlbihlLGZ1bmN0aW9uKCl7YyhFcnJvcihcIk5ldHdvcmsgRXJyb3JcIikpfSl9KX0pfSl9XG5mdW5jdGlvbiBEaShhLGIpe3JldHVybiBhLllhLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHooZnVuY3Rpb24oYyl7YS5hLnNlbmQoYi50eXBlLGIsYyxMKFwiZ2FwaS5pZnJhbWVzLkNST1NTX09SSUdJTl9JRlJBTUVTX0ZJTFRFUlwiKSl9KX0pfWZ1bmN0aW9uIEVpKGEsYil7YS5ZYS50aGVuKGZ1bmN0aW9uKCl7YS5hLnJlZ2lzdGVyKFwiYXV0aEV2ZW50XCIsYixMKFwiZ2FwaS5pZnJhbWVzLkNST1NTX09SSUdJTl9JRlJBTUVTX0ZJTFRFUlwiKSl9KX12YXIgRmk9ZGMoXCJodHRwczovL2FwaXMuZ29vZ2xlLmNvbS9qcy9hcGkuanM/b25sb2FkPSV7b25sb2FkfVwiKSxHaT1uZXcgJGYoM0U0LDZFNCksQ2k9bmV3ICRmKDVFMywxNUUzKSxIaT1udWxsO1xuZnVuY3Rpb24gQmkoKXtyZXR1cm4gSGk/SGk6SGk9KG5ldyB6KGZ1bmN0aW9uKGEsYil7aWYoWmYoKSl7dmFyIGM9ZnVuY3Rpb24oKXtZZigpO0woXCJnYXBpLmxvYWRcIikoXCJnYXBpLmlmcmFtZXNcIix7Y2FsbGJhY2s6YSxvbnRpbWVvdXQ6ZnVuY3Rpb24oKXtZZigpO2IoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpKX0sdGltZW91dDpHaS5nZXQoKX0pfTtpZihMKFwiZ2FwaS5pZnJhbWVzLklmcmFtZVwiKSlhKCk7ZWxzZSBpZihMKFwiZ2FwaS5sb2FkXCIpKWMoKTtlbHNle3ZhciBkPVwiX19pZnJhbWVmY2JcIitNYXRoLmZsb29yKDFFNipNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpO2tbZF09ZnVuY3Rpb24oKXtMKFwiZ2FwaS5sb2FkXCIpP2MoKTpiKEVycm9yKFwiTmV0d29yayBFcnJvclwiKSl9O2Q9aGMoRmkse29ubG9hZDpkfSk7QShrZihkKSkucyhmdW5jdGlvbigpe2IoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpKX0pfX1lbHNlIGIoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpKX0pKS5zKGZ1bmN0aW9uKGEpe0hpPVxubnVsbDt0aHJvdyBhO30pfTtmdW5jdGlvbiBJaShhLGIsYyl7dGhpcy5pPWE7dGhpcy5nPWI7dGhpcy5oPWM7dGhpcy5mPW51bGw7dGhpcy5hPUVlKHRoaXMuaSxcIi9fXy9hdXRoL2lmcmFtZVwiKTtJKHRoaXMuYSxcImFwaUtleVwiLHRoaXMuZyk7SSh0aGlzLmEsXCJhcHBOYW1lXCIsdGhpcy5oKTt0aGlzLmI9bnVsbDt0aGlzLmM9W119SWkucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dGhpcy5mP0kodGhpcy5hLFwidlwiLHRoaXMuZik6TGUodGhpcy5hLmEsXCJ2XCIpO3RoaXMuYj9JKHRoaXMuYSxcImVpZFwiLHRoaXMuYik6TGUodGhpcy5hLmEsXCJlaWRcIik7dGhpcy5jLmxlbmd0aD9JKHRoaXMuYSxcImZ3XCIsdGhpcy5jLmpvaW4oXCIsXCIpKTpMZSh0aGlzLmEuYSxcImZ3XCIpO3JldHVybiB0aGlzLmEudG9TdHJpbmcoKX07ZnVuY3Rpb24gSmkoYSxiLGMsZCxlKXt0aGlzLm09YTt0aGlzLnU9Yjt0aGlzLmM9Yzt0aGlzLmw9ZDt0aGlzLmk9dGhpcy5nPXRoaXMuaD1udWxsO3RoaXMuYT1lO3RoaXMuZj1udWxsfVxuSmkucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9RWUodGhpcy5tLFwiL19fL2F1dGgvaGFuZGxlclwiKTtJKGEsXCJhcGlLZXlcIix0aGlzLnUpO0koYSxcImFwcE5hbWVcIix0aGlzLmMpO0koYSxcImF1dGhUeXBlXCIsdGhpcy5sKTtpZih0aGlzLmEuaXNPQXV0aFByb3ZpZGVyKXt2YXIgYj10aGlzLmE7dHJ5e3ZhciBjPWZpcmViYXNlLmFwcCh0aGlzLmMpLmF1dGgoKS4kKCl9Y2F0Y2gobCl7Yz1udWxsfWIuVWE9YztJKGEsXCJwcm92aWRlcklkXCIsdGhpcy5hLnByb3ZpZGVySWQpO2I9dGhpcy5hO2M9VmYoYi5xYik7Zm9yKHZhciBkIGluIGMpY1tkXT1jW2RdLnRvU3RyaW5nKCk7ZD1iLm5jO2M9VWEoYyk7Zm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWRbZV07ZiBpbiBjJiZkZWxldGUgY1tmXX1iLldhJiZiLlVhJiYhY1tiLldhXSYmKGNbYi5XYV09Yi5VYSk7U2EoYyl8fEkoYSxcImN1c3RvbVBhcmFtZXRlcnNcIixVZihjKSl9XCJmdW5jdGlvblwiPT09dHlwZW9mIHRoaXMuYS52YiYmXG4oYj10aGlzLmEudmIoKSxiLmxlbmd0aCYmSShhLFwic2NvcGVzXCIsYi5qb2luKFwiLFwiKSkpO3RoaXMuaD9JKGEsXCJyZWRpcmVjdFVybFwiLHRoaXMuaCk6TGUoYS5hLFwicmVkaXJlY3RVcmxcIik7dGhpcy5nP0koYSxcImV2ZW50SWRcIix0aGlzLmcpOkxlKGEuYSxcImV2ZW50SWRcIik7dGhpcy5pP0koYSxcInZcIix0aGlzLmkpOkxlKGEuYSxcInZcIik7aWYodGhpcy5iKWZvcih2YXIgZyBpbiB0aGlzLmIpdGhpcy5iLmhhc093blByb3BlcnR5KGcpJiYhQ2UoYSxnKSYmSShhLGcsdGhpcy5iW2ddKTt0aGlzLmY/SShhLFwiZWlkXCIsdGhpcy5mKTpMZShhLmEsXCJlaWRcIik7Zz1LaSh0aGlzLmMpO2cubGVuZ3RoJiZJKGEsXCJmd1wiLGcuam9pbihcIixcIikpO3JldHVybiBhLnRvU3RyaW5nKCl9O2Z1bmN0aW9uIEtpKGEpe3RyeXtyZXR1cm4gZmlyZWJhc2UuYXBwKGEpLmF1dGgoKS5LYSgpfWNhdGNoKGIpe3JldHVybltdfX1cbmZ1bmN0aW9uIExpKGEsYixjLGQsZSl7dGhpcy51PWE7dGhpcy5mPWI7dGhpcy5iPWM7dGhpcy5jPWR8fG51bGw7dGhpcy5oPWV8fG51bGw7dGhpcy5tPXRoaXMubz10aGlzLnY9bnVsbDt0aGlzLmc9W107dGhpcy5sPXRoaXMuYT1udWxsfVxuZnVuY3Rpb24gTWkoYSl7dmFyIGI9dmYoKTtyZXR1cm4gVmgoYSkudGhlbihmdW5jdGlvbihhKXthOnt2YXIgYz1EZShiKSxlPWMuYztjPWMuYjtmb3IodmFyIGY9MDtmPGEubGVuZ3RoO2YrKyl7dmFyIGc9YVtmXTt2YXIgbD1jO3ZhciBuPWU7MD09Zy5pbmRleE9mKFwiY2hyb21lLWV4dGVuc2lvbjovL1wiKT9sPURlKGcpLmI9PWwmJlwiY2hyb21lLWV4dGVuc2lvblwiPT1uOlwiaHR0cFwiIT1uJiZcImh0dHBzXCIhPW4/bD0hMTpHZi50ZXN0KGcpP2w9bD09ZzooZz1nLnNwbGl0KFwiLlwiKS5qb2luKFwiXFxcXC5cIiksbD0obmV3IFJlZ0V4cChcIl4oLitcXFxcLlwiK2crXCJ8XCIrZytcIikkXCIsXCJpXCIpKS50ZXN0KGwpKTtpZihsKXthPSEwO2JyZWFrIGF9fWE9ITF9aWYoIWEpdGhyb3cgbmV3IHloKHZmKCkpO30pfVxuZnVuY3Rpb24gTmkoYSl7aWYoYS5sKXJldHVybiBhLmw7YS5sPUhmKCkudGhlbihmdW5jdGlvbigpe2lmKCFhLm8pe3ZhciBiPWEuYyxjPWEuaCxkPUtpKGEuYiksZT1uZXcgSWkoYS51LGEuZixhLmIpO2UuZj1iO2UuYj1jO2UuYz1MYShkfHxbXSk7YS5vPWUudG9TdHJpbmcoKX1hLmk9bmV3IHppKGEubyk7T2koYSl9KTtyZXR1cm4gYS5sfWg9TGkucHJvdG90eXBlO2guQ2E9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW5ldyBOKFwicG9wdXAtY2xvc2VkLWJ5LXVzZXJcIiksZT1uZXcgTihcIndlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCIpLGY9dGhpcyxnPSExO3JldHVybiB0aGlzLmJhKCkudGhlbihmdW5jdGlvbigpe1BpKGYpLnRoZW4oZnVuY3Rpb24oYyl7Y3x8KGEmJkNmKGEpLGIoZSksZz0hMCl9KX0pLnMoZnVuY3Rpb24oKXt9KS50aGVuKGZ1bmN0aW9uKCl7aWYoIWcpcmV0dXJuIEZmKGEpfSkudGhlbihmdW5jdGlvbigpe2lmKCFnKXJldHVybiBzZChjKS50aGVuKGZ1bmN0aW9uKCl7YihkKX0pfSl9O1xuaC5DYj1mdW5jdGlvbigpe3ZhciBhPUooKTtyZXR1cm4hVGYoYSkmJiFYZihhKX07aC54Yj1mdW5jdGlvbigpe3JldHVybiExfTtcbmgudWI9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7aWYoIWEpcmV0dXJuIEIobmV3IE4oXCJwb3B1cC1ibG9ja2VkXCIpKTtpZihnJiYhVGYoKSlyZXR1cm4gdGhpcy5iYSgpLnMoZnVuY3Rpb24oYil7Q2YoYSk7ZShiKX0pLGQoKSxBKCk7dGhpcy5hfHwodGhpcy5hPU1pKFFpKHRoaXMpKSk7dmFyIGw9dGhpcztyZXR1cm4gdGhpcy5hLnRoZW4oZnVuY3Rpb24oKXt2YXIgYj1sLmJhKCkucyhmdW5jdGlvbihiKXtDZihhKTtlKGIpO3Rocm93IGI7fSk7ZCgpO3JldHVybiBifSkudGhlbihmdW5jdGlvbigpe3ZoKGMpO2lmKCFnKXt2YXIgZD1SaShsLnUsbC5mLGwuYixiLGMsbnVsbCxmLGwuYyx2b2lkIDAsbC5oKTt3ZihkLGEpfX0pLnMoZnVuY3Rpb24oYSl7XCJhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWRcIj09YS5jb2RlJiYobC5hPW51bGwpO3Rocm93IGE7fSl9O1xuZnVuY3Rpb24gUWkoYSl7YS5tfHwoYS52PWEuYz9PZihhLmMsS2koYS5iKSk6bnVsbCxhLm09bmV3IENoKGEuZix4aShhLmgpLGEudikpO3JldHVybiBhLm19aC5BYT1mdW5jdGlvbihhLGIsYyl7dGhpcy5hfHwodGhpcy5hPU1pKFFpKHRoaXMpKSk7dmFyIGQ9dGhpcztyZXR1cm4gdGhpcy5hLnRoZW4oZnVuY3Rpb24oKXt2aChiKTt2YXIgZT1SaShkLnUsZC5mLGQuYixhLGIsdmYoKSxjLGQuYyx2b2lkIDAsZC5oKTt3ZihlKX0pLnMoZnVuY3Rpb24oYSl7XCJhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWRcIj09YS5jb2RlJiYoZC5hPW51bGwpO3Rocm93IGE7fSl9O2guYmE9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiBOaSh0aGlzKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGEuaS5ZYX0pLnMoZnVuY3Rpb24oKXthLmE9bnVsbDt0aHJvdyBuZXcgTihcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIik7fSl9O2guRGI9ZnVuY3Rpb24oKXtyZXR1cm4hMH07XG5mdW5jdGlvbiBSaShhLGIsYyxkLGUsZixnLGwsbixEKXthPW5ldyBKaShhLGIsYyxkLGUpO2EuaD1mO2EuZz1nO2EuaT1sO2EuYj1VYShufHxudWxsKTthLmY9RDtyZXR1cm4gYS50b1N0cmluZygpfWZ1bmN0aW9uIE9pKGEpe2lmKCFhLmkpdGhyb3cgRXJyb3IoXCJJZmNIYW5kbGVyIG11c3QgYmUgaW5pdGlhbGl6ZWQhXCIpO0VpKGEuaSxmdW5jdGlvbihiKXt2YXIgYz17fTtpZihiJiZiLmF1dGhFdmVudCl7dmFyIGQ9ITE7Yj14aChiLmF1dGhFdmVudCk7Zm9yKGM9MDtjPGEuZy5sZW5ndGg7YysrKWQ9YS5nW2NdKGIpfHxkO2M9e307Yy5zdGF0dXM9ZD9cIkFDS1wiOlwiRVJST1JcIjtyZXR1cm4gQShjKX1jLnN0YXR1cz1cIkVSUk9SXCI7cmV0dXJuIEEoYyl9KX1cbmZ1bmN0aW9uIFBpKGEpe3ZhciBiPXt0eXBlOlwid2ViU3RvcmFnZVN1cHBvcnRcIn07cmV0dXJuIE5pKGEpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gRGkoYS5pLGIpfSkudGhlbihmdW5jdGlvbihhKXtpZihhJiZhLmxlbmd0aCYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhWzBdLndlYlN0b3JhZ2VTdXBwb3J0KXJldHVybiBhWzBdLndlYlN0b3JhZ2VTdXBwb3J0O3Rocm93IEVycm9yKCk7fSl9aC51YT1mdW5jdGlvbihhKXt0aGlzLmcucHVzaChhKX07aC5KYT1mdW5jdGlvbihhKXtKYSh0aGlzLmcsZnVuY3Rpb24oYil7cmV0dXJuIGI9PWF9KX07ZnVuY3Rpb24gU2koYSl7dGhpcy5hPWF8fGZpcmViYXNlLklOVEVSTkFMLnJlYWN0TmF0aXZlJiZmaXJlYmFzZS5JTlRFUk5BTC5yZWFjdE5hdGl2ZS5Bc3luY1N0b3JhZ2U7aWYoIXRoaXMuYSl0aHJvdyBuZXcgTihcImludGVybmFsLWVycm9yXCIsXCJUaGUgUmVhY3QgTmF0aXZlIGNvbXBhdGliaWxpdHkgbGlicmFyeSB3YXMgbm90IGZvdW5kLlwiKTt9aD1TaS5wcm90b3R5cGU7aC5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIEEodGhpcy5hLmdldEl0ZW0oYSkpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEmJldmKGEpfSl9O2guc2V0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIEEodGhpcy5hLnNldEl0ZW0oYSxVZihiKSkpfTtoLlg9ZnVuY3Rpb24oYSl7cmV0dXJuIEEodGhpcy5hLnJlbW92ZUl0ZW0oYSkpfTtoLmlhPWZ1bmN0aW9uKCl7fTtoLmRhPWZ1bmN0aW9uKCl7fTtmdW5jdGlvbiBUaSgpe3RoaXMuYT17fX1oPVRpLnByb3RvdHlwZTtoLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gQSh0aGlzLmFbYV0pfTtoLnNldD1mdW5jdGlvbihhLGIpe3RoaXMuYVthXT1iO3JldHVybiBBKCl9O2guWD1mdW5jdGlvbihhKXtkZWxldGUgdGhpcy5hW2FdO3JldHVybiBBKCl9O2guaWE9ZnVuY3Rpb24oKXt9O2guZGE9ZnVuY3Rpb24oKXt9O2Z1bmN0aW9uIFVpKGEsYixjLGQsZSxmKXt0cnl7dmFyIGc9ISFrLmluZGV4ZWREQn1jYXRjaChsKXtnPSExfWlmKCFnKXRocm93IG5ldyBOKFwid2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWRcIik7dGhpcy51PWE7dGhpcy5oPWI7dGhpcy5nPWM7dGhpcy5sPWQ7dGhpcy5tPWU7dGhpcy5mPXt9O3RoaXMuYz1bXTt0aGlzLmE9MDt0aGlzLm89Znx8ay5pbmRleGVkREJ9dmFyIFZpO2Z1bmN0aW9uIFdpKGEpe3JldHVybiBuZXcgeihmdW5jdGlvbihiLGMpe3ZhciBkPWEuby5vcGVuKGEudSxhLm0pO2Qub25lcnJvcj1mdW5jdGlvbihhKXtjKEVycm9yKGEudGFyZ2V0LmVycm9yQ29kZSkpfTtkLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbihiKXtiPWIudGFyZ2V0LnJlc3VsdDt0cnl7Yi5jcmVhdGVPYmplY3RTdG9yZShhLmgse2tleVBhdGg6YS5nfSl9Y2F0Y2goZil7YyhmKX19O2Qub25zdWNjZXNzPWZ1bmN0aW9uKGEpe2IoYS50YXJnZXQucmVzdWx0KX19KX1cbmZ1bmN0aW9uIFhpKGEpe2EuaXx8KGEuaT1XaShhKSk7cmV0dXJuIGEuaX1mdW5jdGlvbiBZaShhLGIpe3JldHVybiBiLm9iamVjdFN0b3JlKGEuaCl9ZnVuY3Rpb24gWmkoYSxiLGMpe3JldHVybiBiLnRyYW5zYWN0aW9uKFthLmhdLGM/XCJyZWFkd3JpdGVcIjpcInJlYWRvbmx5XCIpfWZ1bmN0aW9uICRpKGEpe3JldHVybiBuZXcgeihmdW5jdGlvbihiLGMpe2Eub25zdWNjZXNzPWZ1bmN0aW9uKGEpe2EmJmEudGFyZ2V0P2IoYS50YXJnZXQucmVzdWx0KTpiKCl9O2Eub25lcnJvcj1mdW5jdGlvbihhKXtjKEVycm9yKGEudGFyZ2V0LmVycm9yQ29kZSkpfX0pfWg9VWkucHJvdG90eXBlO1xuaC5zZXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz0hMSxkLGU9dGhpcztyZXR1cm4gUWIoWGkodGhpcykudGhlbihmdW5jdGlvbihiKXtkPWI7Yj1ZaShlLFppKGUsZCwhMCkpO3JldHVybiAkaShiLmdldChhKSl9KS50aGVuKGZ1bmN0aW9uKGYpe3ZhciBnPVlpKGUsWmkoZSxkLCEwKSk7aWYoZilyZXR1cm4gZi52YWx1ZT1iLCRpKGcucHV0KGYpKTtlLmErKztjPSEwO2Y9e307ZltlLmddPWE7ZltlLmxdPWI7cmV0dXJuICRpKGcuYWRkKGYpKX0pLnRoZW4oZnVuY3Rpb24oKXtlLmZbYV09Yn0pLGZ1bmN0aW9uKCl7YyYmZS5hLS19KX07aC5nZXQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gWGkodGhpcykudGhlbihmdW5jdGlvbihjKXtyZXR1cm4gJGkoWWkoYixaaShiLGMsITEpKS5nZXQoYSkpfSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYSYmYS52YWx1ZX0pfTtcbmguWD1mdW5jdGlvbihhKXt2YXIgYj0hMSxjPXRoaXM7cmV0dXJuIFFiKFhpKHRoaXMpLnRoZW4oZnVuY3Rpb24oZCl7Yj0hMDtjLmErKztyZXR1cm4gJGkoWWkoYyxaaShjLGQsITApKVtcImRlbGV0ZVwiXShhKSl9KS50aGVuKGZ1bmN0aW9uKCl7ZGVsZXRlIGMuZlthXX0pLGZ1bmN0aW9uKCl7YiYmYy5hLS19KX07XG5oLnZjPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztyZXR1cm4gWGkodGhpcykudGhlbihmdW5jdGlvbihiKXt2YXIgYz1ZaShhLFppKGEsYiwhMSkpO3JldHVybiBjLmdldEFsbD8kaShjLmdldEFsbCgpKTpuZXcgeihmdW5jdGlvbihhLGIpe3ZhciBkPVtdLGU9Yy5vcGVuQ3Vyc29yKCk7ZS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oYil7KGI9Yi50YXJnZXQucmVzdWx0KT8oZC5wdXNoKGIudmFsdWUpLGJbXCJjb250aW51ZVwiXSgpKTphKGQpfTtlLm9uZXJyb3I9ZnVuY3Rpb24oYSl7YihFcnJvcihhLnRhcmdldC5lcnJvckNvZGUpKX19KX0pLnRoZW4oZnVuY3Rpb24oYil7dmFyIGM9e30sZD1bXTtpZigwPT1hLmEpe2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspY1tiW2RdW2EuZ11dPWJbZF1bYS5sXTtkPXhmKGEuZixjKTthLmY9Y31yZXR1cm4gZH0pfTtoLmlhPWZ1bmN0aW9uKGEpezA9PXRoaXMuYy5sZW5ndGgmJmFqKHRoaXMpO3RoaXMuYy5wdXNoKGEpfTtcbmguZGE9ZnVuY3Rpb24oYSl7SmEodGhpcy5jLGZ1bmN0aW9uKGIpe3JldHVybiBiPT1hfSk7MD09dGhpcy5jLmxlbmd0aCYmdGhpcy5iJiZ0aGlzLmIuY2FuY2VsKFwiU1RPUF9FVkVOVFwiKX07ZnVuY3Rpb24gYWooYSl7ZnVuY3Rpb24gYigpe2EuYj1zZCg4MDApLnRoZW4ocihhLnZjLGEpKS50aGVuKGZ1bmN0aW9uKGIpezA8Yi5sZW5ndGgmJncoYS5jLGZ1bmN0aW9uKGEpe2EoYil9KX0pLnRoZW4oYikucyhmdW5jdGlvbihhKXtcIlNUT1BfRVZFTlRcIiE9YS5tZXNzYWdlJiZiKCl9KTtyZXR1cm4gYS5ifWEuYiYmYS5iLmNhbmNlbChcIlNUT1BfRVZFTlRcIik7YigpfTtmdW5jdGlvbiBiaigpe2lmKCFjaigpKXtpZihcIk5vZGVcIj09SygpKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIixcIlRoZSBMb2NhbFN0b3JhZ2UgY29tcGF0aWJpbGl0eSBsaWJyYXJ5IHdhcyBub3QgZm91bmQuXCIpO3Rocm93IG5ldyBOKFwid2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWRcIik7fXRoaXMuYT1kaigpfHxmaXJlYmFzZS5JTlRFUk5BTC5ub2RlLmxvY2FsU3RvcmFnZX1mdW5jdGlvbiBkaigpe3RyeXt2YXIgYT1rLmxvY2FsU3RvcmFnZSxiPVFmKCk7YSYmKGEuc2V0SXRlbShiLFwiMVwiKSxhLnJlbW92ZUl0ZW0oYikpO3JldHVybiBhfWNhdGNoKGMpe3JldHVybiBudWxsfX1cbmZ1bmN0aW9uIGNqKCl7dmFyIGE9XCJOb2RlXCI9PUsoKTthPWRqKCl8fGEmJmZpcmViYXNlLklOVEVSTkFMLm5vZGUmJmZpcmViYXNlLklOVEVSTkFMLm5vZGUubG9jYWxTdG9yYWdlO2lmKCFhKXJldHVybiExO3RyeXtyZXR1cm4gYS5zZXRJdGVtKFwiX19zYWtcIixcIjFcIiksYS5yZW1vdmVJdGVtKFwiX19zYWtcIiksITB9Y2F0Y2goYil7cmV0dXJuITF9fWg9YmoucHJvdG90eXBlO2guZ2V0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIEEoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGM9Yi5hLmdldEl0ZW0oYSk7cmV0dXJuIFdmKGMpfSl9O2guc2V0PWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztyZXR1cm4gQSgpLnRoZW4oZnVuY3Rpb24oKXt2YXIgZD1VZihiKTtudWxsPT09ZD9jLlgoYSk6Yy5hLnNldEl0ZW0oYSxkKX0pfTtoLlg9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gQSgpLnRoZW4oZnVuY3Rpb24oKXtiLmEucmVtb3ZlSXRlbShhKX0pfTtcbmguaWE9ZnVuY3Rpb24oYSl7ay53aW5kb3cmJmNkKGsud2luZG93LFwic3RvcmFnZVwiLGEpfTtoLmRhPWZ1bmN0aW9uKGEpe2sud2luZG93JiZFKGsud2luZG93LFwic3RvcmFnZVwiLGEpfTtmdW5jdGlvbiBlaigpe31oPWVqLnByb3RvdHlwZTtoLmdldD1mdW5jdGlvbigpe3JldHVybiBBKG51bGwpfTtoLnNldD1mdW5jdGlvbigpe3JldHVybiBBKCl9O2guWD1mdW5jdGlvbigpe3JldHVybiBBKCl9O2guaWE9ZnVuY3Rpb24oKXt9O2guZGE9ZnVuY3Rpb24oKXt9O2Z1bmN0aW9uIGZqKCl7aWYoIWdqKCkpe2lmKFwiTm9kZVwiPT1LKCkpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiLFwiVGhlIFNlc3Npb25TdG9yYWdlIGNvbXBhdGliaWxpdHkgbGlicmFyeSB3YXMgbm90IGZvdW5kLlwiKTt0aHJvdyBuZXcgTihcIndlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCIpO310aGlzLmE9aGooKXx8ZmlyZWJhc2UuSU5URVJOQUwubm9kZS5zZXNzaW9uU3RvcmFnZX1mdW5jdGlvbiBoaigpe3RyeXt2YXIgYT1rLnNlc3Npb25TdG9yYWdlLGI9UWYoKTthJiYoYS5zZXRJdGVtKGIsXCIxXCIpLGEucmVtb3ZlSXRlbShiKSk7cmV0dXJuIGF9Y2F0Y2goYyl7cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gZ2ooKXt2YXIgYT1cIk5vZGVcIj09SygpO2E9aGooKXx8YSYmZmlyZWJhc2UuSU5URVJOQUwubm9kZSYmZmlyZWJhc2UuSU5URVJOQUwubm9kZS5zZXNzaW9uU3RvcmFnZTtpZighYSlyZXR1cm4hMTt0cnl7cmV0dXJuIGEuc2V0SXRlbShcIl9fc2FrXCIsXCIxXCIpLGEucmVtb3ZlSXRlbShcIl9fc2FrXCIpLCEwfWNhdGNoKGIpe3JldHVybiExfX1oPWZqLnByb3RvdHlwZTtoLmdldD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiBBKCkudGhlbihmdW5jdGlvbigpe3ZhciBjPWIuYS5nZXRJdGVtKGEpO3JldHVybiBXZihjKX0pfTtoLnNldD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIEEoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGQ9VWYoYik7bnVsbD09PWQ/Yy5YKGEpOmMuYS5zZXRJdGVtKGEsZCl9KX07aC5YPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIEEoKS50aGVuKGZ1bmN0aW9uKCl7Yi5hLnJlbW92ZUl0ZW0oYSl9KX07aC5pYT1mdW5jdGlvbigpe307XG5oLmRhPWZ1bmN0aW9uKCl7fTtmdW5jdGlvbiBpaigpe3ZhciBhPXt9O2EuQnJvd3Nlcj1qajthLk5vZGU9a2o7YS5SZWFjdE5hdGl2ZT1sajt0aGlzLmE9YVtLKCldfXZhciBtaixqaj17QzpiaixqYjpman0sa2o9e0M6YmosamI6Zmp9LGxqPXtDOlNpLGpiOmVqfTt2YXIgbmo9e0hjOlwibG9jYWxcIixOT05FOlwibm9uZVwiLEpjOlwic2Vzc2lvblwifTtmdW5jdGlvbiBvaihhKXt2YXIgYj1uZXcgTihcImludmFsaWQtcGVyc2lzdGVuY2UtdHlwZVwiKSxjPW5ldyBOKFwidW5zdXBwb3J0ZWQtcGVyc2lzdGVuY2UtdHlwZVwiKTthOntmb3IoZCBpbiBuailpZihualtkXT09YSl7dmFyIGQ9ITA7YnJlYWsgYX1kPSExfWlmKCFkfHxcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgYjtzd2l0Y2goSygpKXtjYXNlIFwiUmVhY3ROYXRpdmVcIjppZihcInNlc3Npb25cIj09PWEpdGhyb3cgYzticmVhaztjYXNlIFwiTm9kZVwiOmlmKFwibm9uZVwiIT09YSl0aHJvdyBjO2JyZWFrO2RlZmF1bHQ6aWYoIVBmKCkmJlwibm9uZVwiIT09YSl0aHJvdyBjO319XG5mdW5jdGlvbiBwaihhLGIsYyxkLGUpe3RoaXMuaT1hO3RoaXMuZz1iO3RoaXMuQT1jO3RoaXMudT1kO3RoaXMudj1lO3RoaXMuYT17fTttanx8KG1qPW5ldyBpaik7YT1tajt0cnl7aWYodWYoKSl7Vml8fChWaT1uZXcgVWkoXCJmaXJlYmFzZUxvY2FsU3RvcmFnZURiXCIsXCJmaXJlYmFzZUxvY2FsU3RvcmFnZVwiLFwiZmJhc2Vfa2V5XCIsXCJ2YWx1ZVwiLDEpKTt2YXIgZj1WaX1lbHNlIGY9bmV3IGEuYS5DO3RoaXMubD1mfWNhdGNoKGcpe3RoaXMubD1uZXcgVGksdGhpcy51PSEwfXRyeXt0aGlzLm89bmV3IGEuYS5qYn1jYXRjaChnKXt0aGlzLm89bmV3IFRpfXRoaXMudz1uZXcgVGk7dGhpcy5oPXIodGhpcy5tLHRoaXMpO3RoaXMuYj17fX12YXIgcWo7ZnVuY3Rpb24gcmooKXtxanx8KHFqPW5ldyBwaihcImZpcmViYXNlXCIsXCI6XCIsIVhmKEooKSkmJkxmKCk/ITA6ITEsVGYoKSxQZigpKSk7cmV0dXJuIHFqfVxuZnVuY3Rpb24gc2ooYSxiKXtzd2l0Y2goYil7Y2FzZSBcInNlc3Npb25cIjpyZXR1cm4gYS5vO2Nhc2UgXCJub25lXCI6cmV0dXJuIGEudztkZWZhdWx0OnJldHVybiBhLmx9fWZ1bmN0aW9uIHRqKGEsYixjKXtyZXR1cm4gYS5pK2EuZytiLm5hbWUrKGM/YS5nK2M6XCJcIil9cGoucHJvdG90eXBlLmdldD1mdW5jdGlvbihhLGIpe3JldHVybiBzaih0aGlzLGEuQykuZ2V0KHRqKHRoaXMsYSxiKSl9O2Z1bmN0aW9uIHVqKGEsYixjKXtjPXRqKGEsYixjKTtcImxvY2FsXCI9PWIuQyYmKGEuYltjXT1udWxsKTtyZXR1cm4gc2ooYSxiLkMpLlgoYyl9cGoucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGoodGhpcyxhLGMpLGU9dGhpcyxmPXNqKHRoaXMsYS5DKTtyZXR1cm4gZi5zZXQoZCxiKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGYuZ2V0KGQpfSkudGhlbihmdW5jdGlvbihiKXtcImxvY2FsXCI9PWEuQyYmKGUuYltkXT1iKX0pfTtcbmZ1bmN0aW9uIHZqKGEsYixjLGQpe2I9dGooYSxiLGMpO2EudiYmKGEuYltiXT1rLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGIpKTtTYShhLmEpJiYoc2ooYSxcImxvY2FsXCIpLmlhKGEuaCksYS51fHx1ZigpfHwhYS52fHx3aihhKSk7YS5hW2JdfHwoYS5hW2JdPVtdKTthLmFbYl0ucHVzaChkKX1mdW5jdGlvbiB4aihhLGIsYyl7Yj10aihhLHlqKFwibG9jYWxcIiksYik7YS5hW2JdJiYoSmEoYS5hW2JdLGZ1bmN0aW9uKGEpe3JldHVybiBhPT1jfSksMD09YS5hW2JdLmxlbmd0aCYmZGVsZXRlIGEuYVtiXSk7U2EoYS5hKSYmemooYSl9XG5mdW5jdGlvbiB3aihhKXtBaihhKTthLmY9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtmb3IodmFyIGIgaW4gYS5hKXt2YXIgYz1rLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGIpLGQ9YS5iW2JdO2MhPWQmJihhLmJbYl09YyxjPW5ldyBRYyh7dHlwZTpcInN0b3JhZ2VcIixrZXk6Yix0YXJnZXQ6d2luZG93LG9sZFZhbHVlOmQsbmV3VmFsdWU6YyxhOiEwfSksYS5tKGMpKX19LDFFMyl9ZnVuY3Rpb24gQWooYSl7YS5mJiYoY2xlYXJJbnRlcnZhbChhLmYpLGEuZj1udWxsKX1mdW5jdGlvbiB6aihhKXtzaihhLFwibG9jYWxcIikuZGEoYS5oKTtBaihhKX1cbnBqLnByb3RvdHlwZS5tPWZ1bmN0aW9uKGEpe2lmKGEmJmEuZyl7dmFyIGI9YS5hLmtleTtpZihudWxsPT1iKWZvcih2YXIgYyBpbiB0aGlzLmEpe3ZhciBkPXRoaXMuYltjXTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGQmJihkPW51bGwpO3ZhciBlPWsubG9jYWxTdG9yYWdlLmdldEl0ZW0oYyk7ZSE9PWQmJih0aGlzLmJbY109ZSx0aGlzLmMoYykpfWVsc2UgaWYoMD09Yi5pbmRleE9mKHRoaXMuaSt0aGlzLmcpJiZ0aGlzLmFbYl0pe1widW5kZWZpbmVkXCIhPT10eXBlb2YgYS5hLmE/c2oodGhpcyxcImxvY2FsXCIpLmRhKHRoaXMuaCk6QWoodGhpcyk7aWYodGhpcy5BKWlmKGM9ay5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShiKSxkPWEuYS5uZXdWYWx1ZSxkIT09YyludWxsIT09ZD9rLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGIsZCk6ay5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShiKTtlbHNlIGlmKHRoaXMuYltiXT09PWQmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgYS5hLmEpcmV0dXJuO3ZhciBmPXRoaXM7XG5jPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhLmEuYXx8Zi5iW2JdIT09ay5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShiKSlmLmJbYl09ay5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShiKSxmLmMoYil9O3kmJmtiJiYxMD09a2ImJmsubG9jYWxTdG9yYWdlLmdldEl0ZW0oYikhPT1hLmEubmV3VmFsdWUmJmEuYS5uZXdWYWx1ZSE9PWEuYS5vbGRWYWx1ZT9zZXRUaW1lb3V0KGMsMTApOmMoKX19ZWxzZSB3KGEscih0aGlzLmMsdGhpcykpfTtwai5wcm90b3R5cGUuYz1mdW5jdGlvbihhKXt0aGlzLmFbYV0mJncodGhpcy5hW2FdLGZ1bmN0aW9uKGEpe2EoKX0pfTtmdW5jdGlvbiBDaihhKXt0aGlzLmE9YTt0aGlzLmI9cmooKX12YXIgRGo9e25hbWU6XCJhdXRoRXZlbnRcIixDOlwibG9jYWxcIn07ZnVuY3Rpb24gRWooYSl7cmV0dXJuIGEuYi5nZXQoRGosYS5hKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiB4aChhKX0pfTtmdW5jdGlvbiBGaigpe3RoaXMuYT1yaigpfTtmdW5jdGlvbiBHaihhLGIsYyxkLGUsZixnKXt0aGlzLnU9YTt0aGlzLmk9Yjt0aGlzLmw9Yzt0aGlzLm09ZHx8bnVsbDt0aGlzLm89Z3x8bnVsbDt0aGlzLmg9YitcIjpcIitjO3RoaXMuQT1uZXcgRmo7dGhpcy5nPW5ldyBDaih0aGlzLmgpO3RoaXMuZj1udWxsO3RoaXMuYj1bXTt0aGlzLnY9ZXx8NTAwO3RoaXMudz1mfHwyRTM7dGhpcy5hPXRoaXMuYz1udWxsfWZ1bmN0aW9uIEhqKGEpe3JldHVybiBuZXcgTihcImludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uXCIsYSl9aD1Hai5wcm90b3R5cGU7XG5oLmJhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueGE/dGhpcy54YTp0aGlzLnhhPUlmKCkudGhlbihmdW5jdGlvbigpe2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBMKFwidW5pdmVyc2FsTGlua3Muc3Vic2NyaWJlXCIsaykpdGhyb3cgSGooXCJjb3Jkb3ZhLXVuaXZlcnNhbC1saW5rcy1wbHVnaW4gaXMgbm90IGluc3RhbGxlZFwiKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIEwoXCJCdWlsZEluZm8ucGFja2FnZU5hbWVcIixrKSl0aHJvdyBIaihcImNvcmRvdmEtcGx1Z2luLWJ1aWxkaW5mbyBpcyBub3QgaW5zdGFsbGVkXCIpO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBMKFwiY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIub3BlblVybFwiLGspKXRocm93IEhqKFwiY29yZG92YS1wbHVnaW4tYnJvd3NlcnRhYiBpcyBub3QgaW5zdGFsbGVkXCIpO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBMKFwiY29yZG92YS5JbkFwcEJyb3dzZXIub3BlblwiLGspKXRocm93IEhqKFwiY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyIGlzIG5vdCBpbnN0YWxsZWRcIik7XG59LGZ1bmN0aW9uKCl7dGhyb3cgbmV3IE4oXCJjb3Jkb3ZhLW5vdC1yZWFkeVwiKTt9KX07ZnVuY3Rpb24gSWooKXtmb3IodmFyIGE9MjAsYj1bXTswPGE7KWIucHVzaChcIjEyMzQ1Njc4OTBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIuY2hhckF0KE1hdGguZmxvb3IoNjIqTWF0aC5yYW5kb20oKSkpKSxhLS07cmV0dXJuIGIuam9pbihcIlwiKX1mdW5jdGlvbiBKaihhKXt2YXIgYj1uZXcgaWU7aGUoYixhKTthPVtdO3ZhciBjPTgqYi5nOzU2PmIuYz9oZShiLGZlLDU2LWIuYyk6aGUoYixmZSxiLmItKGIuYy01NikpO2Zvcih2YXIgZD02Mzs1Njw9ZDtkLS0pYi5mW2RdPWMmMjU1LGMvPTI1NjtnZShiKTtmb3IoZD1jPTA7ZDxiLmk7ZCsrKWZvcih2YXIgZT0yNDswPD1lO2UtPTgpYVtjKytdPWIuYVtkXT4+ZSYyNTU7cmV0dXJuIEhkKGEpfVxuaC5DYT1mdW5jdGlvbihhLGIpe2IobmV3IE4oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKTtyZXR1cm4gQSgpfTtoLnViPWZ1bmN0aW9uKCl7cmV0dXJuIEIobmV3IE4oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKX07aC5EYj1mdW5jdGlvbigpe3JldHVybiExfTtoLkNiPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2gueGI9ZnVuY3Rpb24oKXtyZXR1cm4hMH07XG5oLkFhPWZ1bmN0aW9uKGEsYixjKXtpZih0aGlzLmMpcmV0dXJuIEIobmV3IE4oXCJyZWRpcmVjdC1vcGVyYXRpb24tcGVuZGluZ1wiKSk7dmFyIGQ9dGhpcyxlPWsuZG9jdW1lbnQsZj1udWxsLGc9bnVsbCxsPW51bGwsbj1udWxsO3JldHVybiB0aGlzLmM9UWIoQSgpLnRoZW4oZnVuY3Rpb24oKXt2aChiKTtyZXR1cm4gS2ooZCl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIExqKGQsYSxiLGMpfSkudGhlbihmdW5jdGlvbigpe3JldHVybihuZXcgeihmdW5jdGlvbihhLGIpe2c9ZnVuY3Rpb24oKXt2YXIgYj1MKFwiY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIuY2xvc2VcIixrKTthKCk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGImJmIoKTtkLmEmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmEuY2xvc2UmJihkLmEuY2xvc2UoKSxkLmE9bnVsbCk7cmV0dXJuITF9O2QudWEoZyk7bD1mdW5jdGlvbigpe2Z8fChmPXNkKGQudykudGhlbihmdW5jdGlvbigpe2IobmV3IE4oXCJyZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlclwiKSl9KSl9O1xubj1mdW5jdGlvbigpe2FnKCkmJmwoKX07ZS5hZGRFdmVudExpc3RlbmVyKFwicmVzdW1lXCIsbCwhMSk7SigpLnRvTG93ZXJDYXNlKCkubWF0Y2goL2FuZHJvaWQvKXx8ZS5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLG4sITEpfSkpLnMoZnVuY3Rpb24oYSl7cmV0dXJuIE1qKGQpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBhO30pfSl9KSxmdW5jdGlvbigpe2wmJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc3VtZVwiLGwsITEpO24mJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixuLCExKTtmJiZmLmNhbmNlbCgpO2cmJmQuSmEoZyk7ZC5jPW51bGx9KX07XG5mdW5jdGlvbiBMaihhLGIsYyxkKXt2YXIgZT1JaigpLGY9bmV3IHdoKGIsZCxudWxsLGUsbmV3IE4oXCJuby1hdXRoLWV2ZW50XCIpKSxnPUwoXCJCdWlsZEluZm8ucGFja2FnZU5hbWVcIixrKTtpZihcInN0cmluZ1wiIT09dHlwZW9mIGcpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWNvcmRvdmEtY29uZmlndXJhdGlvblwiKTt2YXIgbD1MKFwiQnVpbGRJbmZvLmRpc3BsYXlOYW1lXCIsayksbj17fTtpZihKKCkudG9Mb3dlckNhc2UoKS5tYXRjaCgvaXBob25lfGlwYWR8aXBvZC8pKW4uaWJpPWc7ZWxzZSBpZihKKCkudG9Mb3dlckNhc2UoKS5tYXRjaCgvYW5kcm9pZC8pKW4uYXBuPWc7ZWxzZSByZXR1cm4gQihuZXcgTihcIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIikpO2wmJihuLmFwcERpc3BsYXlOYW1lPWwpO2U9SmooZSk7bi5zZXNzaW9uSWQ9ZTt2YXIgRD1SaShhLnUsYS5pLGEubCxiLGMsbnVsbCxkLGEubSxuLGEubyk7cmV0dXJuIGEuYmEoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGI9XG5hLmg7cmV0dXJuIGEuQS5hLnNldChEaixmLkIoKSxiKX0pLnRoZW4oZnVuY3Rpb24oKXt2YXIgYj1MKFwiY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIuaXNBdmFpbGFibGVcIixrKTtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgYil0aHJvdyBuZXcgTihcImludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uXCIpO3ZhciBjPW51bGw7YihmdW5jdGlvbihiKXtpZihiKXtjPUwoXCJjb3Jkb3ZhLnBsdWdpbnMuYnJvd3NlcnRhYi5vcGVuVXJsXCIsayk7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGMpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWNvcmRvdmEtY29uZmlndXJhdGlvblwiKTtjKEQpfWVsc2V7Yz1MKFwiY29yZG92YS5JbkFwcEJyb3dzZXIub3BlblwiLGspO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjKXRocm93IG5ldyBOKFwiaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIik7Yj1KKCk7Yj0hKCFiLm1hdGNoKC8oaVBhZHxpUGhvbmV8aVBvZCkuKk9TIDdfXFxkL2kpJiYhYi5tYXRjaCgvKGlQYWR8aVBob25lfGlQb2QpLipPUyA4X1xcZC9pKSk7XG5hLmE9YyhELGI/XCJfYmxhbmtcIjpcIl9zeXN0ZW1cIixcImxvY2F0aW9uPXllc1wiKX19KX0pfWZ1bmN0aW9uIE5qKGEsYil7Zm9yKHZhciBjPTA7YzxhLmIubGVuZ3RoO2MrKyl0cnl7YS5iW2NdKGIpfWNhdGNoKGQpe319ZnVuY3Rpb24gS2ooYSl7YS5mfHwoYS5mPWEuYmEoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoZCl7YihkKTthLkphKGMpO3JldHVybiExfWEudWEoYyk7T2ooYSl9KX0pKTtyZXR1cm4gYS5mfWZ1bmN0aW9uIE1qKGEpe3ZhciBiPW51bGw7cmV0dXJuIEVqKGEuZykudGhlbihmdW5jdGlvbihjKXtiPWM7Yz1hLmc7cmV0dXJuIHVqKGMuYixEaixjLmEpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBifSl9XG5mdW5jdGlvbiBPaihhKXtmdW5jdGlvbiBiKGIpe2U9ITA7ZiYmZi5jYW5jZWwoKTtNaihhKS50aGVuKGZ1bmN0aW9uKGMpe3ZhciBlPWQ7aWYoYyYmYiYmYi51cmwpe2U9bnVsbDt2YXIgZj1iLnVybDt2YXIgZz1EZShmKSxsPUNlKGcsXCJsaW5rXCIpLG49Q2UoRGUobCksXCJsaW5rXCIpO2c9Q2UoZyxcImRlZXBfbGlua19pZFwiKTtmPUNlKERlKGcpLFwibGlua1wiKXx8Z3x8bnx8bHx8ZjstMSE9Zi5pbmRleE9mKFwiL19fL2F1dGgvY2FsbGJhY2tcIikmJihlPURlKGYpLGU9V2YoQ2UoZSxcImZpcmViYXNlRXJyb3JcIil8fG51bGwpLGU9KGU9XCJvYmplY3RcIj09PXR5cGVvZiBlP3ZnKGUpOm51bGwpP25ldyB3aChjLmIsYy5jLG51bGwsbnVsbCxlKTpuZXcgd2goYy5iLGMuYyxmLGMuZykpO2U9ZXx8ZH1OaihhLGUpfSl9dmFyIGM9TChcInVuaXZlcnNhbExpbmtzLnN1YnNjcmliZVwiLGspO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjKXRocm93IG5ldyBOKFwiaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIik7XG52YXIgZD1uZXcgd2goXCJ1bmtub3duXCIsbnVsbCxudWxsLG51bGwsbmV3IE4oXCJuby1hdXRoLWV2ZW50XCIpKSxlPSExLGY9c2QoYS52KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIE1qKGEpLnRoZW4oZnVuY3Rpb24oKXtlfHxOaihhLGQpfSl9KSxnPWsuaGFuZGxlT3BlblVSTDtrLmhhbmRsZU9wZW5VUkw9ZnVuY3Rpb24oYSl7MD09YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoTChcIkJ1aWxkSW5mby5wYWNrYWdlTmFtZVwiLGspLnRvTG93ZXJDYXNlKCkrXCI6Ly9cIikmJmIoe3VybDphfSk7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGcpdHJ5e2coYSl9Y2F0Y2gobil7Y29uc29sZS5lcnJvcihuKX19O2MobnVsbCxiKX1cbmgudWE9ZnVuY3Rpb24oYSl7dGhpcy5iLnB1c2goYSk7S2oodGhpcykucyhmdW5jdGlvbihiKXtcImF1dGgvaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIj09PWIuY29kZSYmKGI9bmV3IHdoKFwidW5rbm93blwiLG51bGwsbnVsbCxudWxsLG5ldyBOKFwibm8tYXV0aC1ldmVudFwiKSksYShiKSl9KX07aC5KYT1mdW5jdGlvbihhKXtKYSh0aGlzLmIsZnVuY3Rpb24oYil7cmV0dXJuIGI9PWF9KX07ZnVuY3Rpb24gUGooYSl7dGhpcy5hPWE7dGhpcy5iPXJqKCl9dmFyIFFqPXtuYW1lOlwicGVuZGluZ1JlZGlyZWN0XCIsQzpcInNlc3Npb25cIn07ZnVuY3Rpb24gUmooYSl7cmV0dXJuIGEuYi5zZXQoUWosXCJwZW5kaW5nXCIsYS5hKX1mdW5jdGlvbiBTaihhKXtyZXR1cm4gdWooYS5iLFFqLGEuYSl9ZnVuY3Rpb24gVGooYSl7cmV0dXJuIGEuYi5nZXQoUWosYS5hKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVyblwicGVuZGluZ1wiPT1hfSl9O2Z1bmN0aW9uIFVqKGEsYixjKXt0aGlzLnY9YTt0aGlzLmw9Yjt0aGlzLnU9Yzt0aGlzLmg9W107dGhpcy5mPSExO3RoaXMuaT1yKHRoaXMubSx0aGlzKTt0aGlzLmM9bmV3IFZqO3RoaXMubz1uZXcgV2o7dGhpcy5nPW5ldyBQaih0aGlzLmwrXCI6XCIrdGhpcy51KTt0aGlzLmI9e307dGhpcy5iLnVua25vd249dGhpcy5jO3RoaXMuYi5zaWduSW5WaWFSZWRpcmVjdD10aGlzLmM7dGhpcy5iLmxpbmtWaWFSZWRpcmVjdD10aGlzLmM7dGhpcy5iLnJlYXV0aFZpYVJlZGlyZWN0PXRoaXMuYzt0aGlzLmIuc2lnbkluVmlhUG9wdXA9dGhpcy5vO3RoaXMuYi5saW5rVmlhUG9wdXA9dGhpcy5vO3RoaXMuYi5yZWF1dGhWaWFQb3B1cD10aGlzLm87dGhpcy5hPVhqKHRoaXMudix0aGlzLmwsdGhpcy51LHlpKX1cbmZ1bmN0aW9uIFhqKGEsYixjLGQpe3ZhciBlPWZpcmViYXNlLlNES19WRVJTSU9OfHxudWxsO3JldHVybiBKZigpP25ldyBHaihhLGIsYyxlLHZvaWQgMCx2b2lkIDAsZCk6bmV3IExpKGEsYixjLGUsZCl9VWoucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5mPSExO3RoaXMuYS5KYSh0aGlzLmkpO3RoaXMuYT1Yaih0aGlzLnYsdGhpcy5sLHRoaXMudSl9O2Z1bmN0aW9uIFlqKGEpe2EuZnx8KGEuZj0hMCxhLmEudWEoYS5pKSk7dmFyIGI9YS5hO3JldHVybiBhLmEuYmEoKS5zKGZ1bmN0aW9uKGMpe2EuYT09YiYmYS5yZXNldCgpO3Rocm93IGM7fSl9ZnVuY3Rpb24gWmooYSl7YS5hLkNiKCkmJllqKGEpLnMoZnVuY3Rpb24oYil7dmFyIGM9bmV3IHdoKFwidW5rbm93blwiLG51bGwsbnVsbCxudWxsLG5ldyBOKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7YWsoYikmJmEubShjKX0pO2EuYS54YigpfHxiayhhLmMpfVxuVWoucHJvdG90eXBlLnN1YnNjcmliZT1mdW5jdGlvbihhKXtIYSh0aGlzLmgsYSl8fHRoaXMuaC5wdXNoKGEpO2lmKCF0aGlzLmYpe3ZhciBiPXRoaXM7VGoodGhpcy5nKS50aGVuKGZ1bmN0aW9uKGEpe2E/U2ooYi5nKS50aGVuKGZ1bmN0aW9uKCl7WWooYikucyhmdW5jdGlvbihhKXt2YXIgYz1uZXcgd2goXCJ1bmtub3duXCIsbnVsbCxudWxsLG51bGwsbmV3IE4oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKTthayhhKSYmYi5tKGMpfSl9KTpaaihiKX0pLnMoZnVuY3Rpb24oKXtaaihiKX0pfX07VWoucHJvdG90eXBlLnVuc3Vic2NyaWJlPWZ1bmN0aW9uKGEpe0phKHRoaXMuaCxmdW5jdGlvbihiKXtyZXR1cm4gYj09YX0pfTtcblVqLnByb3RvdHlwZS5tPWZ1bmN0aW9uKGEpe2lmKCFhKXRocm93IG5ldyBOKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpO2Zvcih2YXIgYj0hMSxjPTA7Yzx0aGlzLmgubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5oW2NdO2lmKGQub2IoYS5iLGEuYykpeyhiPXRoaXMuYlthLmJdKSYmYi5oKGEsZCk7Yj0hMDticmVha319YmsodGhpcy5jKTtyZXR1cm4gYn07dmFyIGNrPW5ldyAkZigyRTMsMUU0KSxkaz1uZXcgJGYoM0U0LDZFNCk7VWoucHJvdG90eXBlLmFhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYy5hYSgpfTtmdW5jdGlvbiBlayhhLGIsYyxkLGUsZil7cmV0dXJuIGEuYS51YihiLGMsZCxmdW5jdGlvbigpe2EuZnx8KGEuZj0hMCxhLmEudWEoYS5pKSl9LGZ1bmN0aW9uKCl7YS5yZXNldCgpfSxlLGYpfWZ1bmN0aW9uIGFrKGEpe3JldHVybiBhJiZcImF1dGgvY29yZG92YS1ub3QtcmVhZHlcIj09YS5jb2RlPyEwOiExfVxuVWoucHJvdG90eXBlLkFhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLGU7cmV0dXJuIFJqKHRoaXMuZykudGhlbihmdW5jdGlvbigpe3JldHVybiBkLmEuQWEoYSxiLGMpLnMoZnVuY3Rpb24oYSl7aWYoYWsoYSkpdGhyb3cgbmV3IE4oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpO2U9YTtyZXR1cm4gU2ooZC5nKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgZTt9KX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZC5hLkRiKCk/bmV3IHooZnVuY3Rpb24oKXt9KTpTaihkLmcpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZC5hYSgpfSkudGhlbihmdW5jdGlvbigpe30pLnMoZnVuY3Rpb24oKXt9KX0pfSl9O1VqLnByb3RvdHlwZS5DYT1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5hLkNhKGMsZnVuY3Rpb24oYyl7YS5mYShiLG51bGwsYyxkKX0sY2suZ2V0KCkpfTt2YXIgZms9e307XG5mdW5jdGlvbiBnayhhLGIsYyl7dmFyIGQ9YitcIjpcIitjO2ZrW2RdfHwoZmtbZF09bmV3IFVqKGEsYixjKSk7cmV0dXJuIGZrW2RdfWZ1bmN0aW9uIFZqKCl7dGhpcy5iPW51bGw7dGhpcy5mPVtdO3RoaXMuYz1bXTt0aGlzLmE9bnVsbDt0aGlzLmc9ITF9VmoucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5iPW51bGw7dGhpcy5hJiYodGhpcy5hLmNhbmNlbCgpLHRoaXMuYT1udWxsKX07XG5Wai5wcm90b3R5cGUuaD1mdW5jdGlvbihhLGIpe2lmKCFhKXJldHVybiBCKG5ldyBOKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpKTt0aGlzLnJlc2V0KCk7dGhpcy5nPSEwO3ZhciBjPWEuYixkPWEuYyxlPWEuYSYmXCJhdXRoL3dlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCI9PWEuYS5jb2RlLGY9YS5hJiZcImF1dGgvb3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiPT1hLmEuY29kZTtcInVua25vd25cIiE9Y3x8ZXx8Zj9hLmE/KGhrKHRoaXMsITAsbnVsbCxhLmEpLGE9QSgpKTphPWIudmEoYyxkKT9payh0aGlzLGEsYik6QihuZXcgTihcImludmFsaWQtYXV0aC1ldmVudFwiKSk6KGhrKHRoaXMsITEsbnVsbCxudWxsKSxhPUEoKSk7cmV0dXJuIGF9O2Z1bmN0aW9uIGJrKGEpe2EuZ3x8KGEuZz0hMCxoayhhLCExLG51bGwsbnVsbCkpfVxuZnVuY3Rpb24gaWsoYSxiLGMpe2M9Yy52YShiLmIsYi5jKTt2YXIgZD1iLmYsZT1iLmcsZj0hIWIuYi5tYXRjaCgvUmVkaXJlY3QkLyk7cmV0dXJuIGMoZCxlKS50aGVuKGZ1bmN0aW9uKGIpe2hrKGEsZixiLG51bGwpfSkucyhmdW5jdGlvbihiKXtoayhhLGYsbnVsbCxiKX0pfWZ1bmN0aW9uIGprKGEsYil7YS5iPWZ1bmN0aW9uKCl7cmV0dXJuIEIoYil9O2lmKGEuYy5sZW5ndGgpZm9yKHZhciBjPTA7YzxhLmMubGVuZ3RoO2MrKylhLmNbY10oYil9ZnVuY3Rpb24ga2soYSxiKXthLmI9ZnVuY3Rpb24oKXtyZXR1cm4gQShiKX07aWYoYS5mLmxlbmd0aClmb3IodmFyIGM9MDtjPGEuZi5sZW5ndGg7YysrKWEuZltjXShiKX1mdW5jdGlvbiBoayhhLGIsYyxkKXtiP2Q/amsoYSxkKTprayhhLGMpOmtrKGEse3VzZXI6bnVsbH0pO2EuZj1bXTthLmM9W119XG5Wai5wcm90b3R5cGUuYWE9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiBuZXcgeihmdW5jdGlvbihiLGMpe2EuYj9hLmIoKS50aGVuKGIsYyk6KGEuZi5wdXNoKGIpLGEuYy5wdXNoKGMpLGxrKGEpKX0pfTtmdW5jdGlvbiBsayhhKXt2YXIgYj1uZXcgTihcInRpbWVvdXRcIik7YS5hJiZhLmEuY2FuY2VsKCk7YS5hPXNkKGRrLmdldCgpKS50aGVuKGZ1bmN0aW9uKCl7YS5ifHxoayhhLCEwLG51bGwsYil9KX1mdW5jdGlvbiBXaigpe31Xai5wcm90b3R5cGUuaD1mdW5jdGlvbihhLGIpe2lmKCFhKXJldHVybiBCKG5ldyBOKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpKTt2YXIgYz1hLmIsZD1hLmM7YS5hPyhiLmZhKGEuYixudWxsLGEuYSxhLmMpLGE9QSgpKTphPWIudmEoYyxkKT9tayhhLGIpOkIobmV3IE4oXCJpbnZhbGlkLWF1dGgtZXZlbnRcIikpO3JldHVybiBhfTtcbmZ1bmN0aW9uIG1rKGEsYil7dmFyIGM9YS5jLGQ9YS5iO3JldHVybiBiLnZhKGQsYykoYS5mLGEuZykudGhlbihmdW5jdGlvbihhKXtiLmZhKGQsYSxudWxsLGMpfSkucyhmdW5jdGlvbihhKXtiLmZhKGQsbnVsbCxhLGMpfSl9O2Z1bmN0aW9uIG5rKGEsYil7dGhpcy5hPWI7TSh0aGlzLFwidmVyaWZpY2F0aW9uSWRcIixhKX1uay5wcm90b3R5cGUuY29uZmlybT1mdW5jdGlvbihhKXthPXRoKHRoaXMudmVyaWZpY2F0aW9uSWQsYSk7cmV0dXJuIHRoaXMuYShhKX07ZnVuY3Rpb24gb2soYSxiLGMsZCl7cmV0dXJuKG5ldyByaChhKSkuUWEoYixjKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbmsoYSxkKX0pfTtmdW5jdGlvbiBwayhhLGIsYyxkLGUsZil7dGhpcy5oPWE7dGhpcy5pPWI7dGhpcy5nPWM7dGhpcy5jPWQ7dGhpcy5mPWU7dGhpcy5sPSEhZjt0aGlzLmI9bnVsbDt0aGlzLmE9dGhpcy5jO2lmKHRoaXMuZjx0aGlzLmMpdGhyb3cgRXJyb3IoXCJQcm9hY3RpdmUgcmVmcmVzaCBsb3dlciBib3VuZCBncmVhdGVyIHRoYW4gdXBwZXIgYm91bmQhXCIpO31way5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXt0aGlzLmE9dGhpcy5jO3FrKHRoaXMsITApfTtmdW5jdGlvbiByayhhLGIpe2lmKGIpcmV0dXJuIGEuYT1hLmMsYS5nKCk7Yj1hLmE7YS5hKj0yO2EuYT5hLmYmJihhLmE9YS5mKTtyZXR1cm4gYn1cbmZ1bmN0aW9uIHFrKGEsYil7c2soYSk7YS5iPXNkKHJrKGEsYikpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYS5sP0EoKTpiZygpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBhLmgoKX0pLnRoZW4oZnVuY3Rpb24oKXtxayhhLCEwKX0pLnMoZnVuY3Rpb24oYil7YS5pKGIpJiZxayhhLCExKX0pfWZ1bmN0aW9uIHNrKGEpe2EuYiYmKGEuYi5jYW5jZWwoKSxhLmI9bnVsbCl9O2Z1bmN0aW9uIHRrKGEpe3RoaXMuZj1hO3RoaXMuYj10aGlzLmE9bnVsbDt0aGlzLmM9MH10ay5wcm90b3R5cGUuQj1mdW5jdGlvbigpe3JldHVybnthcGlLZXk6dGhpcy5mLmIscmVmcmVzaFRva2VuOnRoaXMuYSxhY2Nlc3NUb2tlbjp0aGlzLmIsZXhwaXJhdGlvblRpbWU6dGhpcy5jfX07ZnVuY3Rpb24gdWsoYSxiKXt2YXIgYz1iW09dLGQ9Yi5yZWZyZXNoVG9rZW47Yj12ayhiLmV4cGlyZXNJbik7YS5iPWM7YS5jPWI7YS5hPWR9ZnVuY3Rpb24gdmsoYSl7cmV0dXJuIG5hKCkrMUUzKnBhcnNlSW50KGEsMTApfVxuZnVuY3Rpb24gd2soYSxiKXtyZXR1cm4gT2goYS5mLGIpLnRoZW4oZnVuY3Rpb24oYil7YS5iPWIuYWNjZXNzX3Rva2VuO2EuYz12ayhiLmV4cGlyZXNfaW4pO2EuYT1iLnJlZnJlc2hfdG9rZW47cmV0dXJue2FjY2Vzc1Rva2VuOmEuYixleHBpcmF0aW9uVGltZTphLmMscmVmcmVzaFRva2VuOmEuYX19KS5zKGZ1bmN0aW9uKGIpe1wiYXV0aC91c2VyLXRva2VuLWV4cGlyZWRcIj09Yi5jb2RlJiYoYS5hPW51bGwpO3Rocm93IGI7fSl9dGsucHJvdG90eXBlLmdldFRva2VuPWZ1bmN0aW9uKGEpe2E9ISFhO3JldHVybiB0aGlzLmImJiF0aGlzLmE/QihuZXcgTihcInVzZXItdG9rZW4tZXhwaXJlZFwiKSk6YXx8IXRoaXMuYnx8bmEoKT50aGlzLmMtM0U0P3RoaXMuYT93ayh0aGlzLHtncmFudF90eXBlOlwicmVmcmVzaF90b2tlblwiLHJlZnJlc2hfdG9rZW46dGhpcy5hfSk6QShudWxsKTpBKHthY2Nlc3NUb2tlbjp0aGlzLmIsZXhwaXJhdGlvblRpbWU6dGhpcy5jLHJlZnJlc2hUb2tlbjp0aGlzLmF9KX07ZnVuY3Rpb24geGsoYSxiKXt0aGlzLmE9YXx8bnVsbDt0aGlzLmI9Ynx8bnVsbDtnZyh0aGlzLHtsYXN0U2lnbkluVGltZTpjZyhifHxudWxsKSxjcmVhdGlvblRpbWU6Y2coYXx8bnVsbCl9KX1mdW5jdGlvbiB5ayhhKXtyZXR1cm4gbmV3IHhrKGEuYSxhLmIpfXhrLnByb3RvdHlwZS5CPWZ1bmN0aW9uKCl7cmV0dXJue2xhc3RMb2dpbkF0OnRoaXMuYixjcmVhdGVkQXQ6dGhpcy5hfX07ZnVuY3Rpb24gemsoYSxiLGMsZCxlLGYpe2dnKHRoaXMse3VpZDphLGRpc3BsYXlOYW1lOmR8fG51bGwscGhvdG9VUkw6ZXx8bnVsbCxlbWFpbDpjfHxudWxsLHBob25lTnVtYmVyOmZ8fG51bGwscHJvdmlkZXJJZDpifSl9ZnVuY3Rpb24gQWsoYSxiKXtDLmNhbGwodGhpcyxhKTtmb3IodmFyIGMgaW4gYil0aGlzW2NdPWJbY119dChBayxDKTtcbmZ1bmN0aW9uIEJrKGEsYixjKXt0aGlzLkE9W107dGhpcy5HPWEuYXBpS2V5O3RoaXMubz1hLmFwcE5hbWU7dGhpcy53PWEuYXV0aERvbWFpbnx8bnVsbDthPWZpcmViYXNlLlNES19WRVJTSU9OP09mKGZpcmViYXNlLlNES19WRVJTSU9OKTpudWxsO3RoaXMuYz1uZXcgQ2godGhpcy5HLHhpKHlpKSxhKTt0aGlzLmg9bmV3IHRrKHRoaXMuYyk7Q2sodGhpcyxiW09dKTt1ayh0aGlzLmgsYik7TSh0aGlzLFwicmVmcmVzaFRva2VuXCIsdGhpcy5oLmEpO0RrKHRoaXMsY3x8e30pO0YuY2FsbCh0aGlzKTt0aGlzLkk9ITE7dGhpcy53JiZSZigpJiYodGhpcy5hPWdrKHRoaXMudyx0aGlzLkcsdGhpcy5vKSk7dGhpcy5OPVtdO3RoaXMuaT1udWxsO3RoaXMubD1Fayh0aGlzKTt0aGlzLlU9cih0aGlzLkdhLHRoaXMpO3ZhciBkPXRoaXM7dGhpcy5oYT1udWxsO3RoaXMucmE9ZnVuY3Rpb24oYSl7ZC5uYShhLmgpfTt0aGlzLlc9bnVsbDt0aGlzLlI9W107dGhpcy5xYT1mdW5jdGlvbihhKXtGayhkLFxuYS5mKX07dGhpcy5WPW51bGx9dChCayxGKTtCay5wcm90b3R5cGUubmE9ZnVuY3Rpb24oYSl7dGhpcy5oYT1hO0loKHRoaXMuYyxhKX07QmsucHJvdG90eXBlLiQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYX07ZnVuY3Rpb24gR2soYSxiKXthLlcmJkUoYS5XLFwibGFuZ3VhZ2VDb2RlQ2hhbmdlZFwiLGEucmEpOyhhLlc9YikmJmNkKGIsXCJsYW5ndWFnZUNvZGVDaGFuZ2VkXCIsYS5yYSl9ZnVuY3Rpb24gRmsoYSxiKXthLlI9YjtKaChhLmMsZmlyZWJhc2UuU0RLX1ZFUlNJT04/T2YoZmlyZWJhc2UuU0RLX1ZFUlNJT04sYS5SKTpudWxsKX1Cay5wcm90b3R5cGUuS2E9ZnVuY3Rpb24oKXtyZXR1cm4gTGEodGhpcy5SKX07ZnVuY3Rpb24gSGsoYSxiKXthLlYmJkUoYS5WLFwiZnJhbWV3b3JrQ2hhbmdlZFwiLGEucWEpOyhhLlY9YikmJmNkKGIsXCJmcmFtZXdvcmtDaGFuZ2VkXCIsYS5xYSl9QmsucHJvdG90eXBlLkdhPWZ1bmN0aW9uKCl7dGhpcy5sLmImJihzayh0aGlzLmwpLHRoaXMubC5zdGFydCgpKX07XG5mdW5jdGlvbiBJayhhKXt0cnl7cmV0dXJuIGZpcmViYXNlLmFwcChhLm8pLmF1dGgoKX1jYXRjaChiKXt0aHJvdyBuZXcgTihcImludGVybmFsLWVycm9yXCIsXCJObyBmaXJlYmFzZS5hdXRoLkF1dGggaW5zdGFuY2UgaXMgYXZhaWxhYmxlIGZvciB0aGUgRmlyZWJhc2UgQXBwICdcIithLm8rXCInIVwiKTt9fWZ1bmN0aW9uIEVrKGEpe3JldHVybiBuZXcgcGsoZnVuY3Rpb24oKXtyZXR1cm4gYS5GKCEwKX0sZnVuY3Rpb24oYSl7cmV0dXJuIGEmJlwiYXV0aC9uZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCI9PWEuY29kZT8hMDohMX0sZnVuY3Rpb24oKXt2YXIgYj1hLmguYy1uYSgpLTNFNTtyZXR1cm4gMDxiP2I6MH0sM0U0LDk2RTQsITEpfWZ1bmN0aW9uIEprKGEpe2EubXx8YS5sLmJ8fChhLmwuc3RhcnQoKSxFKGEsXCJ0b2tlbkNoYW5nZWRcIixhLlUpLGNkKGEsXCJ0b2tlbkNoYW5nZWRcIixhLlUpKX1mdW5jdGlvbiBLayhhKXtFKGEsXCJ0b2tlbkNoYW5nZWRcIixhLlUpO3NrKGEubCl9XG5mdW5jdGlvbiBDayhhLGIpe2EucGE9YjtNKGEsXCJfbGF0XCIsYil9ZnVuY3Rpb24gTGsoYSxiKXtKYShhLk4sZnVuY3Rpb24oYSl7cmV0dXJuIGE9PWJ9KX1mdW5jdGlvbiBNayhhKXtmb3IodmFyIGI9W10sYz0wO2M8YS5OLmxlbmd0aDtjKyspYi5wdXNoKGEuTltjXShhKSk7cmV0dXJuIE9iKGIpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYX0pfWZ1bmN0aW9uIE5rKGEpe2EuYSYmIWEuSSYmKGEuST0hMCxhLmEuc3Vic2NyaWJlKGEpKX1cbmZ1bmN0aW9uIERrKGEsYil7Z2coYSx7dWlkOmIudWlkLGRpc3BsYXlOYW1lOmIuZGlzcGxheU5hbWV8fG51bGwscGhvdG9VUkw6Yi5waG90b1VSTHx8bnVsbCxlbWFpbDpiLmVtYWlsfHxudWxsLGVtYWlsVmVyaWZpZWQ6Yi5lbWFpbFZlcmlmaWVkfHwhMSxwaG9uZU51bWJlcjpiLnBob25lTnVtYmVyfHxudWxsLGlzQW5vbnltb3VzOmIuaXNBbm9ueW1vdXN8fCExLG1ldGFkYXRhOm5ldyB4ayhiLmNyZWF0ZWRBdCxiLmxhc3RMb2dpbkF0KSxwcm92aWRlckRhdGE6W119KX1NKEJrLnByb3RvdHlwZSxcInByb3ZpZGVySWRcIixcImZpcmViYXNlXCIpO2Z1bmN0aW9uIE9rKCl7fWZ1bmN0aW9uIFBrKGEpe3JldHVybiBBKCkudGhlbihmdW5jdGlvbigpe2lmKGEubSl0aHJvdyBuZXcgTihcImFwcC1kZWxldGVkXCIpO30pfWZ1bmN0aW9uIFFrKGEpe3JldHVybiBEYShhLnByb3ZpZGVyRGF0YSxmdW5jdGlvbihhKXtyZXR1cm4gYS5wcm92aWRlcklkfSl9XG5mdW5jdGlvbiBSayhhLGIpe2ImJihTayhhLGIucHJvdmlkZXJJZCksYS5wcm92aWRlckRhdGEucHVzaChiKSl9ZnVuY3Rpb24gU2soYSxiKXtKYShhLnByb3ZpZGVyRGF0YSxmdW5jdGlvbihhKXtyZXR1cm4gYS5wcm92aWRlcklkPT1ifSl9ZnVuY3Rpb24gVGsoYSxiLGMpeyhcInVpZFwiIT1ifHxjKSYmYS5oYXNPd25Qcm9wZXJ0eShiKSYmTShhLGIsYyl9XG5mdW5jdGlvbiBVayhhLGIpe2EhPWImJihnZyhhLHt1aWQ6Yi51aWQsZGlzcGxheU5hbWU6Yi5kaXNwbGF5TmFtZSxwaG90b1VSTDpiLnBob3RvVVJMLGVtYWlsOmIuZW1haWwsZW1haWxWZXJpZmllZDpiLmVtYWlsVmVyaWZpZWQscGhvbmVOdW1iZXI6Yi5waG9uZU51bWJlcixpc0Fub255bW91czpiLmlzQW5vbnltb3VzLHByb3ZpZGVyRGF0YTpbXX0pLGIubWV0YWRhdGE/TShhLFwibWV0YWRhdGFcIix5ayhiLm1ldGFkYXRhKSk6TShhLFwibWV0YWRhdGFcIixuZXcgeGspLHcoYi5wcm92aWRlckRhdGEsZnVuY3Rpb24oYil7UmsoYSxiKX0pLGEuaD1iLmgsTShhLFwicmVmcmVzaFRva2VuXCIsYS5oLmEpKX1oPUJrLnByb3RvdHlwZTtoLnJlbG9hZD1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIFIodGhpcyxQayh0aGlzKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFZrKGEpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gTWsoYSl9KS50aGVuKE9rKX0pKX07XG5mdW5jdGlvbiBWayhhKXtyZXR1cm4gYS5GKCkudGhlbihmdW5jdGlvbihiKXt2YXIgYz1hLmlzQW5vbnltb3VzO3JldHVybiBXayhhLGIpLnRoZW4oZnVuY3Rpb24oKXtjfHxUayhhLFwiaXNBbm9ueW1vdXNcIiwhMSk7cmV0dXJuIGJ9KX0pfWguRj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiBSKHRoaXMsUGsodGhpcykudGhlbihmdW5jdGlvbigpe3JldHVybiBiLmguZ2V0VG9rZW4oYSl9KS50aGVuKGZ1bmN0aW9uKGEpe2lmKCFhKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7YS5hY2Nlc3NUb2tlbiE9Yi5wYSYmKENrKGIsYS5hY2Nlc3NUb2tlbiksRyhiLG5ldyBBayhcInRva2VuQ2hhbmdlZFwiKSkpO1RrKGIsXCJyZWZyZXNoVG9rZW5cIixhLnJlZnJlc2hUb2tlbik7cmV0dXJuIGEuYWNjZXNzVG9rZW59KSl9O1xuaC5nZXRUb2tlbj1mdW5jdGlvbihhKXtkZ1tcImZpcmViYXNlLlVzZXIucHJvdG90eXBlLmdldFRva2VuIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgZmlyZWJhc2UuVXNlci5wcm90b3R5cGUuZ2V0SWRUb2tlbiBpbnN0ZWFkLlwiXXx8KGRnW1wiZmlyZWJhc2UuVXNlci5wcm90b3R5cGUuZ2V0VG9rZW4gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBmaXJlYmFzZS5Vc2VyLnByb3RvdHlwZS5nZXRJZFRva2VuIGluc3RlYWQuXCJdPSEwLFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKFwiZmlyZWJhc2UuVXNlci5wcm90b3R5cGUuZ2V0VG9rZW4gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBmaXJlYmFzZS5Vc2VyLnByb3RvdHlwZS5nZXRJZFRva2VuIGluc3RlYWQuXCIpKTtyZXR1cm4gdGhpcy5GKGEpfTtcbmZ1bmN0aW9uIFhrKGEsYil7YltPXSYmYS5wYSE9YltPXSYmKHVrKGEuaCxiKSxHKGEsbmV3IEFrKFwidG9rZW5DaGFuZ2VkXCIpKSxDayhhLGJbT10pLFRrKGEsXCJyZWZyZXNoVG9rZW5cIixhLmguYSkpfWZ1bmN0aW9uIFdrKGEsYil7cmV0dXJuIFEoYS5jLHRpLHtpZFRva2VuOmJ9KS50aGVuKHIoYS5nYyxhKSl9XG5oLmdjPWZ1bmN0aW9uKGEpe2E9YS51c2VycztpZighYXx8IWEubGVuZ3RoKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7YT1hWzBdO0RrKHRoaXMse3VpZDphLmxvY2FsSWQsZGlzcGxheU5hbWU6YS5kaXNwbGF5TmFtZSxwaG90b1VSTDphLnBob3RvVXJsLGVtYWlsOmEuZW1haWwsZW1haWxWZXJpZmllZDohIWEuZW1haWxWZXJpZmllZCxwaG9uZU51bWJlcjphLnBob25lTnVtYmVyLGxhc3RMb2dpbkF0OmEubGFzdExvZ2luQXQsY3JlYXRlZEF0OmEuY3JlYXRlZEF0fSk7Zm9yKHZhciBiPVlrKGEpLGM9MDtjPGIubGVuZ3RoO2MrKylSayh0aGlzLGJbY10pO1RrKHRoaXMsXCJpc0Fub255bW91c1wiLCEodGhpcy5lbWFpbCYmYS5wYXNzd29yZEhhc2gpJiYhKHRoaXMucHJvdmlkZXJEYXRhJiZ0aGlzLnByb3ZpZGVyRGF0YS5sZW5ndGgpKX07XG5mdW5jdGlvbiBZayhhKXtyZXR1cm4oYT1hLnByb3ZpZGVyVXNlckluZm8pJiZhLmxlbmd0aD9EYShhLGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgemsoYS5yYXdJZCxhLnByb3ZpZGVySWQsYS5lbWFpbCxhLmRpc3BsYXlOYW1lLGEucGhvdG9VcmwsYS5waG9uZU51bWJlcil9KTpbXX1oLlphPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1udWxsO3JldHVybiBSKHRoaXMsYS5jKHRoaXMuYyx0aGlzLnVpZCkudGhlbihmdW5jdGlvbihhKXtYayhiLGEpO2M9WmsoYixhLFwicmVhdXRoZW50aWNhdGVcIik7Yi5pPW51bGw7cmV0dXJuIGIucmVsb2FkKCl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSwhMCl9O2guaGM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuWmEoYSkudGhlbihmdW5jdGlvbigpe30pfTtcbmZ1bmN0aW9uICRrKGEsYil7cmV0dXJuIFZrKGEpLnRoZW4oZnVuY3Rpb24oKXtpZihIYShRayhhKSxiKSlyZXR1cm4gTWsoYSkudGhlbihmdW5jdGlvbigpe3Rocm93IG5ldyBOKFwicHJvdmlkZXItYWxyZWFkeS1saW5rZWRcIik7fSl9KX1oLlhhPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1udWxsO3JldHVybiBSKHRoaXMsJGsodGhpcyxhLnByb3ZpZGVySWQpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYi5GKCl9KS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBhLmIoYi5jLGMpfSkudGhlbihmdW5jdGlvbihhKXtjPVprKGIsYSxcImxpbmtcIik7cmV0dXJuIGFsKGIsYSl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSl9O2guWmI9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuWGEoYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS51c2VyfSl9O1xuaC4kYj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIFIodGhpcywkayh0aGlzLFwicGhvbmVcIikudGhlbihmdW5jdGlvbigpe3JldHVybiBvayhJayhjKSxhLGIscihjLlhhLGMpKX0pKX07aC5pYz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIFIodGhpcyxBKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBvayhJayhjKSxhLGIscihjLlphLGMpKX0pLCEwKX07ZnVuY3Rpb24gWmsoYSxiLGMpe3ZhciBkPXVoKGIpO2I9TWcoYik7cmV0dXJuIGhnKHt1c2VyOmEsY3JlZGVudGlhbDpkLGFkZGl0aW9uYWxVc2VySW5mbzpiLG9wZXJhdGlvblR5cGU6Y30pfWZ1bmN0aW9uIGFsKGEsYil7WGsoYSxiKTtyZXR1cm4gYS5yZWxvYWQoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KX1cbmgua2I9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gUih0aGlzLHRoaXMuRigpLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIGIuYy5rYihjLGEpfSkudGhlbihmdW5jdGlvbihhKXtYayhiLGEpO3JldHVybiBiLnJlbG9hZCgpfSkpfTtoLnpjPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIFIodGhpcyx0aGlzLkYoKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBhLmIoYi5jLGMpfSkudGhlbihmdW5jdGlvbihhKXtYayhiLGEpO3JldHVybiBiLnJlbG9hZCgpfSkpfTtoLmxiPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIFIodGhpcyx0aGlzLkYoKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBiLmMubGIoYyxhKX0pLnRoZW4oZnVuY3Rpb24oYSl7WGsoYixhKTtyZXR1cm4gYi5yZWxvYWQoKX0pKX07XG5oLm1iPWZ1bmN0aW9uKGEpe2lmKHZvaWQgMD09PWEuZGlzcGxheU5hbWUmJnZvaWQgMD09PWEucGhvdG9VUkwpcmV0dXJuIFBrKHRoaXMpO3ZhciBiPXRoaXM7cmV0dXJuIFIodGhpcyx0aGlzLkYoKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBiLmMubWIoYyx7ZGlzcGxheU5hbWU6YS5kaXNwbGF5TmFtZSxwaG90b1VybDphLnBob3RvVVJMfSl9KS50aGVuKGZ1bmN0aW9uKGEpe1hrKGIsYSk7VGsoYixcImRpc3BsYXlOYW1lXCIsYS5kaXNwbGF5TmFtZXx8bnVsbCk7VGsoYixcInBob3RvVVJMXCIsYS5waG90b1VybHx8bnVsbCk7dyhiLnByb3ZpZGVyRGF0YSxmdW5jdGlvbihhKXtcInBhc3N3b3JkXCI9PT1hLnByb3ZpZGVySWQmJihNKGEsXCJkaXNwbGF5TmFtZVwiLGIuZGlzcGxheU5hbWUpLE0oYSxcInBob3RvVVJMXCIsYi5waG90b1VSTCkpfSk7cmV0dXJuIE1rKGIpfSkudGhlbihPaykpfTtcbmgueWM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gUih0aGlzLFZrKHRoaXMpLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIEhhKFFrKGIpLGEpP2ZpKGIuYyxjLFthXSkudGhlbihmdW5jdGlvbihhKXt2YXIgYz17fTt3KGEucHJvdmlkZXJVc2VySW5mb3x8W10sZnVuY3Rpb24oYSl7Y1thLnByb3ZpZGVySWRdPSEwfSk7dyhRayhiKSxmdW5jdGlvbihhKXtjW2FdfHxTayhiLGEpfSk7Y1tyaC5QUk9WSURFUl9JRF18fE0oYixcInBob25lTnVtYmVyXCIsbnVsbCk7cmV0dXJuIE1rKGIpfSk6TWsoYikudGhlbihmdW5jdGlvbigpe3Rocm93IG5ldyBOKFwibm8tc3VjaC1wcm92aWRlclwiKTt9KX0pKX07XG5oLmRlbGV0ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIFIodGhpcyx0aGlzLkYoKS50aGVuKGZ1bmN0aW9uKGIpe3JldHVybiBRKGEuYyxzaSx7aWRUb2tlbjpifSl9KS50aGVuKGZ1bmN0aW9uKCl7RyhhLG5ldyBBayhcInVzZXJEZWxldGVkXCIpKX0pKS50aGVuKGZ1bmN0aW9uKCl7Zm9yKHZhciBiPTA7YjxhLkEubGVuZ3RoO2IrKylhLkFbYl0uY2FuY2VsKFwiYXBwLWRlbGV0ZWRcIik7R2soYSxudWxsKTtIayhhLG51bGwpO2EuQT1bXTthLm09ITA7S2soYSk7TShhLFwicmVmcmVzaFRva2VuXCIsbnVsbCk7YS5hJiZhLmEudW5zdWJzY3JpYmUoYSl9KX07XG5oLm9iPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCJsaW5rVmlhUG9wdXBcIj09YSYmKHRoaXMuZ3x8bnVsbCk9PWImJnRoaXMuZnx8XCJyZWF1dGhWaWFQb3B1cFwiPT1hJiYodGhpcy5nfHxudWxsKT09YiYmdGhpcy5mfHxcImxpbmtWaWFSZWRpcmVjdFwiPT1hJiYodGhpcy5afHxudWxsKT09Ynx8XCJyZWF1dGhWaWFSZWRpcmVjdFwiPT1hJiYodGhpcy5afHxudWxsKT09Yj8hMDohMX07aC5mYT1mdW5jdGlvbihhLGIsYyxkKXtcImxpbmtWaWFQb3B1cFwiIT1hJiZcInJlYXV0aFZpYVBvcHVwXCIhPWF8fGQhPSh0aGlzLmd8fG51bGwpfHwoYyYmdGhpcy52P3RoaXMudihjKTpiJiYhYyYmdGhpcy5mJiZ0aGlzLmYoYiksdGhpcy5iJiYodGhpcy5iLmNhbmNlbCgpLHRoaXMuYj1udWxsKSxkZWxldGUgdGhpcy5mLGRlbGV0ZSB0aGlzLnYpfTtcbmgudmE9ZnVuY3Rpb24oYSxiKXtyZXR1cm5cImxpbmtWaWFQb3B1cFwiPT1hJiZiPT0odGhpcy5nfHxudWxsKT9yKHRoaXMuc2IsdGhpcyk6XCJyZWF1dGhWaWFQb3B1cFwiPT1hJiZiPT0odGhpcy5nfHxudWxsKT9yKHRoaXMudGIsdGhpcyk6XCJsaW5rVmlhUmVkaXJlY3RcIj09YSYmKHRoaXMuWnx8bnVsbCk9PWI/cih0aGlzLnNiLHRoaXMpOlwicmVhdXRoVmlhUmVkaXJlY3RcIj09YSYmKHRoaXMuWnx8bnVsbCk9PWI/cih0aGlzLnRiLHRoaXMpOm51bGx9O2guYWM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gYmwodGhpcyxcImxpbmtWaWFQb3B1cFwiLGEsZnVuY3Rpb24oKXtyZXR1cm4gJGsoYixhLnByb3ZpZGVySWQpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gTWsoYil9KX0sITEpfTtoLmpjPWZ1bmN0aW9uKGEpe3JldHVybiBibCh0aGlzLFwicmVhdXRoVmlhUG9wdXBcIixhLGZ1bmN0aW9uKCl7cmV0dXJuIEEoKX0sITApfTtcbmZ1bmN0aW9uIGJsKGEsYixjLGQsZSl7aWYoIVJmKCkpcmV0dXJuIEIobmV3IE4oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKTtpZihhLmkmJiFlKXJldHVybiBCKGEuaSk7dmFyIGY9TGcoYy5wcm92aWRlcklkKSxnPVFmKGEudWlkK1wiOjo6XCIpLGw9bnVsbDsoIVRmKCl8fExmKCkpJiZhLncmJmMuaXNPQXV0aFByb3ZpZGVyJiYobD1SaShhLncsYS5HLGEubyxiLGMsbnVsbCxnLGZpcmViYXNlLlNES19WRVJTSU9OfHxudWxsKSk7dmFyIG49RGYobCxmJiZmLnphLGYmJmYueWEpO2Q9ZCgpLnRoZW4oZnVuY3Rpb24oKXtjbChhKTtpZighZSlyZXR1cm4gYS5GKCkudGhlbihmdW5jdGlvbigpe30pfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBlayhhLmEsbixiLGMsZywhIWwpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBuZXcgeihmdW5jdGlvbihjLGQpe2EuZmEoYixudWxsLG5ldyBOKFwiY2FuY2VsbGVkLXBvcHVwLXJlcXVlc3RcIiksYS5nfHxudWxsKTtcbmEuZj1jO2Eudj1kO2EuZz1nO2EuYj1hLmEuQ2EoYSxiLG4sZyl9KX0pLnRoZW4oZnVuY3Rpb24oYSl7biYmQ2Yobik7cmV0dXJuIGE/aGcoYSk6bnVsbH0pLnMoZnVuY3Rpb24oYSl7biYmQ2Yobik7dGhyb3cgYTt9KTtyZXR1cm4gUihhLGQsZSl9aC5iYz1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiBkbCh0aGlzLFwibGlua1ZpYVJlZGlyZWN0XCIsYSxmdW5jdGlvbigpe3JldHVybiAkayhiLGEucHJvdmlkZXJJZCl9LCExKX07aC5rYz1mdW5jdGlvbihhKXtyZXR1cm4gZGwodGhpcyxcInJlYXV0aFZpYVJlZGlyZWN0XCIsYSxmdW5jdGlvbigpe3JldHVybiBBKCl9LCEwKX07XG5mdW5jdGlvbiBkbChhLGIsYyxkLGUpe2lmKCFSZigpKXJldHVybiBCKG5ldyBOKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7aWYoYS5pJiYhZSlyZXR1cm4gQihhLmkpO3ZhciBmPW51bGwsZz1RZihhLnVpZCtcIjo6OlwiKTtkPWQoKS50aGVuKGZ1bmN0aW9uKCl7Y2woYSk7aWYoIWUpcmV0dXJuIGEuRigpLnRoZW4oZnVuY3Rpb24oKXt9KX0pLnRoZW4oZnVuY3Rpb24oKXthLlo9ZztyZXR1cm4gTWsoYSl9KS50aGVuKGZ1bmN0aW9uKGIpe2EuY2EmJihiPWEuY2EsYj1iLmIuc2V0KGVsLGEuQigpLGIuYSkpO3JldHVybiBifSkudGhlbihmdW5jdGlvbigpe3JldHVybiBhLmEuQWEoYixjLGcpfSkucyhmdW5jdGlvbihiKXtmPWI7aWYoYS5jYSlyZXR1cm4gZmwoYS5jYSk7dGhyb3cgZjt9KS50aGVuKGZ1bmN0aW9uKCl7aWYoZil0aHJvdyBmO30pO3JldHVybiBSKGEsZCxlKX1cbmZ1bmN0aW9uIGNsKGEpe2lmKCFhLmF8fCFhLkkpe2lmKGEuYSYmIWEuSSl0aHJvdyBuZXcgTihcImludGVybmFsLWVycm9yXCIpO3Rocm93IG5ldyBOKFwiYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkXCIpO319aC5zYj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dGhpcy5iJiYodGhpcy5iLmNhbmNlbCgpLHRoaXMuYj1udWxsKTt2YXIgZD1udWxsLGU9dGhpcy5GKCkudGhlbihmdW5jdGlvbihkKXtyZXR1cm4gWmcoYy5jLHtyZXF1ZXN0VXJpOmEsc2Vzc2lvbklkOmIsaWRUb2tlbjpkfSl9KS50aGVuKGZ1bmN0aW9uKGEpe2Q9WmsoYyxhLFwibGlua1wiKTtyZXR1cm4gYWwoYyxhKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3JldHVybiBSKHRoaXMsZSl9O1xuaC50Yj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dGhpcy5iJiYodGhpcy5iLmNhbmNlbCgpLHRoaXMuYj1udWxsKTt2YXIgZD1udWxsLGU9QSgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gVmcoJGcoYy5jLHtyZXF1ZXN0VXJpOmEsc2Vzc2lvbklkOmJ9KSxjLnVpZCl9KS50aGVuKGZ1bmN0aW9uKGEpe2Q9WmsoYyxhLFwicmVhdXRoZW50aWNhdGVcIik7WGsoYyxhKTtjLmk9bnVsbDtyZXR1cm4gYy5yZWxvYWQoKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3JldHVybiBSKHRoaXMsZSwhMCl9O2guYmI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPW51bGw7cmV0dXJuIFIodGhpcyx0aGlzLkYoKS50aGVuKGZ1bmN0aW9uKGIpe2M9YjtyZXR1cm5cInVuZGVmaW5lZFwiPT09dHlwZW9mIGF8fFNhKGEpP3t9OkZnKG5ldyB3ZyhhKSl9KS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBiLmMuYmIoYyxhKX0pLnRoZW4oZnVuY3Rpb24oYSl7aWYoYi5lbWFpbCE9YSlyZXR1cm4gYi5yZWxvYWQoKX0pLnRoZW4oZnVuY3Rpb24oKXt9KSl9O1xuZnVuY3Rpb24gUihhLGIsYyl7dmFyIGQ9Z2woYSxiLGMpO2EuQS5wdXNoKGQpO1FiKGQsZnVuY3Rpb24oKXtJYShhLkEsZCl9KTtyZXR1cm4gZH1mdW5jdGlvbiBnbChhLGIsYyl7cmV0dXJuIGEuaSYmIWM/KGIuY2FuY2VsKCksQihhLmkpKTpiLnMoZnVuY3Rpb24oYil7IWJ8fFwiYXV0aC91c2VyLWRpc2FibGVkXCIhPWIuY29kZSYmXCJhdXRoL3VzZXItdG9rZW4tZXhwaXJlZFwiIT1iLmNvZGV8fChhLml8fEcoYSxuZXcgQWsoXCJ1c2VySW52YWxpZGF0ZWRcIikpLGEuaT1iKTt0aHJvdyBiO30pfWgudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQigpfTtcbmguQj1mdW5jdGlvbigpe3ZhciBhPXt1aWQ6dGhpcy51aWQsZGlzcGxheU5hbWU6dGhpcy5kaXNwbGF5TmFtZSxwaG90b1VSTDp0aGlzLnBob3RvVVJMLGVtYWlsOnRoaXMuZW1haWwsZW1haWxWZXJpZmllZDp0aGlzLmVtYWlsVmVyaWZpZWQscGhvbmVOdW1iZXI6dGhpcy5waG9uZU51bWJlcixpc0Fub255bW91czp0aGlzLmlzQW5vbnltb3VzLHByb3ZpZGVyRGF0YTpbXSxhcGlLZXk6dGhpcy5HLGFwcE5hbWU6dGhpcy5vLGF1dGhEb21haW46dGhpcy53LHN0c1Rva2VuTWFuYWdlcjp0aGlzLmguQigpLHJlZGlyZWN0RXZlbnRJZDp0aGlzLlp8fG51bGx9O3RoaXMubWV0YWRhdGEmJldhKGEsdGhpcy5tZXRhZGF0YS5CKCkpO3codGhpcy5wcm92aWRlckRhdGEsZnVuY3Rpb24oYil7YS5wcm92aWRlckRhdGEucHVzaChpZyhiKSl9KTtyZXR1cm4gYX07XG5mdW5jdGlvbiBobChhKXtpZighYS5hcGlLZXkpcmV0dXJuIG51bGw7dmFyIGI9e2FwaUtleTphLmFwaUtleSxhdXRoRG9tYWluOmEuYXV0aERvbWFpbixhcHBOYW1lOmEuYXBwTmFtZX0sYz17fTtpZihhLnN0c1Rva2VuTWFuYWdlciYmYS5zdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW4mJmEuc3RzVG9rZW5NYW5hZ2VyLmV4cGlyYXRpb25UaW1lKWNbT109YS5zdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW4sYy5yZWZyZXNoVG9rZW49YS5zdHNUb2tlbk1hbmFnZXIucmVmcmVzaFRva2VufHxudWxsLGMuZXhwaXJlc0luPShhLnN0c1Rva2VuTWFuYWdlci5leHBpcmF0aW9uVGltZS1uYSgpKS8xRTM7ZWxzZSByZXR1cm4gbnVsbDt2YXIgZD1uZXcgQmsoYixjLGEpO2EucHJvdmlkZXJEYXRhJiZ3KGEucHJvdmlkZXJEYXRhLGZ1bmN0aW9uKGEpe2EmJlJrKGQsaGcoYSkpfSk7YS5yZWRpcmVjdEV2ZW50SWQmJihkLlo9YS5yZWRpcmVjdEV2ZW50SWQpO3JldHVybiBkfVxuZnVuY3Rpb24gaWwoYSxiLGMsZCl7dmFyIGU9bmV3IEJrKGEsYik7YyYmKGUuY2E9Yyk7ZCYmRmsoZSxkKTtyZXR1cm4gZS5yZWxvYWQoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGV9KX07ZnVuY3Rpb24gamwoYSl7dGhpcy5hPWE7dGhpcy5iPXJqKCl9dmFyIGVsPXtuYW1lOlwicmVkaXJlY3RVc2VyXCIsQzpcInNlc3Npb25cIn07ZnVuY3Rpb24gZmwoYSl7cmV0dXJuIHVqKGEuYixlbCxhLmEpfWZ1bmN0aW9uIGtsKGEsYil7cmV0dXJuIGEuYi5nZXQoZWwsYS5hKS50aGVuKGZ1bmN0aW9uKGEpe2EmJmImJihhLmF1dGhEb21haW49Yik7cmV0dXJuIGhsKGF8fHt9KX0pfTtmdW5jdGlvbiBsbChhLGIpe3RoaXMuYT1hO3RoaXMuYj1ifHxyaigpO3RoaXMuYz1udWxsO3RoaXMuZj1tbCh0aGlzKTt2aih0aGlzLmIseWooXCJsb2NhbFwiKSx0aGlzLmEscih0aGlzLmcsdGhpcykpfWxsLnByb3RvdHlwZS5nPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPXlqKFwibG9jYWxcIik7bmwodGhpcyxmdW5jdGlvbigpe3JldHVybiBBKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBhLmMmJlwibG9jYWxcIiE9YS5jLkM/YS5iLmdldChiLGEuYSk6bnVsbH0pLnRoZW4oZnVuY3Rpb24oYyl7aWYoYylyZXR1cm4gb2woYSxcImxvY2FsXCIpLnRoZW4oZnVuY3Rpb24oKXthLmM9Yn0pfSl9KX07ZnVuY3Rpb24gb2woYSxiKXt2YXIgYz1bXSxkO2ZvcihkIGluIG5qKW5qW2RdIT09YiYmYy5wdXNoKHVqKGEuYix5aihualtkXSksYS5hKSk7Yy5wdXNoKHVqKGEuYixwbCxhLmEpKTtyZXR1cm4gTmIoYyl9XG5mdW5jdGlvbiBtbChhKXt2YXIgYj15aihcImxvY2FsXCIpLGM9eWooXCJzZXNzaW9uXCIpLGQ9eWooXCJub25lXCIpO3JldHVybiBhLmIuZ2V0KGMsYS5hKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBlP2M6YS5iLmdldChkLGEuYSkudGhlbihmdW5jdGlvbihjKXtyZXR1cm4gYz9kOmEuYi5nZXQoYixhLmEpLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIGM/YjphLmIuZ2V0KHBsLGEuYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYT95aihhKTpifSl9KX0pfSkudGhlbihmdW5jdGlvbihiKXthLmM9YjtyZXR1cm4gb2woYSxiLkMpfSkucyhmdW5jdGlvbigpe2EuY3x8KGEuYz1iKX0pfXZhciBwbD17bmFtZTpcInBlcnNpc3RlbmNlXCIsQzpcInNlc3Npb25cIn07ZnVuY3Rpb24geWooYSl7cmV0dXJue25hbWU6XCJhdXRoVXNlclwiLEM6YX19XG5sbC5wcm90b3R5cGUuZWI9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbCxjPXRoaXM7b2ooYSk7cmV0dXJuIG5sKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gYSE9Yy5jLkM/Yy5iLmdldChjLmMsYy5hKS50aGVuKGZ1bmN0aW9uKGQpe2I9ZDtyZXR1cm4gb2woYyxhKX0pLnRoZW4oZnVuY3Rpb24oKXtjLmM9eWooYSk7aWYoYilyZXR1cm4gYy5iLnNldChjLmMsYixjLmEpfSk6QSgpfSl9O2Z1bmN0aW9uIHFsKGEpe3JldHVybiBubChhLGZ1bmN0aW9uKCl7cmV0dXJuIGEuYi5zZXQocGwsYS5jLkMsYS5hKX0pfWZ1bmN0aW9uIHJsKGEsYil7cmV0dXJuIG5sKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5iLnNldChhLmMsYi5CKCksYS5hKX0pfWZ1bmN0aW9uIHNsKGEpe3JldHVybiBubChhLGZ1bmN0aW9uKCl7cmV0dXJuIHVqKGEuYixhLmMsYS5hKX0pfVxuZnVuY3Rpb24gdGwoYSxiKXtyZXR1cm4gbmwoYSxmdW5jdGlvbigpe3JldHVybiBhLmIuZ2V0KGEuYyxhLmEpLnRoZW4oZnVuY3Rpb24oYSl7YSYmYiYmKGEuYXV0aERvbWFpbj1iKTtyZXR1cm4gaGwoYXx8e30pfSl9KX1mdW5jdGlvbiBubChhLGIpe2EuZj1hLmYudGhlbihiLGIpO3JldHVybiBhLmZ9O2Z1bmN0aW9uIHVsKGEpe3RoaXMubD0hMTtNKHRoaXMsXCJhcHBcIixhKTtpZihTKHRoaXMpLm9wdGlvbnMmJlModGhpcykub3B0aW9ucy5hcGlLZXkpYT1maXJlYmFzZS5TREtfVkVSU0lPTj9PZihmaXJlYmFzZS5TREtfVkVSU0lPTik6bnVsbCx0aGlzLmM9bmV3IENoKFModGhpcykub3B0aW9ucyYmUyh0aGlzKS5vcHRpb25zLmFwaUtleSx4aSh5aSksYSk7ZWxzZSB0aHJvdyBuZXcgTihcImludmFsaWQtYXBpLWtleVwiKTt0aGlzLk49W107dGhpcy5tPVtdO3RoaXMuST1bXTt0aGlzLkdiPWZpcmViYXNlLklOVEVSTkFMLmNyZWF0ZVN1YnNjcmliZShyKHRoaXMuWGIsdGhpcykpO3RoaXMuUj12b2lkIDA7dGhpcy5IYj1maXJlYmFzZS5JTlRFUk5BTC5jcmVhdGVTdWJzY3JpYmUocih0aGlzLlliLHRoaXMpKTt2bCh0aGlzLG51bGwpO3RoaXMuaD1uZXcgbGwoUyh0aGlzKS5vcHRpb25zLmFwaUtleStcIjpcIitTKHRoaXMpLm5hbWUpO3RoaXMuRz1uZXcgamwoUyh0aGlzKS5vcHRpb25zLmFwaUtleStcblwiOlwiK1ModGhpcykubmFtZSk7dGhpcy5VPVQodGhpcyx3bCh0aGlzKSk7dGhpcy5pPVQodGhpcyx4bCh0aGlzKSk7dGhpcy5XPSExO3RoaXMuaGE9cih0aGlzLnVjLHRoaXMpO3RoaXMuR2E9cih0aGlzLmthLHRoaXMpO3RoaXMucGE9cih0aGlzLlBiLHRoaXMpO3RoaXMucWE9cih0aGlzLlZiLHRoaXMpO3RoaXMucmE9cih0aGlzLldiLHRoaXMpO3lsKHRoaXMpO3RoaXMuSU5URVJOQUw9e307dGhpcy5JTlRFUk5BTFtcImRlbGV0ZVwiXT1yKHRoaXMuZGVsZXRlLHRoaXMpO3RoaXMuSU5URVJOQUwubG9nRnJhbWV3b3JrPXIodGhpcy5jYyx0aGlzKTt0aGlzLm89MDtGLmNhbGwodGhpcyk7emwodGhpcyk7dGhpcy5BPVtdfXQodWwsRik7ZnVuY3Rpb24gQWwoYSl7Qy5jYWxsKHRoaXMsXCJsYW5ndWFnZUNvZGVDaGFuZ2VkXCIpO3RoaXMuaD1hfXQoQWwsQyk7ZnVuY3Rpb24gQmwoYSl7Qy5jYWxsKHRoaXMsXCJmcmFtZXdvcmtDaGFuZ2VkXCIpO3RoaXMuZj1hfXQoQmwsQyk7aD11bC5wcm90b3R5cGU7XG5oLmViPWZ1bmN0aW9uKGEpe2E9dGhpcy5oLmViKGEpO3JldHVybiBUKHRoaXMsYSl9O2gubmE9ZnVuY3Rpb24oYSl7dGhpcy5WPT09YXx8dGhpcy5sfHwodGhpcy5WPWEsSWgodGhpcy5jLHRoaXMuViksRyh0aGlzLG5ldyBBbCh0aGlzLiQoKSkpKX07aC4kPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuVn07aC5BYz1mdW5jdGlvbigpe3ZhciBhPWsubmF2aWdhdG9yO3RoaXMubmEoYT9hLmxhbmd1YWdlcyYmYS5sYW5ndWFnZXNbMF18fGEubGFuZ3VhZ2V8fGEudXNlckxhbmd1YWdlfHxudWxsOm51bGwpfTtoLmNjPWZ1bmN0aW9uKGEpe3RoaXMuQS5wdXNoKGEpO0poKHRoaXMuYyxmaXJlYmFzZS5TREtfVkVSU0lPTj9PZihmaXJlYmFzZS5TREtfVkVSU0lPTix0aGlzLkEpOm51bGwpO0codGhpcyxuZXcgQmwodGhpcy5BKSl9O2guS2E9ZnVuY3Rpb24oKXtyZXR1cm4gTGEodGhpcy5BKX07XG5mdW5jdGlvbiB6bChhKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImxjXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLiQoKX0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMubmEoYSl9LGVudW1lcmFibGU6ITF9KTthLlY9bnVsbH1oLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnthcGlLZXk6Uyh0aGlzKS5vcHRpb25zLmFwaUtleSxhdXRoRG9tYWluOlModGhpcykub3B0aW9ucy5hdXRoRG9tYWluLGFwcE5hbWU6Uyh0aGlzKS5uYW1lLGN1cnJlbnRVc2VyOlUodGhpcykmJlUodGhpcykuQigpfX07ZnVuY3Rpb24gQ2woYSl7cmV0dXJuIGEuRmJ8fEIobmV3IE4oXCJhdXRoLWRvbWFpbi1jb25maWctcmVxdWlyZWRcIikpfVxuZnVuY3Rpb24geWwoYSl7dmFyIGI9UyhhKS5vcHRpb25zLmF1dGhEb21haW4sYz1TKGEpLm9wdGlvbnMuYXBpS2V5O2ImJlJmKCkmJihhLkZiPWEuVS50aGVuKGZ1bmN0aW9uKCl7aWYoIWEubCl7YS5hPWdrKGIsYyxTKGEpLm5hbWUpO2EuYS5zdWJzY3JpYmUoYSk7VShhKSYmTmsoVShhKSk7aWYoYS53KXtOayhhLncpO3ZhciBkPWEudztkLm5hKGEuJCgpKTtHayhkLGEpO2Q9YS53O0ZrKGQsYS5BKTtIayhkLGEpO2Eudz1udWxsfXJldHVybiBhLmF9fSkpfWgub2I9ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYSl7Y2FzZSBcInVua25vd25cIjpjYXNlIFwic2lnbkluVmlhUmVkaXJlY3RcIjpyZXR1cm4hMDtjYXNlIFwic2lnbkluVmlhUG9wdXBcIjpyZXR1cm4gdGhpcy5nPT1iJiYhIXRoaXMuZjtkZWZhdWx0OnJldHVybiExfX07XG5oLmZhPWZ1bmN0aW9uKGEsYixjLGQpe1wic2lnbkluVmlhUG9wdXBcIj09YSYmdGhpcy5nPT1kJiYoYyYmdGhpcy52P3RoaXMudihjKTpiJiYhYyYmdGhpcy5mJiZ0aGlzLmYoYiksdGhpcy5iJiYodGhpcy5iLmNhbmNlbCgpLHRoaXMuYj1udWxsKSxkZWxldGUgdGhpcy5mLGRlbGV0ZSB0aGlzLnYpfTtoLnZhPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCJzaWduSW5WaWFSZWRpcmVjdFwiPT1hfHxcInNpZ25JblZpYVBvcHVwXCI9PWEmJnRoaXMuZz09YiYmdGhpcy5mP3IodGhpcy5PYix0aGlzKTpudWxsfTtcbmguT2I9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO2E9e3JlcXVlc3RVcmk6YSxzZXNzaW9uSWQ6Yn07dGhpcy5iJiYodGhpcy5iLmNhbmNlbCgpLHRoaXMuYj1udWxsKTt2YXIgZD1udWxsLGU9bnVsbCxmPVhnKGMuYyxhKS50aGVuKGZ1bmN0aW9uKGEpe2Q9dWgoYSk7ZT1NZyhhKTtyZXR1cm4gYX0pO2E9Yy5VLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZn0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIERsKGMsYSl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGhnKHt1c2VyOlUoYyksY3JlZGVudGlhbDpkLGFkZGl0aW9uYWxVc2VySW5mbzplLG9wZXJhdGlvblR5cGU6XCJzaWduSW5cIn0pfSk7cmV0dXJuIFQodGhpcyxhKX07XG5oLnNjPWZ1bmN0aW9uKGEpe2lmKCFSZigpKXJldHVybiBCKG5ldyBOKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7dmFyIGI9dGhpcyxjPUxnKGEucHJvdmlkZXJJZCksZD1RZigpLGU9bnVsbDsoIVRmKCl8fExmKCkpJiZTKHRoaXMpLm9wdGlvbnMuYXV0aERvbWFpbiYmYS5pc09BdXRoUHJvdmlkZXImJihlPVJpKFModGhpcykub3B0aW9ucy5hdXRoRG9tYWluLFModGhpcykub3B0aW9ucy5hcGlLZXksUyh0aGlzKS5uYW1lLFwic2lnbkluVmlhUG9wdXBcIixhLG51bGwsZCxmaXJlYmFzZS5TREtfVkVSU0lPTnx8bnVsbCkpO3ZhciBmPURmKGUsYyYmYy56YSxjJiZjLnlhKTtjPUNsKHRoaXMpLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIGVrKGIsZixcInNpZ25JblZpYVBvcHVwXCIsYSxkLCEhZSl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGEsYyl7Yi5mYShcInNpZ25JblZpYVBvcHVwXCIsbnVsbCxuZXcgTihcImNhbmNlbGxlZC1wb3B1cC1yZXF1ZXN0XCIpLFxuYi5nKTtiLmY9YTtiLnY9YztiLmc9ZDtiLmI9Yi5hLkNhKGIsXCJzaWduSW5WaWFQb3B1cFwiLGYsZCl9KX0pLnRoZW4oZnVuY3Rpb24oYSl7ZiYmQ2YoZik7cmV0dXJuIGE/aGcoYSk6bnVsbH0pLnMoZnVuY3Rpb24oYSl7ZiYmQ2YoZik7dGhyb3cgYTt9KTtyZXR1cm4gVCh0aGlzLGMpfTtoLnRjPWZ1bmN0aW9uKGEpe2lmKCFSZigpKXJldHVybiBCKG5ldyBOKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7dmFyIGI9dGhpcyxjPUNsKHRoaXMpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gcWwoYi5oKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYi5hLkFhKFwic2lnbkluVmlhUmVkaXJlY3RcIixhKX0pO3JldHVybiBUKHRoaXMsYyl9O1xuaC5hYT1mdW5jdGlvbigpe2lmKCFSZigpKXJldHVybiBCKG5ldyBOKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7dmFyIGE9dGhpcyxiPUNsKHRoaXMpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYS5hLmFhKCl9KS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBhP2hnKGEpOm51bGx9KTtyZXR1cm4gVCh0aGlzLGIpfTtmdW5jdGlvbiBEbChhLGIpe3ZhciBjPXt9O2MuYXBpS2V5PVMoYSkub3B0aW9ucy5hcGlLZXk7Yy5hdXRoRG9tYWluPVMoYSkub3B0aW9ucy5hdXRoRG9tYWluO2MuYXBwTmFtZT1TKGEpLm5hbWU7cmV0dXJuIGEuVS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGlsKGMsYixhLkcsYS5LYSgpKX0pLnRoZW4oZnVuY3Rpb24oYil7aWYoVShhKSYmYi51aWQ9PVUoYSkudWlkKXJldHVybiBVayhVKGEpLGIpLGEua2EoYik7dmwoYSxiKTtOayhiKTtyZXR1cm4gYS5rYShiKX0pLnRoZW4oZnVuY3Rpb24oKXtFbChhKX0pfVxuZnVuY3Rpb24gdmwoYSxiKXtVKGEpJiYoTGsoVShhKSxhLkdhKSxFKFUoYSksXCJ0b2tlbkNoYW5nZWRcIixhLnBhKSxFKFUoYSksXCJ1c2VyRGVsZXRlZFwiLGEucWEpLEUoVShhKSxcInVzZXJJbnZhbGlkYXRlZFwiLGEucmEpLEtrKFUoYSkpKTtiJiYoYi5OLnB1c2goYS5HYSksY2QoYixcInRva2VuQ2hhbmdlZFwiLGEucGEpLGNkKGIsXCJ1c2VyRGVsZXRlZFwiLGEucWEpLGNkKGIsXCJ1c2VySW52YWxpZGF0ZWRcIixhLnJhKSwwPGEubyYmSmsoYikpO00oYSxcImN1cnJlbnRVc2VyXCIsYik7YiYmKGIubmEoYS4kKCkpLEdrKGIsYSksRmsoYixhLkEpLEhrKGIsYSkpfWguaGI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9dGhpcy5pLnRoZW4oZnVuY3Rpb24oKXtpZighVShhKSlyZXR1cm4gQSgpO3ZsKGEsbnVsbCk7cmV0dXJuIHNsKGEuaCkudGhlbihmdW5jdGlvbigpe0VsKGEpfSl9KTtyZXR1cm4gVCh0aGlzLGIpfTtcbmZ1bmN0aW9uIEZsKGEpe3ZhciBiPWtsKGEuRyxTKGEpLm9wdGlvbnMuYXV0aERvbWFpbikudGhlbihmdW5jdGlvbihiKXtpZihhLnc9YiliLmNhPWEuRztyZXR1cm4gZmwoYS5HKX0pO3JldHVybiBUKGEsYil9ZnVuY3Rpb24gd2woYSl7dmFyIGI9UyhhKS5vcHRpb25zLmF1dGhEb21haW4sYz1GbChhKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHRsKGEuaCxiKX0pLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIGI/KGIuY2E9YS5HLGEudyYmKGEudy5afHxudWxsKT09KGIuWnx8bnVsbCk/YjpiLnJlbG9hZCgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gcmwoYS5oLGIpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYn0pfSkucyhmdW5jdGlvbihjKXtyZXR1cm5cImF1dGgvbmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiPT1jLmNvZGU/YjpzbChhLmgpfSkpOm51bGx9KS50aGVuKGZ1bmN0aW9uKGIpe3ZsKGEsYnx8bnVsbCl9KTtyZXR1cm4gVChhLGMpfVxuZnVuY3Rpb24geGwoYSl7cmV0dXJuIGEuVS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGEuYWEoKX0pLnMoZnVuY3Rpb24oKXt9KS50aGVuKGZ1bmN0aW9uKCl7aWYoIWEubClyZXR1cm4gYS5oYSgpfSkucyhmdW5jdGlvbigpe30pLnRoZW4oZnVuY3Rpb24oKXtpZighYS5sKXthLlc9ITA7dmFyIGI9YS5oO3ZqKGIuYix5aihcImxvY2FsXCIpLGIuYSxhLmhhKX19KX1cbmgudWM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiB0bCh0aGlzLmgsUyh0aGlzKS5vcHRpb25zLmF1dGhEb21haW4pLnRoZW4oZnVuY3Rpb24oYil7aWYoIWEubCl7dmFyIGM7aWYoYz1VKGEpJiZiKXtjPVUoYSkudWlkO3ZhciBkPWIudWlkO2M9dm9pZCAwPT09Y3x8bnVsbD09PWN8fFwiXCI9PT1jfHx2b2lkIDA9PT1kfHxudWxsPT09ZHx8XCJcIj09PWQ/ITE6Yz09ZH1pZihjKXJldHVybiBVayhVKGEpLGIpLFUoYSkuRigpO2lmKFUoYSl8fGIpdmwoYSxiKSxiJiYoTmsoYiksYi5jYT1hLkcpLGEuYSYmYS5hLnN1YnNjcmliZShhKSxFbChhKX19KX07aC5rYT1mdW5jdGlvbihhKXtyZXR1cm4gcmwodGhpcy5oLGEpfTtoLlBiPWZ1bmN0aW9uKCl7RWwodGhpcyk7dGhpcy5rYShVKHRoaXMpKX07aC5WYj1mdW5jdGlvbigpe3RoaXMuaGIoKX07aC5XYj1mdW5jdGlvbigpe3RoaXMuaGIoKX07XG5mdW5jdGlvbiBHbChhLGIpe3ZhciBjPW51bGwsZD1udWxsO3JldHVybiBUKGEsYi50aGVuKGZ1bmN0aW9uKGIpe2M9dWgoYik7ZD1NZyhiKTtyZXR1cm4gRGwoYSxiKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gaGcoe3VzZXI6VShhKSxjcmVkZW50aWFsOmMsYWRkaXRpb25hbFVzZXJJbmZvOmQsb3BlcmF0aW9uVHlwZTpcInNpZ25JblwifSl9KSl9aC5YYj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3RoaXMuYWRkQXV0aFRva2VuTGlzdGVuZXIoZnVuY3Rpb24oKXthLm5leHQoVShiKSl9KX07aC5ZYj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO0hsKHRoaXMsZnVuY3Rpb24oKXthLm5leHQoVShiKSl9KX07aC5lYz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpczt0aGlzLlcmJmZpcmViYXNlLlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtwKGEpP2EoVShkKSk6cChhLm5leHQpJiZhLm5leHQoVShkKSl9KTtyZXR1cm4gdGhpcy5HYihhLGIsYyl9O1xuaC5kYz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpczt0aGlzLlcmJmZpcmViYXNlLlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtkLlI9ZC5nZXRVaWQoKTtwKGEpP2EoVShkKSk6cChhLm5leHQpJiZhLm5leHQoVShkKSl9KTtyZXR1cm4gdGhpcy5IYihhLGIsYyl9O2guUmI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXRoaXMuaS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFUoYik/VShiKS5GKGEpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJue2FjY2Vzc1Rva2VuOmF9fSk6bnVsbH0pO3JldHVybiBUKHRoaXMsYyl9O2gucGM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gdGhpcy5pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gR2woYixRKGIuYyx2aSx7dG9rZW46YX0pKX0pLnRoZW4oZnVuY3Rpb24oYSl7YT1hLnVzZXI7VGsoYSxcImlzQW5vbnltb3VzXCIsITEpO3JldHVybiBiLmthKGEpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBVKGIpfSl9O1xuaC5xYz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIHRoaXMuaS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIEdsKGMsUShjLmMsa2gse2VtYWlsOmEscGFzc3dvcmQ6Yn0pKX0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEudXNlcn0pfTtoLktiPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztyZXR1cm4gdGhpcy5pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gR2woYyxRKGMuYyxyaSx7ZW1haWw6YSxwYXNzd29yZDpifSkpfSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS51c2VyfSl9O2gub2M9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZmIoYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS51c2VyfSl9O2guZmI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gdGhpcy5pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gR2woYixhLndhKGIuYykpfSl9O1xuaC5nYj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMuaS50aGVuKGZ1bmN0aW9uKCl7dmFyIGI9VShhKTtyZXR1cm4gYiYmYi5pc0Fub255bW91cz9iOkdsKGEsYS5jLmdiKCkpLnRoZW4oZnVuY3Rpb24oYil7Yj1iLnVzZXI7VGsoYixcImlzQW5vbnltb3VzXCIsITApO3JldHVybiBhLmthKGIpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBVKGEpfSl9KX07ZnVuY3Rpb24gUyhhKXtyZXR1cm4gYS5hcHB9ZnVuY3Rpb24gVShhKXtyZXR1cm4gYS5jdXJyZW50VXNlcn1oLmdldFVpZD1mdW5jdGlvbigpe3JldHVybiBVKHRoaXMpJiZVKHRoaXMpLnVpZHx8bnVsbH07ZnVuY3Rpb24gSWwoYSl7cmV0dXJuIFUoYSkmJlUoYSkuX2xhdHx8bnVsbH1cbmZ1bmN0aW9uIEVsKGEpe2lmKGEuVyl7Zm9yKHZhciBiPTA7YjxhLm0ubGVuZ3RoO2IrKylpZihhLm1bYl0pYS5tW2JdKElsKGEpKTtpZihhLlIhPT1hLmdldFVpZCgpJiZhLkkubGVuZ3RoKWZvcihhLlI9YS5nZXRVaWQoKSxiPTA7YjxhLkkubGVuZ3RoO2IrKylpZihhLklbYl0pYS5JW2JdKElsKGEpKX19aC5JYj1mdW5jdGlvbihhKXt0aGlzLmFkZEF1dGhUb2tlbkxpc3RlbmVyKGEpO3RoaXMubysrOzA8dGhpcy5vJiZVKHRoaXMpJiZKayhVKHRoaXMpKX07aC5tYz1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3codGhpcy5tLGZ1bmN0aW9uKGMpe2M9PWEmJmIuby0tfSk7MD50aGlzLm8mJih0aGlzLm89MCk7MD09dGhpcy5vJiZVKHRoaXMpJiZLayhVKHRoaXMpKTt0aGlzLnJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyKGEpfTtcbmguYWRkQXV0aFRva2VuTGlzdGVuZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczt0aGlzLm0ucHVzaChhKTtUKHRoaXMsdGhpcy5pLnRoZW4oZnVuY3Rpb24oKXtiLmx8fEhhKGIubSxhKSYmYShJbChiKSl9KSl9O2gucmVtb3ZlQXV0aFRva2VuTGlzdGVuZXI9ZnVuY3Rpb24oYSl7SmEodGhpcy5tLGZ1bmN0aW9uKGIpe3JldHVybiBiPT1hfSl9O2Z1bmN0aW9uIEhsKGEsYil7YS5JLnB1c2goYik7VChhLGEuaS50aGVuKGZ1bmN0aW9uKCl7IWEubCYmSGEoYS5JLGIpJiZhLlIhPT1hLmdldFVpZCgpJiYoYS5SPWEuZ2V0VWlkKCksYihJbChhKSkpfSkpfWguZGVsZXRlPWZ1bmN0aW9uKCl7dGhpcy5sPSEwO2Zvcih2YXIgYT0wO2E8dGhpcy5OLmxlbmd0aDthKyspdGhpcy5OW2FdLmNhbmNlbChcImFwcC1kZWxldGVkXCIpO3RoaXMuTj1bXTt0aGlzLmgmJihhPXRoaXMuaCx4aihhLmIsYS5hLHRoaXMuaGEpKTt0aGlzLmEmJnRoaXMuYS51bnN1YnNjcmliZSh0aGlzKTtyZXR1cm4gZmlyZWJhc2UuUHJvbWlzZS5yZXNvbHZlKCl9O1xuZnVuY3Rpb24gVChhLGIpe2EuTi5wdXNoKGIpO1FiKGIsZnVuY3Rpb24oKXtJYShhLk4sYil9KTtyZXR1cm4gYn1oLk5iPWZ1bmN0aW9uKGEpe3JldHVybiBUKHRoaXMsVGgodGhpcy5jLGEpKX07aC5CYz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5JYShhKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBhLmRhdGEuZW1haWx9KX07aC5UYT1mdW5jdGlvbihhLGIpe3JldHVybiBUKHRoaXMsdGhpcy5jLlRhKGEsYikudGhlbihmdW5jdGlvbigpe30pKX07aC5JYT1mdW5jdGlvbihhKXtyZXR1cm4gVCh0aGlzLHRoaXMuYy5JYShhKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbGcoYSl9KSl9O2guU2E9ZnVuY3Rpb24oYSl7cmV0dXJuIFQodGhpcyx0aGlzLmMuU2EoYSkudGhlbihmdW5jdGlvbigpe30pKX07XG5oLmNiPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztyZXR1cm4gVCh0aGlzLEEoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBifHxTYShiKT97fTpGZyhuZXcgd2coYikpfSkudGhlbihmdW5jdGlvbihiKXtyZXR1cm4gYy5jLmNiKGEsYil9KS50aGVuKGZ1bmN0aW9uKCl7fSkpfTtoLnJjPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFQodGhpcyxvayh0aGlzLGEsYixyKHRoaXMuZmIsdGhpcykpKX07ZnVuY3Rpb24gSmwoYSxiLGMsZCl7YTp7Yz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjKTt2YXIgZT0wO2Zvcih2YXIgZj0hMSxnPTA7ZzxiLmxlbmd0aDtnKyspaWYoYltnXS5vcHRpb25hbClmPSEwO2Vsc2V7aWYoZil0aHJvdyBuZXcgTihcImludGVybmFsLWVycm9yXCIsXCJBcmd1bWVudCB2YWxpZGF0b3IgZW5jb3VudGVyZWQgYSByZXF1aXJlZCBhcmd1bWVudCBhZnRlciBhbiBvcHRpb25hbCBhcmd1bWVudC5cIik7ZSsrfWY9Yi5sZW5ndGg7aWYoYy5sZW5ndGg8ZXx8ZjxjLmxlbmd0aClkPVwiRXhwZWN0ZWQgXCIrKGU9PWY/MT09ZT9cIjEgYXJndW1lbnRcIjplK1wiIGFyZ3VtZW50c1wiOmUrXCItXCIrZitcIiBhcmd1bWVudHNcIikrXCIgYnV0IGdvdCBcIitjLmxlbmd0aCtcIi5cIjtlbHNle2ZvcihlPTA7ZTxjLmxlbmd0aDtlKyspaWYoZj1iW2VdLm9wdGlvbmFsJiZ2b2lkIDA9PT1jW2VdLCFiW2VdLk0oY1tlXSkmJiFmKXtiPWJbZV07aWYoMD5lfHxlPj1LbC5sZW5ndGgpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiLFxuXCJBcmd1bWVudCB2YWxpZGF0b3IgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7Yz1LbFtlXTtkPShkP1wiXCI6YytcIiBhcmd1bWVudCBcIikrKGIubmFtZT8nXCInK2IubmFtZSsnXCIgJzpcIlwiKStcIm11c3QgYmUgXCIrYi5LK1wiLlwiO2JyZWFrIGF9ZD1udWxsfX1pZihkKXRocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixhK1wiIGZhaWxlZDogXCIrZCk7fXZhciBLbD1cIkZpcnN0IFNlY29uZCBUaGlyZCBGb3VydGggRmlmdGggU2l4dGggU2V2ZW50aCBFaWdodGggTmludGhcIi5zcGxpdChcIiBcIik7ZnVuY3Rpb24gVihhLGIpe3JldHVybntuYW1lOmF8fFwiXCIsSzpcImEgdmFsaWQgc3RyaW5nXCIsb3B0aW9uYWw6ISFiLE06bX19ZnVuY3Rpb24gTGwoKXtyZXR1cm57bmFtZTpcIm9wdF9mb3JjZVJlZnJlc2hcIixLOlwiYSBib29sZWFuXCIsb3B0aW9uYWw6ITAsTTpiYX19XG5mdW5jdGlvbiBXKGEsYil7cmV0dXJue25hbWU6YXx8XCJcIixLOlwiYSB2YWxpZCBvYmplY3RcIixvcHRpb25hbDohIWIsTTpxfX1mdW5jdGlvbiBNbChhLGIpe3JldHVybntuYW1lOmF8fFwiXCIsSzpcImEgZnVuY3Rpb25cIixvcHRpb25hbDohIWIsTTpwfX1mdW5jdGlvbiBObChhLGIpe3JldHVybntuYW1lOmF8fFwiXCIsSzpcIm51bGxcIixvcHRpb25hbDohIWIsTTplYX19ZnVuY3Rpb24gT2woKXtyZXR1cm57bmFtZTpcIlwiLEs6XCJhbiBIVE1MIGVsZW1lbnRcIixvcHRpb25hbDohMSxNOmZ1bmN0aW9uKGEpe3JldHVybiEhKGEmJmEgaW5zdGFuY2VvZiBFbGVtZW50KX19fWZ1bmN0aW9uIFBsKCl7cmV0dXJue25hbWU6XCJhdXRoXCIsSzpcImFuIGluc3RhbmNlIG9mIEZpcmViYXNlIEF1dGhcIixvcHRpb25hbDohMCxNOmZ1bmN0aW9uKGEpe3JldHVybiEhKGEmJmEgaW5zdGFuY2VvZiB1bCl9fX1cbmZ1bmN0aW9uIFFsKCl7cmV0dXJue25hbWU6XCJhcHBcIixLOlwiYW4gaW5zdGFuY2Ugb2YgRmlyZWJhc2UgQXBwXCIsb3B0aW9uYWw6ITAsTTpmdW5jdGlvbihhKXtyZXR1cm4hIShhJiZhIGluc3RhbmNlb2YgZmlyZWJhc2UuYXBwLkFwcCl9fX1mdW5jdGlvbiBSbChhKXtyZXR1cm57bmFtZTphP2ErXCJDcmVkZW50aWFsXCI6XCJjcmVkZW50aWFsXCIsSzphP1wiYSB2YWxpZCBcIithK1wiIGNyZWRlbnRpYWxcIjpcImEgdmFsaWQgY3JlZGVudGlhbFwiLG9wdGlvbmFsOiExLE06ZnVuY3Rpb24oYil7aWYoIWIpcmV0dXJuITE7dmFyIGM9IWF8fGIucHJvdmlkZXJJZD09PWE7cmV0dXJuISghYi53YXx8IWMpfX19XG5mdW5jdGlvbiBTbCgpe3JldHVybntuYW1lOlwiYXV0aFByb3ZpZGVyXCIsSzpcImEgdmFsaWQgQXV0aCBwcm92aWRlclwiLG9wdGlvbmFsOiExLE06ZnVuY3Rpb24oYSl7cmV0dXJuISEoYSYmYS5wcm92aWRlcklkJiZhLmhhc093blByb3BlcnR5JiZhLmhhc093blByb3BlcnR5KFwiaXNPQXV0aFByb3ZpZGVyXCIpKX19fWZ1bmN0aW9uIFRsKCl7cmV0dXJue25hbWU6XCJhcHBsaWNhdGlvblZlcmlmaWVyXCIsSzpcImFuIGltcGxlbWVudGF0aW9uIG9mIGZpcmViYXNlLmF1dGguQXBwbGljYXRpb25WZXJpZmllclwiLG9wdGlvbmFsOiExLE06ZnVuY3Rpb24oYSl7cmV0dXJuISEoYSYmbShhLnR5cGUpJiZwKGEudmVyaWZ5KSl9fX1mdW5jdGlvbiBYKGEsYixjLGQpe3JldHVybntuYW1lOmN8fFwiXCIsSzphLksrXCIgb3IgXCIrYi5LLG9wdGlvbmFsOiEhZCxNOmZ1bmN0aW9uKGMpe3JldHVybiBhLk0oYyl8fGIuTShjKX19fTtmdW5jdGlvbiBVbChhLGIsYyxkLGUsZil7TSh0aGlzLFwidHlwZVwiLFwicmVjYXB0Y2hhXCIpO3RoaXMuYj10aGlzLmM9bnVsbDt0aGlzLm09ITE7dGhpcy5sPWI7dGhpcy5hPWN8fHt0aGVtZTpcImxpZ2h0XCIsdHlwZTpcImltYWdlXCJ9O3RoaXMuZz1bXTtpZih0aGlzLmFbVmxdKXRocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixcInNpdGVrZXkgc2hvdWxkIG5vdCBiZSBwcm92aWRlZCBmb3IgcmVDQVBUQ0hBIGFzIG9uZSBpcyBhdXRvbWF0aWNhbGx5IHByb3Zpc2lvbmVkIGZvciB0aGUgY3VycmVudCBwcm9qZWN0LlwiKTt0aGlzLmg9XCJpbnZpc2libGVcIj09PXRoaXMuYVtXbF07aWYoIXdjKGIpfHwhdGhpcy5oJiZ3YyhiKS5oYXNDaGlsZE5vZGVzKCkpdGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLFwicmVDQVBUQ0hBIGNvbnRhaW5lciBpcyBlaXRoZXIgbm90IGZvdW5kIG9yIGFscmVhZHkgY29udGFpbnMgaW5uZXIgZWxlbWVudHMhXCIpO3RoaXMudT1uZXcgQ2goYSxmfHxudWxsLGV8fG51bGwpO1xudGhpcy5vPWR8fGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O3ZhciBnPXRoaXM7dGhpcy5pPVtdO3ZhciBsPXRoaXMuYVtYbF07dGhpcy5hW1hsXT1mdW5jdGlvbihhKXtZbChnLGEpO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBsKWwoYSk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGwpe3ZhciBiPUwobCxrKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYiYmYihhKX19O3ZhciBuPXRoaXMuYVtabF07dGhpcy5hW1psXT1mdW5jdGlvbigpe1lsKGcsbnVsbCk7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIG4pbigpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBuKXt2YXIgYT1MKG4sayk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGEmJmEoKX19fXZhciBYbD1cImNhbGxiYWNrXCIsWmw9XCJleHBpcmVkLWNhbGxiYWNrXCIsVmw9XCJzaXRla2V5XCIsV2w9XCJzaXplXCI7ZnVuY3Rpb24gWWwoYSxiKXtmb3IodmFyIGM9MDtjPGEuaS5sZW5ndGg7YysrKXRyeXthLmlbY10oYil9Y2F0Y2goZCl7fX1cbmZ1bmN0aW9uICRsKGEsYil7SmEoYS5pLGZ1bmN0aW9uKGEpe3JldHVybiBhPT1ifSl9ZnVuY3Rpb24gYW0oYSxiKXthLmcucHVzaChiKTtRYihiLGZ1bmN0aW9uKCl7SWEoYS5nLGIpfSk7cmV0dXJuIGJ9aD1VbC5wcm90b3R5cGU7XG5oLnhhPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztyZXR1cm4gdGhpcy5jP3RoaXMuYzp0aGlzLmM9YW0odGhpcyxBKCkudGhlbihmdW5jdGlvbigpe2lmKFNmKCkpcmV0dXJuIEhmKCk7dGhyb3cgbmV3IE4oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIsXCJSZWNhcHRjaGFWZXJpZmllciBpcyBvbmx5IHN1cHBvcnRlZCBpbiBhIGJyb3dzZXIgSFRUUC9IVFRQUyBlbnZpcm9ubWVudC5cIik7fSkudGhlbihmdW5jdGlvbigpe3JldHVybiBibShjbSgpLGEubygpKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gUShhLnUsdWkse30pfSkudGhlbihmdW5jdGlvbihiKXthLmFbVmxdPWIucmVjYXB0Y2hhU2l0ZUtleX0pLnMoZnVuY3Rpb24oYil7YS5jPW51bGw7dGhyb3cgYjt9KSl9O1xuaC5yZW5kZXI9ZnVuY3Rpb24oKXtkbSh0aGlzKTt2YXIgYT10aGlzO3JldHVybiBhbSh0aGlzLHRoaXMueGEoKS50aGVuKGZ1bmN0aW9uKCl7aWYobnVsbD09PWEuYil7dmFyIGI9YS5sO2lmKCFhLmgpe3ZhciBjPXdjKGIpO2I9emMoXCJESVZcIik7Yy5hcHBlbmRDaGlsZChiKX1hLmI9Z3JlY2FwdGNoYS5yZW5kZXIoYixhLmEpfXJldHVybiBhLmJ9KSl9O2gudmVyaWZ5PWZ1bmN0aW9uKCl7ZG0odGhpcyk7dmFyIGE9dGhpcztyZXR1cm4gYW0odGhpcyx0aGlzLnJlbmRlcigpLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGMpe3ZhciBkPWdyZWNhcHRjaGEuZ2V0UmVzcG9uc2UoYik7aWYoZCljKGQpO2Vsc2V7dmFyIGU9ZnVuY3Rpb24oYil7YiYmKCRsKGEsZSksYyhiKSl9O2EuaS5wdXNoKGUpO2EuaCYmZ3JlY2FwdGNoYS5leGVjdXRlKGEuYil9fSl9KSl9O2gucmVzZXQ9ZnVuY3Rpb24oKXtkbSh0aGlzKTtudWxsIT09dGhpcy5iJiZncmVjYXB0Y2hhLnJlc2V0KHRoaXMuYil9O1xuZnVuY3Rpb24gZG0oYSl7aWYoYS5tKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIixcIlJlY2FwdGNoYVZlcmlmaWVyIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZC5cIik7fWguY2xlYXI9ZnVuY3Rpb24oKXtkbSh0aGlzKTt0aGlzLm09ITA7Y20oKS5iLS07Zm9yKHZhciBhPTA7YTx0aGlzLmcubGVuZ3RoO2ErKyl0aGlzLmdbYV0uY2FuY2VsKFwiUmVjYXB0Y2hhVmVyaWZpZXIgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLlwiKTtpZighdGhpcy5oKXthPXdjKHRoaXMubCk7Zm9yKHZhciBiO2I9YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGIpfX07dmFyIGVtPWRjKFwiaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9yZWNhcHRjaGEvYXBpLmpzP29ubG9hZD0le29ubG9hZH0mcmVuZGVyPWV4cGxpY2l0JmhsPSV7aGx9XCIpO1xuZnVuY3Rpb24gZm0oKXt0aGlzLmI9ay5ncmVjYXB0Y2hhP0luZmluaXR5OjA7dGhpcy5jPW51bGw7dGhpcy5hPVwiX19yY2JcIitNYXRoLmZsb29yKDFFNipNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpfVxuZnVuY3Rpb24gYm0oYSxiKXtyZXR1cm4gbmV3IHooZnVuY3Rpb24oYyxkKXtpZihaZigpKWlmKCFrLmdyZWNhcHRjaGF8fGIhPT1hLmMmJiFhLmIpe2tbYS5hXT1mdW5jdGlvbigpe2lmKGsuZ3JlY2FwdGNoYSl7YS5jPWI7dmFyIGU9ay5ncmVjYXB0Y2hhLnJlbmRlcjtrLmdyZWNhcHRjaGEucmVuZGVyPWZ1bmN0aW9uKGIsYyl7Yj1lKGIsYyk7YS5iKys7cmV0dXJuIGJ9O2MoKX1lbHNlIGQobmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKSk7ZGVsZXRlIGtbYS5hXX07dmFyIGU9aGMoZW0se29ubG9hZDphLmEsaGw6Ynx8XCJcIn0pO0Eoa2YoZSkpLnMoZnVuY3Rpb24oKXtkKG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIixcIlVuYWJsZSB0byBsb2FkIGV4dGVybmFsIHJlQ0FQVENIQSBkZXBlbmRlbmNpZXMhXCIpKX0pfWVsc2UgYygpO2Vsc2UgZChuZXcgTihcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIikpfSl9dmFyIGdtPW51bGw7XG5mdW5jdGlvbiBjbSgpe2dtfHwoZ209bmV3IGZtKTtyZXR1cm4gZ219ZnVuY3Rpb24gaG0oYSxiLGMpe3RyeXt0aGlzLmY9Y3x8ZmlyZWJhc2UuYXBwKCl9Y2F0Y2goZil7dGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLFwiTm8gZmlyZWJhc2UuYXBwLkFwcCBpbnN0YW5jZSBpcyBjdXJyZW50bHkgaW5pdGlhbGl6ZWQuXCIpO31pZih0aGlzLmYub3B0aW9ucyYmdGhpcy5mLm9wdGlvbnMuYXBpS2V5KWM9dGhpcy5mLm9wdGlvbnMuYXBpS2V5O2Vsc2UgdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWFwaS1rZXlcIik7dmFyIGQ9dGhpcyxlPW51bGw7dHJ5e2U9dGhpcy5mLmF1dGgoKS5LYSgpfWNhdGNoKGYpe31lPWZpcmViYXNlLlNES19WRVJTSU9OP09mKGZpcmViYXNlLlNES19WRVJTSU9OLGUpOm51bGw7VWwuY2FsbCh0aGlzLGMsYSxiLGZ1bmN0aW9uKCl7dHJ5e3ZhciBhPWQuZi5hdXRoKCkuJCgpfWNhdGNoKGcpe2E9bnVsbH1yZXR1cm4gYX0sZSx4aSh5aSkpfXQoaG0sVWwpO2Z1bmN0aW9uIFkoYSxiKXtmb3IodmFyIGMgaW4gYil7dmFyIGQ9YltjXS5uYW1lO2FbZF09aW0oZCxhW2NdLGJbY10uail9fWZ1bmN0aW9uIFooYSxiLGMsZCl7YVtiXT1pbShiLGMsZCl9ZnVuY3Rpb24gaW0oYSxiLGMpe2Z1bmN0aW9uIGQoKXt2YXIgYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO0psKGUsYyxhKTtyZXR1cm4gYi5hcHBseSh0aGlzLGEpfWlmKCFjKXJldHVybiBiO3ZhciBlPWptKGEpLGY7Zm9yKGYgaW4gYilkW2ZdPWJbZl07Zm9yKGYgaW4gYi5wcm90b3R5cGUpZC5wcm90b3R5cGVbZl09Yi5wcm90b3R5cGVbZl07cmV0dXJuIGR9ZnVuY3Rpb24gam0oYSl7YT1hLnNwbGl0KFwiLlwiKTtyZXR1cm4gYVthLmxlbmd0aC0xXX07WSh1bC5wcm90b3R5cGUse1NhOntuYW1lOlwiYXBwbHlBY3Rpb25Db2RlXCIsajpbVihcImNvZGVcIildfSxJYTp7bmFtZTpcImNoZWNrQWN0aW9uQ29kZVwiLGo6W1YoXCJjb2RlXCIpXX0sVGE6e25hbWU6XCJjb25maXJtUGFzc3dvcmRSZXNldFwiLGo6W1YoXCJjb2RlXCIpLFYoXCJuZXdQYXNzd29yZFwiKV19LEtiOntuYW1lOlwiY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkXCIsajpbVihcImVtYWlsXCIpLFYoXCJwYXNzd29yZFwiKV19LE5iOntuYW1lOlwiZmV0Y2hQcm92aWRlcnNGb3JFbWFpbFwiLGo6W1YoXCJlbWFpbFwiKV19LGFhOntuYW1lOlwiZ2V0UmVkaXJlY3RSZXN1bHRcIixqOltdfSxkYzp7bmFtZTpcIm9uQXV0aFN0YXRlQ2hhbmdlZFwiLGo6W1goVygpLE1sKCksXCJuZXh0T3JPYnNlcnZlclwiKSxNbChcIm9wdF9lcnJvclwiLCEwKSxNbChcIm9wdF9jb21wbGV0ZWRcIiwhMCldfSxlYzp7bmFtZTpcIm9uSWRUb2tlbkNoYW5nZWRcIixqOltYKFcoKSxNbCgpLFwibmV4dE9yT2JzZXJ2ZXJcIiksTWwoXCJvcHRfZXJyb3JcIixcbiEwKSxNbChcIm9wdF9jb21wbGV0ZWRcIiwhMCldfSxjYjp7bmFtZTpcInNlbmRQYXNzd29yZFJlc2V0RW1haWxcIixqOltWKFwiZW1haWxcIiksWChXKFwib3B0X2FjdGlvbkNvZGVTZXR0aW5nc1wiLCEwKSxObChudWxsLCEwKSxcIm9wdF9hY3Rpb25Db2RlU2V0dGluZ3NcIiwhMCldfSxlYjp7bmFtZTpcInNldFBlcnNpc3RlbmNlXCIsajpbVihcInBlcnNpc3RlbmNlXCIpXX0sZmI6e25hbWU6XCJzaWduSW5BbmRSZXRyaWV2ZURhdGFXaXRoQ3JlZGVudGlhbFwiLGo6W1JsKCldfSxnYjp7bmFtZTpcInNpZ25JbkFub255bW91c2x5XCIsajpbXX0sb2M6e25hbWU6XCJzaWduSW5XaXRoQ3JlZGVudGlhbFwiLGo6W1JsKCldfSxwYzp7bmFtZTpcInNpZ25JbldpdGhDdXN0b21Ub2tlblwiLGo6W1YoXCJ0b2tlblwiKV19LHFjOntuYW1lOlwic2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmRcIixqOltWKFwiZW1haWxcIiksVihcInBhc3N3b3JkXCIpXX0scmM6e25hbWU6XCJzaWduSW5XaXRoUGhvbmVOdW1iZXJcIixqOltWKFwicGhvbmVOdW1iZXJcIiksXG5UbCgpXX0sc2M6e25hbWU6XCJzaWduSW5XaXRoUG9wdXBcIixqOltTbCgpXX0sdGM6e25hbWU6XCJzaWduSW5XaXRoUmVkaXJlY3RcIixqOltTbCgpXX0saGI6e25hbWU6XCJzaWduT3V0XCIsajpbXX0sdG9KU09OOntuYW1lOlwidG9KU09OXCIsajpbVihudWxsLCEwKV19LEFjOntuYW1lOlwidXNlRGV2aWNlTGFuZ3VhZ2VcIixqOltdfSxCYzp7bmFtZTpcInZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlXCIsajpbVihcImNvZGVcIildfX0pOyhmdW5jdGlvbihhLGIpe2Zvcih2YXIgYyBpbiBiKXt2YXIgZD1iW2NdLm5hbWU7aWYoZCE9PWMpe3ZhciBlPWJbY10uSmI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZCx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbY119LHNldDpmdW5jdGlvbihhKXtKbChkLFtlXSxbYV0sITApO3RoaXNbY109YX0sZW51bWVyYWJsZTohMH0pfX19KSh1bC5wcm90b3R5cGUse2xjOntuYW1lOlwibGFuZ3VhZ2VDb2RlXCIsSmI6WChWKCksTmwoKSxcImxhbmd1YWdlQ29kZVwiKX19KTtcbnVsLlBlcnNpc3RlbmNlPW5qO3VsLlBlcnNpc3RlbmNlLkxPQ0FMPVwibG9jYWxcIjt1bC5QZXJzaXN0ZW5jZS5TRVNTSU9OPVwic2Vzc2lvblwiO3VsLlBlcnNpc3RlbmNlLk5PTkU9XCJub25lXCI7XG5ZKEJrLnByb3RvdHlwZSx7XCJkZWxldGVcIjp7bmFtZTpcImRlbGV0ZVwiLGo6W119LEY6e25hbWU6XCJnZXRJZFRva2VuXCIsajpbTGwoKV19LGdldFRva2VuOntuYW1lOlwiZ2V0VG9rZW5cIixqOltMbCgpXX0sWGE6e25hbWU6XCJsaW5rQW5kUmV0cmlldmVEYXRhV2l0aENyZWRlbnRpYWxcIixqOltSbCgpXX0sWmI6e25hbWU6XCJsaW5rV2l0aENyZWRlbnRpYWxcIixqOltSbCgpXX0sJGI6e25hbWU6XCJsaW5rV2l0aFBob25lTnVtYmVyXCIsajpbVihcInBob25lTnVtYmVyXCIpLFRsKCldfSxhYzp7bmFtZTpcImxpbmtXaXRoUG9wdXBcIixqOltTbCgpXX0sYmM6e25hbWU6XCJsaW5rV2l0aFJlZGlyZWN0XCIsajpbU2woKV19LFphOntuYW1lOlwicmVhdXRoZW50aWNhdGVBbmRSZXRyaWV2ZURhdGFXaXRoQ3JlZGVudGlhbFwiLGo6W1JsKCldfSxoYzp7bmFtZTpcInJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWxcIixqOltSbCgpXX0saWM6e25hbWU6XCJyZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlclwiLGo6W1YoXCJwaG9uZU51bWJlclwiKSxcblRsKCldfSxqYzp7bmFtZTpcInJlYXV0aGVudGljYXRlV2l0aFBvcHVwXCIsajpbU2woKV19LGtjOntuYW1lOlwicmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3RcIixqOltTbCgpXX0scmVsb2FkOntuYW1lOlwicmVsb2FkXCIsajpbXX0sYmI6e25hbWU6XCJzZW5kRW1haWxWZXJpZmljYXRpb25cIixqOltYKFcoXCJvcHRfYWN0aW9uQ29kZVNldHRpbmdzXCIsITApLE5sKG51bGwsITApLFwib3B0X2FjdGlvbkNvZGVTZXR0aW5nc1wiLCEwKV19LHRvSlNPTjp7bmFtZTpcInRvSlNPTlwiLGo6W1YobnVsbCwhMCldfSx5Yzp7bmFtZTpcInVubGlua1wiLGo6W1YoXCJwcm92aWRlclwiKV19LGtiOntuYW1lOlwidXBkYXRlRW1haWxcIixqOltWKFwiZW1haWxcIildfSxsYjp7bmFtZTpcInVwZGF0ZVBhc3N3b3JkXCIsajpbVihcInBhc3N3b3JkXCIpXX0semM6e25hbWU6XCJ1cGRhdGVQaG9uZU51bWJlclwiLGo6W1JsKFwicGhvbmVcIildfSxtYjp7bmFtZTpcInVwZGF0ZVByb2ZpbGVcIixqOltXKFwicHJvZmlsZVwiKV19fSk7XG5ZKHoucHJvdG90eXBlLHtzOntuYW1lOlwiY2F0Y2hcIn0sdGhlbjp7bmFtZTpcInRoZW5cIn19KTtZKG5rLnByb3RvdHlwZSx7Y29uZmlybTp7bmFtZTpcImNvbmZpcm1cIixqOltWKFwidmVyaWZpY2F0aW9uQ29kZVwiKV19fSk7WihtaCxcImNyZWRlbnRpYWxcIixmdW5jdGlvbihhLGIpe3JldHVybiBuZXcgamgoYSxiKX0sW1YoXCJlbWFpbFwiKSxWKFwicGFzc3dvcmRcIildKTtZKGJoLnByb3RvdHlwZSx7c2E6e25hbWU6XCJhZGRTY29wZVwiLGo6W1YoXCJzY29wZVwiKV19LEJhOntuYW1lOlwic2V0Q3VzdG9tUGFyYW1ldGVyc1wiLGo6W1coXCJjdXN0b21PQXV0aFBhcmFtZXRlcnNcIildfX0pO1ooYmgsXCJjcmVkZW50aWFsXCIsY2gsW1goVigpLFcoKSxcInRva2VuXCIpXSk7WShkaC5wcm90b3R5cGUse3NhOntuYW1lOlwiYWRkU2NvcGVcIixqOltWKFwic2NvcGVcIildfSxCYTp7bmFtZTpcInNldEN1c3RvbVBhcmFtZXRlcnNcIixqOltXKFwiY3VzdG9tT0F1dGhQYXJhbWV0ZXJzXCIpXX19KTtcblooZGgsXCJjcmVkZW50aWFsXCIsZWgsW1goVigpLFcoKSxcInRva2VuXCIpXSk7WShmaC5wcm90b3R5cGUse3NhOntuYW1lOlwiYWRkU2NvcGVcIixqOltWKFwic2NvcGVcIildfSxCYTp7bmFtZTpcInNldEN1c3RvbVBhcmFtZXRlcnNcIixqOltXKFwiY3VzdG9tT0F1dGhQYXJhbWV0ZXJzXCIpXX19KTtaKGZoLFwiY3JlZGVudGlhbFwiLGdoLFtYKFYoKSxYKFcoKSxObCgpKSxcImlkVG9rZW5cIiksWChWKCksTmwoKSxcImFjY2Vzc1Rva2VuXCIsITApXSk7WShoaC5wcm90b3R5cGUse0JhOntuYW1lOlwic2V0Q3VzdG9tUGFyYW1ldGVyc1wiLGo6W1coXCJjdXN0b21PQXV0aFBhcmFtZXRlcnNcIildfX0pO1ooaGgsXCJjcmVkZW50aWFsXCIsaWgsW1goVigpLFcoKSxcInRva2VuXCIpLFYoXCJzZWNyZXRcIiwhMCldKTtcblkoUC5wcm90b3R5cGUse3NhOntuYW1lOlwiYWRkU2NvcGVcIixqOltWKFwic2NvcGVcIildfSxjcmVkZW50aWFsOntuYW1lOlwiY3JlZGVudGlhbFwiLGo6W1goVigpLE5sKCksXCJpZFRva2VuXCIsITApLFgoVigpLE5sKCksXCJhY2Nlc3NUb2tlblwiLCEwKV19LEJhOntuYW1lOlwic2V0Q3VzdG9tUGFyYW1ldGVyc1wiLGo6W1coXCJjdXN0b21PQXV0aFBhcmFtZXRlcnNcIildfX0pO1oocmgsXCJjcmVkZW50aWFsXCIsdGgsW1YoXCJ2ZXJpZmljYXRpb25JZFwiKSxWKFwidmVyaWZpY2F0aW9uQ29kZVwiKV0pO1kocmgucHJvdG90eXBlLHtRYTp7bmFtZTpcInZlcmlmeVBob25lTnVtYmVyXCIsajpbVihcInBob25lTnVtYmVyXCIpLFRsKCldfX0pO1koTi5wcm90b3R5cGUse3RvSlNPTjp7bmFtZTpcInRvSlNPTlwiLGo6W1YobnVsbCwhMCldfX0pO1koemgucHJvdG90eXBlLHt0b0pTT046e25hbWU6XCJ0b0pTT05cIixqOltWKG51bGwsITApXX19KTtcblkoeWgucHJvdG90eXBlLHt0b0pTT046e25hbWU6XCJ0b0pTT05cIixqOltWKG51bGwsITApXX19KTtZKGhtLnByb3RvdHlwZSx7Y2xlYXI6e25hbWU6XCJjbGVhclwiLGo6W119LHJlbmRlcjp7bmFtZTpcInJlbmRlclwiLGo6W119LHZlcmlmeTp7bmFtZTpcInZlcmlmeVwiLGo6W119fSk7XG4oZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGZpcmViYXNlJiZmaXJlYmFzZS5JTlRFUk5BTCYmZmlyZWJhc2UuSU5URVJOQUwucmVnaXN0ZXJTZXJ2aWNlKXt2YXIgYT17QXV0aDp1bCxFcnJvcjpOfTtaKGEsXCJFbWFpbEF1dGhQcm92aWRlclwiLG1oLFtdKTtaKGEsXCJGYWNlYm9va0F1dGhQcm92aWRlclwiLGJoLFtdKTtaKGEsXCJHaXRodWJBdXRoUHJvdmlkZXJcIixkaCxbXSk7WihhLFwiR29vZ2xlQXV0aFByb3ZpZGVyXCIsZmgsW10pO1ooYSxcIlR3aXR0ZXJBdXRoUHJvdmlkZXJcIixoaCxbXSk7WihhLFwiT0F1dGhQcm92aWRlclwiLFAsW1YoXCJwcm92aWRlcklkXCIpXSk7WihhLFwiUGhvbmVBdXRoUHJvdmlkZXJcIixyaCxbUGwoKV0pO1ooYSxcIlJlY2FwdGNoYVZlcmlmaWVyXCIsaG0sW1goVigpLE9sKCksXCJyZWNhcHRjaGFDb250YWluZXJcIiksVyhcInJlY2FwdGNoYVBhcmFtZXRlcnNcIiwhMCksUWwoKV0pO2ZpcmViYXNlLklOVEVSTkFMLnJlZ2lzdGVyU2VydmljZShcImF1dGhcIixmdW5jdGlvbihhLFxuYyl7YT1uZXcgdWwoYSk7Yyh7SU5URVJOQUw6e2dldFVpZDpyKGEuZ2V0VWlkLGEpLGdldFRva2VuOnIoYS5SYixhKSxhZGRBdXRoVG9rZW5MaXN0ZW5lcjpyKGEuSWIsYSkscmVtb3ZlQXV0aFRva2VuTGlzdGVuZXI6cihhLm1jLGEpfX0pO3JldHVybiBhfSxhLGZ1bmN0aW9uKGEsYyl7aWYoXCJjcmVhdGVcIj09PWEpdHJ5e2MuYXV0aCgpfWNhdGNoKGQpe319KTtmaXJlYmFzZS5JTlRFUk5BTC5leHRlbmROYW1lc3BhY2Uoe1VzZXI6Qmt9KX1lbHNlIHRocm93IEVycm9yKFwiQ2Fubm90IGZpbmQgdGhlIGZpcmViYXNlIG5hbWVzcGFjZTsgYmUgc3VyZSB0byBpbmNsdWRlIGZpcmViYXNlLWFwcC5qcyBiZWZvcmUgdGhpcyBsaWJyYXJ5LlwiKTt9KSgpO1xufSkuY2FsbCh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcHBfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvYXBwXCIpO1xudmFyIERhdGFiYXNlXzEgPSByZXF1aXJlKFwiLi9zcmMvYXBpL0RhdGFiYXNlXCIpO1xuZXhwb3J0cy5EYXRhYmFzZSA9IERhdGFiYXNlXzEuRGF0YWJhc2U7XG52YXIgUXVlcnlfMSA9IHJlcXVpcmUoXCIuL3NyYy9hcGkvUXVlcnlcIik7XG5leHBvcnRzLlF1ZXJ5ID0gUXVlcnlfMS5RdWVyeTtcbnZhciBSZWZlcmVuY2VfMSA9IHJlcXVpcmUoXCIuL3NyYy9hcGkvUmVmZXJlbmNlXCIpO1xuZXhwb3J0cy5SZWZlcmVuY2UgPSBSZWZlcmVuY2VfMS5SZWZlcmVuY2U7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vc3JjL2NvcmUvdXRpbC91dGlsXCIpO1xuZXhwb3J0cy5lbmFibGVMb2dnaW5nID0gdXRpbF8xLmVuYWJsZUxvZ2dpbmc7XG52YXIgUmVwb01hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL3NyYy9jb3JlL1JlcG9NYW5hZ2VyXCIpO1xudmFyIElOVEVSTkFMID0gcmVxdWlyZShcIi4vc3JjL2FwaS9pbnRlcm5hbFwiKTtcbnZhciBURVNUX0FDQ0VTUyA9IHJlcXVpcmUoXCIuL3NyYy9hcGkvdGVzdF9hY2Nlc3NcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFNlcnZlclZhbHVlID0gRGF0YWJhc2VfMS5EYXRhYmFzZS5TZXJ2ZXJWYWx1ZTtcbmV4cG9ydHMuU2VydmVyVmFsdWUgPSBTZXJ2ZXJWYWx1ZTtcbmZ1bmN0aW9uIHJlZ2lzdGVyRGF0YWJhc2UoaW5zdGFuY2UpIHtcbiAgICAvLyBSZWdpc3RlciB0aGUgRGF0YWJhc2UgU2VydmljZSB3aXRoIHRoZSAnZmlyZWJhc2UnIG5hbWVzcGFjZS5cbiAgICB2YXIgbmFtZXNwYWNlID0gaW5zdGFuY2UuSU5URVJOQUwucmVnaXN0ZXJTZXJ2aWNlKCdkYXRhYmFzZScsIGZ1bmN0aW9uIChhcHAsIHVudXNlZCwgdXJsKSB7IHJldHVybiBSZXBvTWFuYWdlcl8xLlJlcG9NYW5hZ2VyLmdldEluc3RhbmNlKCkuZGF0YWJhc2VGcm9tQXBwKGFwcCwgdXJsKTsgfSwgXG4gICAgLy8gZmlyZWJhc2UuZGF0YWJhc2UgbmFtZXNwYWNlIHByb3BlcnRpZXNcbiAgICB7XG4gICAgICAgIFJlZmVyZW5jZTogUmVmZXJlbmNlXzEuUmVmZXJlbmNlLFxuICAgICAgICBRdWVyeTogUXVlcnlfMS5RdWVyeSxcbiAgICAgICAgRGF0YWJhc2U6IERhdGFiYXNlXzEuRGF0YWJhc2UsXG4gICAgICAgIGVuYWJsZUxvZ2dpbmc6IHV0aWxfMS5lbmFibGVMb2dnaW5nLFxuICAgICAgICBJTlRFUk5BTDogSU5URVJOQUwsXG4gICAgICAgIFNlcnZlclZhbHVlOiBTZXJ2ZXJWYWx1ZSxcbiAgICAgICAgVEVTVF9BQ0NFU1M6IFRFU1RfQUNDRVNTXG4gICAgfSwgbnVsbCwgdHJ1ZSk7XG4gICAgaWYgKHV0aWxfMi5pc05vZGVTZGsoKSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG5hbWVzcGFjZTtcbiAgICB9XG59XG5leHBvcnRzLnJlZ2lzdGVyRGF0YWJhc2UgPSByZWdpc3RlckRhdGFiYXNlO1xucmVnaXN0ZXJEYXRhYmFzZShhcHBfMS5kZWZhdWx0KTtcbnZhciBEYXRhU25hcHNob3RfMSA9IHJlcXVpcmUoXCIuL3NyYy9hcGkvRGF0YVNuYXBzaG90XCIpO1xuZXhwb3J0cy5EYXRhU25hcHNob3QgPSBEYXRhU25hcHNob3RfMS5EYXRhU25hcHNob3Q7XG52YXIgb25EaXNjb25uZWN0XzEgPSByZXF1aXJlKFwiLi9zcmMvYXBpL29uRGlzY29ubmVjdFwiKTtcbmV4cG9ydHMuT25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0XzEuT25EaXNjb25uZWN0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC92YWxpZGF0aW9uXCIpO1xudmFyIFBhdGhfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvUGF0aFwiKTtcbnZhciBQcmlvcml0eUluZGV4XzEgPSByZXF1aXJlKFwiLi4vY29yZS9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleFwiKTtcbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgZmlyZWJhc2UgZGF0YSBzbmFwc2hvdC4gIEl0IHdyYXBzIGEgU25hcHNob3ROb2RlIGFuZFxuICogc3VyZmFjZXMgdGhlIHB1YmxpYyBtZXRob2RzICh2YWwsIGZvckVhY2gsIGV0Yy4pIHdlIHdhbnQgdG8gZXhwb3NlLlxuICovXG52YXIgRGF0YVNuYXBzaG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVfIEEgU25hcHNob3ROb2RlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHshUmVmZXJlbmNlfSByZWZfIFRoZSByZWYgb2YgdGhlIGxvY2F0aW9uIHRoaXMgc25hcHNob3QgY2FtZSBmcm9tLlxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleF8gVGhlIGl0ZXJhdGlvbiBvcmRlciBmb3IgdGhpcyBzbmFwc2hvdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGFTbmFwc2hvdChub2RlXywgcmVmXywgaW5kZXhfKSB7XG4gICAgICAgIHRoaXMubm9kZV8gPSBub2RlXztcbiAgICAgICAgdGhpcy5yZWZfID0gcmVmXztcbiAgICAgICAgdGhpcy5pbmRleF8gPSBpbmRleF87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc25hcHNob3QgY29udGVudHMgYXMgSlNPTi4gIFJldHVybnMgbnVsbCBpZiB0aGUgc25hcHNob3QgaXNcbiAgICAgKiBlbXB0eS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9IEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIERhdGFTbmFwc2hvdCBjb250ZW50cywgb3IgbnVsbCBpZiBlbXB0eS5cbiAgICAgKi9cbiAgICBEYXRhU25hcHNob3QucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC52YWwnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV8udmFsKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzbmFwc2hvdCBjb250ZW50cyBhcyBKU09OLCBpbmNsdWRpbmcgcHJpb3JpdGllcyBvZiBub2RlLiAgU3VpdGFibGUgZm9yIGV4cG9ydGluZ1xuICAgICAqIHRoZSBlbnRpcmUgbm9kZSBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIHsqfSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBEYXRhU25hcHNob3QgY29udGVudHMsIG9yIG51bGwgaWYgZW1wdHkuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS5leHBvcnRWYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QuZXhwb3J0VmFsJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVfLnZhbCh0cnVlKTtcbiAgICB9O1xuICAgIC8vIERvIG5vdCBjcmVhdGUgcHVibGljIGRvY3VtZW50YXRpb24uIFRoaXMgaXMgaW50ZW5kZWQgdG8gbWFrZSBKU09OIHNlcmlhbGl6YXRpb24gd29yayBidXQgaXMgb3RoZXJ3aXNlIHVubmVjZXNzYXJ5XG4gICAgLy8gZm9yIGVuZC11c2Vyc1xuICAgIERhdGFTbmFwc2hvdC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBPcHRpb25hbCBzcGFjZXIgYXJndW1lbnQgaXMgdW5uZWNlc3NhcnkgYmVjYXVzZSB3ZSdyZSBkZXBlbmRpbmcgb24gcmVjdXJzaW9uIHJhdGhlciB0aGFuIHN0cmluZ2lmeWluZyB0aGUgY29udGVudFxuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LnRvSlNPTicsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHBvcnRWYWwoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgc25hcHNob3QgY29udGFpbnMgYSBub24tbnVsbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHNuYXBzaG90IGNvbnRhaW5zIGEgbm9uLW51bGwgdmFsdWUsIG9yIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIERhdGFTbmFwc2hvdC5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LmV4aXN0cycsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gIXRoaXMubm9kZV8uaXNFbXB0eSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIERhdGFTbmFwc2hvdCBvZiB0aGUgc3BlY2lmaWVkIGNoaWxkIG5vZGUncyBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gY2hpbGRQYXRoU3RyaW5nIFBhdGggdG8gYSBjaGlsZC5cbiAgICAgKiBAcmV0dXJuIHshRGF0YVNuYXBzaG90fSBEYXRhU25hcHNob3QgZm9yIGNoaWxkIG5vZGUuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChjaGlsZFBhdGhTdHJpbmcpIHtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5jaGlsZCcsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGNoaWxkUGF0aCBpcyBhIHN0cmluZyAoY2FuIGJlIGEgbnVtYmVyKVxuICAgICAgICBjaGlsZFBhdGhTdHJpbmcgPSBTdHJpbmcoY2hpbGRQYXRoU3RyaW5nKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlUGF0aFN0cmluZygnRGF0YVNuYXBzaG90LmNoaWxkJywgMSwgY2hpbGRQYXRoU3RyaW5nLCBmYWxzZSk7XG4gICAgICAgIHZhciBjaGlsZFBhdGggPSBuZXcgUGF0aF8xLlBhdGgoY2hpbGRQYXRoU3RyaW5nKTtcbiAgICAgICAgdmFyIGNoaWxkUmVmID0gdGhpcy5yZWZfLmNoaWxkKGNoaWxkUGF0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVNuYXBzaG90KHRoaXMubm9kZV8uZ2V0Q2hpbGQoY2hpbGRQYXRoKSwgY2hpbGRSZWYsIFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHNuYXBzaG90IGNvbnRhaW5zIGEgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBjaGlsZFBhdGhTdHJpbmcgUGF0aCB0byBhIGNoaWxkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGNoaWxkIGV4aXN0cy5cbiAgICAgKi9cbiAgICBEYXRhU25hcHNob3QucHJvdG90eXBlLmhhc0NoaWxkID0gZnVuY3Rpb24gKGNoaWxkUGF0aFN0cmluZykge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90Lmhhc0NoaWxkJywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVBhdGhTdHJpbmcoJ0RhdGFTbmFwc2hvdC5oYXNDaGlsZCcsIDEsIGNoaWxkUGF0aFN0cmluZywgZmFsc2UpO1xuICAgICAgICB2YXIgY2hpbGRQYXRoID0gbmV3IFBhdGhfMS5QYXRoKGNoaWxkUGF0aFN0cmluZyk7XG4gICAgICAgIHJldHVybiAhdGhpcy5ub2RlXy5nZXRDaGlsZChjaGlsZFBhdGgpLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByaW9yaXR5IG9mIHRoZSBvYmplY3QsIG9yIG51bGwgaWYgbm8gcHJpb3JpdHkgd2FzIHNldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xudW1iZXJ8bnVsbH0gVGhlIHByaW9yaXR5LlxuICAgICAqL1xuICAgIERhdGFTbmFwc2hvdC5wcm90b3R5cGUuZ2V0UHJpb3JpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QuZ2V0UHJpb3JpdHknLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgLy8gdHlwZWNhc3QgaGVyZSBiZWNhdXNlIHdlIG5ldmVyIHJldHVybiBkZWZlcnJlZCB2YWx1ZXMgb3IgaW50ZXJuYWwgcHJpb3JpdGllcyAoTUFYX1BSSU9SSVRZKVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXy5nZXRQcmlvcml0eSgpLnZhbCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZCBub2RlcyBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZm9yIGVhY2ggb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighRGF0YVNuYXBzaG90KX0gYWN0aW9uIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqIGZvciBlYWNoIGNoaWxkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZm9yRWFjaCB3YXMgY2FuY2VsZWQgYnkgYWN0aW9uIHJldHVybmluZyB0cnVlIGZvclxuICAgICAqIG9uZSBvZiB0aGUgY2hpbGQgbm9kZXMuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LmZvckVhY2gnLCAxLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQ2FsbGJhY2soJ0RhdGFTbmFwc2hvdC5mb3JFYWNoJywgMSwgYWN0aW9uLCBmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLm5vZGVfLmlzTGVhZk5vZGUoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGNoaWxkcmVuTm9kZSA9IHRoaXMubm9kZV87XG4gICAgICAgIC8vIFNhbml0aXplIHRoZSByZXR1cm4gdmFsdWUgdG8gYSBib29sZWFuLiBDaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkIGhhcyBhIHdlaXJkIHJldHVybiB0eXBlLi4uXG4gICAgICAgIHJldHVybiAhIWNoaWxkcmVuTm9kZS5mb3JFYWNoQ2hpbGQodGhpcy5pbmRleF8sIGZ1bmN0aW9uIChrZXksIG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24obmV3IERhdGFTbmFwc2hvdChub2RlLCBfdGhpcy5yZWZfLmNoaWxkKGtleSksIFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIERhdGFTbmFwc2hvdCBoYXMgY2hpbGRyZW4uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRGF0YVNuYXBzaG90IGNvbnRhaW5zIDEgb3IgbW9yZSBjaGlsZCBub2Rlcy5cbiAgICAgKi9cbiAgICBEYXRhU25hcHNob3QucHJvdG90eXBlLmhhc0NoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90Lmhhc0NoaWxkcmVuJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLm5vZGVfLmlzTGVhZk5vZGUoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLm5vZGVfLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhU25hcHNob3QucHJvdG90eXBlLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmXy5nZXRLZXkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGZvciB0aGlzIERhdGFTbmFwc2hvdC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCB0aGlzIERhdGFTbmFwc2hvdCBjb250YWlucy5cbiAgICAgKi9cbiAgICBEYXRhU25hcHNob3QucHJvdG90eXBlLm51bUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90Lm51bUNoaWxkcmVuJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVfLm51bUNoaWxkcmVuKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtSZWZlcmVuY2V9IFRoZSBGaXJlYmFzZSByZWZlcmVuY2UgZm9yIHRoZSBsb2NhdGlvbiB0aGlzIHNuYXBzaG90J3MgZGF0YSBjYW1lIGZyb20uXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS5nZXRSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QucmVmJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZl87XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVNuYXBzaG90LnByb3RvdHlwZSwgXCJyZWZcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlZigpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRGF0YVNuYXBzaG90O1xufSgpKTtcbmV4cG9ydHMuRGF0YVNuYXBzaG90ID0gRGF0YVNuYXBzaG90O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhU25hcHNob3QuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC91dGlsXCIpO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC9saWJzL3BhcnNlclwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL1BhdGhcIik7XG52YXIgUmVmZXJlbmNlXzEgPSByZXF1aXJlKFwiLi9SZWZlcmVuY2VcIik7XG52YXIgUmVwb18xID0gcmVxdWlyZShcIi4uL2NvcmUvUmVwb1wiKTtcbnZhciBSZXBvTWFuYWdlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvUmVwb01hbmFnZXJcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdmFsaWRhdGlvblwiKTtcbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgZmlyZWJhc2UgZGF0YWJhc2UuXG4gKiBAaW1wbGVtZW50cyB7RmlyZWJhc2VTZXJ2aWNlfVxuICovXG52YXIgRGF0YWJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIHNob3VsZCBub3QgYmUgY2FsbGVkIGJ5IHVzZXJzIG9mIG91ciBwdWJsaWMgQVBJLlxuICAgICAqIEBwYXJhbSB7IVJlcG99IHJlcG9fXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YWJhc2UocmVwb18pIHtcbiAgICAgICAgdGhpcy5yZXBvXyA9IHJlcG9fO1xuICAgICAgICBpZiAoIShyZXBvXyBpbnN0YW5jZW9mIFJlcG9fMS5SZXBvKSkge1xuICAgICAgICAgICAgdXRpbF8xLmZhdGFsKFwiRG9uJ3QgY2FsbCBuZXcgRGF0YWJhc2UoKSBkaXJlY3RseSAtIHBsZWFzZSB1c2UgZmlyZWJhc2UuZGF0YWJhc2UoKS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHtSZWZlcmVuY2V9ICovXG4gICAgICAgIHRoaXMucm9vdF8gPSBuZXcgUmVmZXJlbmNlXzEuUmVmZXJlbmNlKHJlcG9fLCBQYXRoXzEuUGF0aC5FbXB0eSk7XG4gICAgICAgIHRoaXMuSU5URVJOQUwgPSBuZXcgRGF0YWJhc2VJbnRlcm5hbHModGhpcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhYmFzZS5wcm90b3R5cGUsIFwiYXBwXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBvXy5hcHA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHJvb3Qgb3IgdGhlIHBhdGggc3BlY2lmaWVkIGluIG9wdF9wYXRoU3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gcGF0aFN0cmluZ1xuICAgICAqIEByZXR1cm4geyFSZWZlcmVuY2V9IEZpcmViYXNlIHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICBEYXRhYmFzZS5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5jaGVja0RlbGV0ZWRfKCdyZWYnKTtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQXJnQ291bnQoJ2RhdGFiYXNlLnJlZicsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyAhPT0gdW5kZWZpbmVkID8gdGhpcy5yb290Xy5jaGlsZChwYXRoU3RyaW5nKSA6IHRoaXMucm9vdF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSByb290IG9yIHRoZSBwYXRoIHNwZWNpZmllZCBpbiB1cmwuXG4gICAgICogV2UgdGhyb3cgYSBleGNlcHRpb24gaWYgdGhlIHVybCBpcyBub3QgaW4gdGhlIHNhbWUgZG9tYWluIGFzIHRoZVxuICAgICAqIGN1cnJlbnQgcmVwby5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHJldHVybiB7IVJlZmVyZW5jZX0gRmlyZWJhc2UgcmVmZXJlbmNlLlxuICAgICAqL1xuICAgIERhdGFiYXNlLnByb3RvdHlwZS5yZWZGcm9tVVJMID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAvKiogQGNvbnN0IHtzdHJpbmd9ICovXG4gICAgICAgIHZhciBhcGlOYW1lID0gJ2RhdGFiYXNlLnJlZkZyb21VUkwnO1xuICAgICAgICB0aGlzLmNoZWNrRGVsZXRlZF8oYXBpTmFtZSk7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUFyZ0NvdW50KGFwaU5hbWUsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YXIgcGFyc2VkVVJMID0gcGFyc2VyXzEucGFyc2VSZXBvSW5mbyh1cmwpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVVcmwoYXBpTmFtZSwgMSwgcGFyc2VkVVJMKTtcbiAgICAgICAgdmFyIHJlcG9JbmZvID0gcGFyc2VkVVJMLnJlcG9JbmZvO1xuICAgICAgICBpZiAocmVwb0luZm8uaG9zdCAhPT0gdGhpcy5yZXBvXy5yZXBvSW5mb18uaG9zdCkge1xuICAgICAgICAgICAgdXRpbF8xLmZhdGFsKGFwaU5hbWUgK1xuICAgICAgICAgICAgICAgICc6IEhvc3QgbmFtZSBkb2VzIG5vdCBtYXRjaCB0aGUgY3VycmVudCBkYXRhYmFzZTogJyArXG4gICAgICAgICAgICAgICAgJyhmb3VuZCAnICtcbiAgICAgICAgICAgICAgICByZXBvSW5mby5ob3N0ICtcbiAgICAgICAgICAgICAgICAnIGJ1dCBleHBlY3RlZCAnICtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9fLnJlcG9JbmZvXy5ob3N0ICtcbiAgICAgICAgICAgICAgICAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZihwYXJzZWRVUkwucGF0aC50b1N0cmluZygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlOYW1lXG4gICAgICovXG4gICAgRGF0YWJhc2UucHJvdG90eXBlLmNoZWNrRGVsZXRlZF8gPSBmdW5jdGlvbiAoYXBpTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5yZXBvXyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbF8xLmZhdGFsKCdDYW5ub3QgY2FsbCAnICsgYXBpTmFtZSArICcgb24gYSBkZWxldGVkIGRhdGFiYXNlLicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBNYWtlIGluZGl2aWR1YWwgcmVwbyBnbyBvZmZsaW5lLlxuICAgIERhdGFiYXNlLnByb3RvdHlwZS5nb09mZmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUFyZ0NvdW50KCdkYXRhYmFzZS5nb09mZmxpbmUnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5jaGVja0RlbGV0ZWRfKCdnb09mZmxpbmUnKTtcbiAgICAgICAgdGhpcy5yZXBvXy5pbnRlcnJ1cHQoKTtcbiAgICB9O1xuICAgIERhdGFiYXNlLnByb3RvdHlwZS5nb09ubGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQXJnQ291bnQoJ2RhdGFiYXNlLmdvT25saW5lJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuY2hlY2tEZWxldGVkXygnZ29PbmxpbmUnKTtcbiAgICAgICAgdGhpcy5yZXBvXy5yZXN1bWUoKTtcbiAgICB9O1xuICAgIERhdGFiYXNlLlNlcnZlclZhbHVlID0ge1xuICAgICAgICBUSU1FU1RBTVA6IHtcbiAgICAgICAgICAgICcuc3YnOiAndGltZXN0YW1wJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YWJhc2U7XG59KCkpO1xuZXhwb3J0cy5EYXRhYmFzZSA9IERhdGFiYXNlO1xudmFyIERhdGFiYXNlSW50ZXJuYWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcGFyYW0geyFEYXRhYmFzZX0gZGF0YWJhc2UgKi9cbiAgICBmdW5jdGlvbiBEYXRhYmFzZUludGVybmFscyhkYXRhYmFzZSkge1xuICAgICAgICB0aGlzLmRhdGFiYXNlID0gZGF0YWJhc2U7XG4gICAgfVxuICAgIC8qKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSAqL1xuICAgIERhdGFiYXNlSW50ZXJuYWxzLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YWJhc2UuY2hlY2tEZWxldGVkXygnZGVsZXRlJyk7XG4gICAgICAgIFJlcG9NYW5hZ2VyXzEuUmVwb01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5kZWxldGVSZXBvKHRoaXMuZGF0YWJhc2UucmVwb18pO1xuICAgICAgICB0aGlzLmRhdGFiYXNlLnJlcG9fID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhYmFzZS5yb290XyA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YWJhc2UuSU5URVJOQUwgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGFiYXNlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFiYXNlSW50ZXJuYWxzO1xufSgpKTtcbmV4cG9ydHMuRGF0YWJhc2VJbnRlcm5hbHMgPSBEYXRhYmFzZUludGVybmFscztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YWJhc2UuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIEtleUluZGV4XzEgPSByZXF1aXJlKFwiLi4vY29yZS9zbmFwL2luZGV4ZXMvS2V5SW5kZXhcIik7XG52YXIgUHJpb3JpdHlJbmRleF8xID0gcmVxdWlyZShcIi4uL2NvcmUvc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG52YXIgVmFsdWVJbmRleF8xID0gcmVxdWlyZShcIi4uL2NvcmUvc25hcC9pbmRleGVzL1ZhbHVlSW5kZXhcIik7XG52YXIgUGF0aEluZGV4XzEgPSByZXF1aXJlKFwiLi4vY29yZS9zbmFwL2luZGV4ZXMvUGF0aEluZGV4XCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdXRpbFwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL1BhdGhcIik7XG52YXIgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC92YWxpZGF0aW9uXCIpO1xudmFyIHV0aWxfMyA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBFdmVudFJlZ2lzdHJhdGlvbl8xID0gcmVxdWlyZShcIi4uL2NvcmUvdmlldy9FdmVudFJlZ2lzdHJhdGlvblwiKTtcbnZhciB1dGlsXzQgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgX19yZWZlcmVuY2VDb25zdHJ1Y3Rvcjtcbi8qKlxuICogQSBRdWVyeSByZXByZXNlbnRzIGEgZmlsdGVyIHRvIGJlIGFwcGxpZWQgdG8gYSBmaXJlYmFzZSBsb2NhdGlvbi4gIFRoaXMgb2JqZWN0IHB1cmVseSByZXByZXNlbnRzIHRoZVxuICogcXVlcnkgZXhwcmVzc2lvbiAoYW5kIGV4cG9zZXMgb3VyIHB1YmxpYyBBUEkgdG8gYnVpbGQgdGhlIHF1ZXJ5KS4gIFRoZSBhY3R1YWwgcXVlcnkgbG9naWMgaXMgaW4gVmlld0Jhc2UuanMuXG4gKlxuICogU2luY2UgZXZlcnkgRmlyZWJhc2UgcmVmZXJlbmNlIGlzIGEgcXVlcnksIEZpcmViYXNlIGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXG4gKi9cbnZhciBRdWVyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWVyeShyZXBvLCBwYXRoLCBxdWVyeVBhcmFtc18sIG9yZGVyQnlDYWxsZWRfKSB7XG4gICAgICAgIHRoaXMucmVwbyA9IHJlcG87XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMucXVlcnlQYXJhbXNfID0gcXVlcnlQYXJhbXNfO1xuICAgICAgICB0aGlzLm9yZGVyQnlDYWxsZWRfID0gb3JkZXJCeUNhbGxlZF87XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeSwgXCJfX3JlZmVyZW5jZUNvbnN0cnVjdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KF9fcmVmZXJlbmNlQ29uc3RydWN0b3IsICdSZWZlcmVuY2UudHMgaGFzIG5vdCBiZWVuIGxvYWRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIF9fcmVmZXJlbmNlQ29uc3RydWN0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgX19yZWZlcmVuY2VDb25zdHJ1Y3RvciA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHN0YXJ0L2VuZCB2YWx1ZXMgZm9yIHF1ZXJpZXMuXG4gICAgICogQHBhcmFtIHshUXVlcnlQYXJhbXN9IHBhcmFtc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUXVlcnkudmFsaWRhdGVRdWVyeUVuZHBvaW50c18gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBzdGFydE5vZGUgPSBudWxsO1xuICAgICAgICB2YXIgZW5kTm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSkge1xuICAgICAgICAgICAgc3RhcnROb2RlID0gcGFyYW1zLmdldEluZGV4U3RhcnRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuaGFzRW5kKCkpIHtcbiAgICAgICAgICAgIGVuZE5vZGUgPSBwYXJhbXMuZ2V0SW5kZXhFbmRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gS2V5SW5kZXhfMS5LRVlfSU5ERVgpIHtcbiAgICAgICAgICAgIHZhciB0b29NYW55QXJnc0Vycm9yID0gJ1F1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgeW91IG1heSBvbmx5IHBhc3Mgb25lIGFyZ3VtZW50IHRvICcgK1xuICAgICAgICAgICAgICAgICdzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKS4nO1xuICAgICAgICAgICAgdmFyIHdyb25nQXJnVHlwZUVycm9yID0gJ1F1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIGVuZEF0KCksJyArXG4gICAgICAgICAgICAgICAgJ29yIGVxdWFsVG8oKSBtdXN0IGJlIGEgc3RyaW5nLic7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnROYW1lID0gcGFyYW1zLmdldEluZGV4U3RhcnROYW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0TmFtZSAhPSB1dGlsXzIuTUlOX05BTUUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRvb01hbnlBcmdzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhcnROb2RlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iod3JvbmdBcmdUeXBlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuaGFzRW5kKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kTmFtZSA9IHBhcmFtcy5nZXRJbmRleEVuZE5hbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kTmFtZSAhPSB1dGlsXzIuTUFYX05BTUUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRvb01hbnlBcmdzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZW5kTm9kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdyb25nQXJnVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLmdldEluZGV4KCkgPT09IFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCkge1xuICAgICAgICAgICAgaWYgKChzdGFydE5vZGUgIT0gbnVsbCAmJiAhdmFsaWRhdGlvbl8xLmlzVmFsaWRQcmlvcml0eShzdGFydE5vZGUpKSB8fFxuICAgICAgICAgICAgICAgIChlbmROb2RlICE9IG51bGwgJiYgIXZhbGlkYXRpb25fMS5pc1ZhbGlkUHJpb3JpdHkoZW5kTm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeTogV2hlbiBvcmRlcmluZyBieSBwcmlvcml0eSwgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksICcgK1xuICAgICAgICAgICAgICAgICAgICAnZW5kQXQoKSwgb3IgZXF1YWxUbygpIG11c3QgYmUgYSB2YWxpZCBwcmlvcml0eSB2YWx1ZSAobnVsbCwgYSBudW1iZXIsIG9yIGEgc3RyaW5nKS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQocGFyYW1zLmdldEluZGV4KCkgaW5zdGFuY2VvZiBQYXRoSW5kZXhfMS5QYXRoSW5kZXggfHxcbiAgICAgICAgICAgICAgICBwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gVmFsdWVJbmRleF8xLlZBTFVFX0lOREVYLCAndW5rbm93biBpbmRleCB0eXBlLicpO1xuICAgICAgICAgICAgaWYgKChzdGFydE5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RhcnROb2RlID09PSAnb2JqZWN0JykgfHxcbiAgICAgICAgICAgICAgICAoZW5kTm9kZSAhPSBudWxsICYmIHR5cGVvZiBlbmROb2RlID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5OiBGaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkgY2Fubm90IGJlICcgK1xuICAgICAgICAgICAgICAgICAgICAnYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhhdCBsaW1pdCogaGFzIGJlZW4gY2FsbGVkIHdpdGggdGhlIGNvcnJlY3QgY29tYmluYXRpb24gb2YgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7IVF1ZXJ5UGFyYW1zfSBwYXJhbXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFF1ZXJ5LnZhbGlkYXRlTGltaXRfID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkgJiZcbiAgICAgICAgICAgIHBhcmFtcy5oYXNFbmQoKSAmJlxuICAgICAgICAgICAgcGFyYW1zLmhhc0xpbWl0KCkgJiZcbiAgICAgICAgICAgICFwYXJhbXMuaGFzQW5jaG9yZWRMaW1pdCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWVyeTogQ2FuJ3QgY29tYmluZSBzdGFydEF0KCksIGVuZEF0KCksIGFuZCBsaW1pdCgpLiBVc2UgbGltaXRUb0ZpcnN0KCkgb3IgbGltaXRUb0xhc3QoKSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoYXQgbm8gb3RoZXIgb3JkZXIgYnkgY2FsbCBoYXMgYmVlbiBtYWRlXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBmbk5hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS52YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbF8gPSBmdW5jdGlvbiAoZm5OYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLm9yZGVyQnlDYWxsZWRfID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm5OYW1lICsgXCI6IFlvdSBjYW4ndCBjb21iaW5lIG11bHRpcGxlIG9yZGVyQnkgY2FsbHMuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshUXVlcnlQYXJhbXN9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLmdldFF1ZXJ5UGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVBhcmFtc187XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshUmVmZXJlbmNlfVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5nZXRSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5yZWYnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNsaWdodCBoYWNrLiBXZSBjYW5ub3QgZ29vZy5yZXF1aXJlKCdmYi5hcGkuRmlyZWJhc2UnKSwgc2luY2UgRmlyZWJhc2UgcmVxdWlyZXMgZmIuYXBpLlF1ZXJ5LlxuICAgICAgICAvLyBIb3dldmVyLCB3ZSB3aWxsIGFsd2F5cyBleHBvcnQgJ0ZpcmViYXNlJyB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZSwgc28gaXQncyBndWFyYW50ZWVkIHRvIGV4aXN0IGJ5IHRoZSB0aW1lIHRoaXNcbiAgICAgICAgLy8gbWV0aG9kIGdldHMgY2FsbGVkLlxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5Ll9fcmVmZXJlbmNlQ29uc3RydWN0b3IodGhpcy5yZXBvLCB0aGlzLnBhdGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihEYXRhU25hcHNob3QsIHN0cmluZz0pfSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uKEVycm9yKXxPYmplY3QpPX0gY2FuY2VsQ2FsbGJhY2tPckNvbnRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oRGF0YVNuYXBzaG90LCBzdHJpbmc9KX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckNvbnRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5Lm9uJywgMiwgNCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUV2ZW50VHlwZSgnUXVlcnkub24nLCAxLCBldmVudFR5cGUsIGZhbHNlKTtcbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQ2FsbGJhY2soJ1F1ZXJ5Lm9uJywgMiwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgdmFyIHJldCA9IFF1ZXJ5LmdldENhbmNlbEFuZENvbnRleHRBcmdzXygnUXVlcnkub24nLCBjYW5jZWxDYWxsYmFja09yQ29udGV4dCwgY29udGV4dCk7XG4gICAgICAgIGlmIChldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIHRoaXMub25WYWx1ZUV2ZW50KGNhbGxiYWNrLCByZXQuY2FuY2VsLCByZXQuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICBjYWxsYmFja3NbZXZlbnRUeXBlXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgdGhpcy5vbkNoaWxkRXZlbnQoY2FsbGJhY2tzLCByZXQuY2FuY2VsLCByZXQuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oIURhdGFTbmFwc2hvdCl9IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oRXJyb3IpfSBjYW5jZWxDYWxsYmFja1xuICAgICAqIEBwYXJhbSB7P09iamVjdH0gY29udGV4dFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub25WYWx1ZUV2ZW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbmV3IEV2ZW50UmVnaXN0cmF0aW9uXzEuVmFsdWVFdmVudFJlZ2lzdHJhdGlvbihjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2sgfHwgbnVsbCwgY29udGV4dCB8fCBudWxsKTtcbiAgICAgICAgdGhpcy5yZXBvLmFkZEV2ZW50Q2FsbGJhY2tGb3JRdWVyeSh0aGlzLCBjb250YWluZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFmdW5jdGlvbighRGF0YVNuYXBzaG90LCA/c3RyaW5nKT59IGNhbGxiYWNrc1xuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKEVycm9yKX0gY2FuY2VsQ2FsbGJhY2tcbiAgICAgKiBAcGFyYW0gez9PYmplY3R9IGNvbnRleHRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLm9uQ2hpbGRFdmVudCA9IGZ1bmN0aW9uIChjYWxsYmFja3MsIGNhbmNlbENhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBuZXcgRXZlbnRSZWdpc3RyYXRpb25fMS5DaGlsZEV2ZW50UmVnaXN0cmF0aW9uKGNhbGxiYWNrcywgY2FuY2VsQ2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnJlcG8uYWRkRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHRoaXMsIGNvbnRhaW5lcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGV2ZW50VHlwZVxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uKCFEYXRhU25hcHNob3QsID9zdHJpbmc9KSk9fSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dFxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB1dGlsXzMudmFsaWRhdGVBcmdDb3VudCgnUXVlcnkub2ZmJywgMCwgMywgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUV2ZW50VHlwZSgnUXVlcnkub2ZmJywgMSwgZXZlbnRUeXBlLCB0cnVlKTtcbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQ2FsbGJhY2soJ1F1ZXJ5Lm9mZicsIDIsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQ29udGV4dE9iamVjdCgnUXVlcnkub2ZmJywgMywgY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBudWxsO1xuICAgICAgICB2YXIgY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBjYWxsYmFjayB8fCBudWxsO1xuICAgICAgICAgICAgY29udGFpbmVyID0gbmV3IEV2ZW50UmVnaXN0cmF0aW9uXzEuVmFsdWVFdmVudFJlZ2lzdHJhdGlvbih2YWx1ZUNhbGxiYWNrLCBudWxsLCBjb250ZXh0IHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzW2V2ZW50VHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lciA9IG5ldyBFdmVudFJlZ2lzdHJhdGlvbl8xLkNoaWxkRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2tzLCBudWxsLCBjb250ZXh0IHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwby5yZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkodGhpcywgY29udGFpbmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgbGlzdGVuZXIsIHdhaXRzIGZvciB0aGUgZmlyc3QgZXZlbnQsIGFuZCB0aGVuIHJlbW92ZXMgdGhlIGxpc3RlbmVyXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbighRGF0YVNuYXBzaG90LCBzdHJpbmc9KX0gdXNlckNhbGxiYWNrXG4gICAgICogQHBhcmFtIGNhbmNlbE9yQ29udGV4dFxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHJldHVybiB7IWZpcmViYXNlLlByb21pc2V9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCB1c2VyQ2FsbGJhY2ssIGNhbmNlbE9yQ29udGV4dCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsXzMudmFsaWRhdGVBcmdDb3VudCgnUXVlcnkub25jZScsIDEsIDQsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVFdmVudFR5cGUoJ1F1ZXJ5Lm9uY2UnLCAxLCBldmVudFR5cGUsIGZhbHNlKTtcbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQ2FsbGJhY2soJ1F1ZXJ5Lm9uY2UnLCAyLCB1c2VyQ2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB2YXIgcmV0ID0gUXVlcnkuZ2V0Q2FuY2VsQW5kQ29udGV4dEFyZ3NfKCdRdWVyeS5vbmNlJywgY2FuY2VsT3JDb250ZXh0LCBjb250ZXh0KTtcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHRoaXMgbW9yZSBlZmZpY2llbnRseSAoaW4gcGFydGljdWxhciwgdXNlICdnZXQnIHdpcmUgcHJvdG9jb2wgZm9yICd2YWx1ZScgZXZlbnQpXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGFjdHVhbGx5IHdpcmluZyB0aGUgY2FsbGJhY2tzIGludG8gdGhlIHByb21pc2UuIFdlIGNhbm5vdCBkbyB0aGlzIHdpdGhvdXQgYSBicmVha2luZyBjaGFuZ2VcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgQVBJIGN1cnJlbnRseSBleHBlY3RzIGNhbGxiYWNrcyB3aWxsIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5IGlmIHRoZSBkYXRhIGlzIGNhY2hlZCwgYnV0IHRoaXMgaXNcbiAgICAgICAgLy8gYWdhaW5zdCB0aGUgUHJvbWlzZSBzcGVjaWZpY2F0aW9uLlxuICAgICAgICB2YXIgZmlyc3RDYWxsID0gdHJ1ZTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHV0aWxfNC5EZWZlcnJlZCgpO1xuICAgICAgICAvLyBBIGR1bW15IGVycm9yIGhhbmRsZXIgaW4gY2FzZSBhIHVzZXIgd2Fzbid0IGV4cGVjdGluZyBwcm9taXNlc1xuICAgICAgICBkZWZlcnJlZC5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgIHZhciBvbmNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoc25hcHNob3QpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IEV2ZW4gdGhvdWdoIHdlIHVuc3Vic2NyaWJlLCB3ZSBtYXkgZ2V0IGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpZiBhIHNpbmdsZSBhY3Rpb24gKGUuZy4gc2V0KCkgd2l0aCBKU09OKVxuICAgICAgICAgICAgLy8gdHJpZ2dlcnMgbXVsdGlwbGUgZXZlbnRzIChlLmcuIGNoaWxkX2FkZGVkIG9yIGNoaWxkX2NoYW5nZWQpLlxuICAgICAgICAgICAgaWYgKGZpcnN0Q2FsbCkge1xuICAgICAgICAgICAgICAgIGZpcnN0Q2FsbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLm9mZihldmVudFR5cGUsIG9uY2VDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB1c2VyQ2FsbGJhY2suYmluZChyZXQuY29udGV4dCkoc25hcHNob3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHNuYXBzaG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbihldmVudFR5cGUsIG9uY2VDYWxsYmFjaywgXG4gICAgICAgIC8qY2FuY2VsPSovIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIF90aGlzLm9mZihldmVudFR5cGUsIG9uY2VDYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAocmV0LmNhbmNlbClcbiAgICAgICAgICAgICAgICByZXQuY2FuY2VsLmJpbmQocmV0LmNvbnRleHQpKGVycik7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGEgbGltaXQgYW5kIGFuY2hvciBpdCB0byB0aGUgc3RhcnQgb2YgdGhlIHdpbmRvdy5cbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IGxpbWl0XG4gICAgICogQHJldHVybiB7IVF1ZXJ5fVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5saW1pdFRvRmlyc3QgPSBmdW5jdGlvbiAobGltaXQpIHtcbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LmxpbWl0VG9GaXJzdCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgTWF0aC5mbG9vcihsaW1pdCkgIT09IGxpbWl0IHx8XG4gICAgICAgICAgICBsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5LmxpbWl0VG9GaXJzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucXVlcnlQYXJhbXNfLmhhc0xpbWl0KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkubGltaXRUb0ZpcnN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgJyArXG4gICAgICAgICAgICAgICAgJ2xpbWl0VG9GaXJzdCwgb3IgbGltaXRUb0xhc3QpLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5yZXBvLCB0aGlzLnBhdGgsIHRoaXMucXVlcnlQYXJhbXNfLmxpbWl0VG9GaXJzdChsaW1pdCksIHRoaXMub3JkZXJCeUNhbGxlZF8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGEgbGltaXQgYW5kIGFuY2hvciBpdCB0byB0aGUgZW5kIG9mIHRoZSB3aW5kb3cuXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSBsaW1pdFxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUubGltaXRUb0xhc3QgPSBmdW5jdGlvbiAobGltaXQpIHtcbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LmxpbWl0VG9MYXN0JywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBNYXRoLmZsb29yKGxpbWl0KSAhPT0gbGltaXQgfHxcbiAgICAgICAgICAgIGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkubGltaXRUb0xhc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1zXy5oYXNMaW1pdCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5LmxpbWl0VG9MYXN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgJyArXG4gICAgICAgICAgICAgICAgJ2xpbWl0VG9GaXJzdCwgb3IgbGltaXRUb0xhc3QpLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5yZXBvLCB0aGlzLnBhdGgsIHRoaXMucXVlcnlQYXJhbXNfLmxpbWl0VG9MYXN0KGxpbWl0KSwgdGhpcy5vcmRlckJ5Q2FsbGVkXyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGNoaWxkIHBhdGgsIHJldHVybiBhIG5ldyBxdWVyeSBvcmRlcmVkIGJ5IHRoZSBzcGVjaWZpZWQgZ3JhbmRjaGlsZCBwYXRoLlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aFxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub3JkZXJCeUNoaWxkID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAocGF0aCA9PT0gJyRrZXknKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogXCIka2V5XCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5S2V5KCkgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXRoID09PSAnJHByaW9yaXR5Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJHByaW9yaXR5XCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5UHJpb3JpdHkoKSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGggPT09ICckdmFsdWUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogXCIkdmFsdWVcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlUGF0aFN0cmluZygnUXVlcnkub3JkZXJCeUNoaWxkJywgMSwgcGF0aCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsXygnUXVlcnkub3JkZXJCeUNoaWxkJyk7XG4gICAgICAgIHZhciBwYXJzZWRQYXRoID0gbmV3IFBhdGhfMS5QYXRoKHBhdGgpO1xuICAgICAgICBpZiAocGFyc2VkUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkub3JkZXJCeUNoaWxkOiBjYW5ub3QgcGFzcyBpbiBlbXB0eSBwYXRoLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gbmV3IFBhdGhJbmRleF8xLlBhdGhJbmRleChwYXJzZWRQYXRoKTtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMucXVlcnlQYXJhbXNfLm9yZGVyQnkoaW5kZXgpO1xuICAgICAgICBRdWVyeS52YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzXyhuZXdQYXJhbXMpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCBuZXdQYXJhbXMsIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBxdWVyeSBvcmRlcmVkIGJ5IHRoZSBLZXlJbmRleFxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub3JkZXJCeUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5Lm9yZGVyQnlLZXknLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbF8oJ1F1ZXJ5Lm9yZGVyQnlLZXknKTtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMucXVlcnlQYXJhbXNfLm9yZGVyQnkoS2V5SW5kZXhfMS5LRVlfSU5ERVgpO1xuICAgICAgICBRdWVyeS52YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzXyhuZXdQYXJhbXMpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCBuZXdQYXJhbXMsIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBxdWVyeSBvcmRlcmVkIGJ5IHRoZSBQcmlvcml0eUluZGV4XG4gICAgICogQHJldHVybiB7IVF1ZXJ5fVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5vcmRlckJ5UHJpb3JpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vcmRlckJ5UHJpb3JpdHknLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbF8oJ1F1ZXJ5Lm9yZGVyQnlQcmlvcml0eScpO1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gdGhpcy5xdWVyeVBhcmFtc18ub3JkZXJCeShQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgpO1xuICAgICAgICBRdWVyeS52YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzXyhuZXdQYXJhbXMpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCBuZXdQYXJhbXMsIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBxdWVyeSBvcmRlcmVkIGJ5IHRoZSBWYWx1ZUluZGV4XG4gICAgICogQHJldHVybiB7IVF1ZXJ5fVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5vcmRlckJ5VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vcmRlckJ5VmFsdWUnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbF8oJ1F1ZXJ5Lm9yZGVyQnlWYWx1ZScpO1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gdGhpcy5xdWVyeVBhcmFtc18ub3JkZXJCeShWYWx1ZUluZGV4XzEuVkFMVUVfSU5ERVgpO1xuICAgICAgICBRdWVyeS52YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzXyhuZXdQYXJhbXMpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCBuZXdQYXJhbXMsIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xib29sZWFufG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nPX0gbmFtZVxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUuc3RhcnRBdCA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IG51bGw7IH1cbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LnN0YXJ0QXQnLCAwLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdRdWVyeS5zdGFydEF0JywgMSwgdmFsdWUsIHRoaXMucGF0aCwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUtleSgnUXVlcnkuc3RhcnRBdCcsIDIsIG5hbWUsIHRydWUpO1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gdGhpcy5xdWVyeVBhcmFtc18uc3RhcnRBdCh2YWx1ZSwgbmFtZSk7XG4gICAgICAgIFF1ZXJ5LnZhbGlkYXRlTGltaXRfKG5ld1BhcmFtcyk7XG4gICAgICAgIFF1ZXJ5LnZhbGlkYXRlUXVlcnlFbmRwb2ludHNfKG5ld1BhcmFtcyk7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1zXy5oYXNTdGFydCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5LnN0YXJ0QXQ6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQgJyArXG4gICAgICAgICAgICAgICAgJ29yIGVxdWFsVG8pLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGxpbmcgd2l0aCBubyBwYXJhbXMgdGVsbHMgdXMgdG8gc3RhcnQgYXQgdGhlIGJlZ2lubmluZy5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5yZXBvLCB0aGlzLnBhdGgsIG5ld1BhcmFtcywgdGhpcy5vcmRlckJ5Q2FsbGVkXyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8Ym9vbGVhbnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P3N0cmluZz19IG5hbWVcbiAgICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLmVuZEF0ID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gbnVsbDsgfVxuICAgICAgICB1dGlsXzMudmFsaWRhdGVBcmdDb3VudCgnUXVlcnkuZW5kQXQnLCAwLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdRdWVyeS5lbmRBdCcsIDEsIHZhbHVlLCB0aGlzLnBhdGgsIHRydWUpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVLZXkoJ1F1ZXJ5LmVuZEF0JywgMiwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSB0aGlzLnF1ZXJ5UGFyYW1zXy5lbmRBdCh2YWx1ZSwgbmFtZSk7XG4gICAgICAgIFF1ZXJ5LnZhbGlkYXRlTGltaXRfKG5ld1BhcmFtcyk7XG4gICAgICAgIFF1ZXJ5LnZhbGlkYXRlUXVlcnlFbmRwb2ludHNfKG5ld1BhcmFtcyk7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1zXy5oYXNFbmQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeS5lbmRBdDogRW5kaW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0IG9yICcgK1xuICAgICAgICAgICAgICAgICdlcXVhbFRvKS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCBuZXdQYXJhbXMsIHRoaXMub3JkZXJCeUNhbGxlZF8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgc2VsZWN0aW9uIG9mIGNoaWxkcmVuIHdpdGggZXhhY3RseSB0aGUgc3BlY2lmaWVkIHZhbHVlLCBhbmQsIG9wdGlvbmFsbHksXG4gICAgICogdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xib29sZWFufG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lXG4gICAgICogQHJldHVybiB7IVF1ZXJ5fVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5lcXVhbFRvID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5lcXVhbFRvJywgMSwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnUXVlcnkuZXF1YWxUbycsIDEsIHZhbHVlLCB0aGlzLnBhdGgsIGZhbHNlKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlS2V5KCdRdWVyeS5lcXVhbFRvJywgMiwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1zXy5oYXNTdGFydCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5LmVxdWFsVG86IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQgb3IgJyArXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8pLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1zXy5oYXNFbmQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeS5lcXVhbFRvOiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgJyArXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8pLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0QXQodmFsdWUsIG5hbWUpLmVuZEF0KHZhbHVlLCBuYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFzdHJpbmd9IFVSTCBmb3IgdGhpcyBsb2NhdGlvbi5cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS50b1N0cmluZycsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBvLnRvU3RyaW5nKCkgKyB0aGlzLnBhdGgudG9VcmxFbmNvZGVkU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvLyBEbyBub3QgY3JlYXRlIHB1YmxpYyBkb2N1bWVudGF0aW9uLiBUaGlzIGlzIGludGVuZGVkIHRvIG1ha2UgSlNPTiBzZXJpYWxpemF0aW9uIHdvcmsgYnV0IGlzIG90aGVyd2lzZSB1bm5lY2Vzc2FyeVxuICAgIC8vIGZvciBlbmQtdXNlcnMuXG4gICAgUXVlcnkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQW4gb3B0aW9uYWwgc3BhY2VyIGFyZ3VtZW50IGlzIHVubmVjZXNzYXJ5IGZvciBhIHN0cmluZy5cbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LnRvSlNPTicsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIHVzZWQgYnkgdGhpcyBRdWVyeS5cbiAgICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5xdWVyeU9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlQYXJhbXNfLmdldFF1ZXJ5T2JqZWN0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshc3RyaW5nfVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5xdWVyeUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLnF1ZXJ5T2JqZWN0KCk7XG4gICAgICAgIHZhciBpZCA9IHV0aWxfMi5PYmplY3RUb1VuaXF1ZUtleShvYmopO1xuICAgICAgICByZXR1cm4gaWQgPT09ICd7fScgPyAnZGVmYXVsdCcgOiBpZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoaXMgcXVlcnkgYW5kIHRoZSBwcm92aWRlZCBxdWVyeSBhcmUgZXF1aXZhbGVudDsgb3RoZXJ3aXNlLCByZXR1cm4gZmFsc2UuXG4gICAgICogQHBhcmFtIHtRdWVyeX0gb3RoZXJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5pc0VxdWFsID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5pc0VxdWFsJywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUXVlcnkpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAnUXVlcnkuaXNFcXVhbCBmYWlsZWQ6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgZmlyZWJhc2UuZGF0YWJhc2UuUXVlcnkuJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNhbWVSZXBvID0gdGhpcy5yZXBvID09PSBvdGhlci5yZXBvO1xuICAgICAgICB2YXIgc2FtZVBhdGggPSB0aGlzLnBhdGguZXF1YWxzKG90aGVyLnBhdGgpO1xuICAgICAgICB2YXIgc2FtZVF1ZXJ5SWRlbnRpZmllciA9IHRoaXMucXVlcnlJZGVudGlmaWVyKCkgPT09IG90aGVyLnF1ZXJ5SWRlbnRpZmllcigpO1xuICAgICAgICByZXR1cm4gc2FtZVJlcG8gJiYgc2FtZVBhdGggJiYgc2FtZVF1ZXJ5SWRlbnRpZmllcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhlbHBlciB1c2VkIGJ5IC5vbiBhbmQgLm9uY2UgdG8gZXh0cmFjdCB0aGUgY29udGV4dCBhbmQgb3IgY2FuY2VsIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZSAob24gb3Igb25jZSlcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbihFcnJvcil8T2JqZWN0KT19IGNhbmNlbE9yQ29udGV4dFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4ge3tjYW5jZWw6ID9mdW5jdGlvbihFcnJvciksIGNvbnRleHQ6ID9PYmplY3R9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUXVlcnkuZ2V0Q2FuY2VsQW5kQ29udGV4dEFyZ3NfID0gZnVuY3Rpb24gKGZuTmFtZSwgY2FuY2VsT3JDb250ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciByZXQgPSB7IGNhbmNlbDogbnVsbCwgY29udGV4dDogbnVsbCB9O1xuICAgICAgICBpZiAoY2FuY2VsT3JDb250ZXh0ICYmIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldC5jYW5jZWwgPSBjYW5jZWxPckNvbnRleHQ7XG4gICAgICAgICAgICB1dGlsXzMudmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIDMsIHJldC5jYW5jZWwsIHRydWUpO1xuICAgICAgICAgICAgcmV0LmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdXRpbF8zLnZhbGlkYXRlQ29udGV4dE9iamVjdChmbk5hbWUsIDQsIHJldC5jb250ZXh0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYW5jZWxPckNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgZWl0aGVyIGEgY2FuY2VsIGNhbGxiYWNrIG9yIGEgY29udGV4dC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FuY2VsT3JDb250ZXh0ID09PSAnb2JqZWN0JyAmJiBjYW5jZWxPckNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgY29udGV4dCFcbiAgICAgICAgICAgICAgICByZXQuY29udGV4dCA9IGNhbmNlbE9yQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjYW5jZWxPckNvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXQuY2FuY2VsID0gY2FuY2VsT3JDb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxfMy5lcnJvclByZWZpeChmbk5hbWUsIDMsIHRydWUpICtcbiAgICAgICAgICAgICAgICAgICAgJyBtdXN0IGVpdGhlciBiZSBhIGNhbmNlbCBjYWxsYmFjayBvciBhIGNvbnRleHQgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnkucHJvdG90eXBlLCBcInJlZlwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVmKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBRdWVyeTtcbn0oKSk7XG5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1ZXJ5LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgb25EaXNjb25uZWN0XzEgPSByZXF1aXJlKFwiLi9vbkRpc2Nvbm5lY3RcIik7XG52YXIgVHJhbnNhY3Rpb25SZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyYW5zYWN0aW9uUmVzdWx0XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdXRpbFwiKTtcbnZhciBOZXh0UHVzaElkXzEgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL05leHRQdXNoSWRcIik7XG52YXIgUXVlcnlfMSA9IHJlcXVpcmUoXCIuL1F1ZXJ5XCIpO1xudmFyIFJlcG9fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL1JlcG9cIik7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC9QYXRoXCIpO1xudmFyIFF1ZXJ5UGFyYW1zXzEgPSByZXF1aXJlKFwiLi4vY29yZS92aWV3L1F1ZXJ5UGFyYW1zXCIpO1xudmFyIHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdmFsaWRhdGlvblwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFN5bmNQb2ludF8xID0gcmVxdWlyZShcIi4uL2NvcmUvU3luY1BvaW50XCIpO1xudmFyIFJlZmVyZW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmZXJlbmNlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENhbGwgb3B0aW9uczpcbiAgICAgKiAgIG5ldyBSZWZlcmVuY2UoUmVwbywgUGF0aCkgb3JcbiAgICAgKiAgIG5ldyBSZWZlcmVuY2UodXJsOiBzdHJpbmcsIHN0cmluZ3xSZXBvTWFuYWdlcilcbiAgICAgKlxuICAgICAqIEV4dGVybmFsbHkgLSB0aGlzIGlzIHRoZSBmaXJlYmFzZS5kYXRhYmFzZS5SZWZlcmVuY2UgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVJlcG99IHJlcG9cbiAgICAgKiBAcGFyYW0geyghUGF0aCl9IHBhdGhcbiAgICAgKiBAZXh0ZW5kcyB7UXVlcnl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlKHJlcG8sIHBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCEocmVwbyBpbnN0YW5jZW9mIFJlcG9fMS5SZXBvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUmVmZXJlbmNlKCkgbm8gbG9uZ2VyIHN1cHBvcnRlZCAtIHVzZSBhcHAuZGF0YWJhc2UoKS4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsIFF1ZXJ5J3MgY29uc3RydWN0b3IsIHBhc3NpbmcgaW4gdGhlIHJlcG8gYW5kIHBhdGguXG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVwbywgcGF0aCwgUXVlcnlQYXJhbXNfMS5RdWVyeVBhcmFtcy5ERUZBVUxULCBmYWxzZSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5rZXknLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc0VtcHR5KCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5nZXRCYWNrKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyEoc3RyaW5nfFBhdGgpfSBwYXRoU3RyaW5nXG4gICAgICogQHJldHVybiB7IVJlZmVyZW5jZX1cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5jaGlsZCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGhTdHJpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBwYXRoU3RyaW5nID0gU3RyaW5nKHBhdGhTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEocGF0aFN0cmluZyBpbnN0YW5jZW9mIFBhdGhfMS5QYXRoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGF0aC5nZXRGcm9udCgpID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVJvb3RQYXRoU3RyaW5nKCdSZWZlcmVuY2UuY2hpbGQnLCAxLCBwYXRoU3RyaW5nLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlUGF0aFN0cmluZygnUmVmZXJlbmNlLmNoaWxkJywgMSwgcGF0aFN0cmluZywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHRoaXMucmVwbywgdGhpcy5wYXRoLmNoaWxkKHBhdGhTdHJpbmcpKTtcbiAgICB9O1xuICAgIC8qKiBAcmV0dXJuIHs/UmVmZXJlbmNlfSAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnBhcmVudCcsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YXIgcGFyZW50UGF0aCA9IHRoaXMucGF0aC5wYXJlbnQoKTtcbiAgICAgICAgcmV0dXJuIHBhcmVudFBhdGggPT09IG51bGwgPyBudWxsIDogbmV3IFJlZmVyZW5jZSh0aGlzLnJlcG8sIHBhcmVudFBhdGgpO1xuICAgIH07XG4gICAgLyoqIEByZXR1cm4geyFSZWZlcmVuY2V9ICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnJvb3QnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChyZWYuZ2V0UGFyZW50KCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlZiA9IHJlZi5nZXRQYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH07XG4gICAgLyoqIEByZXR1cm4geyFEYXRhYmFzZX0gKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLmRhdGFiYXNlUHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwby5kYXRhYmFzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gbmV3VmFsXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFQcm9taXNlfVxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5ld1ZhbCwgb25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnNldCcsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5zZXQnLCB0aGlzLnBhdGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ1JlZmVyZW5jZS5zZXQnLCAxLCBuZXdWYWwsIHRoaXMucGF0aCwgZmFsc2UpO1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnNldCcsIDIsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgdXRpbF8zLkRlZmVycmVkKCk7XG4gICAgICAgIHRoaXMucmVwby5zZXRXaXRoUHJpb3JpdHkodGhpcy5wYXRoLCBuZXdWYWwsIFxuICAgICAgICAvKnByaW9yaXR5PSovIG51bGwsIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3RUb01lcmdlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFQcm9taXNlfVxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9iamVjdFRvTWVyZ2UsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS51cGRhdGUnLCAxLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2UudXBkYXRlJywgdGhpcy5wYXRoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0VG9NZXJnZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdPYmplY3RUb01lcmdlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdFRvTWVyZ2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBuZXdPYmplY3RUb01lcmdlWycnICsgaV0gPSBvYmplY3RUb01lcmdlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0VG9NZXJnZSA9IG5ld09iamVjdFRvTWVyZ2U7XG4gICAgICAgICAgICB1dGlsXzEud2FybignUGFzc2luZyBhbiBBcnJheSB0byBGaXJlYmFzZS51cGRhdGUoKSBpcyBkZXByZWNhdGVkLiAnICtcbiAgICAgICAgICAgICAgICAnVXNlIHNldCgpIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgZGF0YSwgb3IgJyArXG4gICAgICAgICAgICAgICAgJ2FuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gJyArXG4gICAgICAgICAgICAgICAgJ29ubHkgdXBkYXRlIHNvbWUgb2YgdGhlIGNoaWxkcmVuLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnKCdSZWZlcmVuY2UudXBkYXRlJywgMSwgb2JqZWN0VG9NZXJnZSwgdGhpcy5wYXRoLCBmYWxzZSk7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2UudXBkYXRlJywgMiwgb25Db21wbGV0ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyB1dGlsXzMuRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5yZXBvLnVwZGF0ZSh0aGlzLnBhdGgsIG9iamVjdFRvTWVyZ2UsIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBuZXdWYWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8bnVsbH0gbmV3UHJpb3JpdHlcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5zZXRXaXRoUHJpb3JpdHkgPSBmdW5jdGlvbiAobmV3VmFsLCBuZXdQcmlvcml0eSwgb25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnNldFdpdGhQcmlvcml0eScsIDIsIDMsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5zZXRXaXRoUHJpb3JpdHknLCB0aGlzLnBhdGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ1JlZmVyZW5jZS5zZXRXaXRoUHJpb3JpdHknLCAxLCBuZXdWYWwsIHRoaXMucGF0aCwgZmFsc2UpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVQcmlvcml0eSgnUmVmZXJlbmNlLnNldFdpdGhQcmlvcml0eScsIDIsIG5ld1ByaW9yaXR5LCBmYWxzZSk7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2Uuc2V0V2l0aFByaW9yaXR5JywgMywgb25Db21wbGV0ZSwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmdldEtleSgpID09PSAnLmxlbmd0aCcgfHwgdGhpcy5nZXRLZXkoKSA9PT0gJy5rZXlzJylcbiAgICAgICAgICAgIHRocm93ICdSZWZlcmVuY2Uuc2V0V2l0aFByaW9yaXR5IGZhaWxlZDogJyArXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRLZXkoKSArXG4gICAgICAgICAgICAgICAgJyBpcyBhIHJlYWQtb25seSBvYmplY3QuJztcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHV0aWxfMy5EZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnJlcG8uc2V0V2l0aFByaW9yaXR5KHRoaXMucGF0aCwgbmV3VmFsLCBuZXdQcmlvcml0eSwgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAob25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnJlbW92ZScsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5yZW1vdmUnLCB0aGlzLnBhdGgpO1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnJlbW92ZScsIDEsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQobnVsbCwgb25Db21wbGV0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCopOip9IHRyYW5zYWN0aW9uVXBkYXRlXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24oP0Vycm9yLCBib29sZWFuLCA/RGF0YVNuYXBzaG90KSk9fSBvbkNvbXBsZXRlXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gYXBwbHlMb2NhbGx5XG4gICAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS50cmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvblVwZGF0ZSwgb25Db21wbGV0ZSwgYXBwbHlMb2NhbGx5KSB7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2UudHJhbnNhY3Rpb24nLCAxLCAzLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2UudHJhbnNhY3Rpb24nLCB0aGlzLnBhdGgpO1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgMSwgdHJhbnNhY3Rpb25VcGRhdGUsIGZhbHNlKTtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS50cmFuc2FjdGlvbicsIDIsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICAvLyBOT1RFOiBhcHBseUxvY2FsbHkgaXMgYW4gaW50ZXJuYWwtb25seSBvcHRpb24gZm9yIG5vdy4gIFdlIG5lZWQgdG8gZGVjaWRlIGlmIHdlIHdhbnQgdG8ga2VlcCBpdCBhbmQgaG93XG4gICAgICAgIC8vIHRvIGV4cG9zZSBpdC5cbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlQm9vbGVhbignUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgMywgYXBwbHlMb2NhbGx5LCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0S2V5KCkgPT09ICcubGVuZ3RoJyB8fCB0aGlzLmdldEtleSgpID09PSAnLmtleXMnKVxuICAgICAgICAgICAgdGhyb3cgJ1JlZmVyZW5jZS50cmFuc2FjdGlvbiBmYWlsZWQ6ICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0S2V5KCkgK1xuICAgICAgICAgICAgICAgICcgaXMgYSByZWFkLW9ubHkgb2JqZWN0Lic7XG4gICAgICAgIGlmIChhcHBseUxvY2FsbHkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGFwcGx5TG9jYWxseSA9IHRydWU7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyB1dGlsXzMuRGVmZXJyZWQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb21pc2VDb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnJvciwgY29tbWl0dGVkLCBzbmFwc2hvdCkge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUobmV3IFRyYW5zYWN0aW9uUmVzdWx0XzEuVHJhbnNhY3Rpb25SZXN1bHQoY29tbWl0dGVkLCBzbmFwc2hvdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZShlcnJvciwgY29tbWl0dGVkLCBzbmFwc2hvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVwby5zdGFydFRyYW5zYWN0aW9uKHRoaXMucGF0aCwgdHJhbnNhY3Rpb25VcGRhdGUsIHByb21pc2VDb21wbGV0ZSwgYXBwbHlMb2NhbGx5KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8bnVsbH0gcHJpb3JpdHlcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5zZXRQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSwgb25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnNldFByaW9yaXR5JywgMSwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLnNldFByaW9yaXR5JywgdGhpcy5wYXRoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlUHJpb3JpdHkoJ1JlZmVyZW5jZS5zZXRQcmlvcml0eScsIDEsIHByaW9yaXR5LCBmYWxzZSk7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2Uuc2V0UHJpb3JpdHknLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHV0aWxfMy5EZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnJlcG8uc2V0V2l0aFByaW9yaXR5KHRoaXMucGF0aC5jaGlsZCgnLnByaW9yaXR5JyksIHByaW9yaXR5LCBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2sob25Db21wbGV0ZSkpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFSZWZlcmVuY2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHZhbHVlLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2UucHVzaCcsIDAsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5wdXNoJywgdGhpcy5wYXRoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdSZWZlcmVuY2UucHVzaCcsIDEsIHZhbHVlLCB0aGlzLnBhdGgsIHRydWUpO1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnB1c2gnLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMucmVwby5zZXJ2ZXJUaW1lKCk7XG4gICAgICAgIHZhciBuYW1lID0gTmV4dFB1c2hJZF8xLm5leHRQdXNoSWQobm93KTtcbiAgICAgICAgLy8gcHVzaCgpIHJldHVybnMgYSBUaGVubmFibGVSZWZlcmVuY2Ugd2hvc2UgcHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhIHJlZ3VsYXIgUmVmZXJlbmNlLlxuICAgICAgICAvLyBXZSB1c2UgY2hpbGQoKSB0byBjcmVhdGUgaGFuZGxlcyB0byB0d28gZGlmZmVyZW50IHJlZmVyZW5jZXMuIFRoZSBmaXJzdCBpcyB0dXJuZWQgaW50byBhXG4gICAgICAgIC8vIFRoZW5uYWJsZVJlZmVyZW5jZSBiZWxvdyBieSBhZGRpbmcgdGhlbigpIGFuZCBjYXRjaCgpIG1ldGhvZHMgYW5kIGlzIHVzZWQgYXMgdGhlXG4gICAgICAgIC8vIHJldHVybiB2YWx1ZSBvZiBwdXNoKCkuIFRoZSBzZWNvbmQgcmVtYWlucyBhIHJlZ3VsYXIgUmVmZXJlbmNlIGFuZCBpcyB1c2VkIGFzIHRoZSBmdWxmaWxsZWRcbiAgICAgICAgLy8gdmFsdWUgb2YgdGhlIGZpcnN0IFRoZW5uYWJsZVJlZmVyZW5jZS5cbiAgICAgICAgdmFyIHRoZW5uYWJsZVB1c2hSZWYgPSB0aGlzLmNoaWxkKG5hbWUpO1xuICAgICAgICB2YXIgcHVzaFJlZiA9IHRoaXMuY2hpbGQobmFtZSk7XG4gICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHRoZW5uYWJsZVB1c2hSZWYuc2V0KHZhbHVlLCBvbkNvbXBsZXRlKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHB1c2hSZWY7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwdXNoUmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGVubmFibGVQdXNoUmVmLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKTtcbiAgICAgICAgdGhlbm5hYmxlUHVzaFJlZi5jYXRjaCA9IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UsIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25Db21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVubmFibGVQdXNoUmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IU9uRGlzY29ubmVjdH1cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLm9uRGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2Uub25EaXNjb25uZWN0JywgdGhpcy5wYXRoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBvbkRpc2Nvbm5lY3RfMS5PbkRpc2Nvbm5lY3QodGhpcy5yZXBvLCB0aGlzLnBhdGgpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmVyZW5jZS5wcm90b3R5cGUsIFwiZGF0YWJhc2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFiYXNlUHJvcCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJyb290XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSb290KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBSZWZlcmVuY2U7XG59KFF1ZXJ5XzEuUXVlcnkpKTtcbmV4cG9ydHMuUmVmZXJlbmNlID0gUmVmZXJlbmNlO1xuLyoqXG4gKiBEZWZpbmUgcmVmZXJlbmNlIGNvbnN0cnVjdG9yIGluIHZhcmlvdXMgbW9kdWxlc1xuICpcbiAqIFdlIGFyZSBkb2luZyB0aGlzIGhlcmUgdG8gYXZvaWQgc2V2ZXJhbCBjaXJjdWxhclxuICogZGVwZW5kZW5jeSBpc3N1ZXNcbiAqL1xuUXVlcnlfMS5RdWVyeS5fX3JlZmVyZW5jZUNvbnN0cnVjdG9yID0gUmVmZXJlbmNlO1xuU3luY1BvaW50XzEuU3luY1BvaW50Ll9fcmVmZXJlbmNlQ29uc3RydWN0b3IgPSBSZWZlcmVuY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZmVyZW5jZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgVHJhbnNhY3Rpb25SZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQSB0eXBlIGZvciB0aGUgcmVzb2x2ZSB2YWx1ZSBvZiBGaXJlYmFzZS50cmFuc2FjdGlvbi5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZGljdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tbWl0dGVkXG4gICAgICogQHBhcmFtIHtEYXRhU25hcHNob3R9IHNuYXBzaG90XG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNhY3Rpb25SZXN1bHQoY29tbWl0dGVkLCBzbmFwc2hvdCkge1xuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IGNvbW1pdHRlZDtcbiAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgIH1cbiAgICAvLyBEbyBub3QgY3JlYXRlIHB1YmxpYyBkb2N1bWVudGF0aW9uLiBUaGlzIGlzIGludGVuZGVkIHRvIG1ha2UgSlNPTiBzZXJpYWxpemF0aW9uIHdvcmsgYnV0IGlzIG90aGVyd2lzZSB1bm5lY2Vzc2FyeVxuICAgIC8vIGZvciBlbmQtdXNlcnNcbiAgICBUcmFuc2FjdGlvblJlc3VsdC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnVHJhbnNhY3Rpb25SZXN1bHQudG9KU09OJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB7IGNvbW1pdHRlZDogdGhpcy5jb21taXR0ZWQsIHNuYXBzaG90OiB0aGlzLnNuYXBzaG90LnRvSlNPTigpIH07XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXN1bHQ7XG59KCkpO1xuZXhwb3J0cy5UcmFuc2FjdGlvblJlc3VsdCA9IFRyYW5zYWN0aW9uUmVzdWx0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvblJlc3VsdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBXZWJTb2NrZXRDb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vcmVhbHRpbWUvV2ViU29ja2V0Q29ubmVjdGlvblwiKTtcbnZhciBCcm93c2VyUG9sbENvbm5lY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9yZWFsdGltZS9Ccm93c2VyUG9sbENvbm5lY3Rpb25cIik7XG4vKipcbiAqIElOVEVSTkFMIG1ldGhvZHMgZm9yIGludGVybmFsLXVzZSBvbmx5ICh0ZXN0cywgZXRjLikuXG4gKlxuICogQ3VzdG9tZXJzIHNob3VsZG4ndCB1c2UgdGhlc2Ugb3IgZWxzZSBzaG91bGQgYmUgYXdhcmUgdGhhdCB0aGV5IGNvdWxkIGJyZWFrIGF0IGFueSB0aW1lLlxuICpcbiAqIEBjb25zdFxuICovXG5leHBvcnRzLmZvcmNlTG9uZ1BvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbl8xLldlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvdygpO1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbl8xLkJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93KCk7XG59O1xuZXhwb3J0cy5mb3JjZVdlYlNvY2tldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uXzEuQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3coKTtcbn07XG4vKiBVc2VkIGJ5IEFwcCBNYW5hZ2VyICovXG5leHBvcnRzLmlzV2ViU29ja2V0c0F2YWlsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gV2ViU29ja2V0Q29ubmVjdGlvbl8xLldlYlNvY2tldENvbm5lY3Rpb25bJ2lzQXZhaWxhYmxlJ10oKTtcbn07XG5leHBvcnRzLnNldFNlY3VyaXR5RGVidWdDYWxsYmFjayA9IGZ1bmN0aW9uIChyZWYsIGNhbGxiYWNrKSB7XG4gICAgcmVmLnJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fLnNlY3VyaXR5RGVidWdDYWxsYmFja18gPSBjYWxsYmFjaztcbn07XG5leHBvcnRzLnN0YXRzID0gZnVuY3Rpb24gKHJlZiwgc2hvd0RlbHRhKSB7XG4gICAgcmVmLnJlcG8uc3RhdHMoc2hvd0RlbHRhKTtcbn07XG5leHBvcnRzLnN0YXRzSW5jcmVtZW50Q291bnRlciA9IGZ1bmN0aW9uIChyZWYsIG1ldHJpYykge1xuICAgIHJlZi5yZXBvLnN0YXRzSW5jcmVtZW50Q291bnRlcihtZXRyaWMpO1xufTtcbmV4cG9ydHMuZGF0YVVwZGF0ZUNvdW50ID0gZnVuY3Rpb24gKHJlZikge1xuICAgIHJldHVybiByZWYucmVwby5kYXRhVXBkYXRlQ291bnQ7XG59O1xuZXhwb3J0cy5pbnRlcmNlcHRTZXJ2ZXJEYXRhID0gZnVuY3Rpb24gKHJlZiwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVmLnJlcG8uaW50ZXJjZXB0U2VydmVyRGF0YV8oY2FsbGJhY2spO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJuYWwuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdmFsaWRhdGlvblwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL3V0aWxcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE9uRGlzY29ubmVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFSZXBvfSByZXBvX1xuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhfXG4gICAgICovXG4gICAgZnVuY3Rpb24gT25EaXNjb25uZWN0KHJlcG9fLCBwYXRoXykge1xuICAgICAgICB0aGlzLnJlcG9fID0gcmVwb187XG4gICAgICAgIHRoaXMucGF0aF8gPSBwYXRoXztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFmaXJlYmFzZS5Qcm9taXNlfVxuICAgICAqL1xuICAgIE9uRGlzY29ubmVjdC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKG9uQ29tcGxldGUpIHtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ09uRGlzY29ubmVjdC5jYW5jZWwnLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQ2FsbGJhY2soJ09uRGlzY29ubmVjdC5jYW5jZWwnLCAxLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHV0aWxfMy5EZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnJlcG9fLm9uRGlzY29ubmVjdENhbmNlbCh0aGlzLnBhdGhfLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2sob25Db21wbGV0ZSkpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshZmlyZWJhc2UuUHJvbWlzZX1cbiAgICAgKi9cbiAgICBPbkRpc2Nvbm5lY3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZUFyZ0NvdW50KCdPbkRpc2Nvbm5lY3QucmVtb3ZlJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnJlbW92ZScsIHRoaXMucGF0aF8pO1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVDYWxsYmFjaygnT25EaXNjb25uZWN0LnJlbW92ZScsIDEsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgdXRpbF8zLkRlZmVycmVkKCk7XG4gICAgICAgIHRoaXMucmVwb18ub25EaXNjb25uZWN0U2V0KHRoaXMucGF0aF8sIG51bGwsIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshZmlyZWJhc2UuUHJvbWlzZX1cbiAgICAgKi9cbiAgICBPbkRpc2Nvbm5lY3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgb25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnT25EaXNjb25uZWN0LnNldCcsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC5zZXQnLCB0aGlzLnBhdGhfKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdPbkRpc2Nvbm5lY3Quc2V0JywgMSwgdmFsdWUsIHRoaXMucGF0aF8sIGZhbHNlKTtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQ2FsbGJhY2soJ09uRGlzY29ubmVjdC5zZXQnLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHV0aWxfMy5EZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnJlcG9fLm9uRGlzY29ubmVjdFNldCh0aGlzLnBhdGhfLCB2YWx1ZSwgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG51bGx9IHByaW9yaXR5XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFmaXJlYmFzZS5Qcm9taXNlfVxuICAgICAqL1xuICAgIE9uRGlzY29ubmVjdC5wcm90b3R5cGUuc2V0V2l0aFByaW9yaXR5ID0gZnVuY3Rpb24gKHZhbHVlLCBwcmlvcml0eSwgb25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIDIsIDMsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCB0aGlzLnBhdGhfKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgMSwgdmFsdWUsIHRoaXMucGF0aF8sIGZhbHNlKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlUHJpb3JpdHkoJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCAyLCBwcmlvcml0eSwgZmFsc2UpO1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVDYWxsYmFjaygnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIDMsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgdXRpbF8zLkRlZmVycmVkKCk7XG4gICAgICAgIHRoaXMucmVwb18ub25EaXNjb25uZWN0U2V0V2l0aFByaW9yaXR5KHRoaXMucGF0aF8sIHZhbHVlLCBwcmlvcml0eSwgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IG9iamVjdFRvTWVyZ2VcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IWZpcmViYXNlLlByb21pc2V9XG4gICAgICovXG4gICAgT25EaXNjb25uZWN0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob2JqZWN0VG9NZXJnZSwgb25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnT25EaXNjb25uZWN0LnVwZGF0ZScsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC51cGRhdGUnLCB0aGlzLnBhdGhfKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0VG9NZXJnZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdPYmplY3RUb01lcmdlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdFRvTWVyZ2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBuZXdPYmplY3RUb01lcmdlWycnICsgaV0gPSBvYmplY3RUb01lcmdlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0VG9NZXJnZSA9IG5ld09iamVjdFRvTWVyZ2U7XG4gICAgICAgICAgICB1dGlsXzIud2FybignUGFzc2luZyBhbiBBcnJheSB0byBmaXJlYmFzZS5kYXRhYmFzZS5vbkRpc2Nvbm5lY3QoKS51cGRhdGUoKSBpcyBkZXByZWNhdGVkLiBVc2Ugc2V0KCkgaWYgeW91IHdhbnQgdG8gb3ZlcndyaXRlIHRoZSAnICtcbiAgICAgICAgICAgICAgICAnZXhpc3RpbmcgZGF0YSwgb3IgYW4gT2JqZWN0IHdpdGggaW50ZWdlciBrZXlzIGlmIHlvdSByZWFsbHkgZG8gd2FudCB0byBvbmx5IHVwZGF0ZSBzb21lIG9mIHRoZSBjaGlsZHJlbi4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZygnT25EaXNjb25uZWN0LnVwZGF0ZScsIDEsIG9iamVjdFRvTWVyZ2UsIHRoaXMucGF0aF8sIGZhbHNlKTtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQ2FsbGJhY2soJ09uRGlzY29ubmVjdC51cGRhdGUnLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHV0aWxfMy5EZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnJlcG9fLm9uRGlzY29ubmVjdFVwZGF0ZSh0aGlzLnBhdGhfLCBvYmplY3RUb01lcmdlLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2sob25Db21wbGV0ZSkpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIHJldHVybiBPbkRpc2Nvbm5lY3Q7XG59KCkpO1xuZXhwb3J0cy5PbkRpc2Nvbm5lY3QgPSBPbkRpc2Nvbm5lY3Q7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uRGlzY29ubmVjdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZXBvSW5mb18xID0gcmVxdWlyZShcIi4uL2NvcmUvUmVwb0luZm9cIik7XG52YXIgUGVyc2lzdGVudENvbm5lY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BlcnNpc3RlbnRDb25uZWN0aW9uXCIpO1xudmFyIFJlcG9NYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi4vY29yZS9SZXBvTWFuYWdlclwiKTtcbnZhciBDb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vcmVhbHRpbWUvQ29ubmVjdGlvblwiKTtcbmV4cG9ydHMuRGF0YUNvbm5lY3Rpb24gPSBQZXJzaXN0ZW50Q29ubmVjdGlvbl8xLlBlcnNpc3RlbnRDb25uZWN0aW9uO1xuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhTdHJpbmdcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IG9uQ29tcGxldGVcbiAqL1xuUGVyc2lzdGVudENvbm5lY3Rpb25fMS5QZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuc2ltcGxlTGlzdGVuID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KCdxJywgeyBwOiBwYXRoU3RyaW5nIH0sIG9uQ29tcGxldGUpO1xufTtcbi8qKlxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopfSBvbkVjaG9cbiAqL1xuUGVyc2lzdGVudENvbm5lY3Rpb25fMS5QZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuZWNobyA9IGZ1bmN0aW9uIChkYXRhLCBvbkVjaG8pIHtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KCdlY2hvJywgeyBkOiBkYXRhIH0sIG9uRWNobyk7XG59O1xuLy8gUmVhbFRpbWVDb25uZWN0aW9uIHByb3BlcnRpZXMgdGhhdCB3ZSB1c2UgaW4gdGVzdHMuXG5leHBvcnRzLlJlYWxUaW1lQ29ubmVjdGlvbiA9IENvbm5lY3Rpb25fMS5Db25uZWN0aW9uO1xuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHN0cmluZ30gbmV3SGFzaFxuICogQHJldHVybiB7ZnVuY3Rpb24oKX1cbiAqL1xuZXhwb3J0cy5oaWphY2tIYXNoID0gZnVuY3Rpb24gKG5ld0hhc2gpIHtcbiAgICB2YXIgb2xkUHV0ID0gUGVyc2lzdGVudENvbm5lY3Rpb25fMS5QZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucHV0O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uXzEuUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvcHRfb25Db21wbGV0ZSwgb3B0X2hhc2gpIHtcbiAgICAgICAgaWYgKG9wdF9oYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdF9oYXNoID0gbmV3SGFzaCgpO1xuICAgICAgICB9XG4gICAgICAgIG9sZFB1dC5jYWxsKHRoaXMsIHBhdGhTdHJpbmcsIGRhdGEsIG9wdF9vbkNvbXBsZXRlLCBvcHRfaGFzaCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbl8xLlBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQgPSBvbGRQdXQ7XG4gICAgfTtcbn07XG4vKipcbiAqIEB0eXBlIHtmdW5jdGlvbihuZXc6UmVwb0luZm8sICFzdHJpbmcsIGJvb2xlYW4sICFzdHJpbmcsIGJvb2xlYW4pOiB1bmRlZmluZWR9XG4gKi9cbmV4cG9ydHMuQ29ubmVjdGlvblRhcmdldCA9IFJlcG9JbmZvXzEuUmVwb0luZm87XG4vKipcbiAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICogQHJldHVybiB7IXN0cmluZ31cbiAqL1xuZXhwb3J0cy5xdWVyeUlkZW50aWZpZXIgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICByZXR1cm4gcXVlcnkucXVlcnlJZGVudGlmaWVyKCk7XG59O1xuLyoqXG4gKiBAcGFyYW0geyFRdWVyeX0gZmlyZWJhc2VSZWZcbiAqIEByZXR1cm4geyFPYmplY3R9XG4gKi9cbmV4cG9ydHMubGlzdGVucyA9IGZ1bmN0aW9uIChmaXJlYmFzZVJlZikge1xuICAgIHJldHVybiBmaXJlYmFzZVJlZi5yZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5saXN0ZW5zXztcbn07XG4vKipcbiAqIEZvcmNlcyB0aGUgUmVwb01hbmFnZXIgdG8gY3JlYXRlIFJlcG9zIHRoYXQgdXNlIFJlYWRvbmx5UmVzdENsaWVudCBpbnN0ZWFkIG9mIFBlcnNpc3RlbnRDb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VSZXN0Q2xpZW50XG4gKi9cbmV4cG9ydHMuZm9yY2VSZXN0Q2xpZW50ID0gZnVuY3Rpb24gKGZvcmNlUmVzdENsaWVudCkge1xuICAgIFJlcG9NYW5hZ2VyXzEuUmVwb01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5mb3JjZVJlc3RDbGllbnQoZm9yY2VSZXN0Q2xpZW50KTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlc3RfYWNjZXNzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWwvdXRpbFwiKTtcbi8qKlxuICogQWJzdHJhY3Rpb24gYXJvdW5kIEZpcmViYXNlQXBwJ3MgdG9rZW4gZmV0Y2hpbmcgY2FwYWJpbGl0aWVzLlxuICovXG52YXIgQXV0aFRva2VuUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshRmlyZWJhc2VBcHB9IGFwcF9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdXRoVG9rZW5Qcm92aWRlcihhcHBfKSB7XG4gICAgICAgIHRoaXMuYXBwXyA9IGFwcF87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VSZWZyZXNoXG4gICAgICogQHJldHVybiB7IVByb21pc2U8RmlyZWJhc2VBdXRoVG9rZW5EYXRhPn1cbiAgICAgKi9cbiAgICBBdXRoVG9rZW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0VG9rZW4gPSBmdW5jdGlvbiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcF9bJ0lOVEVSTkFMJ11bJ2dldFRva2VuJ10oZm9yY2VSZWZyZXNoKS50aGVuKG51bGwsIFxuICAgICAgICAvLyAuY2F0Y2hcbiAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBOZWVkIHRvIGZpZ3VyZSBvdXQgYWxsIHRoZSBjYXNlcyB0aGlzIGlzIHJhaXNlZCBhbmQgd2hldGhlclxuICAgICAgICAgICAgLy8gdGhpcyBtYWtlcyBzZW5zZS5cbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSAnYXV0aC90b2tlbi1ub3QtaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLmxvZygnR290IGF1dGgvdG9rZW4tbm90LWluaXRpYWxpemVkIGVycm9yLiAgVHJlYXRpbmcgYXMgbnVsbCB0b2tlbi4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXV0aFRva2VuUHJvdmlkZXIucHJvdG90eXBlLmFkZFRva2VuQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgLy8gVE9ETzogV2UgbWlnaHQgd2FudCB0byB3cmFwIHRoZSBsaXN0ZW5lciBhbmQgY2FsbCBpdCB3aXRoIG5vIGFyZ3MgdG9cbiAgICAgICAgLy8gYXZvaWQgYSBsZWFreSBhYnN0cmFjdGlvbiwgYnV0IHRoYXQgbWFrZXMgcmVtb3ZpbmcgdGhlIGxpc3RlbmVyIGhhcmRlci5cbiAgICAgICAgdGhpcy5hcHBfWydJTlRFUk5BTCddWydhZGRBdXRoVG9rZW5MaXN0ZW5lciddKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIEF1dGhUb2tlblByb3ZpZGVyLnByb3RvdHlwZS5yZW1vdmVUb2tlbkNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuYXBwX1snSU5URVJOQUwnXVsncmVtb3ZlQXV0aFRva2VuTGlzdGVuZXInXShsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBBdXRoVG9rZW5Qcm92aWRlci5wcm90b3R5cGUubm90aWZ5Rm9ySW52YWxpZFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ1Byb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGZvciB0aGUgYXBwIG5hbWVkIFwiJyArXG4gICAgICAgICAgICB0aGlzLmFwcF8ubmFtZSArXG4gICAgICAgICAgICAnXCIgYXJlIGludmFsaWQuIFRoaXMgdXN1YWxseSBpbmRpY2F0ZXMgeW91ciBhcHAgd2FzIG5vdCAnICtcbiAgICAgICAgICAgICdpbml0aWFsaXplZCBjb3JyZWN0bHkuICc7XG4gICAgICAgIGlmICgnY3JlZGVudGlhbCcgaW4gdGhpcy5hcHBfLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPVxuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdGhlIFwiY3JlZGVudGlhbFwiIHByb3BlcnR5IHByb3ZpZGVkIHRvIGluaXRpYWxpemVBcHAoKSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lzIGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoZSBzcGVjaWZpZWQgXCJkYXRhYmFzZVVSTFwiIGFuZCBpcyBmcm9tIHRoZSBjb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAncHJvamVjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdzZXJ2aWNlQWNjb3VudCcgaW4gdGhpcy5hcHBfLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPVxuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdGhlIFwic2VydmljZUFjY291bnRcIiBwcm9wZXJ0eSBwcm92aWRlZCB0byBpbml0aWFsaXplQXBwKCkgJyArXG4gICAgICAgICAgICAgICAgICAgICdpcyBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGUgc3BlY2lmaWVkIFwiZGF0YWJhc2VVUkxcIiBhbmQgaXMgZnJvbSB0aGUgY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3Byb2plY3QuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPVxuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdGhlIFwiYXBpS2V5XCIgYW5kIFwiZGF0YWJhc2VVUkxcIiBwcm9wZXJ0aWVzIHByb3ZpZGVkIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbGl6ZUFwcCgpIG1hdGNoIHRoZSB2YWx1ZXMgcHJvdmlkZWQgZm9yIHlvdXIgYXBwIGF0ICcgK1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9jb25zb2xlLmZpcmViYXNlLmdvb2dsZS5jb20vLic7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbF8xLndhcm4oZXJyb3JNZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBBdXRoVG9rZW5Qcm92aWRlcjtcbn0oKSk7XG5leHBvcnRzLkF1dGhUb2tlblByb3ZpZGVyID0gQXV0aFRva2VuUHJvdmlkZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhUb2tlblByb3ZpZGVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEltbXV0YWJsZVRyZWVfMSA9IHJlcXVpcmUoXCIuL3V0aWwvSW1tdXRhYmxlVHJlZVwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi91dGlsL1BhdGhcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIE5vZGVfMSA9IHJlcXVpcmUoXCIuL3NuYXAvTm9kZVwiKTtcbnZhciBQcmlvcml0eUluZGV4XzEgPSByZXF1aXJlKFwiLi9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIFRoaXMgY2xhc3MgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIHdyaXRlcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIG5vZGVzIGluIHVuaXNvbi4gSXQgYWJzdHJhY3RzIGF3YXkgdGhlIGxvZ2ljIHdpdGhcbiAqIGRlYWxpbmcgd2l0aCBwcmlvcml0eSB3cml0ZXMgYW5kIG11bHRpcGxlIG5lc3RlZCB3cml0ZXMuIEF0IGFueSBnaXZlbiBwYXRoIHRoZXJlIGlzIG9ubHkgYWxsb3dlZCB0byBiZSBvbmUgd3JpdGVcbiAqIG1vZGlmeWluZyB0aGF0IHBhdGguIEFueSB3cml0ZSB0byBhbiBleGlzdGluZyBwYXRoIG9yIHNoYWRvd2luZyBhbiBleGlzdGluZyBwYXRoIHdpbGwgbW9kaWZ5IHRoYXQgZXhpc3Rpbmcgd3JpdGVcbiAqIHRvIHJlZmxlY3QgdGhlIHdyaXRlIGFkZGVkLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHshSW1tdXRhYmxlVHJlZS48IU5vZGU+fSB3cml0ZVRyZWVcbiAqL1xudmFyIENvbXBvdW5kV3JpdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcG91bmRXcml0ZSh3cml0ZVRyZWVfKSB7XG4gICAgICAgIHRoaXMud3JpdGVUcmVlXyA9IHdyaXRlVHJlZV87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHJldHVybiB7IUNvbXBvdW5kV3JpdGV9XG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5wcm90b3R5cGUuYWRkV3JpdGUgPSBmdW5jdGlvbiAocGF0aCwgbm9kZSkge1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZV8xLkltbXV0YWJsZVRyZWUobm9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJvb3Rtb3N0ID0gdGhpcy53cml0ZVRyZWVfLmZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChwYXRoKTtcbiAgICAgICAgICAgIGlmIChyb290bW9zdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RNb3N0UGF0aCA9IHJvb3Rtb3N0LnBhdGg7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcm9vdG1vc3QudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aXZlUGF0aCA9IFBhdGhfMS5QYXRoLnJlbGF0aXZlUGF0aChyb290TW9zdFBhdGgsIHBhdGgpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLCBub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUodGhpcy53cml0ZVRyZWVfLnNldChyb290TW9zdFBhdGgsIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VidHJlZSA9IG5ldyBJbW11dGFibGVUcmVlXzEuSW1tdXRhYmxlVHJlZShub2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3V3JpdGVUcmVlID0gdGhpcy53cml0ZVRyZWVfLnNldFRyZWUocGF0aCwgc3VidHJlZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ld1dyaXRlVHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgIU5vZGU+fSB1cGRhdGVzXG4gICAgICogQHJldHVybiB7IUNvbXBvdW5kV3JpdGV9XG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5wcm90b3R5cGUuYWRkV3JpdGVzID0gZnVuY3Rpb24gKHBhdGgsIHVwZGF0ZXMpIHtcbiAgICAgICAgdmFyIG5ld1dyaXRlID0gdGhpcztcbiAgICAgICAgdXRpbF8xLmZvckVhY2godXBkYXRlcywgZnVuY3Rpb24gKGNoaWxkS2V5LCBub2RlKSB7XG4gICAgICAgICAgICBuZXdXcml0ZSA9IG5ld1dyaXRlLmFkZFdyaXRlKHBhdGguY2hpbGQoY2hpbGRLZXkpLCBub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdXcml0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdpbGwgcmVtb3ZlIGEgd3JpdGUgYXQgdGhlIGdpdmVuIHBhdGggYW5kIGRlZXBlciBwYXRocy4gVGhpcyB3aWxsIDxlbT5ub3Q8L2VtPiBtb2RpZnkgYSB3cml0ZSBhdCBhIGhpZ2hlclxuICAgICAqIGxvY2F0aW9uLCB3aGljaCBtdXN0IGJlIHJlbW92ZWQgYnkgY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIHRoYXQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIHBhdGggYXQgd2hpY2ggYSB3cml0ZSBhbmQgYWxsIGRlZXBlciB3cml0ZXMgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgKiBAcmV0dXJuIHshQ29tcG91bmRXcml0ZX0gVGhlIG5ldyBDb21wb3VuZFdyaXRlIHdpdGggdGhlIHJlbW92ZWQgcGF0aFxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUucHJvdG90eXBlLnJlbW92ZVdyaXRlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29tcG91bmRXcml0ZS5FbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdXcml0ZVRyZWUgPSB0aGlzLndyaXRlVHJlZV8uc2V0VHJlZShwYXRoLCBJbW11dGFibGVUcmVlXzEuSW1tdXRhYmxlVHJlZS5FbXB0eSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3V3JpdGVUcmVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgQ29tcG91bmRXcml0ZSB3aWxsIGZ1bGx5IG92ZXJ3cml0ZSBhIG5vZGUgYXQgYSBnaXZlbiBsb2NhdGlvbiBhbmQgY2FuIHRoZXJlZm9yZSBiZVxuICAgICAqIGNvbnNpZGVyZWQgXCJjb21wbGV0ZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCB0byBjaGVjayBmb3JcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZXJlIGlzIGEgY29tcGxldGUgd3JpdGUgYXQgdGhhdCBwYXRoXG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5wcm90b3R5cGUuaGFzQ29tcGxldGVXcml0ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXRlTm9kZShwYXRoKSAhPSBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5vZGUgZm9yIGEgcGF0aCBpZiBhbmQgb25seSBpZiB0aGUgbm9kZSBpcyBhIFwiY29tcGxldGVcIiBvdmVyd3JpdGUgYXQgdGhhdCBwYXRoLiBUaGlzIHdpbGwgbm90IGFnZ3JlZ2F0ZVxuICAgICAqIHdyaXRlcyBmcm9tIGRlZXBlciBwYXRocywgYnV0IHdpbGwgcmV0dXJuIGNoaWxkIG5vZGVzIGZyb20gYSBtb3JlIHNoYWxsb3cgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIHBhdGggdG8gZ2V0IGEgY29tcGxldGUgd3JpdGVcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX0gVGhlIG5vZGUgaWYgY29tcGxldGUgYXQgdGhhdCBwYXRoLCBvciBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBDb21wb3VuZFdyaXRlLnByb3RvdHlwZS5nZXRDb21wbGV0ZU5vZGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgcm9vdG1vc3QgPSB0aGlzLndyaXRlVHJlZV8uZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoKHBhdGgpO1xuICAgICAgICBpZiAocm9vdG1vc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVUcmVlX1xuICAgICAgICAgICAgICAgIC5nZXQocm9vdG1vc3QucGF0aClcbiAgICAgICAgICAgICAgICAuZ2V0Q2hpbGQoUGF0aF8xLlBhdGgucmVsYXRpdmVQYXRoKHJvb3Rtb3N0LnBhdGgsIHBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBjaGlsZHJlbiB0aGF0IGFyZSBndWFyYW50ZWVkIHRvIGJlIGEgY29tcGxldGUgb3ZlcndyaXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IUFycmF5LjxOYW1lZE5vZGU+fSBBIGxpc3Qgb2YgYWxsIGNvbXBsZXRlIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUucHJvdG90eXBlLmdldENvbXBsZXRlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMud3JpdGVUcmVlXy52YWx1ZTtcbiAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgaXQncyBhIGxlYWYgbm9kZSwgaXQgaGFzIG5vIGNoaWxkcmVuOyBzbyBub3RoaW5nIHRvIGRvLlxuICAgICAgICAgICAgaWYgKCFub2RlLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgICAgIG5vZGUuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGNoaWxkTmFtZSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5vZGVfMS5OYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZE5vZGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVUcmVlXy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZFRyZWUudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOb2RlXzEuTmFtZWROb2RlKGNoaWxkTmFtZSwgY2hpbGRUcmVlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEByZXR1cm4geyFDb21wb3VuZFdyaXRlfVxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUucHJvdG90eXBlLmNoaWxkQ29tcG91bmRXcml0ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2hhZG93aW5nTm9kZSA9IHRoaXMuZ2V0Q29tcGxldGVOb2RlKHBhdGgpO1xuICAgICAgICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZV8xLkltbXV0YWJsZVRyZWUoc2hhZG93aW5nTm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKHRoaXMud3JpdGVUcmVlXy5zdWJ0cmVlKHBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgQ29tcG91bmRXcml0ZSBpcyBlbXB0eSBhbmQgdGhlcmVmb3JlIGRvZXMgbm90IG1vZGlmeSBhbnkgbm9kZXMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIENvbXBvdW5kV3JpdGUgaXMgZW1wdHlcbiAgICAgKi9cbiAgICBDb21wb3VuZFdyaXRlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVRyZWVfLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhpcyBDb21wb3VuZFdyaXRlIHRvIGEgbm9kZS4gVGhlIG5vZGUgaXMgcmV0dXJuZWQgd2l0aCBhbGwgd3JpdGVzIGZyb20gdGhpcyBDb21wb3VuZFdyaXRlIGFwcGxpZWQgdG8gdGhlXG4gICAgICogbm9kZVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gYXBwbHkgdGhpcyBDb21wb3VuZFdyaXRlIHRvXG4gICAgICogQHJldHVybiB7IU5vZGV9IFRoZSBub2RlIHdpdGggYWxsIHdyaXRlcyBhcHBsaWVkXG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gQ29tcG91bmRXcml0ZS5hcHBseVN1YnRyZWVXcml0ZV8oUGF0aF8xLlBhdGguRW1wdHksIHRoaXMud3JpdGVUcmVlXywgbm9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUNvbXBvdW5kV3JpdGV9XG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5FbXB0eSA9IG5ldyBDb21wb3VuZFdyaXRlKG5ldyBJbW11dGFibGVUcmVlXzEuSW1tdXRhYmxlVHJlZShudWxsKSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcmVsYXRpdmVQYXRoXG4gICAgICogQHBhcmFtIHshSW1tdXRhYmxlVHJlZS48IU5vZGU+fSB3cml0ZVRyZWVcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb21wb3VuZFdyaXRlLmFwcGx5U3VidHJlZVdyaXRlXyA9IGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIHdyaXRlVHJlZSwgbm9kZSkge1xuICAgICAgICBpZiAod3JpdGVUcmVlLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZXJlIGEgd3JpdGUgaXMgYWx3YXlzIGEgbGVhZiwgd2UncmUgZG9uZSBoZXJlXG4gICAgICAgICAgICByZXR1cm4gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIHdyaXRlVHJlZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdHlXcml0ZV8xID0gbnVsbDtcbiAgICAgICAgICAgIHdyaXRlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZEtleSwgY2hpbGRUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwcmlvcml0aWVzIGF0IHRoZSBlbmQgc28gd2UgZG9uJ3QgdXBkYXRlIHByaW9yaXRpZXMgZm9yIGVpdGhlciBlbXB0eSBub2RlcyBvciBmb3JnZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXBwbHkgcHJpb3JpdGllcyB0byBlbXB0eSBub2RlcyB0aGF0IGFyZSBsYXRlciBmaWxsZWRcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8yLmFzc2VydChjaGlsZFRyZWUudmFsdWUgIT09IG51bGwsICdQcmlvcml0eSB3cml0ZXMgbXVzdCBhbHdheXMgYmUgbGVhZiBub2RlcycpO1xuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eVdyaXRlXzEgPSBjaGlsZFRyZWUudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gQ29tcG91bmRXcml0ZS5hcHBseVN1YnRyZWVXcml0ZV8ocmVsYXRpdmVQYXRoLmNoaWxkKGNoaWxkS2V5KSwgY2hpbGRUcmVlLCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHByaW9yaXR5IHdyaXRlLCB3ZSBvbmx5IGFwcGx5IGl0IGlmIHRoZSBub2RlIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgaWYgKCFub2RlLmdldENoaWxkKHJlbGF0aXZlUGF0aCkuaXNFbXB0eSgpICYmIHByaW9yaXR5V3JpdGVfMSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZUNoaWxkKHJlbGF0aXZlUGF0aC5jaGlsZCgnLnByaW9yaXR5JyksIHByaW9yaXR5V3JpdGVfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbXBvdW5kV3JpdGU7XG59KCkpO1xuZXhwb3J0cy5Db21wb3VuZFdyaXRlID0gQ29tcG91bmRXcml0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcG91bmRXcml0ZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFwcF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS9hcHBcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzMgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF80ID0gcmVxdWlyZShcIi4vdXRpbC91dGlsXCIpO1xudmFyIFBhdGhfMSA9IHJlcXVpcmUoXCIuL3V0aWwvUGF0aFwiKTtcbnZhciBWaXNpYmlsaXR5TW9uaXRvcl8xID0gcmVxdWlyZShcIi4vdXRpbC9WaXNpYmlsaXR5TW9uaXRvclwiKTtcbnZhciBPbmxpbmVNb25pdG9yXzEgPSByZXF1aXJlKFwiLi91dGlsL09ubGluZU1vbml0b3JcIik7XG52YXIgdXRpbF81ID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIENvbm5lY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9yZWFsdGltZS9Db25uZWN0aW9uXCIpO1xudmFyIHV0aWxfNiA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzcgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgU2VydmVyQWN0aW9uc18xID0gcmVxdWlyZShcIi4vU2VydmVyQWN0aW9uc1wiKTtcbnZhciBSRUNPTk5FQ1RfTUlOX0RFTEFZID0gMTAwMDtcbnZhciBSRUNPTk5FQ1RfTUFYX0RFTEFZX0RFRkFVTFQgPSA2MCAqIDUgKiAxMDAwOyAvLyA1IG1pbnV0ZXMgaW4gbWlsbGlzZWNvbmRzIChDYXNlOiAxODU4KVxudmFyIFJFQ09OTkVDVF9NQVhfREVMQVlfRk9SX0FETUlOUyA9IDMwICogMTAwMDsgLy8gMzAgc2Vjb25kcyBmb3IgYWRtaW4gY2xpZW50cyAobGlrZWx5IHRvIGJlIGEgYmFja2VuZCBzZXJ2ZXIpXG52YXIgUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIgPSAxLjM7XG52YXIgUkVDT05ORUNUX0RFTEFZX1JFU0VUX1RJTUVPVVQgPSAzMDAwMDsgLy8gUmVzZXQgZGVsYXkgYmFjayB0byBNSU5fREVMQVkgYWZ0ZXIgYmVpbmcgY29ubmVjdGVkIGZvciAzMHNlYy5cbnZhciBTRVJWRVJfS0lMTF9JTlRFUlJVUFRfUkVBU09OID0gJ3NlcnZlcl9raWxsJztcbi8vIElmIGF1dGggZmFpbHMgcmVwZWF0ZWRseSwgd2UnbGwgYXNzdW1lIHNvbWV0aGluZyBpcyB3cm9uZyBhbmQgbG9nIGEgd2FybmluZyAvIGJhY2sgb2ZmLlxudmFyIElOVkFMSURfQVVUSF9UT0tFTl9USFJFU0hPTEQgPSAzO1xuLyoqXG4gKiBGaXJlYmFzZSBjb25uZWN0aW9uLiAgQWJzdHJhY3RzIHdpcmUgcHJvdG9jb2wgYW5kIGhhbmRsZXMgcmVjb25uZWN0aW5nLlxuICpcbiAqIE5PVEU6IEFsbCBKU09OIG9iamVjdHMgc2VudCB0byB0aGUgcmVhbHRpbWUgY29ubmVjdGlvbiBtdXN0IGhhdmUgcHJvcGVydHkgbmFtZXMgZW5jbG9zZWRcbiAqIGluIHF1b3RlcyB0byBtYWtlIHN1cmUgdGhlIGNsb3N1cmUgY29tcGlsZXIgZG9lcyBub3QgbWluaWZ5IHRoZW0uXG4gKi9cbnZhciBQZXJzaXN0ZW50Q29ubmVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGVyc2lzdGVudENvbm5lY3Rpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQGltcGxlbWVudHMge1NlcnZlckFjdGlvbnN9XG4gICAgICogQHBhcmFtIHshUmVwb0luZm99IHJlcG9JbmZvXyBEYXRhIGFib3V0IHRoZSBuYW1lc3BhY2Ugd2UgYXJlIGNvbm5lY3RpbmcgdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgKiwgYm9vbGVhbiwgP251bWJlcil9IG9uRGF0YVVwZGF0ZV8gQSBjYWxsYmFjayBmb3IgbmV3IGRhdGEgZnJvbSB0aGUgc2VydmVyXG4gICAgICogQHBhcmFtIG9uQ29ubmVjdFN0YXR1c19cbiAgICAgKiBAcGFyYW0gb25TZXJ2ZXJJbmZvVXBkYXRlX1xuICAgICAqIEBwYXJhbSBhdXRoVG9rZW5Qcm92aWRlcl9cbiAgICAgKiBAcGFyYW0gYXV0aE92ZXJyaWRlX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBlcnNpc3RlbnRDb25uZWN0aW9uKHJlcG9JbmZvXywgb25EYXRhVXBkYXRlXywgb25Db25uZWN0U3RhdHVzXywgb25TZXJ2ZXJJbmZvVXBkYXRlXywgYXV0aFRva2VuUHJvdmlkZXJfLCBhdXRoT3ZlcnJpZGVfKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlcG9JbmZvXyA9IHJlcG9JbmZvXztcbiAgICAgICAgX3RoaXMub25EYXRhVXBkYXRlXyA9IG9uRGF0YVVwZGF0ZV87XG4gICAgICAgIF90aGlzLm9uQ29ubmVjdFN0YXR1c18gPSBvbkNvbm5lY3RTdGF0dXNfO1xuICAgICAgICBfdGhpcy5vblNlcnZlckluZm9VcGRhdGVfID0gb25TZXJ2ZXJJbmZvVXBkYXRlXztcbiAgICAgICAgX3RoaXMuYXV0aFRva2VuUHJvdmlkZXJfID0gYXV0aFRva2VuUHJvdmlkZXJfO1xuICAgICAgICBfdGhpcy5hdXRoT3ZlcnJpZGVfID0gYXV0aE92ZXJyaWRlXztcbiAgICAgICAgLy8gVXNlZCBmb3IgZGlhZ25vc3RpYyBsb2dnaW5nLlxuICAgICAgICBfdGhpcy5pZCA9IFBlcnNpc3RlbnRDb25uZWN0aW9uLm5leHRQZXJzaXN0ZW50Q29ubmVjdGlvbklkXysrO1xuICAgICAgICBfdGhpcy5sb2dfID0gdXRpbF80LmxvZ1dyYXBwZXIoJ3A6JyArIF90aGlzLmlkICsgJzonKTtcbiAgICAgICAgLyoqIEBwcml2YXRlIHtPYmplY3R9ICovXG4gICAgICAgIF90aGlzLmludGVycnVwdFJlYXNvbnNfID0ge307XG4gICAgICAgIF90aGlzLmxpc3RlbnNfID0ge307XG4gICAgICAgIF90aGlzLm91dHN0YW5kaW5nUHV0c18gPSBbXTtcbiAgICAgICAgX3RoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPSAwO1xuICAgICAgICBfdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfID0gW107XG4gICAgICAgIF90aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcbiAgICAgICAgX3RoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcbiAgICAgICAgX3RoaXMubWF4UmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9ERUZBVUxUO1xuICAgICAgICBfdGhpcy5zZWN1cml0eURlYnVnQ2FsbGJhY2tfID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdFNlc3Npb25JZCA9IG51bGw7XG4gICAgICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfG51bGx9ICovXG4gICAgICAgIF90aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xuICAgICAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgICAgIF90aGlzLnZpc2libGVfID0gZmFsc2U7XG4gICAgICAgIC8vIEJlZm9yZSB3ZSBnZXQgY29ubmVjdGVkLCB3ZSBrZWVwIGEgcXVldWUgb2YgcGVuZGluZyBtZXNzYWdlcyB0byBzZW5kLlxuICAgICAgICBfdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xuICAgICAgICBfdGhpcy5yZXF1ZXN0TnVtYmVyXyA9IDA7XG4gICAgICAgIC8qKiBAcHJpdmF0ZSB7P3tcbiAgICAgICAgICogICBzZW5kUmVxdWVzdChPYmplY3QpLFxuICAgICAgICAgKiAgIGNsb3NlKClcbiAgICAgICAgICogfX0gKi9cbiAgICAgICAgX3RoaXMucmVhbHRpbWVfID0gbnVsbDtcbiAgICAgICAgLyoqIEBwcml2YXRlIHtzdHJpbmd8bnVsbH0gKi9cbiAgICAgICAgX3RoaXMuYXV0aFRva2VuXyA9IG51bGw7XG4gICAgICAgIF90aGlzLmZvcmNlVG9rZW5SZWZyZXNoXyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcbiAgICAgICAgX3RoaXMuZmlyc3RDb25uZWN0aW9uXyA9IHRydWU7XG4gICAgICAgIF90aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbnVsbDtcbiAgICAgICAgaWYgKGF1dGhPdmVycmlkZV8gJiYgIXV0aWxfNy5pc05vZGVTZGsoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoIG92ZXJyaWRlIHNwZWNpZmllZCBpbiBvcHRpb25zLCBidXQgbm90IHN1cHBvcnRlZCBvbiBub24gTm9kZS5qcyBwbGF0Zm9ybXMnKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xuICAgICAgICBWaXNpYmlsaXR5TW9uaXRvcl8xLlZpc2liaWxpdHlNb25pdG9yLmdldEluc3RhbmNlKCkub24oJ3Zpc2libGUnLCBfdGhpcy5vblZpc2libGVfLCBfdGhpcyk7XG4gICAgICAgIGlmIChyZXBvSW5mb18uaG9zdC5pbmRleE9mKCdmYmxvY2FsJykgPT09IC0xKSB7XG4gICAgICAgICAgICBPbmxpbmVNb25pdG9yXzEuT25saW5lTW9uaXRvci5nZXRJbnN0YW5jZSgpLm9uKCdvbmxpbmUnLCBfdGhpcy5vbk9ubGluZV8sIF90aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gYWN0aW9uXG4gICAgICogQHBhcmFtIHsqfSBib2R5XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigqKT19IG9uUmVzcG9uc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gKGFjdGlvbiwgYm9keSwgb25SZXNwb25zZSkge1xuICAgICAgICB2YXIgY3VyUmVxTnVtID0gKyt0aGlzLnJlcXVlc3ROdW1iZXJfO1xuICAgICAgICB2YXIgbXNnID0geyByOiBjdXJSZXFOdW0sIGE6IGFjdGlvbiwgYjogYm9keSB9O1xuICAgICAgICB0aGlzLmxvZ18odXRpbF8yLnN0cmluZ2lmeShtc2cpKTtcbiAgICAgICAgdXRpbF8zLmFzc2VydCh0aGlzLmNvbm5lY3RlZF8sIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xuICAgICAgICB0aGlzLnJlYWx0aW1lXy5zZW5kUmVxdWVzdChtc2cpO1xuICAgICAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoX1tjdXJSZXFOdW1dID0gb25SZXNwb25zZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIHF1ZXJ5SWQgPSBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSBxdWVyeS5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMubG9nXygnTGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeUlkKTtcbiAgICAgICAgdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXSA9IHRoaXMubGlzdGVuc19bcGF0aFN0cmluZ10gfHwge307XG4gICAgICAgIHV0aWxfMy5hc3NlcnQocXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5pc0RlZmF1bHQoKSB8fFxuICAgICAgICAgICAgIXF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkubG9hZHNBbGxEYXRhKCksICdsaXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeScpO1xuICAgICAgICB1dGlsXzMuYXNzZXJ0KCF0aGlzLmxpc3RlbnNfW3BhdGhTdHJpbmddW3F1ZXJ5SWRdLCAnbGlzdGVuKCkgY2FsbGVkIHR3aWNlIGZvciBzYW1lIHBhdGgvcXVlcnlJZC4nKTtcbiAgICAgICAgdmFyIGxpc3RlblNwZWMgPSB7XG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlLFxuICAgICAgICAgICAgaGFzaEZuOiBjdXJyZW50SGFzaEZuLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgdGFnOiB0YWdcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXVtxdWVyeUlkXSA9IGxpc3RlblNwZWM7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZExpc3Rlbl8obGlzdGVuU3BlYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IXtvbkNvbXBsZXRlKCksXG4gICAgICogICAgICAgICAgIGhhc2hGbigpOiFzdHJpbmcsXG4gICAgICogICAgICAgICAgIHF1ZXJ5OiAhUXVlcnksXG4gICAgICogICAgICAgICAgIHRhZzogP251bWJlcn19IGxpc3RlblNwZWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kTGlzdGVuXyA9IGZ1bmN0aW9uIChsaXN0ZW5TcGVjKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxdWVyeSA9IGxpc3RlblNwZWMucXVlcnk7XG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gcXVlcnkucGF0aC50b1N0cmluZygpO1xuICAgICAgICB2YXIgcXVlcnlJZCA9IHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcbiAgICAgICAgdmFyIHJlcSA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZyB9O1xuICAgICAgICB2YXIgYWN0aW9uID0gJ3EnO1xuICAgICAgICAvLyBPbmx5IGJvdGhlciB0byBzZW5kIHF1ZXJ5IGlmIGl0J3Mgbm9uLWRlZmF1bHQuXG4gICAgICAgIGlmIChsaXN0ZW5TcGVjLnRhZykge1xuICAgICAgICAgICAgcmVxWydxJ10gPSBxdWVyeS5xdWVyeU9iamVjdCgpO1xuICAgICAgICAgICAgcmVxWyd0J10gPSBsaXN0ZW5TcGVjLnRhZztcbiAgICAgICAgfVxuICAgICAgICByZXFbJ2gnXSA9IGxpc3RlblNwZWMuaGFzaEZuKCk7XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoYWN0aW9uLCByZXEsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IG1lc3NhZ2VbJ2QnXTtcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSBtZXNzYWdlWydzJ107XG4gICAgICAgICAgICAvLyBwcmludCB3YXJuaW5ncyBpbiBhbnkgY2FzZS4uLlxuICAgICAgICAgICAgUGVyc2lzdGVudENvbm5lY3Rpb24ud2Fybk9uTGlzdGVuV2FybmluZ3NfKHBheWxvYWQsIHF1ZXJ5KTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGlzdGVuU3BlYyA9IF90aGlzLmxpc3RlbnNfW3BhdGhTdHJpbmddICYmIF90aGlzLmxpc3RlbnNfW3BhdGhTdHJpbmddW3F1ZXJ5SWRdO1xuICAgICAgICAgICAgLy8gb25seSB0cmlnZ2VyIGFjdGlvbnMgaWYgdGhlIGxpc3RlbiBoYXNuJ3QgYmVlbiByZW1vdmVkIGFuZCByZWFkZGVkXG4gICAgICAgICAgICBpZiAoY3VycmVudExpc3RlblNwZWMgPT09IGxpc3RlblNwZWMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dfKCdsaXN0ZW4gcmVzcG9uc2UnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAnb2snKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUxpc3Rlbl8ocGF0aFN0cmluZywgcXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5TcGVjLm9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuU3BlYy5vbkNvbXBsZXRlKHN0YXR1cywgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ud2Fybk9uTGlzdGVuV2FybmluZ3NfID0gZnVuY3Rpb24gKHBheWxvYWQsIHF1ZXJ5KSB7XG4gICAgICAgIGlmIChwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJiB1dGlsXzEuY29udGFpbnMocGF5bG9hZCwgJ3cnKSkge1xuICAgICAgICAgICAgdmFyIHdhcm5pbmdzID0gdXRpbF8xLnNhZmVHZXQocGF5bG9hZCwgJ3cnKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdhcm5pbmdzKSAmJiB+d2FybmluZ3MuaW5kZXhPZignbm9faW5kZXgnKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleFNwZWMgPSAnXCIuaW5kZXhPblwiOiBcIicgK1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldFF1ZXJ5UGFyYW1zKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRJbmRleCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICdcIic7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4UGF0aCA9IHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB1dGlsXzQud2FybihcIlVzaW5nIGFuIHVuc3BlY2lmaWVkIGluZGV4LiBZb3VyIGRhdGEgd2lsbCBiZSBkb3dubG9hZGVkIGFuZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcImZpbHRlcmVkIG9uIHRoZSBjbGllbnQuIENvbnNpZGVyIGFkZGluZyBcIiArIGluZGV4U3BlYyArIFwiIGF0IFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChpbmRleFBhdGggKyBcIiB0byB5b3VyIHNlY3VyaXR5IHJ1bGVzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucmVmcmVzaEF1dGhUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5sb2dfKCdBdXRoIHRva2VuIHJlZnJlc2hlZCcpO1xuICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW5fKSB7XG4gICAgICAgICAgICB0aGlzLnRyeUF1dGgoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vSWYgd2UncmUgY29ubmVjdGVkIHdlIHdhbnQgdG8gbGV0IHRoZSBzZXJ2ZXIga25vdyB0byB1bmF1dGhlbnRpY2F0ZSB1cy4gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgc2ltcGx5IGRlbGV0ZVxuICAgICAgICAgICAgLy90aGUgY3JlZGVudGlhbCBzbyB3ZSBkb250IGJlY29tZSBhdXRoZW50aWNhdGVkIG5leHQgdGltZSB3ZSBjb25uZWN0LlxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ3VuYXV0aCcsIHt9LCBmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8odG9rZW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBjcmVkZW50aWFsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8gPSBmdW5jdGlvbiAoY3JlZGVudGlhbCkge1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzbid0IGludGVuZGVkIHRvIGJlIGJ1bGxldHByb29mIChhIG1hbGljaW91cyBkZXZlbG9wZXIgY2FuIGFsd2F5cyBqdXN0IG1vZGlmeSB0aGUgY2xpZW50KS5cbiAgICAgICAgLy8gQWRkaXRpb25hbGx5LCB3ZSBkb24ndCBib3RoZXIgcmVzZXR0aW5nIHRoZSBtYXggZGVsYXkgYmFjayB0byB0aGUgZGVmYXVsdCBpZiBhdXRoIGZhaWxzIC8gZXhwaXJlcy5cbiAgICAgICAgdmFyIGlzRmlyZWJhc2VTZWNyZXQgPSBjcmVkZW50aWFsICYmIGNyZWRlbnRpYWwubGVuZ3RoID09PSA0MDtcbiAgICAgICAgaWYgKGlzRmlyZWJhc2VTZWNyZXQgfHwgdXRpbF81LmlzQWRtaW4oY3JlZGVudGlhbCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnQWRtaW4gYXV0aCBjcmVkZW50aWFsIGRldGVjdGVkLiAgUmVkdWNpbmcgbWF4IHJlY29ubmVjdCB0aW1lLicpO1xuICAgICAgICAgICAgdGhpcy5tYXhSZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy4gSWYgdGhlIGF1dGhlbnRpY2F0aW9uIGF0dGVtcHQgZmFpbHMsIGl0J3MgdHJpZ2dlcmVkIGxpa2VcbiAgICAgKiBhIGF1dGggcmV2b2tlZCAodGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkKS5cbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUudHJ5QXV0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXyAmJiB0aGlzLmF1dGhUb2tlbl8pIHtcbiAgICAgICAgICAgIHZhciB0b2tlbl8xID0gdGhpcy5hdXRoVG9rZW5fO1xuICAgICAgICAgICAgdmFyIGF1dGhNZXRob2QgPSB1dGlsXzUuaXNWYWxpZEZvcm1hdCh0b2tlbl8xKSA/ICdhdXRoJyA6ICdnYXV0aCc7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdERhdGEgPSB7IGNyZWQ6IHRva2VuXzEgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dGhPdmVycmlkZV8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YVsnbm9hdXRoJ10gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuYXV0aE92ZXJyaWRlXyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YVsnYXV0aHZhciddID0gdGhpcy5hdXRoT3ZlcnJpZGVfO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhdXRoTWV0aG9kLCByZXF1ZXN0RGF0YSwgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSByZXNbJ3MnXTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHJlc1snZCddIHx8ICdlcnJvcic7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmF1dGhUb2tlbl8gPT09IHRva2VuXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW52YWxpZEF1dGhUb2tlbkNvdW50XyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VycyByZWNvbm5lY3QgYW5kIGZvcmNlIHJlZnJlc2ggZm9yIGF1dGggdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQXV0aFJldm9rZWRfKHN0YXR1cywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUudW5saXN0ZW4gPSBmdW5jdGlvbiAocXVlcnksIHRhZykge1xuICAgICAgICB2YXIgcGF0aFN0cmluZyA9IHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIHF1ZXJ5SWQgPSBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy5sb2dfKCdVbmxpc3RlbiBjYWxsZWQgZm9yICcgKyBwYXRoU3RyaW5nICsgJyAnICsgcXVlcnlJZCk7XG4gICAgICAgIHV0aWxfMy5hc3NlcnQocXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5pc0RlZmF1bHQoKSB8fFxuICAgICAgICAgICAgIXF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkubG9hZHNBbGxEYXRhKCksICd1bmxpc3RlbigpIGNhbGxlZCBmb3Igbm9uLWRlZmF1bHQgYnV0IGNvbXBsZXRlIHF1ZXJ5Jyk7XG4gICAgICAgIHZhciBsaXN0ZW4gPSB0aGlzLnJlbW92ZUxpc3Rlbl8ocGF0aFN0cmluZywgcXVlcnlJZCk7XG4gICAgICAgIGlmIChsaXN0ZW4gJiYgdGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRVbmxpc3Rlbl8ocGF0aFN0cmluZywgcXVlcnlJZCwgcXVlcnkucXVlcnlPYmplY3QoKSwgdGFnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRVbmxpc3Rlbl8gPSBmdW5jdGlvbiAocGF0aFN0cmluZywgcXVlcnlJZCwgcXVlcnlPYmosIHRhZykge1xuICAgICAgICB0aGlzLmxvZ18oJ1VubGlzdGVuIG9uICcgKyBwYXRoU3RyaW5nICsgJyBmb3IgJyArIHF1ZXJ5SWQpO1xuICAgICAgICB2YXIgcmVxID0geyAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nIH07XG4gICAgICAgIHZhciBhY3Rpb24gPSAnbic7XG4gICAgICAgIC8vIE9ubHkgYm90aGVyIHNlbmRpbmcgcXVlcnlJZCBpZiBpdCdzIG5vbi1kZWZhdWx0LlxuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICByZXFbJ3EnXSA9IHF1ZXJ5T2JqO1xuICAgICAgICAgICAgcmVxWyd0J10gPSB0YWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3RQdXQgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKCdvJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZzogcGF0aFN0cmluZyxcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3RNZXJnZSA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ29tJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZzogcGF0aFN0cmluZyxcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvbScsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25EaXNjb25uZWN0Q2FuY2VsID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0Xygnb2MnLCBwYXRoU3RyaW5nLCBudWxsLCBvbkNvbXBsZXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nOiBwYXRoU3RyaW5nLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ29jJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZE9uRGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoYWN0aW9uLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0geyAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nLCAvKmRhdGEqLyBkOiBkYXRhIH07XG4gICAgICAgIHRoaXMubG9nXygnb25EaXNjb25uZWN0ICcgKyBhY3Rpb24sIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxdWVzdCwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKHJlc3BvbnNlWydzJ10sIHJlc3BvbnNlWydkJ10pO1xuICAgICAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XG4gICAgICAgIHRoaXMucHV0SW50ZXJuYWwoJ3AnLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcbiAgICAgICAgdGhpcy5wdXRJbnRlcm5hbCgnbScsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpO1xuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dEludGVybmFsID0gZnVuY3Rpb24gKGFjdGlvbiwgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIC8qcGF0aCovIHA6IHBhdGhTdHJpbmcsXG4gICAgICAgICAgICAvKmRhdGEqLyBkOiBkYXRhXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXF1ZXN0WydoJ10gPSBoYXNoO1xuICAgICAgICAvLyBUT0RPOiBPbmx5IGtlZXAgdHJhY2sgb2YgdGhlIG1vc3QgcmVjZW50IHB1dCBmb3IgYSBnaXZlbiBwYXRoP1xuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c18ucHVzaCh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfKys7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRQdXRfKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnQnVmZmVyaW5nIHB1dDogJyArIHBhdGhTdHJpbmcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZFB1dF8gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF0uYWN0aW9uO1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF0ucmVxdWVzdDtcbiAgICAgICAgdmFyIG9uQ29tcGxldGUgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLm9uQ29tcGxldGU7XG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF0ucXVldWVkID0gdGhpcy5jb25uZWN0ZWRfO1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxdWVzdCwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ18oYWN0aW9uICsgJyByZXNwb25zZScsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdO1xuICAgICAgICAgICAgX3RoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8tLTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGFycmF5IG9jY2FzaW9uYWxseS5cbiAgICAgICAgICAgIGlmIChfdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm91dHN0YW5kaW5nUHV0c18gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKVxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUobWVzc2FnZVsncyddLCBtZXNzYWdlWydkJ10pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnJlcG9ydFN0YXRzID0gZnVuY3Rpb24gKHN0YXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIElmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIHdlIGp1c3QgZHJvcCB0aGUgc3RhdHMuXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0geyAvKmNvdW50ZXJzKi8gYzogc3RhdHMgfTtcbiAgICAgICAgICAgIHRoaXMubG9nXygncmVwb3J0U3RhdHMnLCByZXF1ZXN0KTtcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoLypzdGF0cyovICdzJywgcmVxdWVzdCwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSByZXN1bHRbJ3MnXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAnb2snKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvclJlYXNvbiA9IHJlc3VsdFsnZCddO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dfKCdyZXBvcnRTdGF0cycsICdFcnJvciBzZW5kaW5nIHN0YXRzOiAnICsgZXJyb3JSZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IG1lc3NhZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5vbkRhdGFNZXNzYWdlXyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICgncicgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHJlc3BvbnNlXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ2Zyb20gc2VydmVyOiAnICsgdXRpbF8yLnN0cmluZ2lmeShtZXNzYWdlKSk7XG4gICAgICAgICAgICB2YXIgcmVxTnVtID0gbWVzc2FnZVsnciddO1xuICAgICAgICAgICAgdmFyIG9uUmVzcG9uc2UgPSB0aGlzLnJlcXVlc3RDQkhhc2hfW3JlcU51bV07XG4gICAgICAgICAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlcXVlc3RDQkhhc2hfW3JlcU51bV07XG4gICAgICAgICAgICAgICAgb25SZXNwb25zZShtZXNzYWdlWydiJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdlcnJvcicgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgJ0Egc2VydmVyLXNpZGUgZXJyb3IgaGFzIG9jY3VycmVkOiAnICsgbWVzc2FnZVsnZXJyb3InXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnYScgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gYSBhbmQgYiBhcmUgYWN0aW9uIGFuZCBib2R5LCByZXNwZWN0aXZlbHlcbiAgICAgICAgICAgIHRoaXMub25EYXRhUHVzaF8obWVzc2FnZVsnYSddLCBtZXNzYWdlWydiJ10pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25EYXRhUHVzaF8gPSBmdW5jdGlvbiAoYWN0aW9uLCBib2R5KSB7XG4gICAgICAgIHRoaXMubG9nXygnaGFuZGxlU2VydmVyTWVzc2FnZScsIGFjdGlvbiwgYm9keSk7XG4gICAgICAgIGlmIChhY3Rpb24gPT09ICdkJylcbiAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhib2R5WydwJ10sIGJvZHlbJ2QnXSwgXG4gICAgICAgICAgICAvKmlzTWVyZ2UqLyBmYWxzZSwgYm9keVsndCddKTtcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnbScpXG4gICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8oYm9keVsncCddLCBib2R5WydkJ10sIFxuICAgICAgICAgICAgLyppc01lcmdlPSovIHRydWUsIGJvZHlbJ3QnXSk7XG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2MnKVxuICAgICAgICAgICAgdGhpcy5vbkxpc3RlblJldm9rZWRfKGJvZHlbJ3AnXSwgYm9keVsncSddKTtcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYWMnKVxuICAgICAgICAgICAgdGhpcy5vbkF1dGhSZXZva2VkXyhib2R5WydzJ10sIGJvZHlbJ2QnXSk7XG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3NkJylcbiAgICAgICAgICAgIHRoaXMub25TZWN1cml0eURlYnVnUGFja2V0Xyhib2R5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdXRpbF80LmVycm9yKCdVbnJlY29nbml6ZWQgYWN0aW9uIHJlY2VpdmVkIGZyb20gc2VydmVyOiAnICtcbiAgICAgICAgICAgICAgICB1dGlsXzIuc3RyaW5naWZ5KGFjdGlvbikgK1xuICAgICAgICAgICAgICAgICdcXG5BcmUgeW91IHVzaW5nIHRoZSBsYXRlc3QgY2xpZW50PycpO1xuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLm9uUmVhZHlfID0gZnVuY3Rpb24gKHRpbWVzdGFtcCwgc2Vzc2lvbklkKSB7XG4gICAgICAgIHRoaXMubG9nXygnY29ubmVjdGlvbiByZWFkeScpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLmhhbmRsZVRpbWVzdGFtcF8odGltZXN0YW1wKTtcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgICAgICBpZiAodGhpcy5maXJzdENvbm5lY3Rpb25fKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRDb25uZWN0U3RhdHNfKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN0b3JlU3RhdGVfKCk7XG4gICAgICAgIHRoaXMuZmlyc3RDb25uZWN0aW9uXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18odHJ1ZSk7XG4gICAgfTtcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGVDb25uZWN0XyA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWxfMy5hc3NlcnQoIXRoaXMucmVhbHRpbWVfLCBcIlNjaGVkdWxpbmcgYSBjb25uZWN0IHdoZW4gd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQvaW5nP1wiKTtcbiAgICAgICAgaWYgKHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogRXZlbiB3aGVuIHRpbWVvdXQgaXMgMCwgaXQncyBpbXBvcnRhbnQgdG8gZG8gYSBzZXRUaW1lb3V0IHRvIHdvcmsgYXJvdW5kIGFuIGluZnVyaWF0aW5nIFwiU2VjdXJpdHkgRXJyb3JcIiBpblxuICAgICAgICAvLyBGaXJlZm94IHdoZW4gdHJ5aW5nIHRvIHdyaXRlIHRvIG91ciBsb25nLXBvbGxpbmcgaWZyYW1lIGluIHNvbWUgc2NlbmFyaW9zIChlLmcuIEZvcmdlIG9yIG91ciB1bml0IHRlc3RzKS5cbiAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmVzdGFibGlzaENvbm5lY3Rpb25fKCk7XG4gICAgICAgIH0sIE1hdGguZmxvb3IodGltZW91dCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25WaXNpYmxlXyA9IGZ1bmN0aW9uICh2aXNpYmxlKSB7XG4gICAgICAgIC8vIE5PVEU6IFRhYmJpbmcgYXdheSBhbmQgYmFjayB0byBhIHdpbmRvdyB3aWxsIGRlZmVhdCBvdXIgcmVjb25uZWN0IGJhY2tvZmYsIGJ1dCBJIHRoaW5rIHRoYXQncyBmaW5lLlxuICAgICAgICBpZiAodmlzaWJsZSAmJlxuICAgICAgICAgICAgIXRoaXMudmlzaWJsZV8gJiZcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID09PSB0aGlzLm1heFJlY29ubmVjdERlbGF5Xykge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdXaW5kb3cgYmVjYW1lIHZpc2libGUuICBSZWR1Y2luZyBkZWxheS4nKTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpYmxlXyA9IHZpc2libGU7XG4gICAgfTtcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25PbmxpbmVfID0gZnVuY3Rpb24gKG9ubGluZSkge1xuICAgICAgICBpZiAob25saW5lKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Jyb3dzZXIgd2VudCBvbmxpbmUuJyk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdCcm93c2VyIHdlbnQgb2ZmbGluZS4gIEtpbGxpbmcgY29ubmVjdGlvbi4nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWx0aW1lXykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWVfLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5vblJlYWx0aW1lRGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nXygnZGF0YSBjbGllbnQgZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWx0aW1lXyA9IG51bGw7XG4gICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGtub3cgaWYgb3VyIHNlbnQgdHJhbnNhY3Rpb25zIHN1Y2NlZWRlZCBvciBub3QsIHdlIG5lZWQgdG8gY2FuY2VsIHRoZW0uXG4gICAgICAgIHRoaXMuY2FuY2VsU2VudFRyYW5zYWN0aW9uc18oKTtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBwZW5kaW5nIHJlcXVlc3RzLlxuICAgICAgICB0aGlzLnJlcXVlc3RDQkhhc2hfID0ge307XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdF8oKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZpc2libGVfKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKFwiV2luZG93IGlzbid0IHZpc2libGUuICBEZWxheWluZyByZWNvbm5lY3QuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gdGhpcy5tYXhSZWNvbm5lY3REZWxheV87XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBiZWVuIGNvbm5lY3RlZCBsb25nIGVub3VnaCwgcmVzZXQgcmVjb25uZWN0IGRlbGF5IHRvIG1pbmltdW0uXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXztcbiAgICAgICAgICAgICAgICBpZiAodGltZVNpbmNlTGFzdENvbm5lY3RTdWNjZWVkZWQgPiBSRUNPTk5FQ1RfREVMQVlfUkVTRVRfVElNRU9VVClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q29ubmVjdEF0dGVtcHQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV87XG4gICAgICAgICAgICB2YXIgcmVjb25uZWN0RGVsYXkgPSBNYXRoLm1heCgwLCB0aGlzLnJlY29ubmVjdERlbGF5XyAtIHRpbWVTaW5jZUxhc3RDb25uZWN0QXR0ZW1wdCk7XG4gICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IE1hdGgucmFuZG9tKCkgKiByZWNvbm5lY3REZWxheTtcbiAgICAgICAgICAgIHRoaXMubG9nXygnVHJ5aW5nIHRvIHJlY29ubmVjdCBpbiAnICsgcmVjb25uZWN0RGVsYXkgKyAnbXMnKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XyhyZWNvbm5lY3REZWxheSk7XG4gICAgICAgICAgICAvLyBBZGp1c3QgcmVjb25uZWN0IGRlbGF5IGZvciBuZXh0IHRpbWUuXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IE1hdGgubWluKHRoaXMubWF4UmVjb25uZWN0RGVsYXlfLCB0aGlzLnJlY29ubmVjdERlbGF5XyAqIFJFQ09OTkVDVF9ERUxBWV9NVUxUSVBMSUVSKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18oZmFsc2UpO1xuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLmVzdGFibGlzaENvbm5lY3Rpb25fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRSZWNvbm5lY3RfKCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnTWFraW5nIGEgY29ubmVjdGlvbiBhdHRlbXB0Jyk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgb25EYXRhTWVzc2FnZV8xID0gdGhpcy5vbkRhdGFNZXNzYWdlXy5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG9uUmVhZHlfMSA9IHRoaXMub25SZWFkeV8uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBvbkRpc2Nvbm5lY3RfMSA9IHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB2YXIgY29ubklkXzEgPSB0aGlzLmlkICsgJzonICsgUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dENvbm5lY3Rpb25JZF8rKztcbiAgICAgICAgICAgIHZhciBzZWxmXzEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGxhc3RTZXNzaW9uSWRfMSA9IHRoaXMubGFzdFNlc3Npb25JZDtcbiAgICAgICAgICAgIHZhciBjYW5jZWxlZF8xID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbl8xID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjbG9zZUZuXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25fMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uXzEuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGVkXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvbkRpc2Nvbm5lY3RfMSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc2VuZFJlcXVlc3RGbiA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzMuYXNzZXJ0KGNvbm5lY3Rpb25fMSwgXCJzZW5kUmVxdWVzdCBjYWxsIHdoZW4gd2UncmUgbm90IGNvbm5lY3RlZCBub3QgYWxsb3dlZC5cIik7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbl8xLnNlbmRSZXF1ZXN0KG1zZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZV8gPSB7XG4gICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlRm5fMSxcbiAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdDogc2VuZFJlcXVlc3RGblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBmb3JjZVJlZnJlc2ggPSB0aGlzLmZvcmNlVG9rZW5SZWZyZXNoXztcbiAgICAgICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBGaXJzdCBmZXRjaCBhdXRoIHRva2VuLCBhbmQgZXN0YWJsaXNoIGNvbm5lY3Rpb24gYWZ0ZXIgZmV0Y2hpbmcgdGhlIHRva2VuIHdhcyBzdWNjZXNzZnVsXG4gICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyX1xuICAgICAgICAgICAgICAgIC5nZXRUb2tlbihmb3JjZVJlZnJlc2gpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWRfMSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzQubG9nKCdnZXRUb2tlbigpIGNvbXBsZXRlZC4gQ3JlYXRpbmcgY29ubmVjdGlvbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZl8xLmF1dGhUb2tlbl8gPSByZXN1bHQgJiYgcmVzdWx0LmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uXzEgPSBuZXcgQ29ubmVjdGlvbl8xLkNvbm5lY3Rpb24oY29ubklkXzEsIHNlbGZfMS5yZXBvSW5mb18sIG9uRGF0YU1lc3NhZ2VfMSwgb25SZWFkeV8xLCBvbkRpc2Nvbm5lY3RfMSwgXG4gICAgICAgICAgICAgICAgICAgIC8qIG9uS2lsbD0gKi8gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbF80Lndhcm4ocmVhc29uICsgJyAoJyArIHNlbGZfMS5yZXBvSW5mb18udG9TdHJpbmcoKSArICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmXzEuaW50ZXJydXB0KFNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04pO1xuICAgICAgICAgICAgICAgICAgICB9LCBsYXN0U2Vzc2lvbklkXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF80LmxvZygnZ2V0VG9rZW4oKSBjb21wbGV0ZWQgYnV0IHdhcyBjYW5jZWxlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgc2VsZl8xLmxvZ18oJ0ZhaWxlZCB0byBnZXQgdG9rZW46ICcgKyBlcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZF8xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlsXzYuQ09OU1RBTlRTLk5PREVfQURNSU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IGJlIGEgY3JpdGljYWwgZXJyb3IgZm9yIHRoZSBBZG1pbiBOb2RlLmpzIFNESywgc28gbG9nIGEgd2FybmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBnZXRUb2tlbigpIG1heSBhbHNvIGp1c3QgaGF2ZSB0ZW1wb3JhcmlseSBmYWlsZWQsIHNvIHdlIHN0aWxsIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHJldHJ5aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbF80Lndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlRm5fMSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLmludGVycnVwdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdXRpbF80LmxvZygnSW50ZXJydXB0aW5nIGNvbm5lY3Rpb24gZm9yIHJlYXNvbjogJyArIHJlYXNvbik7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0UmVhc29uc19bcmVhc29uXSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnJlYWx0aW1lXykge1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8pIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgICAgICAgICAgIHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICB1dGlsXzQubG9nKCdSZXN1bWluZyBjb25uZWN0aW9uIGZvciByZWFzb246ICcgKyByZWFzb24pO1xuICAgICAgICBkZWxldGUgdGhpcy5pbnRlcnJ1cHRSZWFzb25zX1tyZWFzb25dO1xuICAgICAgICBpZiAodXRpbF8xLmlzRW1wdHkodGhpcy5pbnRlcnJ1cHRSZWFzb25zXykpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVUaW1lc3RhbXBfID0gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgZGVsdGEgPSB0aW1lc3RhbXAgLSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5vblNlcnZlckluZm9VcGRhdGVfKHsgc2VydmVyVGltZU9mZnNldDogZGVsdGEgfSk7XG4gICAgfTtcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuY2FuY2VsU2VudFRyYW5zYWN0aW9uc18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHV0ID0gdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2ldO1xuICAgICAgICAgICAgaWYgKHB1dCAmJiAvKmhhc2gqLyAnaCcgaW4gcHV0LnJlcXVlc3QgJiYgcHV0LnF1ZXVlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwdXQub25Db21wbGV0ZSlcbiAgICAgICAgICAgICAgICAgICAgcHV0Lm9uQ29tcGxldGUoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhbiB1cCBhcnJheSBvY2Nhc2lvbmFsbHkuXG4gICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfID09PSAwKVxuICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfID0gW107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0ge0FycmF5LjwqPj19IHF1ZXJ5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25MaXN0ZW5SZXZva2VkXyA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBxdWVyeSkge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3RlbiBhbmQgbWFudWZhY3R1cmUgYSBcInBlcm1pc3Npb25fZGVuaWVkXCIgZXJyb3IgZm9yIHRoZSBmYWlsZWQgbGlzdGVuLlxuICAgICAgICB2YXIgcXVlcnlJZDtcbiAgICAgICAgaWYgKCFxdWVyeSkge1xuICAgICAgICAgICAgcXVlcnlJZCA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5SWQgPSBxdWVyeS5tYXAoZnVuY3Rpb24gKHEpIHsgcmV0dXJuIHV0aWxfNC5PYmplY3RUb1VuaXF1ZUtleShxKTsgfSkuam9pbignJCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW4gPSB0aGlzLnJlbW92ZUxpc3Rlbl8ocGF0aFN0cmluZywgcXVlcnlJZCk7XG4gICAgICAgIGlmIChsaXN0ZW4gJiYgbGlzdGVuLm9uQ29tcGxldGUpXG4gICAgICAgICAgICBsaXN0ZW4ub25Db21wbGV0ZSgncGVybWlzc2lvbl9kZW5pZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aFN0cmluZ1xuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gcXVlcnlJZFxuICAgICAqIEByZXR1cm4ge3txdWVyaWVzOkFycmF5LjxRdWVyeT4sIG9uQ29tcGxldGU6ZnVuY3Rpb24oc3RyaW5nKX19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlTGlzdGVuXyA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBxdWVyeUlkKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkUGF0aFN0cmluZyA9IG5ldyBQYXRoXzEuUGF0aChwYXRoU3RyaW5nKS50b1N0cmluZygpOyAvLyBub3JtYWxpemUgcGF0aC5cbiAgICAgICAgdmFyIGxpc3RlbjtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuc19bbm9ybWFsaXplZFBhdGhTdHJpbmddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbiA9IHRoaXMubGlzdGVuc19bbm9ybWFsaXplZFBhdGhTdHJpbmddW3F1ZXJ5SWRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuc19bbm9ybWFsaXplZFBhdGhTdHJpbmddW3F1ZXJ5SWRdO1xuICAgICAgICAgICAgaWYgKHV0aWxfMS5nZXRDb3VudCh0aGlzLmxpc3RlbnNfW25vcm1hbGl6ZWRQYXRoU3RyaW5nXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5zX1tub3JtYWxpemVkUGF0aFN0cmluZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhbGwgbGlzdGVucyBmb3IgdGhpcyBwYXRoIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgbGlzdGVuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW47XG4gICAgfTtcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25BdXRoUmV2b2tlZF8gPSBmdW5jdGlvbiAoc3RhdHVzQ29kZSwgZXhwbGFuYXRpb24pIHtcbiAgICAgICAgdXRpbF80LmxvZygnQXV0aCB0b2tlbiByZXZva2VkOiAnICsgc3RhdHVzQ29kZSArICcvJyArIGV4cGxhbmF0aW9uKTtcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JjZVRva2VuUmVmcmVzaF8gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gJ2ludmFsaWRfdG9rZW4nIHx8IHN0YXR1c0NvZGUgPT09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcbiAgICAgICAgICAgIC8vIFdlJ2xsIHdhaXQgYSBjb3VwbGUgdGltZXMgYmVmb3JlIGxvZ2dpbmcgdGhlIHdhcm5pbmcgLyBpbmNyZWFzaW5nIHRoZVxuICAgICAgICAgICAgLy8gcmV0cnkgcGVyaW9kIHNpbmNlIG9hdXRoIHRva2VucyB3aWxsIHJlcG9ydCBhcyBcImludmFsaWRcIiBpZiB0aGV5J3JlXG4gICAgICAgICAgICAvLyBqdXN0IGV4cGlyZWQuIFBsdXMgdGhlcmUgbWF5IGJlIHRyYW5zaWVudCBpc3N1ZXMgdGhhdCByZXNvbHZlIHRoZW1zZWx2ZXMuXG4gICAgICAgICAgICB0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8rKztcbiAgICAgICAgICAgIGlmICh0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8gPj0gSU5WQUxJRF9BVVRIX1RPS0VOX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgIC8vIFNldCBhIGxvbmcgcmVjb25uZWN0IGRlbGF5IGJlY2F1c2UgcmVjb3ZlcnkgaXMgdW5saWtlbHlcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NQVhfREVMQVlfRk9SX0FETUlOUztcbiAgICAgICAgICAgICAgICAvLyBOb3RpZnkgdGhlIGF1dGggdG9rZW4gcHJvdmlkZXIgdGhhdCB0aGUgdG9rZW4gaXMgaW52YWxpZCwgd2hpY2ggd2lsbCBsb2dcbiAgICAgICAgICAgICAgICAvLyBhIHdhcm5pbmdcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXy5ub3RpZnlGb3JJbnZhbGlkVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLm9uU2VjdXJpdHlEZWJ1Z1BhY2tldF8gPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICBpZiAodGhpcy5zZWN1cml0eURlYnVnQ2FsbGJhY2tfKSB7XG4gICAgICAgICAgICB0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18oYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoJ21zZycgaW4gYm9keSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRklSRUJBU0U6ICcgKyBib2R5Wydtc2cnXS5yZXBsYWNlKCdcXG4nLCAnXFxuRklSRUJBU0U6ICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnJlc3RvcmVTdGF0ZV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vUmUtYXV0aGVudGljYXRlIG91cnNlbHZlcyBpZiB3ZSBoYXZlIGEgY3JlZGVudGlhbCBzdG9yZWQuXG4gICAgICAgIHRoaXMudHJ5QXV0aCgpO1xuICAgICAgICAvLyBQdXRzIGRlcGVuZCBvbiBoYXZpbmcgcmVjZWl2ZWQgdGhlIGNvcnJlc3BvbmRpbmcgZGF0YSB1cGRhdGUgZnJvbSB0aGUgc2VydmVyIGJlZm9yZSB0aGV5IGNvbXBsZXRlLCBzbyB3ZSBtdXN0XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBzZW5kIGxpc3RlbnMgYmVmb3JlIHB1dHMuXG4gICAgICAgIHV0aWxfMS5mb3JFYWNoKHRoaXMubGlzdGVuc18sIGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBxdWVyaWVzKSB7XG4gICAgICAgICAgICB1dGlsXzEuZm9yRWFjaChxdWVyaWVzLCBmdW5jdGlvbiAoa2V5LCBsaXN0ZW5TcGVjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZExpc3Rlbl8obGlzdGVuU3BlYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ1B1dHNfW2ldKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFB1dF8oaSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKHJlcXVlc3QuYWN0aW9uLCByZXF1ZXN0LnBhdGhTdHJpbmcsIHJlcXVlc3QuZGF0YSwgcmVxdWVzdC5vbkNvbXBsZXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZHMgY2xpZW50IHN0YXRzIGZvciBmaXJzdCBjb25uZWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZENvbm5lY3RTdGF0c18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0cyA9IHt9O1xuICAgICAgICB2YXIgY2xpZW50TmFtZSA9ICdqcyc7XG4gICAgICAgIGlmICh1dGlsXzYuQ09OU1RBTlRTLk5PREVfQURNSU4pIHtcbiAgICAgICAgICAgIGNsaWVudE5hbWUgPSAnYWRtaW5fbm9kZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXRpbF82LkNPTlNUQU5UUy5OT0RFX0NMSUVOVCkge1xuICAgICAgICAgICAgY2xpZW50TmFtZSA9ICdub2RlJztcbiAgICAgICAgfVxuICAgICAgICBzdGF0c1snc2RrLicgKyBjbGllbnROYW1lICsgJy4nICsgYXBwXzEuZGVmYXVsdC5TREtfVkVSU0lPTi5yZXBsYWNlKC9cXC4vZywgJy0nKV0gPSAxO1xuICAgICAgICBpZiAodXRpbF83LmlzTW9iaWxlQ29yZG92YSgpKSB7XG4gICAgICAgICAgICBzdGF0c1snZnJhbWV3b3JrLmNvcmRvdmEnXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXRpbF83LmlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgc3RhdHNbJ2ZyYW1ld29yay5yZWFjdG5hdGl2ZSddID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcG9ydFN0YXRzKHN0YXRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuc2hvdWxkUmVjb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ubGluZSA9IE9ubGluZU1vbml0b3JfMS5PbmxpbmVNb25pdG9yLmdldEluc3RhbmNlKCkuY3VycmVudGx5T25saW5lKCk7XG4gICAgICAgIHJldHVybiB1dGlsXzEuaXNFbXB0eSh0aGlzLmludGVycnVwdFJlYXNvbnNfKSAmJiBvbmxpbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLm5leHRQZXJzaXN0ZW50Q29ubmVjdGlvbklkXyA9IDA7XG4gICAgLyoqXG4gICAgICogQ291bnRlciBmb3IgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGNyZWF0ZWQuIE1haW5seSB1c2VkIGZvciB0YWdnaW5nIGluIHRoZSBsb2dzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLm5leHRDb25uZWN0aW9uSWRfID0gMDtcbiAgICByZXR1cm4gUGVyc2lzdGVudENvbm5lY3Rpb247XG59KFNlcnZlckFjdGlvbnNfMS5TZXJ2ZXJBY3Rpb25zKSk7XG5leHBvcnRzLlBlcnNpc3RlbnRDb25uZWN0aW9uID0gUGVyc2lzdGVudENvbm5lY3Rpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBlcnNpc3RlbnRDb25uZWN0aW9uLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuL3V0aWwvdXRpbFwiKTtcbnZhciB1dGlsXzMgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF80ID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfNSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBTZXJ2ZXJBY3Rpb25zXzEgPSByZXF1aXJlKFwiLi9TZXJ2ZXJBY3Rpb25zXCIpO1xuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBTZXJ2ZXJBY3Rpb25zIHRoYXQgY29tbXVuaWNhdGVzIHdpdGggdGhlIHNlcnZlciB2aWEgUkVTVCByZXF1ZXN0cy5cbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGNyYXdsZXJzLCB3aGVyZSB3ZSBkb24ndCB3YW50IHRvIHNwaW4gdXAgYSBmdWxsXG4gKiBwZXJzaXN0ZW50IGNvbm5lY3Rpb24gKHVzaW5nIFdlYlNvY2tldHMgb3IgbG9uZy1wb2xsaW5nKVxuICovXG52YXIgUmVhZG9ubHlSZXN0Q2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWFkb25seVJlc3RDbGllbnQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUmVwb0luZm99IHJlcG9JbmZvXyBEYXRhIGFib3V0IHRoZSBuYW1lc3BhY2Ugd2UgYXJlIGNvbm5lY3RpbmcgdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgKiwgYm9vbGVhbiwgP251bWJlcil9IG9uRGF0YVVwZGF0ZV8gQSBjYWxsYmFjayBmb3IgbmV3IGRhdGEgZnJvbSB0aGUgc2VydmVyXG4gICAgICogQHBhcmFtIHtBdXRoVG9rZW5Qcm92aWRlcn0gYXV0aFRva2VuUHJvdmlkZXJfXG4gICAgICogQGltcGxlbWVudHMge1NlcnZlckFjdGlvbnN9XG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVhZG9ubHlSZXN0Q2xpZW50KHJlcG9JbmZvXywgb25EYXRhVXBkYXRlXywgYXV0aFRva2VuUHJvdmlkZXJfKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlcG9JbmZvXyA9IHJlcG9JbmZvXztcbiAgICAgICAgX3RoaXMub25EYXRhVXBkYXRlXyA9IG9uRGF0YVVwZGF0ZV87XG4gICAgICAgIF90aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcbiAgICAgICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbiguLi5bKl0pfSAqL1xuICAgICAgICBfdGhpcy5sb2dfID0gdXRpbF8yLmxvZ1dyYXBwZXIoJ3A6cmVzdDonKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGRvbid0IGFjdHVhbGx5IG5lZWQgdG8gdHJhY2sgbGlzdGVucywgZXhjZXB0IHRvIHByZXZlbnQgdXMgY2FsbGluZyBhbiBvbkNvbXBsZXRlIGZvciBhIGxpc3RlblxuICAgICAgICAgKiB0aGF0J3MgYmVlbiByZW1vdmVkLiA6LS9cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGUgeyFPYmplY3QuPHN0cmluZywgIU9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5saXN0ZW5zXyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlYWRvbmx5UmVzdENsaWVudC5wcm90b3R5cGUucmVwb3J0U3RhdHMgPSBmdW5jdGlvbiAoc3RhdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHs/bnVtYmVyPX0gdGFnXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyA9IGZ1bmN0aW9uIChxdWVyeSwgdGFnKSB7XG4gICAgICAgIGlmICh0YWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWckJyArIHRhZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQocXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5pc0RlZmF1bHQoKSwgXCJzaG91bGQgaGF2ZSBhIHRhZyBpZiBpdCdzIG5vdCBhIGRlZmF1bHQgcXVlcnkuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgUmVhZG9ubHlSZXN0Q2xpZW50LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAocXVlcnksIGN1cnJlbnRIYXNoRm4sIHRhZywgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGF0aFN0cmluZyA9IHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5sb2dfKCdMaXN0ZW4gY2FsbGVkIGZvciAnICsgcGF0aFN0cmluZyArICcgJyArIHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpKTtcbiAgICAgICAgLy8gTWFyayB0aGlzIGxpc3RlbmVyIHNvIHdlIGNhbiB0ZWxsIGlmIGl0J3MgcmVtb3ZlZC5cbiAgICAgICAgdmFyIGxpc3RlbklkID0gUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyhxdWVyeSwgdGFnKTtcbiAgICAgICAgdmFyIHRoaXNMaXN0ZW4gPSB7fTtcbiAgICAgICAgdGhpcy5saXN0ZW5zX1tsaXN0ZW5JZF0gPSB0aGlzTGlzdGVuO1xuICAgICAgICB2YXIgcXVlcnlTdHJpbmdQYXJhbWF0ZXJzID0gcXVlcnlcbiAgICAgICAgICAgIC5nZXRRdWVyeVBhcmFtcygpXG4gICAgICAgICAgICAudG9SZXN0UXVlcnlTdHJpbmdQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHRoaXMucmVzdFJlcXVlc3RfKHBhdGhTdHJpbmcgKyAnLmpzb24nLCBxdWVyeVN0cmluZ1BhcmFtYXRlcnMsIGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25EYXRhVXBkYXRlXyhwYXRoU3RyaW5nLCBkYXRhLCAvKmlzTWVyZ2U9Ki8gZmFsc2UsIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXRpbF80LnNhZmVHZXQoX3RoaXMubGlzdGVuc18sIGxpc3RlbklkKSA9PT0gdGhpc0xpc3Rlbikge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNfMTtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c18xID0gJ29rJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgPT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c18xID0gJ3Blcm1pc3Npb25fZGVuaWVkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c18xID0gJ3Jlc3RfZXJyb3I6JyArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKHN0YXR1c18xLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBSZWFkb25seVJlc3RDbGllbnQucHJvdG90eXBlLnVubGlzdGVuID0gZnVuY3Rpb24gKHF1ZXJ5LCB0YWcpIHtcbiAgICAgICAgdmFyIGxpc3RlbklkID0gUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyhxdWVyeSwgdGFnKTtcbiAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuc19bbGlzdGVuSWRdO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgUmVhZG9ubHlSZXN0Q2xpZW50LnByb3RvdHlwZS5yZWZyZXNoQXV0aFRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIC8vIG5vLW9wIHNpbmNlIHdlIGp1c3QgYWx3YXlzIGNhbGwgZ2V0VG9rZW4uXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIFJFU1QgcmVxdWVzdCB0byB0aGUgZ2l2ZW4gcGF0aCwgd2l0aCB0aGUgcHJvdmlkZWQgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMsXG4gICAgICogYW5kIGFueSBhdXRoIGNyZWRlbnRpYWxzIHdlIGhhdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgKj59IHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9udW1iZXIsICo9KX0gY2FsbGJhY2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlYWRvbmx5UmVzdENsaWVudC5wcm90b3R5cGUucmVzdFJlcXVlc3RfID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIHF1ZXJ5U3RyaW5nUGFyYW1ldGVycywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyA9PT0gdm9pZCAwKSB7IHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyA9IHt9OyB9XG4gICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snZm9ybWF0J10gPSAnZXhwb3J0JztcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl9cbiAgICAgICAgICAgIC5nZXRUb2tlbigvKmZvcmNlUmVmcmVzaD0qLyBmYWxzZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhdXRoVG9rZW5EYXRhKSB7XG4gICAgICAgICAgICB2YXIgYXV0aFRva2VuID0gYXV0aFRva2VuRGF0YSAmJiBhdXRoVG9rZW5EYXRhLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgaWYgKGF1dGhUb2tlbikge1xuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snYXV0aCddID0gYXV0aFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVybCA9IChfdGhpcy5yZXBvSW5mb18uc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgK1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcG9JbmZvXy5ob3N0ICtcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nICtcbiAgICAgICAgICAgICAgICAnPycgK1xuICAgICAgICAgICAgICAgIHV0aWxfNS5xdWVyeXN0cmluZyhxdWVyeVN0cmluZ1BhcmFtZXRlcnMpO1xuICAgICAgICAgICAgX3RoaXMubG9nXygnU2VuZGluZyBSRVNUIHJlcXVlc3QgZm9yICcgKyB1cmwpO1xuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nXygnUkVTVCBSZXNwb25zZSBmb3IgJyArIHVybCArICcgcmVjZWl2ZWQuIHN0YXR1czonLCB4aHIuc3RhdHVzLCAncmVzcG9uc2U6JywgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB1dGlsXzMuanNvbkV2YWwoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxfMi53YXJuKCdGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSBmb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA0MDEgYW5kIDQwNCBhcmUgZXhwZWN0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gNDAxICYmIHhoci5zdGF0dXMgIT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxfMi53YXJuKCdHb3QgdW5zdWNjZXNzZnVsIFJFU1QgcmVzcG9uc2UgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIFN0YXR1czogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCAvKmFzeW5jaHJvbm91cz0qLyB0cnVlKTtcbiAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWRvbmx5UmVzdENsaWVudDtcbn0oU2VydmVyQWN0aW9uc18xLlNlcnZlckFjdGlvbnMpKTtcbmV4cG9ydHMuUmVhZG9ubHlSZXN0Q2xpZW50ID0gUmVhZG9ubHlSZXN0Q2xpZW50O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFkb25seVJlc3RDbGllbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU2VydmVyVmFsdWVzXzEgPSByZXF1aXJlKFwiLi91dGlsL1NlcnZlclZhbHVlc1wiKTtcbnZhciBub2RlRnJvbUpTT05fMSA9IHJlcXVpcmUoXCIuL3NuYXAvbm9kZUZyb21KU09OXCIpO1xudmFyIFBhdGhfMSA9IHJlcXVpcmUoXCIuL3V0aWwvUGF0aFwiKTtcbnZhciBTcGFyc2VTbmFwc2hvdFRyZWVfMSA9IHJlcXVpcmUoXCIuL1NwYXJzZVNuYXBzaG90VHJlZVwiKTtcbnZhciBTeW5jVHJlZV8xID0gcmVxdWlyZShcIi4vU3luY1RyZWVcIik7XG52YXIgU25hcHNob3RIb2xkZXJfMSA9IHJlcXVpcmUoXCIuL1NuYXBzaG90SG9sZGVyXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiLi91dGlsL3V0aWxcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIEF1dGhUb2tlblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9BdXRoVG9rZW5Qcm92aWRlclwiKTtcbnZhciBTdGF0c01hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRzL1N0YXRzTWFuYWdlclwiKTtcbnZhciBTdGF0c1JlcG9ydGVyXzEgPSByZXF1aXJlKFwiLi9zdGF0cy9TdGF0c1JlcG9ydGVyXCIpO1xudmFyIFN0YXRzTGlzdGVuZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRzL1N0YXRzTGlzdGVuZXJcIik7XG52YXIgRXZlbnRRdWV1ZV8xID0gcmVxdWlyZShcIi4vdmlldy9FdmVudFF1ZXVlXCIpO1xudmFyIFBlcnNpc3RlbnRDb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9QZXJzaXN0ZW50Q29ubmVjdGlvblwiKTtcbnZhciBSZWFkb25seVJlc3RDbGllbnRfMSA9IHJlcXVpcmUoXCIuL1JlYWRvbmx5UmVzdENsaWVudFwiKTtcbnZhciBEYXRhYmFzZV8xID0gcmVxdWlyZShcIi4uL2FwaS9EYXRhYmFzZVwiKTtcbnZhciBJTlRFUlJVUFRfUkVBU09OID0gJ3JlcG9faW50ZXJydXB0Jztcbi8qKlxuICogQSBjb25uZWN0aW9uIHRvIGEgc2luZ2xlIGRhdGEgcmVwb3NpdG9yeS5cbiAqL1xudmFyIFJlcG8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUmVwb0luZm99IHJlcG9JbmZvX1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VSZXN0Q2xpZW50XG4gICAgICogQHBhcmFtIHshRmlyZWJhc2VBcHB9IGFwcFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlcG8ocmVwb0luZm9fLCBmb3JjZVJlc3RDbGllbnQsIGFwcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlcG9JbmZvXyA9IHJlcG9JbmZvXztcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuZGF0YVVwZGF0ZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zdGF0c0xpc3RlbmVyXyA9IG51bGw7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8gPSBuZXcgRXZlbnRRdWV1ZV8xLkV2ZW50UXVldWUoKTtcbiAgICAgICAgdGhpcy5uZXh0V3JpdGVJZF8gPSAxO1xuICAgICAgICB0aGlzLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18gPSBudWxsO1xuICAgICAgICAvLyBBIGxpc3Qgb2YgZGF0YSBwaWVjZXMgYW5kIHBhdGhzIHRvIGJlIHNldCB3aGVuIHRoaXMgY2xpZW50IGRpc2Nvbm5lY3RzLlxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBuZXcgU3BhcnNlU25hcHNob3RUcmVlXzEuU3BhcnNlU25hcHNob3RUcmVlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPOiBUaGlzIHNob3VsZCBiZSBAcHJpdmF0ZSBidXQgaXQncyB1c2VkIGJ5IHRlc3RfYWNjZXNzLmpzIGFuZCBpbnRlcm5hbC5qc1xuICAgICAgICAgKiBAdHlwZSB7P1BlcnNpc3RlbnRDb25uZWN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8gPSBudWxsO1xuICAgICAgICAvKiogQHR5cGUgeyFBdXRoVG9rZW5Qcm92aWRlcn0gKi9cbiAgICAgICAgdmFyIGF1dGhUb2tlblByb3ZpZGVyID0gbmV3IEF1dGhUb2tlblByb3ZpZGVyXzEuQXV0aFRva2VuUHJvdmlkZXIoYXBwKTtcbiAgICAgICAgdGhpcy5zdGF0c18gPSBTdGF0c01hbmFnZXJfMS5TdGF0c01hbmFnZXIuZ2V0Q29sbGVjdGlvbihyZXBvSW5mb18pO1xuICAgICAgICBpZiAoZm9yY2VSZXN0Q2xpZW50IHx8IHV0aWxfMi5iZWluZ0NyYXdsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJfID0gbmV3IFJlYWRvbmx5UmVzdENsaWVudF8xLlJlYWRvbmx5UmVzdENsaWVudCh0aGlzLnJlcG9JbmZvXywgdGhpcy5vbkRhdGFVcGRhdGVfLmJpbmQodGhpcyksIGF1dGhUb2tlblByb3ZpZGVyKTtcbiAgICAgICAgICAgIC8vIE1pbm9yIGhhY2s6IEZpcmUgb25Db25uZWN0IGltbWVkaWF0ZWx5LCBzaW5jZSB0aGVyZSdzIG5vIGFjdHVhbCBjb25uZWN0aW9uLlxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLm9uQ29ubmVjdFN0YXR1c18uYmluZCh0aGlzLCB0cnVlKSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXV0aE92ZXJyaWRlID0gYXBwLm9wdGlvbnNbJ2RhdGFiYXNlQXV0aFZhcmlhYmxlT3ZlcnJpZGUnXTtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIGF1dGhPdmVycmlkZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdXRoT3ZlcnJpZGUgIT09ICd1bmRlZmluZWQnICYmIGF1dGhPdmVycmlkZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXV0aE92ZXJyaWRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb2JqZWN0cyBhcmUgc3VwcG9ydGVkIGZvciBvcHRpb24gZGF0YWJhc2VBdXRoVmFyaWFibGVPdmVycmlkZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuc3RyaW5naWZ5KGF1dGhPdmVycmlkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhdXRoT3ZlcnJpZGUgcHJvdmlkZWQ6ICcgKyBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXyA9IG5ldyBQZXJzaXN0ZW50Q29ubmVjdGlvbl8xLlBlcnNpc3RlbnRDb25uZWN0aW9uKHRoaXMucmVwb0luZm9fLCB0aGlzLm9uRGF0YVVwZGF0ZV8uYmluZCh0aGlzKSwgdGhpcy5vbkNvbm5lY3RTdGF0dXNfLmJpbmQodGhpcyksIHRoaXMub25TZXJ2ZXJJbmZvVXBkYXRlXy5iaW5kKHRoaXMpLCBhdXRoVG9rZW5Qcm92aWRlciwgYXV0aE92ZXJyaWRlKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyXyA9IHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fO1xuICAgICAgICB9XG4gICAgICAgIGF1dGhUb2tlblByb3ZpZGVyLmFkZFRva2VuQ2hhbmdlTGlzdGVuZXIoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXJ2ZXJfLnJlZnJlc2hBdXRoVG9rZW4odG9rZW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgbXVsdGlwbGUgUmVwb3MgZm9yIHRoZSBzYW1lIHJlcG9JbmZvIChpLmUuIHRoZXJlIGFyZSBtdWx0aXBsZSBGaXJlYmFzZS5Db250ZXh0cyBiZWluZyB1c2VkKSxcbiAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIGNyZWF0ZSBvbmUgU3RhdHNSZXBvcnRlci4gIEFzIHN1Y2gsIHdlJ2xsIHJlcG9ydCBzdGF0cyBvdmVyIHRoZSBmaXJzdCBSZXBvIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuc3RhdHNSZXBvcnRlcl8gPSBTdGF0c01hbmFnZXJfMS5TdGF0c01hbmFnZXIuZ2V0T3JDcmVhdGVSZXBvcnRlcihyZXBvSW5mb18sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBTdGF0c1JlcG9ydGVyXzEuU3RhdHNSZXBvcnRlcihfdGhpcy5zdGF0c18sIF90aGlzLnNlcnZlcl8pOyB9KTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnNfaW5pdF8oKTtcbiAgICAgICAgLy8gVXNlZCBmb3IgLmluZm8uXG4gICAgICAgIHRoaXMuaW5mb0RhdGFfID0gbmV3IFNuYXBzaG90SG9sZGVyXzEuU25hcHNob3RIb2xkZXIoKTtcbiAgICAgICAgdGhpcy5pbmZvU3luY1RyZWVfID0gbmV3IFN5bmNUcmVlXzEuU3luY1RyZWUoe1xuICAgICAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IGZ1bmN0aW9uIChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm9FdmVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzLmluZm9EYXRhXy5nZXROb2RlKHF1ZXJ5LnBhdGgpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcG9zc2libHkgYSBoYWNrLCBidXQgd2UgaGF2ZSBkaWZmZXJlbnQgc2VtYW50aWNzIGZvciAuaW5mbyBlbmRwb2ludHMuIFdlIGRvbid0IHJhaXNlIG51bGwgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8gb24gaW5pdGlhbCBkYXRhLi4uXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvRXZlbnRzID0gX3RoaXMuaW5mb1N5bmNUcmVlXy5hcHBseVNlcnZlck92ZXJ3cml0ZShxdWVyeS5wYXRoLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKCdvaycpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZm9FdmVudHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcExpc3RlbmluZzogZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZUluZm9fKCdjb25uZWN0ZWQnLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2VydmVyU3luY1RyZWVfID0gbmV3IFN5bmNUcmVlXzEuU3luY1RyZWUoe1xuICAgICAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IGZ1bmN0aW9uIChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VydmVyXy5saXN0ZW4ocXVlcnksIGN1cnJlbnRIYXNoRm4sIHRhZywgZnVuY3Rpb24gKHN0YXR1cywgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gb25Db21wbGV0ZShzdGF0dXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHF1ZXJ5LnBhdGgsIGV2ZW50cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gTm8gc3luY2hyb25vdXMgZXZlbnRzIGZvciBuZXR3b3JrLWJhY2tlZCBzeW5jIHRyZWVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3BMaXN0ZW5pbmc6IGZ1bmN0aW9uIChxdWVyeSwgdGFnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VydmVyXy51bmxpc3RlbihxdWVyeSwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gIFRoZSBVUkwgY29ycmVzcG9uZGluZyB0byB0aGUgcm9vdCBvZiB0aGlzIEZpcmViYXNlLlxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLnJlcG9JbmZvXy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArIHRoaXMucmVwb0luZm9fLmhvc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IXN0cmluZ30gVGhlIG5hbWVzcGFjZSByZXByZXNlbnRlZCBieSB0aGUgcmVwby5cbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBvSW5mb18ubmFtZXNwYWNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IW51bWJlcn0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzLCB0YWtpbmcgdGhlIHNlcnZlciBvZmZzZXQgaW50byBhY2NvdW50IGlmIHdlIGhhdmUgb25lLlxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLnNlcnZlclRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvZmZzZXROb2RlID0gdGhpcy5pbmZvRGF0YV8uZ2V0Tm9kZShuZXcgUGF0aF8xLlBhdGgoJy5pbmZvL3NlcnZlclRpbWVPZmZzZXQnKSk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXROb2RlLnZhbCgpIHx8IDA7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIG9mZnNldDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIFNlcnZlclZhbHVlcyB1c2luZyBzb21lIHZhcmlhYmxlcyBmcm9tIHRoZSByZXBvIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLmdlbmVyYXRlU2VydmVyVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU2VydmVyVmFsdWVzXzEuZ2VuZXJhdGVXaXRoVmFsdWVzKHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGhpcy5zZXJ2ZXJUaW1lKClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkgcmVhbHRpbWUgd2hlbiB3ZSBnZXQgbmV3IG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTWVyZ2VcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IHRhZ1xuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLm9uRGF0YVVwZGF0ZV8gPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKSB7XG4gICAgICAgIC8vIEZvciB0ZXN0aW5nLlxuICAgICAgICB0aGlzLmRhdGFVcGRhdGVDb3VudCsrO1xuICAgICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoXzEuUGF0aChwYXRoU3RyaW5nKTtcbiAgICAgICAgZGF0YSA9IHRoaXMuaW50ZXJjZXB0U2VydmVyRGF0YUNhbGxiYWNrX1xuICAgICAgICAgICAgPyB0aGlzLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18ocGF0aFN0cmluZywgZGF0YSlcbiAgICAgICAgICAgIDogZGF0YTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBpZiAoaXNNZXJnZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YWdnZWRDaGlsZHJlbiA9IHV0aWxfMy5tYXAoZGF0YSwgZnVuY3Rpb24gKHJhdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZUZyb21KU09OXzEubm9kZUZyb21KU09OKHJhdyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYXBwbHlUYWdnZWRRdWVyeU1lcmdlKHBhdGgsIHRhZ2dlZENoaWxkcmVuLCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZ2dlZFNuYXAgPSBub2RlRnJvbUpTT05fMS5ub2RlRnJvbUpTT04oZGF0YSk7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShwYXRoLCB0YWdnZWRTbmFwLCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTWVyZ2UpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkQ2hpbGRyZW4gPSB1dGlsXzMubWFwKGRhdGEsIGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZUZyb21KU09OXzEubm9kZUZyb21KU09OKHJhdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5U2VydmVyTWVyZ2UocGF0aCwgY2hhbmdlZENoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzbmFwID0gbm9kZUZyb21KU09OXzEubm9kZUZyb21KU09OKGRhdGEpO1xuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYXBwbHlTZXJ2ZXJPdmVyd3JpdGUocGF0aCwgc25hcCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFmZmVjdGVkUGF0aCA9IHBhdGg7XG4gICAgICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBhIGxpc3RlbmVyIG91dHN0YW5kaW5nIGZvciBlYWNoIHRyYW5zYWN0aW9uLCByZWNlaXZpbmcgYW55IGV2ZW50c1xuICAgICAgICAgICAgLy8gaXMgYSBwcm94eSBmb3Igc29tZSBjaGFuZ2UgaGF2aW5nIG9jY3VycmVkLlxuICAgICAgICAgICAgYWZmZWN0ZWRQYXRoID0gdGhpcy5yZXJ1blRyYW5zYWN0aW9uc18ocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKGFmZmVjdGVkUGF0aCwgZXZlbnRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRPRE86IFRoaXMgc2hvdWxkIGJlIEBwcml2YXRlIGJ1dCBpdCdzIHVzZWQgYnkgdGVzdF9hY2Nlc3MuanMgYW5kIGludGVybmFsLmpzXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oIXN0cmluZywgKik6Kn0gY2FsbGJhY2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLmludGVyY2VwdFNlcnZlckRhdGFfID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0U2VydmVyRGF0YUNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshYm9vbGVhbn0gY29ubmVjdFN0YXR1c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUub25Db25uZWN0U3RhdHVzXyA9IGZ1bmN0aW9uIChjb25uZWN0U3RhdHVzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSW5mb18oJ2Nvbm5lY3RlZCcsIGNvbm5lY3RTdGF0dXMpO1xuICAgICAgICBpZiAoY29ubmVjdFN0YXR1cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMucnVuT25EaXNjb25uZWN0RXZlbnRzXygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IHVwZGF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLm9uU2VydmVySW5mb1VwZGF0ZV8gPSBmdW5jdGlvbiAodXBkYXRlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsXzIuZWFjaCh1cGRhdGVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlSW5mb18oa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS51cGRhdGVJbmZvXyA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoXzEuUGF0aCgnLy5pbmZvLycgKyBwYXRoU3RyaW5nKTtcbiAgICAgICAgdmFyIG5ld05vZGUgPSBub2RlRnJvbUpTT05fMS5ub2RlRnJvbUpTT04odmFsdWUpO1xuICAgICAgICB0aGlzLmluZm9EYXRhXy51cGRhdGVTbmFwc2hvdChwYXRoLCBuZXdOb2RlKTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuaW5mb1N5bmNUcmVlXy5hcHBseVNlcnZlck92ZXJ3cml0ZShwYXRoLCBuZXdOb2RlKTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIGV2ZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshbnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUuZ2V0TmV4dFdyaXRlSWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0V3JpdGVJZF8rKztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyp9IG5ld1ZhbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfSBuZXdQcmlvcml0eVxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgKj0pfSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUuc2V0V2l0aFByaW9yaXR5ID0gZnVuY3Rpb24gKHBhdGgsIG5ld1ZhbCwgbmV3UHJpb3JpdHksIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5sb2dfKCdzZXQnLCB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsLFxuICAgICAgICAgICAgcHJpb3JpdHk6IG5ld1ByaW9yaXR5XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPOiBPcHRpbWl6ZSB0aGlzIGJlaGF2aW9yIHRvIGVpdGhlciAoYSkgc3RvcmUgZmxhZyB0byBza2lwIHJlc29sdmluZyB3aGVyZSBwb3NzaWJsZSBhbmQgLyBvclxuICAgICAgICAvLyAoYikgc3RvcmUgdW5yZXNvbHZlZCBwYXRocyBvbiBKU09OIHBhcnNlXG4gICAgICAgIHZhciBzZXJ2ZXJWYWx1ZXMgPSB0aGlzLmdlbmVyYXRlU2VydmVyVmFsdWVzKCk7XG4gICAgICAgIHZhciBuZXdOb2RlVW5yZXNvbHZlZCA9IG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihuZXdWYWwsIG5ld1ByaW9yaXR5KTtcbiAgICAgICAgdmFyIG5ld05vZGUgPSBTZXJ2ZXJWYWx1ZXNfMS5yZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KG5ld05vZGVVbnJlc29sdmVkLCBzZXJ2ZXJWYWx1ZXMpO1xuICAgICAgICB2YXIgd3JpdGVJZCA9IHRoaXMuZ2V0TmV4dFdyaXRlSWRfKCk7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVVzZXJPdmVyd3JpdGUocGF0aCwgbmV3Tm9kZSwgd3JpdGVJZCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJfLnB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGVVbnJlc29sdmVkLnZhbCgvKmV4cG9ydD0qLyB0cnVlKSwgZnVuY3Rpb24gKHN0YXR1cywgZXJyb3JSZWFzb24pIHtcbiAgICAgICAgICAgIHZhciBzdWNjZXNzID0gc3RhdHVzID09PSAnb2snO1xuICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8yLndhcm4oJ3NldCBhdCAnICsgcGF0aCArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbGVhckV2ZW50cyA9IF90aGlzLnNlcnZlclN5bmNUcmVlXy5hY2tVc2VyV3JpdGUod3JpdGVJZCwgIXN1Y2Nlc3MpO1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChwYXRoLCBjbGVhckV2ZW50cyk7XG4gICAgICAgICAgICBfdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGFmZmVjdGVkUGF0aCA9IHRoaXMuYWJvcnRUcmFuc2FjdGlvbnNfKHBhdGgpO1xuICAgICAgICB0aGlzLnJlcnVuVHJhbnNhY3Rpb25zXyhhZmZlY3RlZFBhdGgpO1xuICAgICAgICAvLyBXZSBxdWV1ZWQgdGhlIGV2ZW50cyBhYm92ZSwgc28ganVzdCBmbHVzaCB0aGUgcXVldWUgaGVyZVxuICAgICAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgoYWZmZWN0ZWRQYXRoLCBbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBjaGlsZHJlblRvTWVyZ2VcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbig/RXJyb3IsICo9KX0gb25Db21wbGV0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChwYXRoLCBjaGlsZHJlblRvTWVyZ2UsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5sb2dfKCd1cGRhdGUnLCB7IHBhdGg6IHBhdGgudG9TdHJpbmcoKSwgdmFsdWU6IGNoaWxkcmVuVG9NZXJnZSB9KTtcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBvdXIgZXhpc3RpbmcgZGF0YSBhbmQgbWVyZ2UgZWFjaCBjaGlsZCBpbnRvIGl0LlxuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICB2YXIgc2VydmVyVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVNlcnZlclZhbHVlcygpO1xuICAgICAgICB2YXIgY2hhbmdlZENoaWxkcmVuID0ge307XG4gICAgICAgIHV0aWxfMy5mb3JFYWNoKGNoaWxkcmVuVG9NZXJnZSwgZnVuY3Rpb24gKGNoYW5nZWRLZXksIGNoYW5nZWRWYWx1ZSkge1xuICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlVW5yZXNvbHZlZCA9IG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihjaGFuZ2VkVmFsdWUpO1xuICAgICAgICAgICAgY2hhbmdlZENoaWxkcmVuW2NoYW5nZWRLZXldID0gU2VydmVyVmFsdWVzXzEucmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdOb2RlVW5yZXNvbHZlZCwgc2VydmVyVmFsdWVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZW1wdHkpIHtcbiAgICAgICAgICAgIHZhciB3cml0ZUlkXzEgPSB0aGlzLmdldE5leHRXcml0ZUlkXygpO1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5VXNlck1lcmdlKHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVJZF8xKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyXy5tZXJnZShwYXRoLnRvU3RyaW5nKCksIGNoaWxkcmVuVG9NZXJnZSwgZnVuY3Rpb24gKHN0YXR1cywgZXJyb3JSZWFzb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VjY2VzcyA9IHN0YXR1cyA9PT0gJ29rJztcbiAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8yLndhcm4oJ3VwZGF0ZSBhdCAnICsgcGF0aCArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNsZWFyRXZlbnRzID0gX3RoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZSh3cml0ZUlkXzEsICFzdWNjZXNzKTtcbiAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRQYXRoID0gY2xlYXJFdmVudHMubGVuZ3RoID4gMCA/IF90aGlzLnJlcnVuVHJhbnNhY3Rpb25zXyhwYXRoKSA6IHBhdGg7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChhZmZlY3RlZFBhdGgsIGNsZWFyRXZlbnRzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1dGlsXzMuZm9yRWFjaChjaGlsZHJlblRvTWVyZ2UsIGZ1bmN0aW9uIChjaGFuZ2VkUGF0aCkge1xuICAgICAgICAgICAgICAgIHZhciBhZmZlY3RlZFBhdGggPSBfdGhpcy5hYm9ydFRyYW5zYWN0aW9uc18ocGF0aC5jaGlsZChjaGFuZ2VkUGF0aCkpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcnVuVHJhbnNhY3Rpb25zXyhhZmZlY3RlZFBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBXZSBxdWV1ZWQgdGhlIGV2ZW50cyBhYm92ZSwgc28ganVzdCBmbHVzaCB0aGUgcXVldWUgaGVyZVxuICAgICAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxfMi5sb2coXCJ1cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpO1xuICAgICAgICAgICAgdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsICdvaycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCBvZiB0aGUgY2hhbmdlcyBzdG9yZWQgdXAgaW4gdGhlIG9uRGlzY29ubmVjdF8gdHJlZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLnJ1bk9uRGlzY29ubmVjdEV2ZW50c18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubG9nXygnb25EaXNjb25uZWN0RXZlbnRzJyk7XG4gICAgICAgIHZhciBzZXJ2ZXJWYWx1ZXMgPSB0aGlzLmdlbmVyYXRlU2VydmVyVmFsdWVzKCk7XG4gICAgICAgIHZhciByZXNvbHZlZE9uRGlzY29ubmVjdFRyZWUgPSBTZXJ2ZXJWYWx1ZXNfMS5yZXNvbHZlRGVmZXJyZWRWYWx1ZVRyZWUodGhpcy5vbkRpc2Nvbm5lY3RfLCBzZXJ2ZXJWYWx1ZXMpO1xuICAgICAgICB2YXIgZXZlbnRzID0gW107XG4gICAgICAgIHJlc29sdmVkT25EaXNjb25uZWN0VHJlZS5mb3JFYWNoVHJlZShQYXRoXzEuUGF0aC5FbXB0eSwgZnVuY3Rpb24gKHBhdGgsIHNuYXApIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoX3RoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5U2VydmVyT3ZlcndyaXRlKHBhdGgsIHNuYXApKTtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZFBhdGggPSBfdGhpcy5hYm9ydFRyYW5zYWN0aW9uc18ocGF0aCk7XG4gICAgICAgICAgICBfdGhpcy5yZXJ1blRyYW5zYWN0aW9uc18oYWZmZWN0ZWRQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG5ldyBTcGFyc2VTbmFwc2hvdFRyZWVfMS5TcGFyc2VTbmFwc2hvdFRyZWUoKTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKFBhdGhfMS5QYXRoLkVtcHR5LCBldmVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgKj0pfSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUub25EaXNjb25uZWN0Q2FuY2VsID0gZnVuY3Rpb24gKHBhdGgsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zZXJ2ZXJfLm9uRGlzY29ubmVjdENhbmNlbChwYXRoLnRvU3RyaW5nKCksIGZ1bmN0aW9uIChzdGF0dXMsIGVycm9yUmVhc29uKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25EaXNjb25uZWN0Xy5mb3JnZXQocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP0Vycm9yLCAqPSl9IG9uQ29tcGxldGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3RTZXQgPSBmdW5jdGlvbiAocGF0aCwgdmFsdWUsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5ld05vZGUgPSBub2RlRnJvbUpTT05fMS5ub2RlRnJvbUpTT04odmFsdWUpO1xuICAgICAgICB0aGlzLnNlcnZlcl8ub25EaXNjb25uZWN0UHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZS52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIGZ1bmN0aW9uIChzdGF0dXMsIGVycm9yUmVhc29uKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25EaXNjb25uZWN0Xy5yZW1lbWJlcihwYXRoLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNhbGxPbkNvbXBsZXRlQ2FsbGJhY2sob25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IHByaW9yaXR5XG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP0Vycm9yLCAqPSl9IG9uQ29tcGxldGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3RTZXRXaXRoUHJpb3JpdHkgPSBmdW5jdGlvbiAocGF0aCwgdmFsdWUsIHByaW9yaXR5LCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuZXdOb2RlID0gbm9kZUZyb21KU09OXzEubm9kZUZyb21KU09OKHZhbHVlLCBwcmlvcml0eSk7XG4gICAgICAgIHRoaXMuc2VydmVyXy5vbkRpc2Nvbm5lY3RQdXQocGF0aC50b1N0cmluZygpLCBuZXdOb2RlLnZhbCgvKmV4cG9ydD0qLyB0cnVlKSwgZnVuY3Rpb24gKHN0YXR1cywgZXJyb3JSZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkRpc2Nvbm5lY3RfLnJlbWVtYmVyKHBhdGgsIG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY2FsbE9uQ29tcGxldGVDYWxsYmFjayhvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHsqfSBjaGlsZHJlblRvTWVyZ2VcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbig/RXJyb3IsICo9KX0gb25Db21wbGV0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLm9uRGlzY29ubmVjdFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXRoLCBjaGlsZHJlblRvTWVyZ2UsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHV0aWxfMy5pc0VtcHR5KGNoaWxkcmVuVG9NZXJnZSkpIHtcbiAgICAgICAgICAgIHV0aWxfMi5sb2coXCJvbkRpc2Nvbm5lY3QoKS51cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpO1xuICAgICAgICAgICAgdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsICdvaycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VydmVyXy5vbkRpc2Nvbm5lY3RNZXJnZShwYXRoLnRvU3RyaW5nKCksIGNoaWxkcmVuVG9NZXJnZSwgZnVuY3Rpb24gKHN0YXR1cywgZXJyb3JSZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzMuZm9yRWFjaChjaGlsZHJlblRvTWVyZ2UsIGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGROb2RlID0gbm9kZUZyb21KU09OXzEubm9kZUZyb21KU09OKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRGlzY29ubmVjdF8ucmVtZW1iZXIocGF0aC5jaGlsZChjaGlsZE5hbWUpLCBuZXdDaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY2FsbE9uQ29tcGxldGVDYWxsYmFjayhvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcGFyYW0geyFFdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5hZGRFdmVudENhbGxiYWNrRm9yUXVlcnkgPSBmdW5jdGlvbiAocXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHZhciBldmVudHM7XG4gICAgICAgIGlmIChxdWVyeS5wYXRoLmdldEZyb250KCkgPT09ICcuaW5mbycpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuaW5mb1N5bmNUcmVlXy5hZGRFdmVudFJlZ2lzdHJhdGlvbihxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYWRkRXZlbnRSZWdpc3RyYXRpb24ocXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzQXRQYXRoKHF1ZXJ5LnBhdGgsIGV2ZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcGFyYW0gez9FdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5yZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkgPSBmdW5jdGlvbiAocXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIC8vIFRoZXNlIGFyZSBndWFyYW50ZWVkIG5vdCB0byByYWlzZSBldmVudHMsIHNpbmNlIHdlJ3JlIG5vdCBwYXNzaW5nIGluIGEgY2FuY2VsRXJyb3IuIEhvd2V2ZXIsIHdlIGNhbiBmdXR1cmUtcHJvb2ZcbiAgICAgICAgLy8gYSBsaXR0bGUgYml0IGJ5IGhhbmRsaW5nIHRoZSByZXR1cm4gdmFsdWVzIGFueXdheXMuXG4gICAgICAgIHZhciBldmVudHM7XG4gICAgICAgIGlmIChxdWVyeS5wYXRoLmdldEZyb250KCkgPT09ICcuaW5mbycpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuaW5mb1N5bmNUcmVlXy5yZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8ucmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24ocXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzQXRQYXRoKHF1ZXJ5LnBhdGgsIGV2ZW50cyk7XG4gICAgfTtcbiAgICBSZXBvLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXykge1xuICAgICAgICAgICAgdGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaW50ZXJydXB0KElOVEVSUlVQVF9SRUFTT04pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXBvLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXykge1xuICAgICAgICAgICAgdGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8ucmVzdW1lKElOVEVSUlVQVF9SRUFTT04pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXBvLnByb3RvdHlwZS5zdGF0cyA9IGZ1bmN0aW9uIChzaG93RGVsdGEpIHtcbiAgICAgICAgaWYgKHNob3dEZWx0YSA9PT0gdm9pZCAwKSB7IHNob3dEZWx0YSA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBzdGF0cztcbiAgICAgICAgaWYgKHNob3dEZWx0YSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRzTGlzdGVuZXJfKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHNMaXN0ZW5lcl8gPSBuZXcgU3RhdHNMaXN0ZW5lcl8xLlN0YXRzTGlzdGVuZXIodGhpcy5zdGF0c18pO1xuICAgICAgICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzTGlzdGVuZXJfLmdldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzXy5nZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9uZ2VzdE5hbWUgPSBPYmplY3Qua2V5cyhzdGF0cykucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChjdXJyZW50VmFsdWUubGVuZ3RoLCBwcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHV0aWxfMy5mb3JFYWNoKHN0YXRzLCBmdW5jdGlvbiAoc3RhdCwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHBhZCBzdGF0IG5hbWVzIHRvIGJlIHRoZSBzYW1lIGxlbmd0aCAocGx1cyAyIGV4dHJhIHNwYWNlcykuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhdC5sZW5ndGg7IGkgPCBsb25nZXN0TmFtZSArIDI7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ICs9ICcgJztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXQgKyB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVwby5wcm90b3R5cGUuc3RhdHNJbmNyZW1lbnRDb3VudGVyID0gZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKG1ldHJpYyk7XG4gICAgICAgIHRoaXMuc3RhdHNSZXBvcnRlcl8uaW5jbHVkZVN0YXQobWV0cmljKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLmxvZ18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZml4ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXykge1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaWQgKyAnOic7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbF8yLmxvZy5hcHBseSh2b2lkIDAsIFtwcmVmaXhdLmNvbmNhdCh2YXJfYXJncykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP0Vycm9yLCAqPSl9IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBzdGF0dXNcbiAgICAgKiBAcGFyYW0gez9zdHJpbmc9fSBlcnJvclJlYXNvblxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLmNhbGxPbkNvbXBsZXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHN0YXR1cywgZXJyb3JSZWFzb24pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB1dGlsXzIuZXhjZXB0aW9uR3VhcmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT0gJ29rJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0gKHN0YXR1cyB8fCAnZXJyb3InKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvclJlYXNvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJzogJyArIGVycm9yUmVhc29uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXBvLnByb3RvdHlwZSwgXCJkYXRhYmFzZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhYmFzZSB8fCAodGhpcy5fX2RhdGFiYXNlID0gbmV3IERhdGFiYXNlXzEuRGF0YWJhc2UodGhpcykpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUmVwbztcbn0oKSk7XG5leHBvcnRzLlJlcG8gPSBSZXBvO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXBvLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgc3RvcmFnZV8xID0gcmVxdWlyZShcIi4vc3RvcmFnZS9zdG9yYWdlXCIpO1xudmFyIENvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL3JlYWx0aW1lL0NvbnN0YW50c1wiKTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGhvbGRzIG1ldGFkYXRhIGFib3V0IGEgUmVwbyBvYmplY3RcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJlcG9JbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBob3N0IEhvc3RuYW1lIHBvcnRpb24gb2YgdGhlIHVybCBmb3IgdGhlIHJlcG9cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlY3VyZSBXaGV0aGVyIG9yIG5vdCB0aGlzIHJlcG8gaXMgYWNjZXNzZWQgb3ZlciBzc2xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2UgcmVwcmVzZW50ZWQgYnkgdGhlIHJlcG9cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdlYlNvY2tldE9ubHkgV2hldGhlciB0byBwcmVmZXIgd2Vic29ja2V0cyBvdmVyIGFsbCBvdGhlciB0cmFuc3BvcnRzICh1c2VkIGJ5IE5lc3QpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gcGVyc2lzdGVuY2VLZXkgT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2Vzc2lvbiBwZXJzaXN0ZW5jZSBzdG9yYWdlIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlcG9JbmZvKGhvc3QsIHNlY3VyZSwgbmFtZXNwYWNlLCB3ZWJTb2NrZXRPbmx5LCBwZXJzaXN0ZW5jZUtleSkge1xuICAgICAgICBpZiAocGVyc2lzdGVuY2VLZXkgPT09IHZvaWQgMCkgeyBwZXJzaXN0ZW5jZUtleSA9ICcnOyB9XG4gICAgICAgIHRoaXMuc2VjdXJlID0gc2VjdXJlO1xuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRPbmx5ID0gd2ViU29ja2V0T25seTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuZG9tYWluID0gdGhpcy5ob3N0LnN1YnN0cih0aGlzLmhvc3QuaW5kZXhPZignLicpICsgMSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxIb3N0ID0gc3RvcmFnZV8xLlBlcnNpc3RlbnRTdG9yYWdlLmdldCgnaG9zdDonICsgaG9zdCkgfHwgdGhpcy5ob3N0O1xuICAgIH1cbiAgICBSZXBvSW5mby5wcm90b3R5cGUubmVlZHNRdWVyeVBhcmFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0ICE9PSB0aGlzLmludGVybmFsSG9zdDtcbiAgICB9O1xuICAgIFJlcG9JbmZvLnByb3RvdHlwZS5pc0NhY2hlYWJsZUhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsSG9zdC5zdWJzdHIoMCwgMikgPT09ICdzLSc7XG4gICAgfTtcbiAgICBSZXBvSW5mby5wcm90b3R5cGUuaXNEZW1vSG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tYWluID09PSAnZmlyZWJhc2Vpby1kZW1vLmNvbSc7XG4gICAgfTtcbiAgICBSZXBvSW5mby5wcm90b3R5cGUuaXNDdXN0b21Ib3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZG9tYWluICE9PSAnZmlyZWJhc2Vpby5jb20nICYmIHRoaXMuZG9tYWluICE9PSAnZmlyZWJhc2Vpby1kZW1vLmNvbScpO1xuICAgIH07XG4gICAgUmVwb0luZm8ucHJvdG90eXBlLnVwZGF0ZUhvc3QgPSBmdW5jdGlvbiAobmV3SG9zdCkge1xuICAgICAgICBpZiAobmV3SG9zdCAhPT0gdGhpcy5pbnRlcm5hbEhvc3QpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxIb3N0ID0gbmV3SG9zdDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZV8xLlBlcnNpc3RlbnRTdG9yYWdlLnNldCgnaG9zdDonICsgdGhpcy5ob3N0LCB0aGlzLmludGVybmFsSG9zdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdlYnNvY2tldCBVUkwgZm9yIHRoaXMgcmVwb1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIG9mIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIGxpc3RcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwgZm9yIHRoaXMgcmVwb1xuICAgICAqL1xuICAgIFJlcG9JbmZvLnByb3RvdHlwZS5jb25uZWN0aW9uVVJMID0gZnVuY3Rpb24gKHR5cGUsIHBhcmFtcykge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgJ3R5cGVvZiB0eXBlIG11c3QgPT0gc3RyaW5nJyk7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcsICd0eXBlb2YgcGFyYW1zIG11c3QgPT0gb2JqZWN0Jyk7XG4gICAgICAgIHZhciBjb25uVVJMO1xuICAgICAgICBpZiAodHlwZSA9PT0gQ29uc3RhbnRzXzEuV0VCU09DS0VUKSB7XG4gICAgICAgICAgICBjb25uVVJMID1cbiAgICAgICAgICAgICAgICAodGhpcy5zZWN1cmUgPyAnd3NzOi8vJyA6ICd3czovLycpICsgdGhpcy5pbnRlcm5hbEhvc3QgKyAnLy53cz8nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IENvbnN0YW50c18xLkxPTkdfUE9MTElORykge1xuICAgICAgICAgICAgY29ublVSTCA9XG4gICAgICAgICAgICAgICAgKHRoaXMuc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgKyB0aGlzLmludGVybmFsSG9zdCArICcvLmxwPyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29ubmVjdGlvbiB0eXBlOiAnICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmVlZHNRdWVyeVBhcmFtKCkpIHtcbiAgICAgICAgICAgIHBhcmFtc1snbnMnXSA9IHRoaXMubmFtZXNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgICB1dGlsXzIuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBwYWlycy5wdXNoKGtleSArICc9JyArIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb25uVVJMICsgcGFpcnMuam9pbignJicpO1xuICAgIH07XG4gICAgLyoqIEByZXR1cm4ge3N0cmluZ30gKi9cbiAgICBSZXBvSW5mby5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzLnRvVVJMU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlS2V5KSB7XG4gICAgICAgICAgICBzdHIgKz0gJzwnICsgdGhpcy5wZXJzaXN0ZW5jZUtleSArICc+JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgLyoqIEByZXR1cm4ge3N0cmluZ30gKi9cbiAgICBSZXBvSW5mby5wcm90b3R5cGUudG9VUkxTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArIHRoaXMuaG9zdDtcbiAgICB9O1xuICAgIHJldHVybiBSZXBvSW5mbztcbn0oKSk7XG5leHBvcnRzLlJlcG9JbmZvID0gUmVwb0luZm87XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcG9JbmZvLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBSZXBvXzEgPSByZXF1aXJlKFwiLi9SZXBvXCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuL3V0aWwvdXRpbFwiKTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWwvbGlicy9wYXJzZXJcIik7XG52YXIgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdXRpbC92YWxpZGF0aW9uXCIpO1xucmVxdWlyZShcIi4vUmVwb190cmFuc2FjdGlvblwiKTtcbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbnZhciBEQVRBQkFTRV9VUkxfT1BUSU9OID0gJ2RhdGFiYXNlVVJMJztcbnZhciBfc3RhdGljSW5zdGFuY2U7XG4vKipcbiAqIENyZWF0ZXMgYW5kIGNhY2hlcyBSZXBvIGluc3RhbmNlcy5cbiAqL1xudmFyIFJlcG9NYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcG9NYW5hZ2VyKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGUgeyFPYmplY3QuPHN0cmluZywgT2JqZWN0PHN0cmluZywgIWZiLmNvcmUuUmVwbz4+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXBvc18gPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIG5ldyBSZXBvcyB3aWxsIGJlIGNyZWF0ZWQgdG8gdXNlIFJlYWRvbmx5UmVzdENsaWVudCAoZm9yIHRlc3RpbmcgcHVycG9zZXMpLlxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlUmVzdENsaWVudF8gPSBmYWxzZTtcbiAgICB9XG4gICAgUmVwb01hbmFnZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghX3N0YXRpY0luc3RhbmNlKSB7XG4gICAgICAgICAgICBfc3RhdGljSW5zdGFuY2UgPSBuZXcgUmVwb01hbmFnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N0YXRpY0luc3RhbmNlO1xuICAgIH07XG4gICAgLy8gVE9ETyhrb3NzKTogUmVtb3ZlIHRoZXNlIGZ1bmN0aW9ucyB1bmxlc3MgdXNlZCBpbiB0ZXN0cz9cbiAgICBSZXBvTWFuYWdlci5wcm90b3R5cGUuaW50ZXJydXB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBhcHBOYW1lIGluIHRoaXMucmVwb3NfKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkYlVybCBpbiB0aGlzLnJlcG9zX1thcHBOYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3NfW2FwcE5hbWVdW2RiVXJsXS5pbnRlcnJ1cHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVwb01hbmFnZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgYXBwTmFtZSBpbiB0aGlzLnJlcG9zXykge1xuICAgICAgICAgICAgZm9yICh2YXIgZGJVcmwgaW4gdGhpcy5yZXBvc19bYXBwTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9zX1thcHBOYW1lXVtkYlVybF0ucmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgZXZlciBiZSBjYWxsZWQgdG8gQ1JFQVRFIGEgbmV3IGRhdGFiYXNlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshRmlyZWJhc2VBcHB9IGFwcFxuICAgICAqIEByZXR1cm4geyFEYXRhYmFzZX1cbiAgICAgKi9cbiAgICBSZXBvTWFuYWdlci5wcm90b3R5cGUuZGF0YWJhc2VGcm9tQXBwID0gZnVuY3Rpb24gKGFwcCwgdXJsKSB7XG4gICAgICAgIHZhciBkYlVybCA9IHVybCB8fCBhcHAub3B0aW9uc1tEQVRBQkFTRV9VUkxfT1BUSU9OXTtcbiAgICAgICAgaWYgKGRiVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHV0aWxfMi5mYXRhbChcIkNhbid0IGRldGVybWluZSBGaXJlYmFzZSBEYXRhYmFzZSBVUkwuICBCZSBzdXJlIHRvIGluY2x1ZGUgXCIgK1xuICAgICAgICAgICAgICAgIERBVEFCQVNFX1VSTF9PUFRJT04gK1xuICAgICAgICAgICAgICAgICcgb3B0aW9uIHdoZW4gY2FsbGluZyBmaXJlYmFzZS5pbnRpYWxpemVBcHAoKS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyc2VkVXJsID0gcGFyc2VyXzEucGFyc2VSZXBvSW5mbyhkYlVybCk7XG4gICAgICAgIHZhciByZXBvSW5mbyA9IHBhcnNlZFVybC5yZXBvSW5mbztcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlVXJsKCdJbnZhbGlkIEZpcmViYXNlIERhdGFiYXNlIFVSTCcsIDEsIHBhcnNlZFVybCk7XG4gICAgICAgIGlmICghcGFyc2VkVXJsLnBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB1dGlsXzIuZmF0YWwoJ0RhdGFiYXNlIFVSTCBtdXN0IHBvaW50IHRvIHRoZSByb290IG9mIGEgRmlyZWJhc2UgRGF0YWJhc2UgJyArXG4gICAgICAgICAgICAgICAgJyhub3QgaW5jbHVkaW5nIGEgY2hpbGQgcGF0aCkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcG8gPSB0aGlzLmNyZWF0ZVJlcG8ocmVwb0luZm8sIGFwcCk7XG4gICAgICAgIHJldHVybiByZXBvLmRhdGFiYXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSByZXBvIGFuZCBtYWtlIHN1cmUgaXQgaXMgZGlzY29ubmVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUmVwb30gcmVwb1xuICAgICAqL1xuICAgIFJlcG9NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVSZXBvID0gZnVuY3Rpb24gKHJlcG8pIHtcbiAgICAgICAgdmFyIGFwcFJlcG9zID0gdXRpbF8xLnNhZmVHZXQodGhpcy5yZXBvc18sIHJlcG8uYXBwLm5hbWUpO1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uLi5cbiAgICAgICAgaWYgKCFhcHBSZXBvcyB8fCB1dGlsXzEuc2FmZUdldChhcHBSZXBvcywgcmVwby5yZXBvSW5mb18udG9VUkxTdHJpbmcoKSkgIT09IHJlcG8pIHtcbiAgICAgICAgICAgIHV0aWxfMi5mYXRhbChcIkRhdGFiYXNlIFwiICsgcmVwby5hcHAubmFtZSArIFwiKFwiICsgcmVwby5yZXBvSW5mb18gKyBcIikgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXBvLmludGVycnVwdCgpO1xuICAgICAgICBkZWxldGUgYXBwUmVwb3NbcmVwby5yZXBvSW5mb18udG9VUkxTdHJpbmcoKV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIGEgcmVwbyBkb2Vzbid0IGFscmVhZHkgZXhpc3QgYW5kIHRoZW4gY3JlYXRlcyBvbmUgdXNpbmcgdGhlXG4gICAgICogcHJvdmlkZWQgYXBwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUmVwb0luZm99IHJlcG9JbmZvIFRoZSBtZXRhZGF0YSBhYm91dCB0aGUgUmVwb1xuICAgICAqIEBwYXJhbSB7IUZpcmViYXNlQXBwfSBhcHBcbiAgICAgKiBAcmV0dXJuIHshUmVwb30gVGhlIFJlcG8gb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHNlcnZlciAvIHJlcG9OYW1lLlxuICAgICAqL1xuICAgIFJlcG9NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVSZXBvID0gZnVuY3Rpb24gKHJlcG9JbmZvLCBhcHApIHtcbiAgICAgICAgdmFyIGFwcFJlcG9zID0gdXRpbF8xLnNhZmVHZXQodGhpcy5yZXBvc18sIGFwcC5uYW1lKTtcbiAgICAgICAgaWYgKCFhcHBSZXBvcykge1xuICAgICAgICAgICAgYXBwUmVwb3MgPSB7fTtcbiAgICAgICAgICAgIHRoaXMucmVwb3NfW2FwcC5uYW1lXSA9IGFwcFJlcG9zO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXBvID0gdXRpbF8xLnNhZmVHZXQoYXBwUmVwb3MsIHJlcG9JbmZvLnRvVVJMU3RyaW5nKCkpO1xuICAgICAgICBpZiAocmVwbykge1xuICAgICAgICAgICAgdXRpbF8yLmZhdGFsKCdEYXRhYmFzZSBpbml0aWFsaXplZCBtdWx0aXBsZSB0aW1lcy4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhYmFzZSBVUkwgbWF0Y2hlcyB3aXRoIGVhY2ggZGF0YWJhc2UoKSBjYWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIHJlcG8gPSBuZXcgUmVwb18xLlJlcG8ocmVwb0luZm8sIHRoaXMudXNlUmVzdENsaWVudF8sIGFwcCk7XG4gICAgICAgIGFwcFJlcG9zW3JlcG9JbmZvLnRvVVJMU3RyaW5nKCldID0gcmVwbztcbiAgICAgICAgcmV0dXJuIHJlcG87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdXMgdG8gdXNlIFJlYWRvbmx5UmVzdENsaWVudCBpbnN0ZWFkIG9mIFBlcnNpc3RlbnRDb25uZWN0aW9uIGZvciBuZXcgUmVwb3MuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZVJlc3RDbGllbnRcbiAgICAgKi9cbiAgICBSZXBvTWFuYWdlci5wcm90b3R5cGUuZm9yY2VSZXN0Q2xpZW50ID0gZnVuY3Rpb24gKGZvcmNlUmVzdENsaWVudCkge1xuICAgICAgICB0aGlzLnVzZVJlc3RDbGllbnRfID0gZm9yY2VSZXN0Q2xpZW50O1xuICAgIH07XG4gICAgcmV0dXJuIFJlcG9NYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuUmVwb01hbmFnZXIgPSBSZXBvTWFuYWdlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVwb01hbmFnZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFJlZmVyZW5jZV8xID0gcmVxdWlyZShcIi4uL2FwaS9SZWZlcmVuY2VcIik7XG52YXIgRGF0YVNuYXBzaG90XzEgPSByZXF1aXJlKFwiLi4vYXBpL0RhdGFTbmFwc2hvdFwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi91dGlsL1BhdGhcIik7XG52YXIgVHJlZV8xID0gcmVxdWlyZShcIi4vdXRpbC9UcmVlXCIpO1xudmFyIFByaW9yaXR5SW5kZXhfMSA9IHJlcXVpcmUoXCIuL3NuYXAvaW5kZXhlcy9Qcmlvcml0eUluZGV4XCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuL3V0aWwvdXRpbFwiKTtcbnZhciBTZXJ2ZXJWYWx1ZXNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvU2VydmVyVmFsdWVzXCIpO1xudmFyIHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3V0aWwvdmFsaWRhdGlvblwiKTtcbnZhciB1dGlsXzMgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgbm9kZUZyb21KU09OXzEgPSByZXF1aXJlKFwiLi9zbmFwL25vZGVGcm9tSlNPTlwiKTtcbnZhciBDaGlsZHJlbk5vZGVfMSA9IHJlcXVpcmUoXCIuL3NuYXAvQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIFJlcG9fMSA9IHJlcXVpcmUoXCIuL1JlcG9cIik7XG4vLyBUT0RPOiBUaGlzIGlzIHByZXR0eSBtZXNzeS4gIElkZWFsbHksIGEgbG90IG9mIHRoaXMgd291bGQgbW92ZSBpbnRvIEZpcmViYXNlRGF0YSwgb3IgYSB0cmFuc2FjdGlvbi1zcGVjaWZpY1xuLy8gY29tcG9uZW50IHVzZWQgYnkgRmlyZWJhc2VEYXRhLCBidXQgaXQgaGFzIHRpZXMgdG8gdXNlciBjYWxsYmFja3MgKHRyYW5zYWN0aW9uIHVwZGF0ZSBhbmQgb25Db21wbGV0ZSkgYXMgd2VsbFxuLy8gYXMgdGhlIHJlYWx0aW1lIGNvbm5lY3Rpb24gKHRvIHNlbmQgdHJhbnNhY3Rpb25zIHRvIHRoZSBzZXJ2ZXIpLiAgU28gdGhhdCBhbGwgbmVlZHMgdG8gYmUgZGVjb3VwbGVkIGZpcnN0LlxuLy8gRm9yIG5vdyBpdCdzIHBhcnQgb2YgUmVwbywgYnV0IGluIGl0cyBvd24gZmlsZS5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xudmFyIFRyYW5zYWN0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblN0YXR1cykge1xuICAgIC8vIFdlJ3ZlIHJ1biB0aGUgdHJhbnNhY3Rpb24gYW5kIHVwZGF0ZWQgdHJhbnNhY3Rpb25SZXN1bHREYXRhXyB3aXRoIHRoZSByZXN1bHQsIGJ1dCBpdCBpc24ndCBjdXJyZW50bHkgc2VudCB0byB0aGVcbiAgICAvLyBzZXJ2ZXIuIEEgdHJhbnNhY3Rpb24gd2lsbCBnbyBmcm9tIFJVTiAtPiBTRU5UIC0+IFJVTiBpZiBpdCBjb21lcyBiYWNrIGZyb20gdGhlIHNlcnZlciBhcyByZWplY3RlZCBkdWUgdG9cbiAgICAvLyBtaXNtYXRjaGVkIGhhc2guXG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJSVU5cIl0gPSAwXSA9IFwiUlVOXCI7XG4gICAgLy8gV2UndmUgcnVuIHRoZSB0cmFuc2FjdGlvbiBhbmQgc2VudCBpdCB0byB0aGUgc2VydmVyIGFuZCBpdCdzIGN1cnJlbnRseSBvdXRzdGFuZGluZyAoaGFzbid0IGNvbWUgYmFjayBhcyBhY2NlcHRlZFxuICAgIC8vIG9yIHJlamVjdGVkIHlldCkuXG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJTRU5UXCJdID0gMV0gPSBcIlNFTlRcIjtcbiAgICAvLyBUZW1wb3Jhcnkgc3RhdGUgdXNlZCB0byBtYXJrIGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMgKHdoZXRoZXIgc3VjY2Vzc2Z1bCBvciBhYm9ydGVkKS4gIFRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlXG4gICAgLy8gcmVtb3ZlZCB3aGVuIHdlIGdldCBhIGNoYW5jZSB0byBwcnVuZSBjb21wbGV0ZWQgb25lcy5cbiAgICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIkNPTVBMRVRFRFwiXSA9IDJdID0gXCJDT01QTEVURURcIjtcbiAgICAvLyBVc2VkIHdoZW4gYW4gYWxyZWFkeS1zZW50IHRyYW5zYWN0aW9uIG5lZWRzIHRvIGJlIGFib3J0ZWQgKGUuZy4gZHVlIHRvIGEgY29uZmxpY3Rpbmcgc2V0KCkgY2FsbCB0aGF0IHdhcyBtYWRlKS5cbiAgICAvLyBJZiBpdCBjb21lcyBiYWNrIGFzIHVuc3VjY2Vzc2Z1bCwgd2UnbGwgYWJvcnQgaXQuXG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJTRU5UX05FRURTX0FCT1JUXCJdID0gM10gPSBcIlNFTlRfTkVFRFNfQUJPUlRcIjtcbiAgICAvLyBUZW1wb3Jhcnkgc3RhdGUgdXNlZCB0byBtYXJrIHRyYW5zYWN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgYWJvcnRlZC5cbiAgICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIk5FRURTX0FCT1JUXCJdID0gNF0gPSBcIk5FRURTX0FCT1JUXCI7XG59KShUcmFuc2FjdGlvblN0YXR1cyA9IGV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0dXMgfHwgKGV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBJZiBhIHRyYW5zYWN0aW9uIGRvZXMgbm90IHN1Y2NlZWQgYWZ0ZXIgMjUgcmV0cmllcywgd2UgYWJvcnQgaXQuICBBbW9uZyBvdGhlciB0aGluZ3MgdGhpcyBlbnN1cmUgdGhhdCBpZiB0aGVyZSdzXG4gKiBldmVyIGEgYnVnIGNhdXNpbmcgYSBtaXNtYXRjaCBiZXR3ZWVuIGNsaWVudCAvIHNlcnZlciBoYXNoZXMgZm9yIHNvbWUgZGF0YSwgd2Ugd29uJ3QgcmV0cnkgaW5kZWZpbml0ZWx5LlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQHByaXZhdGVcbiAqL1xuUmVwb18xLlJlcG8uTUFYX1RSQU5TQUNUSU9OX1JFVFJJRVNfID0gMjU7XG4vKipcbiAqIFNldHVwIHRoZSB0cmFuc2FjdGlvbiBkYXRhIHN0cnVjdHVyZXNcbiAqIEBwcml2YXRlXG4gKi9cblJlcG9fMS5SZXBvLnByb3RvdHlwZS50cmFuc2FjdGlvbnNfaW5pdF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogU3RvcmVzIHF1ZXVlcyBvZiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbnMgZm9yIEZpcmViYXNlIGxvY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHshVHJlZS48QXJyYXkuPCFUcmFuc2FjdGlvbj4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV8gPSBuZXcgVHJlZV8xLlRyZWUoKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24sIGFkZHMgaXQgdG8gdGhlIHRyYW5zYWN0aW9ucyB3ZSdyZSB0cmFja2luZywgYW5kIHNlbmRzIGl0IHRvIHRoZSBzZXJ2ZXIgaWYgcG9zc2libGUuXG4gKlxuICogQHBhcmFtIHshUGF0aH0gcGF0aCBQYXRoIGF0IHdoaWNoIHRvIGRvIHRyYW5zYWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbigqKToqfSB0cmFuc2FjdGlvblVwZGF0ZSBVcGRhdGUgY2FsbGJhY2suXG4gKiBAcGFyYW0gez9mdW5jdGlvbig/RXJyb3IsIGJvb2xlYW4sID9EYXRhU25hcHNob3QpfSBvbkNvbXBsZXRlIENvbXBsZXRpb24gY2FsbGJhY2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFwcGx5TG9jYWxseSBXaGV0aGVyIG9yIG5vdCB0byBtYWtlIGludGVybWVkaWF0ZSByZXN1bHRzIHZpc2libGVcbiAqL1xuUmVwb18xLlJlcG8ucHJvdG90eXBlLnN0YXJ0VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAocGF0aCwgdHJhbnNhY3Rpb25VcGRhdGUsIG9uQ29tcGxldGUsIGFwcGx5TG9jYWxseSkge1xuICAgIHRoaXMubG9nXygndHJhbnNhY3Rpb24gb24gJyArIHBhdGgpO1xuICAgIC8vIEFkZCBhIHdhdGNoIHRvIG1ha2Ugc3VyZSB3ZSBnZXQgc2VydmVyIHVwZGF0ZXMuXG4gICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgdmFyIHdhdGNoUmVmID0gbmV3IFJlZmVyZW5jZV8xLlJlZmVyZW5jZSh0aGlzLCBwYXRoKTtcbiAgICB3YXRjaFJlZi5vbigndmFsdWUnLCB2YWx1ZUNhbGxiYWNrKTtcbiAgICB2YXIgdW53YXRjaGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXRjaFJlZi5vZmYoJ3ZhbHVlJywgdmFsdWVDYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBJbml0aWFsaXplIHRyYW5zYWN0aW9uLlxuICAgIHZhciB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdXBkYXRlOiB0cmFuc2FjdGlvblVwZGF0ZSxcbiAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZSxcbiAgICAgICAgLy8gT25lIG9mIFRyYW5zYWN0aW9uU3RhdHVzIGVudW1zLlxuICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgIC8vIFVzZWQgd2hlbiBjb21iaW5pbmcgdHJhbnNhY3Rpb25zIGF0IGRpZmZlcmVudCBsb2NhdGlvbnMgdG8gZmlndXJlIG91dCB3aGljaCBvbmUgZ29lcyBmaXJzdC5cbiAgICAgICAgb3JkZXI6IHV0aWxfMi5MVUlER2VuZXJhdG9yKCksXG4gICAgICAgIC8vIFdoZXRoZXIgdG8gcmFpc2UgbG9jYWwgZXZlbnRzIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICBhcHBseUxvY2FsbHk6IGFwcGx5TG9jYWxseSxcbiAgICAgICAgLy8gQ291bnQgb2YgaG93IG1hbnkgdGltZXMgd2UndmUgcmV0cmllZCB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIHJldHJ5Q291bnQ6IDAsXG4gICAgICAgIC8vIEZ1bmN0aW9uIHRvIGNhbGwgdG8gY2xlYW4gdXAgb3VyIC5vbigpIGxpc3RlbmVyLlxuICAgICAgICB1bndhdGNoZXI6IHVud2F0Y2hlcixcbiAgICAgICAgLy8gU3RvcmVzIHdoeSBhIHRyYW5zYWN0aW9uIHdhcyBhYm9ydGVkLlxuICAgICAgICBhYm9ydFJlYXNvbjogbnVsbCxcbiAgICAgICAgY3VycmVudFdyaXRlSWQ6IG51bGwsXG4gICAgICAgIGN1cnJlbnRJbnB1dFNuYXBzaG90OiBudWxsLFxuICAgICAgICBjdXJyZW50T3V0cHV0U25hcHNob3RSYXc6IG51bGwsXG4gICAgICAgIGN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkOiBudWxsXG4gICAgfTtcbiAgICAvLyBSdW4gdHJhbnNhY3Rpb24gaW5pdGlhbGx5LlxuICAgIHZhciBjdXJyZW50U3RhdGUgPSB0aGlzLmdldExhdGVzdFN0YXRlXyhwYXRoKTtcbiAgICB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCA9IGN1cnJlbnRTdGF0ZTtcbiAgICB2YXIgbmV3VmFsID0gdHJhbnNhY3Rpb24udXBkYXRlKGN1cnJlbnRTdGF0ZS52YWwoKSk7XG4gICAgaWYgKG5ld1ZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEFib3J0IHRyYW5zYWN0aW9uLlxuICAgICAgICB0cmFuc2FjdGlvbi51bndhdGNoZXIoKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmF3ID0gbnVsbDtcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQgPSBudWxsO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24ub25Db21wbGV0ZSkge1xuICAgICAgICAgICAgLy8gV2UganVzdCBzZXQgdGhlIGlucHV0IHNuYXBzaG90LCBzbyB0aGlzIGNhc3Qgc2hvdWxkIGJlIHNhZmVcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IG5ldyBEYXRhU25hcHNob3RfMS5EYXRhU25hcHNob3QodHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QsIG5ldyBSZWZlcmVuY2VfMS5SZWZlcmVuY2UodGhpcywgdHJhbnNhY3Rpb24ucGF0aCksIFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5vbkNvbXBsZXRlKG51bGwsIGZhbHNlLCBzbmFwc2hvdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUZpcmViYXNlRGF0YSgndHJhbnNhY3Rpb24gZmFpbGVkOiBEYXRhIHJldHVybmVkICcsIG5ld1ZhbCwgdHJhbnNhY3Rpb24ucGF0aCk7XG4gICAgICAgIC8vIE1hcmsgYXMgcnVuIGFuZCBhZGQgdG8gb3VyIHF1ZXVlLlxuICAgICAgICB0cmFuc2FjdGlvbi5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5SVU47XG4gICAgICAgIHZhciBxdWV1ZU5vZGUgPSB0aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXy5zdWJUcmVlKHBhdGgpO1xuICAgICAgICB2YXIgbm9kZVF1ZXVlID0gcXVldWVOb2RlLmdldFZhbHVlKCkgfHwgW107XG4gICAgICAgIG5vZGVRdWV1ZS5wdXNoKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcXVldWVOb2RlLnNldFZhbHVlKG5vZGVRdWV1ZSk7XG4gICAgICAgIC8vIFVwZGF0ZSB2aXNpYmxlRGF0YSBhbmQgcmFpc2UgZXZlbnRzXG4gICAgICAgIC8vIE5vdGU6IFdlIGludGVudGlvbmFsbHkgcmFpc2UgZXZlbnRzIGFmdGVyIHVwZGF0aW5nIGFsbCBvZiBvdXIgdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSB1c2VyIGNvdWxkXG4gICAgICAgIC8vIHN0YXJ0IG5ldyB0cmFuc2FjdGlvbnMgZnJvbSB0aGUgZXZlbnQgY2FsbGJhY2tzLlxuICAgICAgICB2YXIgcHJpb3JpdHlGb3JOb2RlID0gdm9pZCAwO1xuICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIG5ld1ZhbCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdXRpbF8zLmNvbnRhaW5zKG5ld1ZhbCwgJy5wcmlvcml0eScpKSB7XG4gICAgICAgICAgICBwcmlvcml0eUZvck5vZGUgPSB1dGlsXzMuc2FmZUdldChuZXdWYWwsICcucHJpb3JpdHknKTtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQodmFsaWRhdGlvbl8xLmlzVmFsaWRQcmlvcml0eShwcmlvcml0eUZvck5vZGUpLCAnSW52YWxpZCBwcmlvcml0eSByZXR1cm5lZCBieSB0cmFuc2FjdGlvbi4gJyArXG4gICAgICAgICAgICAgICAgJ1ByaW9yaXR5IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocGF0aCkgfHxcbiAgICAgICAgICAgICAgICBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkudmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJpb3JpdHlGb3JOb2RlIC8qKiBAdHlwZSB7bnVsbHxudW1iZXJ8c3RyaW5nfSAqLyA9IHByaW9yaXR5Rm9yTm9kZTtcbiAgICAgICAgdmFyIHNlcnZlclZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVTZXJ2ZXJWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG5ld05vZGVVbnJlc29sdmVkID0gbm9kZUZyb21KU09OXzEubm9kZUZyb21KU09OKG5ld1ZhbCwgcHJpb3JpdHlGb3JOb2RlKTtcbiAgICAgICAgdmFyIG5ld05vZGUgPSBTZXJ2ZXJWYWx1ZXNfMS5yZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KG5ld05vZGVVbnJlc29sdmVkLCBzZXJ2ZXJWYWx1ZXMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBuZXdOb2RlVW5yZXNvbHZlZDtcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQgPSBuZXdOb2RlO1xuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCA9IHRoaXMuZ2V0TmV4dFdyaXRlSWRfKCk7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVVzZXJPdmVyd3JpdGUocGF0aCwgbmV3Tm9kZSwgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRyYW5zYWN0aW9uLmFwcGx5TG9jYWxseSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChwYXRoLCBldmVudHMpO1xuICAgICAgICB0aGlzLnNlbmRSZWFkeVRyYW5zYWN0aW9uc18oKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gZXhjbHVkZVNldHMgQSBzcGVjaWZpYyBzZXQgdG8gZXhjbHVkZVxuICogQHJldHVybiB7Tm9kZX1cbiAqIEBwcml2YXRlXG4gKi9cblJlcG9fMS5SZXBvLnByb3RvdHlwZS5nZXRMYXRlc3RTdGF0ZV8gPSBmdW5jdGlvbiAocGF0aCwgZXhjbHVkZVNldHMpIHtcbiAgICByZXR1cm4gKHRoaXMuc2VydmVyU3luY1RyZWVfLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocGF0aCwgZXhjbHVkZVNldHMpIHx8XG4gICAgICAgIENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcbn07XG4vKipcbiAqIFNlbmRzIGFueSBhbHJlYWR5LXJ1biB0cmFuc2FjdGlvbnMgdGhhdCBhcmVuJ3Qgd2FpdGluZyBmb3Igb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb25zIHRvXG4gKiBjb21wbGV0ZS5cbiAqXG4gKiBFeHRlcm5hbGx5IGl0J3MgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCBidXQgaXQgY2FsbHMgaXRzZWxmIHJlY3Vyc2l2ZWx5IHdpdGggYSBwYXJ0aWN1bGFyXG4gKiB0cmFuc2FjdGlvblF1ZXVlVHJlZSBub2RlIHRvIHJlY3Vyc2UgdGhyb3VnaCB0aGUgdHJlZS5cbiAqXG4gKiBAcGFyYW0ge1RyZWUuPEFycmF5LjxUcmFuc2FjdGlvbj4+PX0gbm9kZSAgdHJhbnNhY3Rpb25RdWV1ZVRyZWUgbm9kZSB0byBzdGFydCBhdC5cbiAqIEBwcml2YXRlXG4gKi9cblJlcG9fMS5SZXBvLnByb3RvdHlwZS5zZW5kUmVhZHlUcmFuc2FjdGlvbnNfID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChub2RlID09PSB2b2lkIDApIHsgbm9kZSA9IHRoaXMudHJhbnNhY3Rpb25RdWV1ZVRyZWVfOyB9XG4gICAgLy8gQmVmb3JlIHJlY3Vyc2luZywgbWFrZSBzdXJlIGFueSBjb21wbGV0ZWQgdHJhbnNhY3Rpb25zIGFyZSByZW1vdmVkLlxuICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aGlzLnBydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlXyhub2RlKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuZ2V0VmFsdWUoKSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcXVldWUgPSB0aGlzLmJ1aWxkVHJhbnNhY3Rpb25RdWV1ZV8obm9kZSk7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQocXVldWUubGVuZ3RoID4gMCwgJ1NlbmRpbmcgemVybyBsZW5ndGggdHJhbnNhY3Rpb24gcXVldWUnKTtcbiAgICAgICAgdmFyIGFsbFJ1biA9IHF1ZXVlLmV2ZXJ5KGZ1bmN0aW9uICh0cmFuc2FjdGlvbikgeyByZXR1cm4gdHJhbnNhY3Rpb24uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5SVU47IH0pO1xuICAgICAgICAvLyBJZiB0aGV5J3JlIGFsbCBydW4gKGFuZCBub3Qgc2VudCksIHdlIGNhbiBzZW5kIHRoZW0uICBFbHNlLCB3ZSBtdXN0IHdhaXQuXG4gICAgICAgIGlmIChhbGxSdW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFRyYW5zYWN0aW9uUXVldWVfKG5vZGUucGF0aCgpLCBxdWV1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgIG5vZGUuZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIF90aGlzLnNlbmRSZWFkeVRyYW5zYWN0aW9uc18oY2hpbGROb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIHJ1biB0cmFuc2FjdGlvbnMsIHNlbmQgdGhlbSB0byB0aGUgc2VydmVyIGFuZCB0aGVuIGhhbmRsZSB0aGUgcmVzdWx0IChzdWNjZXNzIG9yIGZhaWx1cmUpLlxuICpcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIGxvY2F0aW9uIG9mIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7IUFycmF5LjxUcmFuc2FjdGlvbj59IHF1ZXVlIFF1ZXVlIG9mIHRyYW5zYWN0aW9ucyB1bmRlciB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuUmVwb18xLlJlcG8ucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvblF1ZXVlXyA9IGZ1bmN0aW9uIChwYXRoLCBxdWV1ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gTWFyayB0cmFuc2FjdGlvbnMgYXMgc2VudCBhbmQgaW5jcmVtZW50IHJldHJ5IGNvdW50IVxuICAgIHZhciBzZXRzVG9JZ25vcmUgPSBxdWV1ZS5tYXAoZnVuY3Rpb24gKHR4bikge1xuICAgICAgICByZXR1cm4gdHhuLmN1cnJlbnRXcml0ZUlkO1xuICAgIH0pO1xuICAgIHZhciBsYXRlc3RTdGF0ZSA9IHRoaXMuZ2V0TGF0ZXN0U3RhdGVfKHBhdGgsIHNldHNUb0lnbm9yZSk7XG4gICAgdmFyIHNuYXBUb1NlbmQgPSBsYXRlc3RTdGF0ZTtcbiAgICB2YXIgbGF0ZXN0SGFzaCA9IGxhdGVzdFN0YXRlLmhhc2goKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eG4gPSBxdWV1ZVtpXTtcbiAgICAgICAgdXRpbF8xLmFzc2VydCh0eG4uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5SVU4sICd0cnlUb1NlbmRUcmFuc2FjdGlvblF1ZXVlXzogaXRlbXMgaW4gcXVldWUgc2hvdWxkIGFsbCBiZSBydW4uJyk7XG4gICAgICAgIHR4bi5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5TRU5UO1xuICAgICAgICB0eG4ucmV0cnlDb3VudCsrO1xuICAgICAgICB2YXIgcmVsYXRpdmVQYXRoID0gUGF0aF8xLlBhdGgucmVsYXRpdmVQYXRoKHBhdGgsIHR4bi5wYXRoKTtcbiAgICAgICAgLy8gSWYgd2UndmUgZ290dGVuIHRvIHRoaXMgcG9pbnQsIHRoZSBvdXRwdXQgc25hcHNob3QgbXVzdCBiZSBkZWZpbmVkLlxuICAgICAgICBzbmFwVG9TZW5kID0gc25hcFRvU2VuZC51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGggLyoqQHR5cGUgeyFOb2RlfSAqLywgdHhuLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyk7XG4gICAgfVxuICAgIHZhciBkYXRhVG9TZW5kID0gc25hcFRvU2VuZC52YWwodHJ1ZSk7XG4gICAgdmFyIHBhdGhUb1NlbmQgPSBwYXRoO1xuICAgIC8vIFNlbmQgdGhlIHB1dC5cbiAgICB0aGlzLnNlcnZlcl8ucHV0KHBhdGhUb1NlbmQudG9TdHJpbmcoKSwgZGF0YVRvU2VuZCwgZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICBfdGhpcy5sb2dfKCd0cmFuc2FjdGlvbiBwdXQgcmVzcG9uc2UnLCB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoVG9TZW5kLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1c1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XG4gICAgICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91ciB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2VcbiAgICAgICAgICAgIC8vIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zIG9yIHNldHMuXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEO1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoX3RoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZShxdWV1ZVtpXS5jdXJyZW50V3JpdGVJZCkpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5vbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5ldmVyIHVuc2V0IHRoZSBvdXRwdXQgc25hcHNob3QsIGFuZCBnaXZlbiB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gaXMgY29tcGxldGUsIGl0IHNob3VsZCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBxdWV1ZVtpXS5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IG5ldyBSZWZlcmVuY2VfMS5SZWZlcmVuY2UoX3RoaXMsIHF1ZXVlW2ldLnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcHNob3QgPSBuZXcgRGF0YVNuYXBzaG90XzEuRGF0YVNuYXBzaG90KG5vZGUsIHJlZiwgUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2gocXVldWVbaV0ub25Db21wbGV0ZS5iaW5kKG51bGwsIG51bGwsIHRydWUsIHNuYXBzaG90KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnVud2F0Y2hlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IHJlbW92ZSB0aGUgY29tcGxldGVkIHRyYW5zYWN0aW9ucy5cbiAgICAgICAgICAgIF90aGlzLnBydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlXyhfdGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV8uc3ViVHJlZShwYXRoKSk7XG4gICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgcGVuZGluZyB0cmFuc2FjdGlvbnMgdGhhdCB3ZSBjYW4gbm93IHNlbmQuXG4gICAgICAgICAgICBfdGhpcy5zZW5kUmVhZHlUcmFuc2FjdGlvbnNfKCk7XG4gICAgICAgICAgICBfdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIGV2ZW50cyk7XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB0cmlnZ2VyIG9uQ29tcGxldGUgY2FsbGJhY2tzLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB1dGlsXzIuZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9ucyBhcmUgbm8gbG9uZ2VyIHNlbnQuICBVcGRhdGUgdGhlaXIgc3RhdHVzIGFwcHJvcHJpYXRlbHkuXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnZGF0YXN0YWxlJykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVClcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLk5FRURTX0FCT1JUO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5SVU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbF8yLndhcm4oJ3RyYW5zYWN0aW9uIGF0ICcgKyBwYXRoVG9TZW5kLnRvU3RyaW5nKCkgKyAnIGZhaWxlZDogJyArIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVDtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uYWJvcnRSZWFzb24gPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVydW5UcmFuc2FjdGlvbnNfKHBhdGgpO1xuICAgICAgICB9XG4gICAgfSwgbGF0ZXN0SGFzaCk7XG59O1xuLyoqXG4gKiBGaW5kcyBhbGwgdHJhbnNhY3Rpb25zIGRlcGVuZGVudCBvbiB0aGUgZGF0YSBhdCBjaGFuZ2VkUGF0aCBhbmQgcmVydW5zIHRoZW0uXG4gKlxuICogU2hvdWxkIGJlIGNhbGxlZCBhbnkgdGltZSBjYWNoZWQgZGF0YSBjaGFuZ2VzLlxuICpcbiAqIFJldHVybiB0aGUgaGlnaGVzdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuICBUaGlzIGlzIHRoZSBwYXRoIGF0IHdoaWNoIGV2ZW50cyBuZWVkIHRvXG4gKiBiZSByYWlzZWQgZm9yLlxuICpcbiAqIEBwYXJhbSB7IVBhdGh9IGNoYW5nZWRQYXRoIFRoZSBwYXRoIGluIG1lcmdlZERhdGEgdGhhdCBjaGFuZ2VkLlxuICogQHJldHVybiB7IVBhdGh9IFRoZSByb290bW9zdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvXzEuUmVwby5wcm90b3R5cGUucmVydW5UcmFuc2FjdGlvbnNfID0gZnVuY3Rpb24gKGNoYW5nZWRQYXRoKSB7XG4gICAgdmFyIHJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlID0gdGhpcy5nZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZV8oY2hhbmdlZFBhdGgpO1xuICAgIHZhciBwYXRoID0gcm9vdE1vc3RUcmFuc2FjdGlvbk5vZGUucGF0aCgpO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvblF1ZXVlXyhyb290TW9zdFRyYW5zYWN0aW9uTm9kZSk7XG4gICAgdGhpcy5yZXJ1blRyYW5zYWN0aW9uUXVldWVfKHF1ZXVlLCBwYXRoKTtcbiAgICByZXR1cm4gcGF0aDtcbn07XG4vKipcbiAqIERvZXMgYWxsIHRoZSB3b3JrIG9mIHJlcnVubmluZyB0cmFuc2FjdGlvbnMgKGFzIHdlbGwgYXMgY2xlYW5zIHVwIGFib3J0ZWQgdHJhbnNhY3Rpb25zIGFuZCB3aGF0bm90KS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxUcmFuc2FjdGlvbj59IHF1ZXVlIFRoZSBxdWV1ZSBvZiB0cmFuc2FjdGlvbnMgdG8gcnVuLlxuICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCB0aGUgcXVldWUgaXMgZm9yLlxuICogQHByaXZhdGVcbiAqL1xuUmVwb18xLlJlcG8ucHJvdG90eXBlLnJlcnVuVHJhbnNhY3Rpb25RdWV1ZV8gPSBmdW5jdGlvbiAocXVldWUsIHBhdGgpIHtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkbyFcbiAgICB9XG4gICAgLy8gUXVldWUgdXAgdGhlIGNhbGxiYWNrcyBhbmQgZmlyZSB0aGVtIGFmdGVyIGNsZWFuaW5nIHVwIGFsbCBvZiBvdXIgdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlXG4gICAgLy8gdGhlIGNhbGxiYWNrIGNvdWxkIHRyaWdnZXIgbW9yZSB0cmFuc2FjdGlvbnMgb3Igc2V0cy5cbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgIC8vIElnbm9yZSBhbGwgb2YgdGhlIHNldHMgd2UncmUgZ29pbmcgdG8gcmUtcnVuLlxuICAgIHZhciB0eG5zVG9SZXJ1biA9IHF1ZXVlLmZpbHRlcihmdW5jdGlvbiAocSkge1xuICAgICAgICByZXR1cm4gcS5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlJVTjtcbiAgICB9KTtcbiAgICB2YXIgc2V0c1RvSWdub3JlID0gdHhuc1RvUmVydW4ubWFwKGZ1bmN0aW9uIChxKSB7XG4gICAgICAgIHJldHVybiBxLmN1cnJlbnRXcml0ZUlkO1xuICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gcXVldWVbaV07XG4gICAgICAgIHZhciByZWxhdGl2ZVBhdGggPSBQYXRoXzEuUGF0aC5yZWxhdGl2ZVBhdGgocGF0aCwgdHJhbnNhY3Rpb24ucGF0aCk7XG4gICAgICAgIHZhciBhYm9ydFRyYW5zYWN0aW9uID0gZmFsc2UsIGFib3J0UmVhc29uID0gdm9pZCAwO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHJlbGF0aXZlUGF0aCAhPT0gbnVsbCwgJ3JlcnVuVHJhbnNhY3Rpb25zVW5kZXJOb2RlXzogcmVsYXRpdmVQYXRoIHNob3VsZCBub3QgYmUgbnVsbC4nKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuTkVFRFNfQUJPUlQpIHtcbiAgICAgICAgICAgIGFib3J0VHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgYWJvcnRSZWFzb24gPSB0cmFuc2FjdGlvbi5hYm9ydFJlYXNvbjtcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYWNrVXNlcldyaXRlKHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhbnNhY3Rpb24uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5SVU4pIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5yZXRyeUNvdW50ID49IFJlcG9fMS5SZXBvLk1BWF9UUkFOU0FDVElPTl9SRVRSSUVTXykge1xuICAgICAgICAgICAgICAgIGFib3J0VHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFib3J0UmVhc29uID0gJ21heHJldHJ5JztcbiAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHRoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZSh0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHJlcnVucyBhIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5nZXRMYXRlc3RTdGF0ZV8odHJhbnNhY3Rpb24ucGF0aCwgc2V0c1RvSWdub3JlKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCA9IGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhID0gcXVldWVbaV0udXBkYXRlKGN1cnJlbnROb2RlLnZhbCgpKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUZpcmViYXNlRGF0YSgndHJhbnNhY3Rpb24gZmFpbGVkOiBEYXRhIHJldHVybmVkICcsIG5ld0RhdGEsIHRyYW5zYWN0aW9uLnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YU5vZGUgPSBub2RlRnJvbUpTT05fMS5ub2RlRnJvbUpTT04obmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNFeHBsaWNpdFByaW9yaXR5ID0gdHlwZW9mIG5ld0RhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxfMy5jb250YWlucyhuZXdEYXRhLCAnLnByaW9yaXR5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzRXhwbGljaXRQcmlvcml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgb2xkIHByaW9yaXR5IGlmIHRoZXJlIHdhc24ndCBhIHByaW9yaXR5IGV4cGxpY2l0bHkgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YU5vZGUgPSBuZXdEYXRhTm9kZS51cGRhdGVQcmlvcml0eShjdXJyZW50Tm9kZS5nZXRQcmlvcml0eSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkV3JpdGVJZCA9IHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmVyVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVNlcnZlclZhbHVlcygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZVJlc29sdmVkID0gU2VydmVyVmFsdWVzXzEucmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdEYXRhTm9kZSwgc2VydmVyVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmF3ID0gbmV3RGF0YU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbmV3Tm9kZVJlc29sdmVkO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCA9IHRoaXMuZ2V0TmV4dFdyaXRlSWRfKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11dGF0ZXMgc2V0c1RvSWdub3JlIGluIHBsYWNlXG4gICAgICAgICAgICAgICAgICAgIHNldHNUb0lnbm9yZS5zcGxpY2Uoc2V0c1RvSWdub3JlLmluZGV4T2Yob2xkV3JpdGVJZCksIDEpO1xuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHRoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5VXNlck92ZXJ3cml0ZSh0cmFuc2FjdGlvbi5wYXRoLCBuZXdOb2RlUmVzb2x2ZWQsIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cmFuc2FjdGlvbi5hcHBseUxvY2FsbHkpKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdCh0aGlzLnNlcnZlclN5bmNUcmVlXy5hY2tVc2VyV3JpdGUob2xkV3JpdGVJZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0UmVhc29uID0gJ25vZGF0YSc7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYWNrVXNlcldyaXRlKHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChwYXRoLCBldmVudHMpO1xuICAgICAgICBldmVudHMgPSBbXTtcbiAgICAgICAgaWYgKGFib3J0VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIEFib3J0LlxuICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEO1xuICAgICAgICAgICAgLy8gUmVtb3ZpbmcgYSBsaXN0ZW5lciBjYW4gdHJpZ2dlciBwcnVuaW5nIHdoaWNoIGNhbiBtdWNrIHdpdGggbWVyZ2VkRGF0YS92aXNpYmxlRGF0YSAoYXMgaXQgcHJ1bmVzIGRhdGEpLlxuICAgICAgICAgICAgLy8gU28gZGVmZXIgdGhlIHVud2F0Y2hlciB1bnRpbCB3ZSdyZSBkb25lLlxuICAgICAgICAgICAgKGZ1bmN0aW9uICh1bndhdGNoZXIpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHVud2F0Y2hlciwgTWF0aC5mbG9vcigwKSk7XG4gICAgICAgICAgICB9KShxdWV1ZVtpXS51bndhdGNoZXIpO1xuICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLm9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJvcnRSZWFzb24gPT09ICdub2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSBuZXcgUmVmZXJlbmNlXzEuUmVmZXJlbmNlKHRoaXMsIHF1ZXVlW2ldLnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzZXQgdGhpcyBmaWVsZCBpbW1lZGlhdGVseSwgc28gaXQncyBzYWZlIHRvIGNhc3QgdG8gYW4gYWN0dWFsIHNuYXBzaG90XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0SW5wdXQgLyoqIEB0eXBlIHshTm9kZX0gKi8gPSBxdWV1ZVtpXS5jdXJyZW50SW5wdXRTbmFwc2hvdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gbmV3IERhdGFTbmFwc2hvdF8xLkRhdGFTbmFwc2hvdChsYXN0SW5wdXQsIHJlZiwgUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2gocXVldWVbaV0ub25Db21wbGV0ZS5iaW5kKG51bGwsIG51bGwsIGZhbHNlLCBzbmFwc2hvdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2gocXVldWVbaV0ub25Db21wbGV0ZS5iaW5kKG51bGwsIG5ldyBFcnJvcihhYm9ydFJlYXNvbiksIGZhbHNlLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMuXG4gICAgdGhpcy5wcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZV8odGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV8pO1xuICAgIC8vIE5vdyBmaXJlIGNhbGxiYWNrcywgbm93IHRoYXQgd2UncmUgaW4gYSBnb29kLCBrbm93biBzdGF0ZS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1dGlsXzIuZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHNlbmQgdGhlIHRyYW5zYWN0aW9uIHJlc3VsdCB0byB0aGUgc2VydmVyLlxuICAgIHRoaXMuc2VuZFJlYWR5VHJhbnNhY3Rpb25zXygpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgcm9vdG1vc3QgYW5jZXN0b3Igbm9kZSBvZiB0aGUgc3BlY2lmaWVkIHBhdGggdGhhdCBoYXMgYSBwZW5kaW5nIHRyYW5zYWN0aW9uIG9uIGl0LCBvciBqdXN0IHJldHVybnNcbiAqIHRoZSBub2RlIGZvciB0aGUgZ2l2ZW4gcGF0aCBpZiB0aGVyZSBhcmUgbm8gcGVuZGluZyB0cmFuc2FjdGlvbnMgb24gYW55IGFuY2VzdG9yLlxuICpcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIGxvY2F0aW9uIHRvIHN0YXJ0IGF0LlxuICogQHJldHVybiB7IVRyZWUuPEFycmF5LjwhVHJhbnNhY3Rpb24+Pn0gVGhlIHJvb3Rtb3N0IG5vZGUgd2l0aCBhIHRyYW5zYWN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuUmVwb18xLlJlcG8ucHJvdG90eXBlLmdldEFuY2VzdG9yVHJhbnNhY3Rpb25Ob2RlXyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIGZyb250O1xuICAgIC8vIFN0YXJ0IGF0IHRoZSByb290IGFuZCB3YWxrIGRlZXBlciBpbnRvIHRoZSB0cmVlIHRvd2FyZHMgcGF0aCB1bnRpbCB3ZSBmaW5kIGEgbm9kZSB3aXRoIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgIHZhciB0cmFuc2FjdGlvbk5vZGUgPSB0aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXztcbiAgICB3aGlsZSAoKGZyb250ID0gcGF0aC5nZXRGcm9udCgpKSAhPT0gbnVsbCAmJlxuICAgICAgICB0cmFuc2FjdGlvbk5vZGUuZ2V0VmFsdWUoKSA9PT0gbnVsbCkge1xuICAgICAgICB0cmFuc2FjdGlvbk5vZGUgPSB0cmFuc2FjdGlvbk5vZGUuc3ViVHJlZShmcm9udCk7XG4gICAgICAgIHBhdGggPSBwYXRoLnBvcEZyb250KCk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2FjdGlvbk5vZGU7XG59O1xuLyoqXG4gKiBCdWlsZHMgdGhlIHF1ZXVlIG9mIGFsbCB0cmFuc2FjdGlvbnMgYXQgb3IgYmVsb3cgdGhlIHNwZWNpZmllZCB0cmFuc2FjdGlvbk5vZGUuXG4gKlxuICogQHBhcmFtIHshVHJlZS48QXJyYXkuPFRyYW5zYWN0aW9uPj59IHRyYW5zYWN0aW9uTm9kZVxuICogQHJldHVybiB7QXJyYXkuPFRyYW5zYWN0aW9uPn0gVGhlIGdlbmVyYXRlZCBxdWV1ZS5cbiAqIEBwcml2YXRlXG4gKi9cblJlcG9fMS5SZXBvLnByb3RvdHlwZS5idWlsZFRyYW5zYWN0aW9uUXVldWVfID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uTm9kZSkge1xuICAgIC8vIFdhbGsgYW55IGNoaWxkIHRyYW5zYWN0aW9uIHF1ZXVlcyBhbmQgYWdncmVnYXRlIHRoZW0gaW50byBhIHNpbmdsZSBxdWV1ZS5cbiAgICB2YXIgdHJhbnNhY3Rpb25RdWV1ZSA9IFtdO1xuICAgIHRoaXMuYWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlXyh0cmFuc2FjdGlvbk5vZGUsIHRyYW5zYWN0aW9uUXVldWUpO1xuICAgIC8vIFNvcnQgdGhlbSBieSB0aGUgb3JkZXIgdGhlIHRyYW5zYWN0aW9ucyB3ZXJlIGNyZWF0ZWQuXG4gICAgdHJhbnNhY3Rpb25RdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25RdWV1ZTtcbn07XG4vKipcbiAqIEBwYXJhbSB7IVRyZWUuPEFycmF5LjxUcmFuc2FjdGlvbj4+fSBub2RlXG4gKiBAcGFyYW0ge0FycmF5LjxUcmFuc2FjdGlvbj59IHF1ZXVlXG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvXzEuUmVwby5wcm90b3R5cGUuYWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlXyA9IGZ1bmN0aW9uIChub2RlLCBxdWV1ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIG5vZGVRdWV1ZSA9IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICBpZiAobm9kZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZVF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGVRdWV1ZVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIF90aGlzLmFnZ3JlZ2F0ZVRyYW5zYWN0aW9uUXVldWVzRm9yTm9kZV8oY2hpbGQsIHF1ZXVlKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFJlbW92ZSBDT01QTEVURUQgdHJhbnNhY3Rpb25zIGF0IG9yIGJlbG93IHRoaXMgbm9kZSBpbiB0aGUgdHJhbnNhY3Rpb25RdWV1ZVRyZWVfLlxuICpcbiAqIEBwYXJhbSB7IVRyZWUuPEFycmF5LjwhVHJhbnNhY3Rpb24+Pn0gbm9kZVxuICogQHByaXZhdGVcbiAqL1xuUmVwb18xLlJlcG8ucHJvdG90eXBlLnBydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlXyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgcXVldWUgPSBub2RlLmdldFZhbHVlKCk7XG4gICAgaWYgKHF1ZXVlKSB7XG4gICAgICAgIHZhciB0byA9IDA7XG4gICAgICAgIGZvciAodmFyIGZyb20gPSAwOyBmcm9tIDwgcXVldWUubGVuZ3RoOyBmcm9tKyspIHtcbiAgICAgICAgICAgIGlmIChxdWV1ZVtmcm9tXS5zdGF0dXMgIT09IFRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFRCkge1xuICAgICAgICAgICAgICAgIHF1ZXVlW3RvXSA9IHF1ZXVlW2Zyb21dO1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWUubGVuZ3RoID0gdG87XG4gICAgICAgIG5vZGUuc2V0VmFsdWUocXVldWUubGVuZ3RoID4gMCA/IHF1ZXVlIDogbnVsbCk7XG4gICAgfVxuICAgIG5vZGUuZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgX3RoaXMucHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGVfKGNoaWxkTm9kZSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBBYm9ydHMgYWxsIHRyYW5zYWN0aW9ucyBvbiBhbmNlc3RvcnMgb3IgZGVzY2VuZGFudHMgb2YgdGhlIHNwZWNpZmllZCBwYXRoLiAgQ2FsbGVkIHdoZW4gZG9pbmcgYSBzZXQoKSBvciB1cGRhdGUoKVxuICogc2luY2Ugd2UgY29uc2lkZXIgdGhlbSBpbmNvbXBhdGlibGUgd2l0aCB0cmFuc2FjdGlvbnMuXG4gKlxuICogQHBhcmFtIHshUGF0aH0gcGF0aCBQYXRoIGZvciB3aGljaCB3ZSB3YW50IHRvIGFib3J0IHJlbGF0ZWQgdHJhbnNhY3Rpb25zLlxuICogQHJldHVybiB7IVBhdGh9XG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvXzEuUmVwby5wcm90b3R5cGUuYWJvcnRUcmFuc2FjdGlvbnNfID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBhZmZlY3RlZFBhdGggPSB0aGlzLmdldEFuY2VzdG9yVHJhbnNhY3Rpb25Ob2RlXyhwYXRoKS5wYXRoKCk7XG4gICAgdmFyIHRyYW5zYWN0aW9uTm9kZSA9IHRoaXMudHJhbnNhY3Rpb25RdWV1ZVRyZWVfLnN1YlRyZWUocGF0aCk7XG4gICAgdHJhbnNhY3Rpb25Ob2RlLmZvckVhY2hBbmNlc3RvcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBfdGhpcy5hYm9ydFRyYW5zYWN0aW9uc09uTm9kZV8obm9kZSk7XG4gICAgfSk7XG4gICAgdGhpcy5hYm9ydFRyYW5zYWN0aW9uc09uTm9kZV8odHJhbnNhY3Rpb25Ob2RlKTtcbiAgICB0cmFuc2FjdGlvbk5vZGUuZm9yRWFjaERlc2NlbmRhbnQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgX3RoaXMuYWJvcnRUcmFuc2FjdGlvbnNPbk5vZGVfKG5vZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhZmZlY3RlZFBhdGg7XG59O1xuLyoqXG4gKiBBYm9ydCB0cmFuc2FjdGlvbnMgc3RvcmVkIGluIHRoaXMgdHJhbnNhY3Rpb24gcXVldWUgbm9kZS5cbiAqXG4gKiBAcGFyYW0geyFUcmVlLjxBcnJheS48VHJhbnNhY3Rpb24+Pn0gbm9kZSBOb2RlIHRvIGFib3J0IHRyYW5zYWN0aW9ucyBmb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvXzEuUmVwby5wcm90b3R5cGUuYWJvcnRUcmFuc2FjdGlvbnNPbk5vZGVfID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgcXVldWUgPSBub2RlLmdldFZhbHVlKCk7XG4gICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyIHRyYW5zYWN0aW9uIHN0YXRlLCBzaW5jZVxuICAgICAgICAvLyB0aGUgY2FsbGJhY2sgY291bGQgdHJpZ2dlciBtb3JlIHRyYW5zYWN0aW9ucyBvciBzZXRzLlxuICAgICAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgICAgIC8vIEdvIHRocm91Z2ggcXVldWUuICBBbnkgYWxyZWFkeS1zZW50IHRyYW5zYWN0aW9ucyBtdXN0IGJlIG1hcmtlZCBmb3IgYWJvcnQsIHdoaWxlIHRoZSB1bnNlbnQgb25lc1xuICAgICAgICAvLyBjYW4gYmUgaW1tZWRpYXRlbHkgYWJvcnRlZCBhbmQgcmVtb3ZlZC5cbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgbGFzdFNlbnQgPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVCkge1xuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgbWFya2VkLiAgTm8gYWN0aW9uIG5lZWRlZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuU0VOVCkge1xuICAgICAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQobGFzdFNlbnQgPT09IGkgLSAxLCAnQWxsIFNFTlQgaXRlbXMgc2hvdWxkIGJlIGF0IGJlZ2lubmluZyBvZiBxdWV1ZS4nKTtcbiAgICAgICAgICAgICAgICBsYXN0U2VudCA9IGk7XG4gICAgICAgICAgICAgICAgLy8gTWFyayB0cmFuc2FjdGlvbiBmb3IgYWJvcnQgd2hlbiBpdCBjb21lcyBiYWNrLlxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLlNFTlRfTkVFRFNfQUJPUlQ7XG4gICAgICAgICAgICAgICAgcXVldWVbaV0uYWJvcnRSZWFzb24gPSAnc2V0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQocXVldWVbaV0uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5SVU4sICdVbmV4cGVjdGVkIHRyYW5zYWN0aW9uIHN0YXR1cyBpbiBhYm9ydCcpO1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBhYm9ydCBpdCBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS51bndhdGNoZXIoKTtcbiAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHRoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZShxdWV1ZVtpXS5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5vbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKHF1ZXVlW2ldLm9uQ29tcGxldGUuYmluZChudWxsLCBuZXcgRXJyb3IoJ3NldCcpLCBmYWxzZSwgc25hcHNob3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RTZW50ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gV2UncmUgbm90IHdhaXRpbmcgZm9yIGFueSBzZW50IHRyYW5zYWN0aW9ucy4gIFdlIGNhbiBjbGVhciB0aGUgcXVldWUuXG4gICAgICAgICAgICBub2RlLnNldFZhbHVlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmFuc2FjdGlvbnMgd2UgYWJvcnRlZC5cbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCA9IGxhc3RTZW50ICsgMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgZmlyZSB0aGUgY2FsbGJhY2tzLlxuICAgICAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgobm9kZS5wYXRoKCksIGV2ZW50cyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB1dGlsXzIuZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcG9fdHJhbnNhY3Rpb24uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEludGVyZmFjZSBkZWZpbmluZyB0aGUgc2V0IG9mIGFjdGlvbnMgdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGFnYWluc3QgdGhlIEZpcmViYXNlIHNlcnZlclxuICogKGJhc2ljYWxseSBjb3JyZXNwb25kcyB0byBvdXIgd2lyZSBwcm90b2NvbCkuXG4gKlxuICogQGludGVyZmFjZVxuICovXG52YXIgU2VydmVyQWN0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJ2ZXJBY3Rpb25zKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCBzdHJpbmcpPX0gb25Db21wbGV0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gaGFzaFxuICAgICAqL1xuICAgIFNlcnZlckFjdGlvbnMucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgP3N0cmluZyl9IG9uQ29tcGxldGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGhhc2hcbiAgICAgKi9cbiAgICBTZXJ2ZXJBY3Rpb25zLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7IH07XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhdXRoIHRva2VuIGZvciB0aGUgY3VycmVudCBjb25uZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgYXV0aGVudGljYXRpb24gdG9rZW5cbiAgICAgKi9cbiAgICBTZXJ2ZXJBY3Rpb25zLnByb3RvdHlwZS5yZWZyZXNoQXV0aFRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgc3RyaW5nKT19IG9uQ29tcGxldGVcbiAgICAgKi9cbiAgICBTZXJ2ZXJBY3Rpb25zLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3RQdXQgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZyk9fSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgU2VydmVyQWN0aW9ucy5wcm90b3R5cGUub25EaXNjb25uZWN0TWVyZ2UgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZyk9fSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgU2VydmVyQWN0aW9ucy5wcm90b3R5cGUub25EaXNjb25uZWN0Q2FuY2VsID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPn0gc3RhdHNcbiAgICAgKi9cbiAgICBTZXJ2ZXJBY3Rpb25zLnByb3RvdHlwZS5yZXBvcnRTdGF0cyA9IGZ1bmN0aW9uIChzdGF0cykgeyB9O1xuICAgIHJldHVybiBTZXJ2ZXJBY3Rpb25zO1xufSgpKTtcbmV4cG9ydHMuU2VydmVyQWN0aW9ucyA9IFNlcnZlckFjdGlvbnM7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlcnZlckFjdGlvbnMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2hpbGRyZW5Ob2RlXzEgPSByZXF1aXJlKFwiLi9zbmFwL0NoaWxkcmVuTm9kZVwiKTtcbi8qKlxuICogTXV0YWJsZSBvYmplY3Qgd2hpY2ggYmFzaWNhbGx5IGp1c3Qgc3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBcImxhdGVzdFwiIGltbXV0YWJsZSBzbmFwc2hvdC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNuYXBzaG90SG9sZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNuYXBzaG90SG9sZGVyKCkge1xuICAgICAgICB0aGlzLnJvb3ROb2RlXyA9IENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgIH1cbiAgICBTbmFwc2hvdEhvbGRlci5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3ROb2RlXy5nZXRDaGlsZChwYXRoKTtcbiAgICB9O1xuICAgIFNuYXBzaG90SG9sZGVyLnByb3RvdHlwZS51cGRhdGVTbmFwc2hvdCA9IGZ1bmN0aW9uIChwYXRoLCBuZXdTbmFwc2hvdE5vZGUpIHtcbiAgICAgICAgdGhpcy5yb290Tm9kZV8gPSB0aGlzLnJvb3ROb2RlXy51cGRhdGVDaGlsZChwYXRoLCBuZXdTbmFwc2hvdE5vZGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFNuYXBzaG90SG9sZGVyO1xufSgpKTtcbmV4cG9ydHMuU25hcHNob3RIb2xkZXIgPSBTbmFwc2hvdEhvbGRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U25hcHNob3RIb2xkZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4vdXRpbC9QYXRoXCIpO1xudmFyIFByaW9yaXR5SW5kZXhfMSA9IHJlcXVpcmUoXCIuL3NuYXAvaW5kZXhlcy9Qcmlvcml0eUluZGV4XCIpO1xudmFyIENvdW50ZWRTZXRfMSA9IHJlcXVpcmUoXCIuL3V0aWwvQ291bnRlZFNldFwiKTtcbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIHN0b3JlIGEgc3BhcnNlIHNldCBvZiBzbmFwc2hvdHMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTcGFyc2VTbmFwc2hvdFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3BhcnNlU25hcHNob3RUcmVlKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge05vZGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlXyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Q291bnRlZFNldH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbm9kZSBzdG9yZWQgYXQgdGhlIGdpdmVuIHBhdGggaWYgb25lIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggUGF0aCB0byBsb29rIHVwIHNuYXBzaG90IGZvci5cbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX0gVGhlIHJldHJpZXZlZCBub2RlLCBvciBudWxsLlxuICAgICAqL1xuICAgIFNwYXJzZVNuYXBzaG90VHJlZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlXyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV8uZ2V0Q2hpbGQocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXBhdGguaXNFbXB0eSgpICYmIHRoaXMuY2hpbGRyZW5fICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEtleSA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnBvcEZyb250KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uY29udGFpbnMoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZEtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVHJlZS5maW5kKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBnaXZlbiBub2RlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC4gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5vZGVcbiAgICAgKiBhdCBhIHNoYWxsb3dlciBwYXRoLCBpdCBtZXJnZXMgdGhlIG5ldyBkYXRhIGludG8gdGhhdCBzbmFwc2hvdCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBQYXRoIHRvIGxvb2sgdXAgc25hcHNob3QgZm9yLlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IGRhdGEgVGhlIG5ldyBkYXRhLCBvciBudWxsLlxuICAgICAqL1xuICAgIFNwYXJzZVNuYXBzaG90VHJlZS5wcm90b3R5cGUucmVtZW1iZXIgPSBmdW5jdGlvbiAocGF0aCwgZGF0YSkge1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVfID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnZhbHVlXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZV8gPSB0aGlzLnZhbHVlXy51cGRhdGVDaGlsZChwYXRoLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbl8gPSBuZXcgQ291bnRlZFNldF8xLkNvdW50ZWRTZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGlsZEtleSA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGlsZHJlbl8uY29udGFpbnMoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbl8uYWRkKGNoaWxkS2V5LCBuZXcgU3BhcnNlU25hcHNob3RUcmVlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbl8uZ2V0KGNoaWxkS2V5KTtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnBvcEZyb250KCk7XG4gICAgICAgICAgICBjaGlsZC5yZW1lbWJlcihwYXRoLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVyZ2UgdGhlIGRhdGEgYXQgcGF0aCBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggUGF0aCB0byBsb29rIHVwIHNuYXBzaG90IGZvci5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgbm9kZSBzaG91bGQgbm93IGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgU3BhcnNlU25hcHNob3RUcmVlLnByb3RvdHlwZS5mb3JnZXQgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVfID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVfICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVfLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSB0cnlpbmcgdG8gZm9yZ2V0IGEgbm9kZSB0aGF0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVfID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGZfMSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2hDaGlsZChQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgsIGZ1bmN0aW9uIChrZXksIHRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGZfMS5yZW1lbWJlcihuZXcgUGF0aF8xLlBhdGgoa2V5KSwgdHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JnZXQocGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jaGlsZHJlbl8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRLZXkgPSBwYXRoLmdldEZyb250KCk7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgucG9wRnJvbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uY29udGFpbnMoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlVG9SZW1vdmUgPSB0aGlzLmNoaWxkcmVuXy5nZXQoY2hpbGRLZXkpLmZvcmdldChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhZmVUb1JlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbl8ucmVtb3ZlKGNoaWxkS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGl0ZXJhdGVzIHRocm91Z2ggYWxsIG9mIHRoZSBzdG9yZWQgdHJlZSBhbmQgY2FsbHMgdGhlXG4gICAgICogY2FsbGJhY2sgb24gZWFjaCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwcmVmaXhQYXRoIFBhdGggdG8gbG9vayB1cCBub2RlIGZvci5cbiAgICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHRyZWUuXG4gICAgICovXG4gICAgU3BhcnNlU25hcHNob3RUcmVlLnByb3RvdHlwZS5mb3JFYWNoVHJlZSA9IGZ1bmN0aW9uIChwcmVmaXhQYXRoLCBmdW5jKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZnVuYyhwcmVmaXhQYXRoLCB0aGlzLnZhbHVlXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hDaGlsZChmdW5jdGlvbiAoa2V5LCB0cmVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aF8xLlBhdGgocHJlZml4UGF0aC50b1N0cmluZygpICsgJy8nICsga2V5KTtcbiAgICAgICAgICAgICAgICB0cmVlLmZvckVhY2hUcmVlKHBhdGgsIGZ1bmMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggZWFjaCBpbW1lZGlhdGUgY2hpbGQgYW5kIHRyaWdnZXJzIHRoZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggY2hpbGQuXG4gICAgICovXG4gICAgU3BhcnNlU25hcHNob3RUcmVlLnByb3RvdHlwZS5mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5fLmVhY2goZnVuY3Rpb24gKGtleSwgdHJlZSkge1xuICAgICAgICAgICAgICAgIGZ1bmMoa2V5LCB0cmVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3BhcnNlU25hcHNob3RUcmVlO1xufSgpKTtcbmV4cG9ydHMuU3BhcnNlU25hcHNob3RUcmVlID0gU3BhcnNlU25hcHNob3RUcmVlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcGFyc2VTbmFwc2hvdFRyZWUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2FjaGVOb2RlXzEgPSByZXF1aXJlKFwiLi92aWV3L0NhY2hlTm9kZVwiKTtcbnZhciBDaGlsZHJlbk5vZGVfMSA9IHJlcXVpcmUoXCIuL3NuYXAvQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgVmlld0NhY2hlXzEgPSByZXF1aXJlKFwiLi92aWV3L1ZpZXdDYWNoZVwiKTtcbnZhciBWaWV3XzEgPSByZXF1aXJlKFwiLi92aWV3L1ZpZXdcIik7XG52YXIgX19yZWZlcmVuY2VDb25zdHJ1Y3Rvcjtcbi8qKlxuICogU3luY1BvaW50IHJlcHJlc2VudHMgYSBzaW5nbGUgbG9jYXRpb24gaW4gYSBTeW5jVHJlZSB3aXRoIDEgb3IgbW9yZSBldmVudCByZWdpc3RyYXRpb25zLCBtZWFuaW5nIHdlIG5lZWQgdG9cbiAqIG1haW50YWluIDEgb3IgbW9yZSBWaWV3cyBhdCB0aGlzIGxvY2F0aW9uIHRvIGNhY2hlIHNlcnZlciBkYXRhIGFuZCByYWlzZSBhcHByb3ByaWF0ZSBldmVudHMgZm9yIHNlcnZlciBjaGFuZ2VzXG4gKiBhbmQgdXNlciB3cml0ZXMgKHNldCwgdHJhbnNhY3Rpb24sIHVwZGF0ZSkuXG4gKlxuICogSXQncyByZXNwb25zaWJsZSBmb3I6XG4gKiAgLSBNYWludGFpbmluZyB0aGUgc2V0IG9mIDEgb3IgbW9yZSB2aWV3cyBuZWNlc3NhcnkgYXQgdGhpcyBsb2NhdGlvbiAoYSBTeW5jUG9pbnQgd2l0aCAwIHZpZXdzIHNob3VsZCBiZSByZW1vdmVkKS5cbiAqICAtIFByb3h5aW5nIHVzZXIgLyBzZXJ2ZXIgb3BlcmF0aW9ucyB0byB0aGUgdmlld3MgYXMgYXBwcm9wcmlhdGUgKGkuZS4gYXBwbHlTZXJ2ZXJPdmVyd3JpdGUsXG4gKiAgICBhcHBseVVzZXJPdmVyd3JpdGUsIGV0Yy4pXG4gKi9cbnZhciBTeW5jUG9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3luY1BvaW50KCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFZpZXdzIGJlaW5nIHRyYWNrZWQgYXQgdGhpcyBsb2NhdGlvbiBpbiB0aGUgdHJlZSwgc3RvcmVkIGFzIGEgbWFwIHdoZXJlIHRoZSBrZXkgaXMgYVxuICAgICAgICAgKiBxdWVyeUlkIGFuZCB0aGUgdmFsdWUgaXMgdGhlIFZpZXcgZm9yIHRoYXQgcXVlcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFRoaXMgbGlzdCB3aWxsIGJlIHF1aXRlIHNtYWxsICh1c3VhbGx5IDEsIGJ1dCBwZXJoYXBzIDIgb3IgMzsgYW55IG1vcmUgaXMgYW4gb2RkIHVzZSBjYXNlKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPCFzdHJpbmcsICFWaWV3Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld3NfID0ge307XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTeW5jUG9pbnQsIFwiX19yZWZlcmVuY2VDb25zdHJ1Y3RvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXRpbF8xLmFzc2VydChfX3JlZmVyZW5jZUNvbnN0cnVjdG9yLCAnUmVmZXJlbmNlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoIV9fcmVmZXJlbmNlQ29uc3RydWN0b3IsICdfX3JlZmVyZW5jZUNvbnN0cnVjdG9yIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCcpO1xuICAgICAgICAgICAgX19yZWZlcmVuY2VDb25zdHJ1Y3RvciA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBTeW5jUG9pbnQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsXzIuaXNFbXB0eSh0aGlzLnZpZXdzXyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7P05vZGV9IG9wdENvbXBsZXRlU2VydmVyQ2FjaGVcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICovXG4gICAgU3luY1BvaW50LnByb3RvdHlwZS5hcHBseU9wZXJhdGlvbiA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKSB7XG4gICAgICAgIHZhciBxdWVyeUlkID0gb3BlcmF0aW9uLnNvdXJjZS5xdWVyeUlkO1xuICAgICAgICBpZiAocXVlcnlJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB1dGlsXzIuc2FmZUdldCh0aGlzLnZpZXdzXywgcXVlcnlJZCk7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHZpZXcgIT0gbnVsbCwgJ1N5bmNUcmVlIGdhdmUgdXMgYW4gb3AgZm9yIGFuIGludmFsaWQgcXVlcnkuJyk7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBldmVudHNfMSA9IFtdO1xuICAgICAgICAgICAgdXRpbF8yLmZvckVhY2godGhpcy52aWV3c18sIGZ1bmN0aW9uIChrZXksIHZpZXcpIHtcbiAgICAgICAgICAgICAgICBldmVudHNfMSA9IGV2ZW50c18xLmNvbmNhdCh2aWV3LmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG9wdENvbXBsZXRlU2VydmVyQ2FjaGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50c18xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgY2FsbGJhY2sgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcGFyYW0geyFFdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gc2VydmVyQ2FjaGUgQ29tcGxldGUgc2VydmVyIGNhY2hlLCBpZiB3ZSBoYXZlIGl0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VydmVyQ2FjaGVDb21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgICAqL1xuICAgIFN5bmNQb2ludC5wcm90b3R5cGUuYWRkRXZlbnRSZWdpc3RyYXRpb24gPSBmdW5jdGlvbiAocXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIHF1ZXJ5SWQgPSBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgdmFyIHZpZXcgPSB1dGlsXzIuc2FmZUdldCh0aGlzLnZpZXdzXywgcXVlcnlJZCk7XG4gICAgICAgIGlmICghdmlldykge1xuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSB3cml0ZXNDYWNoZSB0YWtlIGZsYWcgZm9yIGNvbXBsZXRlIHNlcnZlciBub2RlXG4gICAgICAgICAgICB2YXIgZXZlbnRDYWNoZSA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUoc2VydmVyQ2FjaGVDb21wbGV0ZSA/IHNlcnZlckNhY2hlIDogbnVsbCk7XG4gICAgICAgICAgICB2YXIgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXZlbnRDYWNoZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50Q2FjaGVDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZXJ2ZXJDYWNoZSBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50Q2FjaGUgPSB3cml0ZXNDYWNoZS5jYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHNlcnZlckNhY2hlKTtcbiAgICAgICAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50Q2FjaGUgPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2aWV3Q2FjaGUgPSBuZXcgVmlld0NhY2hlXzEuVmlld0NhY2hlKG5ldyBDYWNoZU5vZGVfMS5DYWNoZU5vZGUoXG4gICAgICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqLyAoZXZlbnRDYWNoZSksIGV2ZW50Q2FjaGVDb21wbGV0ZSwgZmFsc2UpLCBuZXcgQ2FjaGVOb2RlXzEuQ2FjaGVOb2RlKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi8gKHNlcnZlckNhY2hlKSwgc2VydmVyQ2FjaGVDb21wbGV0ZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIHZpZXcgPSBuZXcgVmlld18xLlZpZXcocXVlcnksIHZpZXdDYWNoZSk7XG4gICAgICAgICAgICB0aGlzLnZpZXdzX1txdWVyeUlkXSA9IHZpZXc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IG5vdywgd2UganVzdCBjcmVhdGVkIGFueXRoaW5nIHRoYXQgd2FzIG1pc3NpbmdcbiAgICAgICAgdmlldy5hZGRFdmVudFJlZ2lzdHJhdGlvbihldmVudFJlZ2lzdHJhdGlvbik7XG4gICAgICAgIHJldHVybiB2aWV3LmdldEluaXRpYWxFdmVudHMoZXZlbnRSZWdpc3RyYXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGNhbGxiYWNrKHMpLiAgUmV0dXJuIGNhbmNlbEV2ZW50cyBpZiBhIGNhbmNlbEVycm9yIGlzIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIElmIHF1ZXJ5IGlzIHRoZSBkZWZhdWx0IHF1ZXJ5LCB3ZSdsbCBjaGVjayBhbGwgdmlld3MgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRSZWdpc3RyYXRpb24uXG4gICAgICogSWYgZXZlbnRSZWdpc3RyYXRpb24gaXMgbnVsbCwgd2UnbGwgcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBzcGVjaWZpZWQgdmlldyhzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEBwYXJhbSB7P0V2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvbiBJZiBudWxsLCByZW1vdmUgYWxsIGNhbGxiYWNrcy5cbiAgICAgKiBAcGFyYW0ge0Vycm9yPX0gY2FuY2VsRXJyb3IgSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm4ge3tyZW1vdmVkOiFBcnJheS48IVF1ZXJ5PiwgZXZlbnRzOiFBcnJheS48IUV2ZW50Pn19IHJlbW92ZWQgcXVlcmllcyBhbmQgYW55IGNhbmNlbCBldmVudHNcbiAgICAgKi9cbiAgICBTeW5jUG9pbnQucHJvdG90eXBlLnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uID0gZnVuY3Rpb24gKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgdmFyIHF1ZXJ5SWQgPSBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgICAgdmFyIGNhbmNlbEV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgaGFkQ29tcGxldGVWaWV3ID0gdGhpcy5oYXNDb21wbGV0ZVZpZXcoKTtcbiAgICAgICAgaWYgKHF1ZXJ5SWQgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgLy8gV2hlbiB5b3UgZG8gcmVmLm9mZiguLi4pLCB3ZSBzZWFyY2ggYWxsIHZpZXdzIGZvciB0aGUgcmVnaXN0cmF0aW9uIHRvIHJlbW92ZS5cbiAgICAgICAgICAgIHZhciBzZWxmXzEgPSB0aGlzO1xuICAgICAgICAgICAgdXRpbF8yLmZvckVhY2godGhpcy52aWV3c18sIGZ1bmN0aW9uICh2aWV3UXVlcnlJZCwgdmlldykge1xuICAgICAgICAgICAgICAgIGNhbmNlbEV2ZW50cyA9IGNhbmNlbEV2ZW50cy5jb25jYXQodmlldy5yZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpKTtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGZfMS52aWV3c19bdmlld1F1ZXJ5SWRdO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSdsbCBkZWFsIHdpdGggY29tcGxldGUgdmlld3MgbGF0ZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgLmdldFF1ZXJ5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRRdWVyeVBhcmFtcygpXG4gICAgICAgICAgICAgICAgICAgICAgICAubG9hZHNBbGxEYXRhKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaCh2aWV3LmdldFF1ZXJ5KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHNwZWNpZmljIHZpZXcuXG4gICAgICAgICAgICB2YXIgdmlldyA9IHV0aWxfMi5zYWZlR2V0KHRoaXMudmlld3NfLCBxdWVyeUlkKTtcbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsRXZlbnRzID0gY2FuY2VsRXZlbnRzLmNvbmNhdCh2aWV3LnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy52aWV3c19bcXVlcnlJZF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGRlYWwgd2l0aCBjb21wbGV0ZSB2aWV3cyBsYXRlci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0UXVlcnkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldFF1ZXJ5UGFyYW1zKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5sb2Fkc0FsbERhdGEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKHZpZXcuZ2V0UXVlcnkoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhZENvbXBsZXRlVmlldyAmJiAhdGhpcy5oYXNDb21wbGV0ZVZpZXcoKSkge1xuICAgICAgICAgICAgLy8gV2UgcmVtb3ZlZCBvdXIgbGFzdCBjb21wbGV0ZSB2aWV3LlxuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKG5ldyBTeW5jUG9pbnQuX19yZWZlcmVuY2VDb25zdHJ1Y3RvcihxdWVyeS5yZXBvLCBxdWVyeS5wYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmVtb3ZlZDogcmVtb3ZlZCwgZXZlbnRzOiBjYW5jZWxFdmVudHMgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IVZpZXc+fVxuICAgICAqL1xuICAgIFN5bmNQb2ludC5wcm90b3R5cGUuZ2V0UXVlcnlWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMudmlld3NfKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gX3RoaXMudmlld3NfW2tleV07IH0pO1xuICAgICAgICByZXR1cm4gdmFsdWVzLmZpbHRlcihmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgcmV0dXJuICF2aWV3XG4gICAgICAgICAgICAgICAgLmdldFF1ZXJ5KClcbiAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbXMoKVxuICAgICAgICAgICAgICAgIC5sb2Fkc0FsbERhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIHBhdGggdG8gdGhlIGRlc2lyZWQgY29tcGxldGUgc25hcHNob3RcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX0gQSBjb21wbGV0ZSBjYWNoZSwgaWYgaXQgZXhpc3RzXG4gICAgICovXG4gICAgU3luY1BvaW50LnByb3RvdHlwZS5nZXRDb21wbGV0ZVNlcnZlckNhY2hlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHNlcnZlckNhY2hlID0gbnVsbDtcbiAgICAgICAgdXRpbF8yLmZvckVhY2godGhpcy52aWV3c18sIGZ1bmN0aW9uIChrZXksIHZpZXcpIHtcbiAgICAgICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUgfHwgdmlldy5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKHBhdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcnZlckNhY2hlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHJldHVybiB7P1ZpZXd9XG4gICAgICovXG4gICAgU3luY1BvaW50LnByb3RvdHlwZS52aWV3Rm9yUXVlcnkgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCk7XG4gICAgICAgIGlmIChwYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXRlVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5SWQgPSBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzIuc2FmZUdldCh0aGlzLnZpZXdzXywgcXVlcnlJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgU3luY1BvaW50LnByb3RvdHlwZS52aWV3RXhpc3RzRm9yUXVlcnkgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0ZvclF1ZXJ5KHF1ZXJ5KSAhPSBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBTeW5jUG9pbnQucHJvdG90eXBlLmhhc0NvbXBsZXRlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcGxldGVWaWV3KCkgIT0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez9WaWV3fVxuICAgICAqL1xuICAgIFN5bmNQb2ludC5wcm90b3R5cGUuZ2V0Q29tcGxldGVWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcGxldGVWaWV3ID0gdXRpbF8yLmZpbmRWYWx1ZSh0aGlzLnZpZXdzXywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3XG4gICAgICAgICAgICAgICAgLmdldFF1ZXJ5KClcbiAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbXMoKVxuICAgICAgICAgICAgICAgIC5sb2Fkc0FsbERhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZVZpZXcgfHwgbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBTeW5jUG9pbnQ7XG59KCkpO1xuZXhwb3J0cy5TeW5jUG9pbnQgPSBTeW5jUG9pbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5bmNQb2ludC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4vdXRpbC91dGlsXCIpO1xudmFyIEFja1VzZXJXcml0ZV8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uL0Fja1VzZXJXcml0ZVwiKTtcbnZhciBDaGlsZHJlbk5vZGVfMSA9IHJlcXVpcmUoXCIuL3NuYXAvQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIHV0aWxfMyA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBJbW11dGFibGVUcmVlXzEgPSByZXF1aXJlKFwiLi91dGlsL0ltbXV0YWJsZVRyZWVcIik7XG52YXIgTGlzdGVuQ29tcGxldGVfMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbi9MaXN0ZW5Db21wbGV0ZVwiKTtcbnZhciBNZXJnZV8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uL01lcmdlXCIpO1xudmFyIE9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uL09wZXJhdGlvblwiKTtcbnZhciBPdmVyd3JpdGVfMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbi9PdmVyd3JpdGVcIik7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4vdXRpbC9QYXRoXCIpO1xudmFyIFN5bmNQb2ludF8xID0gcmVxdWlyZShcIi4vU3luY1BvaW50XCIpO1xudmFyIFdyaXRlVHJlZV8xID0gcmVxdWlyZShcIi4vV3JpdGVUcmVlXCIpO1xuLyoqXG4gKiBTeW5jVHJlZSBpcyB0aGUgY2VudHJhbCBjbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnQgY2FsbGJhY2sgcmVnaXN0cmF0aW9uLCBkYXRhIGNhY2hpbmcsIHZpZXdzXG4gKiAocXVlcnkgcHJvY2Vzc2luZyksIGFuZCBldmVudCBnZW5lcmF0aW9uLiAgVGhlcmUgYXJlIHR5cGljYWxseSB0d28gU3luY1RyZWUgaW5zdGFuY2VzIGZvclxuICogZWFjaCBSZXBvLCBvbmUgZm9yIHRoZSBub3JtYWwgRmlyZWJhc2UgZGF0YSwgYW5kIG9uZSBmb3IgdGhlIC5pbmZvIGRhdGEuXG4gKlxuICogSXQgaGFzIGEgbnVtYmVyIG9mIHJlc3BvbnNpYmlsaXRpZXMsIGluY2x1ZGluZzpcbiAqICAtIFRyYWNraW5nIGFsbCB1c2VyIGV2ZW50IGNhbGxiYWNrcyAocmVnaXN0ZXJlZCB2aWEgYWRkRXZlbnRSZWdpc3RyYXRpb24oKSBhbmQgcmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oKSkuXG4gKiAgLSBBcHBseWluZyBhbmQgY2FjaGluZyBkYXRhIGNoYW5nZXMgZm9yIHVzZXIgc2V0KCksIHRyYW5zYWN0aW9uKCksIGFuZCB1cGRhdGUoKSBjYWxsc1xuICogICAgKGFwcGx5VXNlck92ZXJ3cml0ZSgpLCBhcHBseVVzZXJNZXJnZSgpKS5cbiAqICAtIEFwcGx5aW5nIGFuZCBjYWNoaW5nIGRhdGEgY2hhbmdlcyBmb3Igc2VydmVyIGRhdGEgY2hhbmdlcyAoYXBwbHlTZXJ2ZXJPdmVyd3JpdGUoKSxcbiAqICAgIGFwcGx5U2VydmVyTWVyZ2UoKSkuXG4gKiAgLSBHZW5lcmF0aW5nIHVzZXItZmFjaW5nIGV2ZW50cyBmb3Igc2VydmVyIGFuZCB1c2VyIGNoYW5nZXMgKGFsbCBvZiB0aGUgYXBwbHkqIG1ldGhvZHNcbiAqICAgIHJldHVybiB0aGUgc2V0IG9mIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgcmFpc2VkIGFzIGEgcmVzdWx0KS5cbiAqICAtIE1haW50YWluaW5nIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc2VydmVyIGxpc3RlbnMgdG8gZW5zdXJlIHdlIGFyZSBhbHdheXMgc3Vic2NyaWJlZFxuICogICAgdG8gdGhlIGNvcnJlY3Qgc2V0IG9mIHBhdGhzIGFuZCBxdWVyaWVzIHRvIHNhdGlzZnkgdGhlIGN1cnJlbnQgc2V0IG9mIHVzZXIgZXZlbnRcbiAqICAgIGNhbGxiYWNrcyAobGlzdGVucyBhcmUgc3RhcnRlZC9zdG9wcGVkIHVzaW5nIHRoZSBwcm92aWRlZCBsaXN0ZW5Qcm92aWRlcikuXG4gKlxuICogTk9URTogQWx0aG91Z2ggU3luY1RyZWUgdHJhY2tzIGV2ZW50IGNhbGxiYWNrcyBhbmQgY2FsY3VsYXRlcyBldmVudHMgdG8gcmFpc2UsIHRoZSBhY3R1YWxcbiAqIGV2ZW50cyBhcmUgcmV0dXJuZWQgdG8gdGhlIGNhbGxlciByYXRoZXIgdGhhbiByYWlzZWQgc3luY2hyb25vdXNseS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFN5bmNUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUxpc3RlblByb3ZpZGVyfSBsaXN0ZW5Qcm92aWRlcl8gVXNlZCBieSBTeW5jVHJlZSB0byBzdGFydCAvIHN0b3AgbGlzdGVuaW5nXG4gICAgICogICB0byBzZXJ2ZXIgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTeW5jVHJlZShsaXN0ZW5Qcm92aWRlcl8pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5Qcm92aWRlcl8gPSBsaXN0ZW5Qcm92aWRlcl87XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmVlIG9mIFN5bmNQb2ludHMuICBUaGVyZSdzIGEgU3luY1BvaW50IGF0IGFueSBsb2NhdGlvbiB0aGF0IGhhcyAxIG9yIG1vcmUgdmlld3MuXG4gICAgICAgICAqIEB0eXBlIHshSW1tdXRhYmxlVHJlZS48IVN5bmNQb2ludD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN5bmNQb2ludFRyZWVfID0gSW1tdXRhYmxlVHJlZV8xLkltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHRyZWUgb2YgYWxsIHBlbmRpbmcgdXNlciB3cml0ZXMgKHVzZXItaW5pdGlhdGVkIHNldCgpJ3MsIHRyYW5zYWN0aW9uKCkncywgdXBkYXRlKCkncywgZXRjLikuXG4gICAgICAgICAqIEB0eXBlIHshV3JpdGVUcmVlfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVUcmVlXyA9IG5ldyBXcml0ZVRyZWVfMS5Xcml0ZVRyZWUoKTtcbiAgICAgICAgdGhpcy50YWdUb1F1ZXJ5TWFwXyA9IHt9O1xuICAgICAgICB0aGlzLnF1ZXJ5VG9UYWdNYXBfID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBkYXRhIGNoYW5nZXMgZm9yIGEgdXNlci1nZW5lcmF0ZWQgc2V0KCkgb3IgdHJhbnNhY3Rpb24oKSBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5ld0RhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd3JpdGVJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHZpc2libGVcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlVc2VyT3ZlcndyaXRlID0gZnVuY3Rpb24gKHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpIHtcbiAgICAgICAgLy8gUmVjb3JkIHBlbmRpbmcgd3JpdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ1dyaXRlVHJlZV8uYWRkT3ZlcndyaXRlKHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpO1xuICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhuZXcgT3ZlcndyaXRlXzEuT3ZlcndyaXRlKE9wZXJhdGlvbl8xLk9wZXJhdGlvblNvdXJjZS5Vc2VyLCBwYXRoLCBuZXdEYXRhKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBkYXRhIGZyb20gYSB1c2VyLWdlbmVyYXRlZCB1cGRhdGUoKSBjYWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBFdmVudHMgdG8gcmFpc2UuXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFwcGx5VXNlck1lcmdlID0gZnVuY3Rpb24gKHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVJZCkge1xuICAgICAgICAvLyBSZWNvcmQgcGVuZGluZyBtZXJnZS5cbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5hZGRNZXJnZShwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpO1xuICAgICAgICB2YXIgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWVfMS5JbW11dGFibGVUcmVlLmZyb21PYmplY3QoY2hhbmdlZENoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKG5ldyBNZXJnZV8xLk1lcmdlKE9wZXJhdGlvbl8xLk9wZXJhdGlvblNvdXJjZS5Vc2VyLCBwYXRoLCBjaGFuZ2VUcmVlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBY2tub3dsZWRnZSBhIHBlbmRpbmcgdXNlciB3cml0ZSB0aGF0IHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhcHBseVVzZXJPdmVyd3JpdGUoKSBvciBhcHBseVVzZXJNZXJnZSgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcmV2ZXJ0IFRydWUgaWYgdGhlIGdpdmVuIHdyaXRlIGZhaWxlZCBhbmQgbmVlZHMgdG8gYmUgcmV2ZXJ0ZWRcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYWNrVXNlcldyaXRlID0gZnVuY3Rpb24gKHdyaXRlSWQsIHJldmVydCkge1xuICAgICAgICBpZiAocmV2ZXJ0ID09PSB2b2lkIDApIHsgcmV2ZXJ0ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHdyaXRlID0gdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5nZXRXcml0ZSh3cml0ZUlkKTtcbiAgICAgICAgdmFyIG5lZWRUb1JlZXZhbHVhdGUgPSB0aGlzLnBlbmRpbmdXcml0ZVRyZWVfLnJlbW92ZVdyaXRlKHdyaXRlSWQpO1xuICAgICAgICBpZiAoIW5lZWRUb1JlZXZhbHVhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZFRyZWVfMSA9IEltbXV0YWJsZVRyZWVfMS5JbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICAgICAgaWYgKHdyaXRlLnNuYXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIG92ZXJ3cml0ZVxuICAgICAgICAgICAgICAgIGFmZmVjdGVkVHJlZV8xID0gYWZmZWN0ZWRUcmVlXzEuc2V0KFBhdGhfMS5QYXRoLkVtcHR5LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWxfMy5mb3JFYWNoKHdyaXRlLmNoaWxkcmVuLCBmdW5jdGlvbiAocGF0aFN0cmluZywgbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZFRyZWVfMSA9IGFmZmVjdGVkVHJlZV8xLnNldChuZXcgUGF0aF8xLlBhdGgocGF0aFN0cmluZyksIG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKG5ldyBBY2tVc2VyV3JpdGVfMS5BY2tVc2VyV3JpdGUod3JpdGUucGF0aCwgYWZmZWN0ZWRUcmVlXzEsIHJldmVydCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSBuZXcgc2VydmVyIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshTm9kZX0gbmV3RGF0YVxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5hcHBseVNlcnZlck92ZXJ3cml0ZSA9IGZ1bmN0aW9uIChwYXRoLCBuZXdEYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhuZXcgT3ZlcndyaXRlXzEuT3ZlcndyaXRlKE9wZXJhdGlvbl8xLk9wZXJhdGlvblNvdXJjZS5TZXJ2ZXIsIHBhdGgsIG5ld0RhdGEpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSB0byBiZSBtZXJnZWQgaW4gYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCAhTm9kZT59IGNoYW5nZWRDaGlsZHJlblxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5hcHBseVNlcnZlck1lcmdlID0gZnVuY3Rpb24gKHBhdGgsIGNoYW5nZWRDaGlsZHJlbikge1xuICAgICAgICB2YXIgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWVfMS5JbW11dGFibGVUcmVlLmZyb21PYmplY3QoY2hhbmdlZENoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKG5ldyBNZXJnZV8xLk1lcmdlKE9wZXJhdGlvbl8xLk9wZXJhdGlvblNvdXJjZS5TZXJ2ZXIsIHBhdGgsIGNoYW5nZVRyZWUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgbGlzdGVuIGNvbXBsZXRlIGZvciBhIHF1ZXJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBFdmVudHMgdG8gcmFpc2UuXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFwcGx5TGlzdGVuQ29tcGxldGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18obmV3IExpc3RlbkNvbXBsZXRlXzEuTGlzdGVuQ29tcGxldGUoT3BlcmF0aW9uXzEuT3BlcmF0aW9uU291cmNlLlNlcnZlciwgcGF0aCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgbmV3IHNlcnZlciBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIHRhZ2dlZCBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBzbmFwXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB0YWdcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZSA9IGZ1bmN0aW9uIChwYXRoLCBzbmFwLCB0YWcpIHtcbiAgICAgICAgdmFyIHF1ZXJ5S2V5ID0gdGhpcy5xdWVyeUtleUZvclRhZ18odGFnKTtcbiAgICAgICAgaWYgKHF1ZXJ5S2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByID0gU3luY1RyZWUucGFyc2VRdWVyeUtleV8ocXVlcnlLZXkpO1xuICAgICAgICAgICAgdmFyIHF1ZXJ5UGF0aCA9IHIucGF0aCwgcXVlcnlJZCA9IHIucXVlcnlJZDtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVBhdGggPSBQYXRoXzEuUGF0aC5yZWxhdGl2ZVBhdGgocXVlcnlQYXRoLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBvcCA9IG5ldyBPdmVyd3JpdGVfMS5PdmVyd3JpdGUoT3BlcmF0aW9uXzEuT3BlcmF0aW9uU291cmNlLmZvclNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgsIHNuYXApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUYWdnZWRPcGVyYXRpb25fKHF1ZXJ5UGF0aCwgb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUXVlcnkgbXVzdCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IHNlcnZlciBkYXRhIHRvIGJlIG1lcmdlZCBpbiBmb3IgdGhlIHNwZWNpZmllZCB0YWdnZWQgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB0YWdcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlUYWdnZWRRdWVyeU1lcmdlID0gZnVuY3Rpb24gKHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgdGFnKSB7XG4gICAgICAgIHZhciBxdWVyeUtleSA9IHRoaXMucXVlcnlLZXlGb3JUYWdfKHRhZyk7XG4gICAgICAgIGlmIChxdWVyeUtleSkge1xuICAgICAgICAgICAgdmFyIHIgPSBTeW5jVHJlZS5wYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XG4gICAgICAgICAgICB2YXIgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlUGF0aCA9IFBhdGhfMS5QYXRoLnJlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xuICAgICAgICAgICAgdmFyIGNoYW5nZVRyZWUgPSBJbW11dGFibGVUcmVlXzEuSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0KGNoYW5nZWRDaGlsZHJlbik7XG4gICAgICAgICAgICB2YXIgb3AgPSBuZXcgTWVyZ2VfMS5NZXJnZShPcGVyYXRpb25fMS5PcGVyYXRpb25Tb3VyY2UuZm9yU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCksIHJlbGF0aXZlUGF0aCwgY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRhZ2dlZE9wZXJhdGlvbl8ocXVlcnlQYXRoLCBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IHJlbW92ZWQgdGhlIHF1ZXJ5LiBObyBiaWcgZGVhbCwgaWdub3JlIHRoZSB1cGRhdGVcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBsaXN0ZW4gY29tcGxldGUgZm9yIGEgdGFnZ2VkIHF1ZXJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB0YWdcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlUYWdnZWRMaXN0ZW5Db21wbGV0ZSA9IGZ1bmN0aW9uIChwYXRoLCB0YWcpIHtcbiAgICAgICAgdmFyIHF1ZXJ5S2V5ID0gdGhpcy5xdWVyeUtleUZvclRhZ18odGFnKTtcbiAgICAgICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICAgICAgICB2YXIgciA9IFN5bmNUcmVlLnBhcnNlUXVlcnlLZXlfKHF1ZXJ5S2V5KTtcbiAgICAgICAgICAgIHZhciBxdWVyeVBhdGggPSByLnBhdGgsIHF1ZXJ5SWQgPSByLnF1ZXJ5SWQ7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVQYXRoID0gUGF0aF8xLlBhdGgucmVsYXRpdmVQYXRoKHF1ZXJ5UGF0aCwgcGF0aCk7XG4gICAgICAgICAgICB2YXIgb3AgPSBuZXcgTGlzdGVuQ29tcGxldGVfMS5MaXN0ZW5Db21wbGV0ZShPcGVyYXRpb25fMS5PcGVyYXRpb25Tb3VyY2UuZm9yU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCksIHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRhZ2dlZE9wZXJhdGlvbl8ocXVlcnlQYXRoLCBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IHJlbW92ZWQgdGhlIHF1ZXJ5LiBObyBiaWcgZGVhbCwgaWdub3JlIHRoZSB1cGRhdGVcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGNhbGxiYWNrIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHshRXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBFdmVudHMgdG8gcmFpc2UuXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFkZEV2ZW50UmVnaXN0cmF0aW9uID0gZnVuY3Rpb24gKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbikge1xuICAgICAgICB2YXIgcGF0aCA9IHF1ZXJ5LnBhdGg7XG4gICAgICAgIHZhciBzZXJ2ZXJDYWNoZSA9IG51bGw7XG4gICAgICAgIHZhciBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPSBmYWxzZTtcbiAgICAgICAgLy8gQW55IGNvdmVyaW5nIHdyaXRlcyB3aWxsIG5lY2Vzc2FyaWx5IGJlIGF0IHRoZSByb290LCBzbyByZWFsbHkgYWxsIHdlIG5lZWQgdG8gZmluZCBpcyB0aGUgc2VydmVyIGNhY2hlLlxuICAgICAgICAvLyBDb25zaWRlciBvcHRpbWl6aW5nIHRoaXMgb25jZSB0aGVyZSdzIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2Ygd2hhdCBhY3R1YWwgYmVoYXZpb3Igd2lsbCBiZS5cbiAgICAgICAgdGhpcy5zeW5jUG9pbnRUcmVlXy5mb3JlYWNoT25QYXRoKHBhdGgsIGZ1bmN0aW9uIChwYXRoVG9TeW5jUG9pbnQsIHNwKSB7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVQYXRoID0gUGF0aF8xLlBhdGgucmVsYXRpdmVQYXRoKHBhdGhUb1N5bmNQb2ludCwgcGF0aCk7XG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlIHx8IHNwLmdldENvbXBsZXRlU2VydmVyQ2FjaGUocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyA9XG4gICAgICAgICAgICAgICAgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3IHx8IHNwLmhhc0NvbXBsZXRlVmlldygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN5bmNQb2ludCA9IHRoaXMuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoIXN5bmNQb2ludCkge1xuICAgICAgICAgICAgc3luY1BvaW50ID0gbmV3IFN5bmNQb2ludF8xLlN5bmNQb2ludCgpO1xuICAgICAgICAgICAgdGhpcy5zeW5jUG9pbnRUcmVlXyA9IHRoaXMuc3luY1BvaW50VHJlZV8uc2V0KHBhdGgsIHN5bmNQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxuICAgICAgICAgICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyB8fCBzeW5jUG9pbnQuaGFzQ29tcGxldGVWaWV3KCk7XG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludC5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKFBhdGhfMS5QYXRoLkVtcHR5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VydmVyQ2FjaGVDb21wbGV0ZTtcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlcnZlckNhY2hlQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgIHZhciBzdWJ0cmVlID0gdGhpcy5zeW5jUG9pbnRUcmVlXy5zdWJ0cmVlKHBhdGgpO1xuICAgICAgICAgICAgc3VidHJlZS5mb3JlYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkTmFtZSwgY2hpbGRTeW5jUG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVDYWNoZSA9IGNoaWxkU3luY1BvaW50LmdldENvbXBsZXRlU2VydmVyQ2FjaGUoUGF0aF8xLlBhdGguRW1wdHkpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBjb21wbGV0ZUNhY2hlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlld0FscmVhZHlFeGlzdHMgPSBzeW5jUG9pbnQudmlld0V4aXN0c0ZvclF1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgaWYgKCF2aWV3QWxyZWFkeUV4aXN0cyAmJiAhcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5sb2Fkc0FsbERhdGEoKSkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0cmFjayBhIHRhZyBmb3IgdGhpcyBxdWVyeVxuICAgICAgICAgICAgdmFyIHF1ZXJ5S2V5ID0gU3luY1RyZWUubWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KCEocXVlcnlLZXkgaW4gdGhpcy5xdWVyeVRvVGFnTWFwXyksICdWaWV3IGRvZXMgbm90IGV4aXN0LCBidXQgd2UgaGF2ZSBhIHRhZycpO1xuICAgICAgICAgICAgdmFyIHRhZyA9IFN5bmNUcmVlLmdldE5leHRRdWVyeVRhZ18oKTtcbiAgICAgICAgICAgIHRoaXMucXVlcnlUb1RhZ01hcF9bcXVlcnlLZXldID0gdGFnO1xuICAgICAgICAgICAgLy8gQ29lcmNlIHRvIHN0cmluZyB0byBhdm9pZCBzcGFyc2UgYXJyYXlzLlxuICAgICAgICAgICAgdGhpcy50YWdUb1F1ZXJ5TWFwX1snXycgKyB0YWddID0gcXVlcnlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyaXRlc0NhY2hlID0gdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5jaGlsZFdyaXRlcyhwYXRoKTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHN5bmNQb2ludC5hZGRFdmVudFJlZ2lzdHJhdGlvbihxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XG4gICAgICAgIGlmICghdmlld0FscmVhZHlFeGlzdHMgJiYgIWZvdW5kQW5jZXN0b3JEZWZhdWx0Vmlldykge1xuICAgICAgICAgICAgdmFyIHZpZXcgLyoqIEB0eXBlICFWaWV3ICovID0gc3luY1BvaW50LnZpZXdGb3JRdWVyeShxdWVyeSk7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHRoaXMuc2V0dXBMaXN0ZW5lcl8ocXVlcnksIHZpZXcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGNhbGxiYWNrKHMpLlxuICAgICAqXG4gICAgICogSWYgcXVlcnkgaXMgdGhlIGRlZmF1bHQgcXVlcnksIHdlJ2xsIGNoZWNrIGFsbCBxdWVyaWVzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50UmVnaXN0cmF0aW9uLlxuICAgICAqIElmIGV2ZW50UmVnaXN0cmF0aW9uIGlzIG51bGwsIHdlJ2xsIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5L3F1ZXJpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcGFyYW0gez9FdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb24gSWYgbnVsbCwgYWxsIGNhbGxiYWNrcyBhcmUgcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0ge0Vycm9yPX0gY2FuY2VsRXJyb3IgSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gQ2FuY2VsIGV2ZW50cywgaWYgY2FuY2VsRXJyb3Igd2FzIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5yZW1vdmVFdmVudFJlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uIChxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEZpbmQgdGhlIHN5bmNQb2ludCBmaXJzdC4gVGhlbiBkZWFsIHdpdGggd2hldGhlciBvciBub3QgaXQgaGFzIG1hdGNoaW5nIGxpc3RlbmVyc1xuICAgICAgICB2YXIgcGF0aCA9IHF1ZXJ5LnBhdGg7XG4gICAgICAgIHZhciBtYXliZVN5bmNQb2ludCA9IHRoaXMuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xuICAgICAgICB2YXIgY2FuY2VsRXZlbnRzID0gW107XG4gICAgICAgIC8vIEEgcmVtb3ZhbCBvbiBhIGRlZmF1bHQgcXVlcnkgYWZmZWN0cyBhbGwgcXVlcmllcyBhdCB0aGF0IGxvY2F0aW9uLiBBIHJlbW92YWwgb24gYW4gaW5kZXhlZCBxdWVyeSwgZXZlbiBvbmUgd2l0aG91dFxuICAgICAgICAvLyBvdGhlciBxdWVyeSBjb25zdHJhaW50cywgZG9lcyAqbm90KiBhZmZlY3QgYWxsIHF1ZXJpZXMgYXQgdGhhdCBsb2NhdGlvbi4gU28gdGhpcyBjaGVjayBtdXN0IGJlIGZvciAnZGVmYXVsdCcsIGFuZFxuICAgICAgICAvLyBub3QgbG9hZHNBbGxEYXRhKCkuXG4gICAgICAgIGlmIChtYXliZVN5bmNQb2ludCAmJlxuICAgICAgICAgICAgKHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpID09PSAnZGVmYXVsdCcgfHxcbiAgICAgICAgICAgICAgICBtYXliZVN5bmNQb2ludC52aWV3RXhpc3RzRm9yUXVlcnkocXVlcnkpKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7e3JlbW92ZWQ6ICFBcnJheS48IVF1ZXJ5PiwgZXZlbnRzOiAhQXJyYXkuPCFFdmVudD59fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZEFuZEV2ZW50cyA9IG1heWJlU3luY1BvaW50LnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpO1xuICAgICAgICAgICAgaWYgKG1heWJlU3luY1BvaW50LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3luY1BvaW50VHJlZV8gPSB0aGlzLnN5bmNQb2ludFRyZWVfLnJlbW92ZShwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gcmVtb3ZlZEFuZEV2ZW50cy5yZW1vdmVkO1xuICAgICAgICAgICAgY2FuY2VsRXZlbnRzID0gcmVtb3ZlZEFuZEV2ZW50cy5ldmVudHM7XG4gICAgICAgICAgICAvLyBXZSBtYXkgaGF2ZSBqdXN0IHJlbW92ZWQgb25lIG9mIG1hbnkgbGlzdGVuZXJzIGFuZCBjYW4gc2hvcnQtY2lyY3VpdCB0aGlzIHdob2xlIHByb2Nlc3NcbiAgICAgICAgICAgIC8vIFdlIG1heSBhbHNvIG5vdCBoYXZlIHJlbW92ZWQgYSBkZWZhdWx0IGxpc3RlbmVyLCBpbiB3aGljaCBjYXNlIGFsbCBvZiB0aGUgZGVzY2VuZGFudCBsaXN0ZW5lcnMgc2hvdWxkIGFscmVhZHkgYmVcbiAgICAgICAgICAgIC8vIHByb3Blcmx5IHNldCB1cC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTaW5jZSBpbmRleGVkIHF1ZXJpZXMgY2FuIHNoYWRvdyBpZiB0aGV5IGRvbid0IGhhdmUgb3RoZXIgcXVlcnkgY29uc3RyYWludHMsIGNoZWNrIGZvciBsb2Fkc0FsbERhdGEoKSwgaW5zdGVhZCBvZlxuICAgICAgICAgICAgLy8gcXVlcnlJZCA9PT0gJ2RlZmF1bHQnXG4gICAgICAgICAgICB2YXIgcmVtb3ZpbmdEZWZhdWx0ID0gLTEgIT09XG4gICAgICAgICAgICAgICAgcmVtb3ZlZC5maW5kSW5kZXgoZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGNvdmVyZWQgPSB0aGlzLnN5bmNQb2ludFRyZWVfLmZpbmRPblBhdGgocGF0aCwgZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgcGFyZW50U3luY1BvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFN5bmNQb2ludC5oYXNDb21wbGV0ZVZpZXcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlbW92aW5nRGVmYXVsdCAmJiAhY292ZXJlZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJ0cmVlID0gdGhpcy5zeW5jUG9pbnRUcmVlXy5zdWJ0cmVlKHBhdGgpO1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBwb3RlbnRpYWxseSBjaGlsZCBsaXN0ZW5lcnMuIERldGVybWluZSB3aGF0IGlmIGFueSBsaXN0ZW5zIHdlIG5lZWQgdG8gc2VuZCBiZWZvcmUgZXhlY3V0aW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlbW92YWxcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnRyZWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZm9sZCBvdmVyIG91ciBzdWJ0cmVlIGFuZCBjb2xsZWN0IHRoZSBsaXN0ZW5lcnMgdG8gc2VuZFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Vmlld3MgPSB0aGlzLmNvbGxlY3REaXN0aW5jdFZpZXdzRm9yU3ViVHJlZV8oc3VidHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9rLCB3ZSd2ZSBjb2xsZWN0ZWQgYWxsIHRoZSBsaXN0ZW5zIHdlIG5lZWQuIFNldCB0aGVtIHVwLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1ZpZXdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlldyA9IG5ld1ZpZXdzW2ldLCBuZXdRdWVyeSA9IHZpZXcuZ2V0UXVlcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuY3JlYXRlTGlzdGVuZXJGb3JWaWV3Xyh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKFN5bmNUcmVlLnF1ZXJ5Rm9yTGlzdGVuaW5nXyhuZXdRdWVyeSksIHRoaXMudGFnRm9yUXVlcnlfKG5ld1F1ZXJ5KSwgbGlzdGVuZXIuaGFzaEZuLCBsaXN0ZW5lci5vbkNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUncyBub3RoaW5nIGJlbG93IHVzLCBzbyBub3RoaW5nIHdlIG5lZWQgdG8gc3RhcnQgbGlzdGVuaW5nIG9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhbnl0aGluZyBhbmQgd2UncmUgbm90IGNvdmVyZWQgYnkgYSBoaWdoZXIgdXAgbGlzdGVuLCB3ZSBuZWVkIHRvIHN0b3AgbGlzdGVuaW5nIG9uIHRoaXMgcXVlcnlcbiAgICAgICAgICAgIC8vIFRoZSBhYm92ZSBibG9jayBoYXMgdXMgY292ZXJlZCBpbiB0ZXJtcyBvZiBtYWtpbmcgc3VyZSB3ZSdyZSBzZXQgdXAgb24gbGlzdGVucyBsb3dlciBpbiB0aGUgdHJlZS5cbiAgICAgICAgICAgIC8vIEFsc28sIG5vdGUgdGhhdCBpZiB3ZSBoYXZlIGEgY2FuY2VsRXJyb3IsIGl0J3MgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYXQgdGhlIHByb3ZpZGVyIGxldmVsLlxuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkICYmIHJlbW92ZWQubGVuZ3RoID4gMCAmJiAhY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZW1vdmVkIGEgZGVmYXVsdCwgdGhlbiB3ZSB3ZXJlbid0IGxpc3RlbmluZyBvbiBhbnkgb2YgdGhlIG90aGVyIHF1ZXJpZXMgaGVyZS4gSnVzdCBjYW5jZWwgdGhlIG9uZVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQuIE90aGVyd2lzZSwgd2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggYW5kIGNhbmNlbCBlYWNoIGluZGl2aWR1YWwgcXVlcnlcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZpbmdEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHRhZyBkZWZhdWx0IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFRhZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoU3luY1RyZWUucXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5KSwgZGVmYXVsdFRhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5VG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWdUb1JlbW92ZSA9IF90aGlzLnF1ZXJ5VG9UYWdNYXBfW1N5bmNUcmVlLm1ha2VRdWVyeUtleV8ocXVlcnlUb1JlbW92ZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoU3luY1RyZWUucXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9SZW1vdmUpLCB0YWdUb1JlbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdywgY2xlYXIgYWxsIG9mIHRoZSB0YWdzIHdlJ3JlIHRyYWNraW5nIGZvciB0aGUgcmVtb3ZlZCBsaXN0ZW5zXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRhZ3NfKHJlbW92ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8tb3AsIHRoaXMgbGlzdGVuZXIgbXVzdCd2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5jZWxFdmVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29tcGxldGUgY2FjaGUsIGlmIHdlIGhhdmUgb25lLCBvZiB0aGUgZGF0YSBhdCBhIHBhcnRpY3VsYXIgcGF0aC4gVGhlIGxvY2F0aW9uIG11c3QgaGF2ZSBhIGxpc3RlbmVyIGFib3ZlXG4gICAgICogaXQsIGJ1dCBhcyB0aGlzIGlzIG9ubHkgdXNlZCBieSB0cmFuc2FjdGlvbiBjb2RlLCB0aGF0IHNob3VsZCBhbHdheXMgYmUgdGhlIGNhc2UgYW55d2F5cy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIHdpbGwgKmluY2x1ZGUqIGhpZGRlbiB3cml0ZXMgZnJvbSB0cmFuc2FjdGlvbiB3aXRoIGFwcGx5TG9jYWxseSBzZXQgdG8gZmFsc2UuXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCB0byB0aGUgZGF0YSB3ZSB3YW50XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IHdyaXRlSWRzVG9FeGNsdWRlIEEgc3BlY2lmaWMgc2V0IHRvIGJlIGV4Y2x1ZGVkXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUgPSBmdW5jdGlvbiAocGF0aCwgd3JpdGVJZHNUb0V4Y2x1ZGUpIHtcbiAgICAgICAgdmFyIGluY2x1ZGVIaWRkZW5TZXRzID0gdHJ1ZTtcbiAgICAgICAgdmFyIHdyaXRlVHJlZSA9IHRoaXMucGVuZGluZ1dyaXRlVHJlZV87XG4gICAgICAgIHZhciBzZXJ2ZXJDYWNoZSA9IHRoaXMuc3luY1BvaW50VHJlZV8uZmluZE9uUGF0aChwYXRoLCBmdW5jdGlvbiAocGF0aFNvRmFyLCBzeW5jUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVBhdGggPSBQYXRoXzEuUGF0aC5yZWxhdGl2ZVBhdGgocGF0aFNvRmFyLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludC5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICBpZiAoc2VydmVyQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VydmVyQ2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd3JpdGVUcmVlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocGF0aCwgc2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuU2V0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbGxhcHNlcyBtdWx0aXBsZSB1bmZpbHRlcmVkIHZpZXdzIGludG8gYSBzaW5nbGUgdmlldywgc2luY2Ugd2Ugb25seSBuZWVkIGEgc2luZ2xlXG4gICAgICogbGlzdGVuZXIgZm9yIHRoZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFJbW11dGFibGVUcmVlLjwhU3luY1BvaW50Pn0gc3VidHJlZVxuICAgICAqIEByZXR1cm4geyFBcnJheS48IVZpZXc+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmNvbGxlY3REaXN0aW5jdFZpZXdzRm9yU3ViVHJlZV8gPSBmdW5jdGlvbiAoc3VidHJlZSkge1xuICAgICAgICByZXR1cm4gc3VidHJlZS5mb2xkKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIG1heWJlQ2hpbGRTeW5jUG9pbnQsIGNoaWxkTWFwKSB7XG4gICAgICAgICAgICBpZiAobWF5YmVDaGlsZFN5bmNQb2ludCAmJiBtYXliZUNoaWxkU3luY1BvaW50Lmhhc0NvbXBsZXRlVmlldygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlVmlldyA9IG1heWJlQ2hpbGRTeW5jUG9pbnQuZ2V0Q29tcGxldGVWaWV3KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjb21wbGV0ZVZpZXddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gY29tcGxldGUgdmlldyBoZXJlLCBmbGF0dGVuIGFueSBkZWVwZXIgbGlzdGVucyBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVDaGlsZFN5bmNQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3c18xID0gbWF5YmVDaGlsZFN5bmNQb2ludC5nZXRRdWVyeVZpZXdzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHV0aWxfMy5mb3JFYWNoKGNoaWxkTWFwLCBmdW5jdGlvbiAoa2V5LCBjaGlsZFZpZXdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdzXzEgPSB2aWV3c18xLmNvbmNhdChjaGlsZFZpZXdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlld3NfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IVF1ZXJ5Pn0gcXVlcmllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLnJlbW92ZVRhZ3NfID0gZnVuY3Rpb24gKHF1ZXJpZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBxdWVyaWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlZFF1ZXJ5ID0gcXVlcmllc1tqXTtcbiAgICAgICAgICAgIGlmICghcmVtb3ZlZFF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkubG9hZHNBbGxEYXRhKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgaGF2ZSBhIHRhZyBmb3IgdGhpc1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkUXVlcnlLZXkgPSBTeW5jVHJlZS5tYWtlUXVlcnlLZXlfKHJlbW92ZWRRdWVyeSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRRdWVyeVRhZyA9IHRoaXMucXVlcnlUb1RhZ01hcF9bcmVtb3ZlZFF1ZXJ5S2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5xdWVyeVRvVGFnTWFwX1tyZW1vdmVkUXVlcnlLZXldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhZ1RvUXVlcnlNYXBfWydfJyArIHJlbW92ZWRRdWVyeVRhZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSBxdWVyeSB0byBhIHF1ZXJ5IHdlIHNlbmQgdGhlIHNlcnZlciBmb3IgbGlzdGVuaW5nXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHJldHVybiB7IVF1ZXJ5fSBUaGUgbm9ybWFsaXplZCBxdWVyeVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucXVlcnlGb3JMaXN0ZW5pbmdfID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIGlmIChxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpICYmXG4gICAgICAgICAgICAhcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5pc0RlZmF1bHQoKSkge1xuICAgICAgICAgICAgLy8gV2UgdHJlYXQgcXVlcmllcyB0aGF0IGxvYWQgYWxsIGRhdGEgYXMgZGVmYXVsdCBxdWVyaWVzXG4gICAgICAgICAgICAvLyBDYXN0IGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHJlZigpIHRlY2huaWNhbGx5IHJldHVybnMgRmlyZWJhc2Ugd2hpY2ggaXMgYWN0dWFsbHkgZmIuYXBpLkZpcmViYXNlIHdoaWNoIGluaGVyaXRzXG4gICAgICAgICAgICAvLyBmcm9tIFF1ZXJ5XG4gICAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHshUXVlcnl9ICovIHF1ZXJ5LmdldFJlZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3IgYSBnaXZlbiBuZXcgbGlzdGVuLCBtYW5hZ2UgdGhlIGRlLWR1cGxpY2F0aW9uIG9mIG91dHN0YW5kaW5nIHN1YnNjcmlwdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcGFyYW0geyFWaWV3fSB2aWV3XG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBUaGlzIG1ldGhvZCBjYW4gcmV0dXJuIGV2ZW50cyB0byBzdXBwb3J0IHN5bmNocm9ub3VzIGRhdGEgc291cmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLnNldHVwTGlzdGVuZXJfID0gZnVuY3Rpb24gKHF1ZXJ5LCB2aWV3KSB7XG4gICAgICAgIHZhciBwYXRoID0gcXVlcnkucGF0aDtcbiAgICAgICAgdmFyIHRhZyA9IHRoaXMudGFnRm9yUXVlcnlfKHF1ZXJ5KTtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5jcmVhdGVMaXN0ZW5lckZvclZpZXdfKHZpZXcpO1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5saXN0ZW5Qcm92aWRlcl8uc3RhcnRMaXN0ZW5pbmcoU3luY1RyZWUucXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5KSwgdGFnLCBsaXN0ZW5lci5oYXNoRm4sIGxpc3RlbmVyLm9uQ29tcGxldGUpO1xuICAgICAgICB2YXIgc3VidHJlZSA9IHRoaXMuc3luY1BvaW50VHJlZV8uc3VidHJlZShwYXRoKTtcbiAgICAgICAgLy8gVGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlIGhhcyBvdXIgcXVlcnkuIFdlJ3JlIGhlcmUgYmVjYXVzZSB3ZSBkZWZpbml0ZWx5IG5lZWQgdG8gc2VuZCBhIGxpc3RlbiBmb3IgdGhhdCwgYnV0IHdlXG4gICAgICAgIC8vIG1heSBuZWVkIHRvIHNoYWRvdyBvdGhlciBsaXN0ZW5zIGFzIHdlbGwuXG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoIXN1YnRyZWUudmFsdWUuaGFzQ29tcGxldGVWaWV3KCksIFwiSWYgd2UncmUgYWRkaW5nIGEgcXVlcnksIGl0IHNob3VsZG4ndCBiZSBzaGFkb3dlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNoYWRvdyBldmVyeXRoaW5nIGF0IG9yIGJlbG93IHRoaXMgbG9jYXRpb24sIHRoaXMgaXMgYSBkZWZhdWx0IGxpc3RlbmVyLlxuICAgICAgICAgICAgdmFyIHF1ZXJpZXNUb1N0b3AgPSBzdWJ0cmVlLmZvbGQoZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGF0aC5pc0VtcHR5KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVDaGlsZFN5bmNQb2ludCAmJlxuICAgICAgICAgICAgICAgICAgICBtYXliZUNoaWxkU3luY1BvaW50Lmhhc0NvbXBsZXRlVmlldygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWF5YmVDaGlsZFN5bmNQb2ludC5nZXRDb21wbGV0ZVZpZXcoKS5nZXRRdWVyeSgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGRlZmF1bHQgbGlzdGVuZXIgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIHF1ZXJpZXMgaW50byBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVlcmllc18xID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVzXzEgPSBxdWVyaWVzXzEuY29uY2F0KG1heWJlQ2hpbGRTeW5jUG9pbnQuZ2V0UXVlcnlWaWV3cygpLm1hcChmdW5jdGlvbiAodmlldykgeyByZXR1cm4gdmlldy5nZXRRdWVyeSgpOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXRpbF8zLmZvckVhY2goY2hpbGRNYXAsIGZ1bmN0aW9uIChrZXksIGNoaWxkUXVlcmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcmllc18xID0gcXVlcmllc18xLmNvbmNhdChjaGlsZFF1ZXJpZXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJpZXNfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcmllc1RvU3RvcC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeVRvU3RvcCA9IHF1ZXJpZXNUb1N0b3BbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5Qcm92aWRlcl8uc3RvcExpc3RlbmluZyhTeW5jVHJlZS5xdWVyeUZvckxpc3RlbmluZ18ocXVlcnlUb1N0b3ApLCB0aGlzLnRhZ0ZvclF1ZXJ5XyhxdWVyeVRvU3RvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVZpZXd9IHZpZXdcbiAgICAgKiBAcmV0dXJuIHt7aGFzaEZuOiBmdW5jdGlvbigpLCBvbkNvbXBsZXRlOiBmdW5jdGlvbighc3RyaW5nLCAqKX19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuY3JlYXRlTGlzdGVuZXJGb3JWaWV3XyA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxdWVyeSA9IHZpZXcuZ2V0UXVlcnkoKTtcbiAgICAgICAgdmFyIHRhZyA9IHRoaXMudGFnRm9yUXVlcnlfKHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc2hGbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IHZpZXcuZ2V0U2VydmVyQ2FjaGUoKSB8fCBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuaGFzaCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcHBseVRhZ2dlZExpc3RlbkNvbXBsZXRlKHF1ZXJ5LnBhdGgsIHRhZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYXBwbHlMaXN0ZW5Db21wbGV0ZShxdWVyeS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBsaXN0ZW4gZmFpbGVkLCBraWxsIGFsbCBvZiB0aGUgbGlzdGVuZXJzIGhlcmUsIG5vdCBqdXN0IHRoZSBvbmUgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgbmVlZCB0byBiZSBzY29wZWQgdG8ganVzdCB0aGlzIGxpc3RlbmVyIGlmIHdlIGNoYW5nZSBwZXJtaXNzaW9ucyBvbiBmaWx0ZXJlZCBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB1dGlsXzIuZXJyb3JGb3JTZXJ2ZXJDb2RlKHN0YXR1cywgcXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24ocXVlcnksIFxuICAgICAgICAgICAgICAgICAgICAvKmV2ZW50UmVnaXN0cmF0aW9uKi8gbnVsbCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcXVlcnksIGNvbXB1dGVzIGEgXCJxdWVyeUtleVwiIHN1aXRhYmxlIGZvciB1c2UgaW4gb3VyIHF1ZXJ5VG9UYWdNYXBfLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIFN5bmNUcmVlLm1ha2VRdWVyeUtleV8gPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnBhdGgudG9TdHJpbmcoKSArICckJyArIHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBxdWVyeUtleSAoY3JlYXRlZCBieSBtYWtlUXVlcnlLZXkpLCBwYXJzZSBpdCBiYWNrIGludG8gYSBwYXRoIGFuZCBxdWVyeUlkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBxdWVyeUtleVxuICAgICAqIEByZXR1cm4ge3txdWVyeUlkOiAhc3RyaW5nLCBwYXRoOiAhUGF0aH19XG4gICAgICovXG4gICAgU3luY1RyZWUucGFyc2VRdWVyeUtleV8gPSBmdW5jdGlvbiAocXVlcnlLZXkpIHtcbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSBxdWVyeUtleS5pbmRleE9mKCckJyk7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQoc3BsaXRJbmRleCAhPT0gLTEgJiYgc3BsaXRJbmRleCA8IHF1ZXJ5S2V5Lmxlbmd0aCAtIDEsICdCYWQgcXVlcnlLZXkuJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWVyeUlkOiBxdWVyeUtleS5zdWJzdHIoc3BsaXRJbmRleCArIDEpLFxuICAgICAgICAgICAgcGF0aDogbmV3IFBhdGhfMS5QYXRoKHF1ZXJ5S2V5LnN1YnN0cigwLCBzcGxpdEluZGV4KSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcXVlcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiB0YWcsIGlmIHdlIGhhdmUgb25lXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB0YWdcbiAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLnF1ZXJ5S2V5Rm9yVGFnXyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnVG9RdWVyeU1hcF9bJ18nICsgdGFnXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdGFnIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcXVlcnkuXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHJldHVybiB7P251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS50YWdGb3JRdWVyeV8gPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIHF1ZXJ5S2V5ID0gU3luY1RyZWUubWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XG4gICAgICAgIHJldHVybiB1dGlsXzMuc2FmZUdldCh0aGlzLnF1ZXJ5VG9UYWdNYXBfLCBxdWVyeUtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGF0aWMgYWNjZXNzb3IgZm9yIHF1ZXJ5IHRhZ3MuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUuZ2V0TmV4dFF1ZXJ5VGFnXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFN5bmNUcmVlLm5leHRRdWVyeVRhZ18rKztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIG1ldGhvZCB0byBhcHBseSB0YWdnZWQgb3BlcmF0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcXVlcnlQYXRoXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlUYWdnZWRPcGVyYXRpb25fID0gZnVuY3Rpb24gKHF1ZXJ5UGF0aCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHZhciBzeW5jUG9pbnQgPSB0aGlzLnN5bmNQb2ludFRyZWVfLmdldChxdWVyeVBhdGgpO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHN5bmNQb2ludCwgXCJNaXNzaW5nIHN5bmMgcG9pbnQgZm9yIHF1ZXJ5IHRhZyB0aGF0IHdlJ3JlIHRyYWNraW5nXCIpO1xuICAgICAgICB2YXIgd3JpdGVzQ2FjaGUgPSB0aGlzLnBlbmRpbmdXcml0ZVRyZWVfLmNoaWxkV3JpdGVzKHF1ZXJ5UGF0aCk7XG4gICAgICAgIHJldHVybiBzeW5jUG9pbnQuYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgXG4gICAgICAgIC8qc2VydmVyQ2FjaGU9Ki8gbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBtZXRob2QgdGhhdCB2aXNpdHMgYWxsIGRlc2NlbmRhbnQgYW5kIGFuY2VzdG9yIFN5bmNQb2ludHMsIGFwcGx5aW5nIHRoZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBOT1RFUzpcbiAgICAgKiAtIERlc2NlbmRhbnQgU3luY1BvaW50cyB3aWxsIGJlIHZpc2l0ZWQgZmlyc3QgKHNpbmNlIHdlIHJhaXNlIGV2ZW50cyBkZXB0aC1maXJzdCkuXG4gIFxuICAgICAqIC0gV2UgY2FsbCBhcHBseU9wZXJhdGlvbigpIG9uIGVhY2ggU3luY1BvaW50IHBhc3NpbmcgdGhyZWUgdGhpbmdzOlxuICAgICAqICAgMS4gQSB2ZXJzaW9uIG9mIHRoZSBPcGVyYXRpb24gdGhhdCBoYXMgYmVlbiBtYWRlIHJlbGF0aXZlIHRvIHRoZSBTeW5jUG9pbnQgbG9jYXRpb24uXG4gICAgICogICAyLiBBIFdyaXRlVHJlZVJlZiBvZiBhbnkgd3JpdGVzIHdlIGhhdmUgY2FjaGVkIGF0IHRoZSBTeW5jUG9pbnQgbG9jYXRpb24uXG4gICAgICogICAzLiBBIHNuYXBzaG90IE5vZGUgd2l0aCBjYWNoZWQgc2VydmVyIGRhdGEsIGlmIHdlIGhhdmUgaXQuXG4gIFxuICAgICAqIC0gV2UgY29uY2F0ZW5hdGUgYWxsIG9mIHRoZSBldmVudHMgcmV0dXJuZWQgYnkgZWFjaCBTeW5jUG9pbnQgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfID0gZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU9wZXJhdGlvbkhlbHBlcl8ob3BlcmF0aW9uLCB0aGlzLnN5bmNQb2ludFRyZWVfLCBcbiAgICAgICAgLypzZXJ2ZXJDYWNoZT0qLyBudWxsLCB0aGlzLnBlbmRpbmdXcml0ZVRyZWVfLmNoaWxkV3JpdGVzKFBhdGhfMS5QYXRoLkVtcHR5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgaGVscGVyIGZvciBhcHBseU9wZXJhdGlvblRvU3luY1BvaW50c19cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge0ltbXV0YWJsZVRyZWUuPCFTeW5jUG9pbnQ+fSBzeW5jUG9pbnRUcmVlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gc2VydmVyQ2FjaGVcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5hcHBseU9wZXJhdGlvbkhlbHBlcl8gPSBmdW5jdGlvbiAob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5wYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25EZXNjZW5kYW50c0hlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN5bmNQb2ludCA9IHN5bmNQb2ludFRyZWUuZ2V0KFBhdGhfMS5QYXRoLkVtcHR5KTtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIHNlcnZlciBkYXRhLCBzZWUgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHRoaXMgU3luY1BvaW50LlxuICAgICAgICAgICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludC5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKFBhdGhfMS5QYXRoLkVtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5hbWUgPSBvcGVyYXRpb24ucGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkT3BlcmF0aW9uID0gb3BlcmF0aW9uLm9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRUcmVlID0gc3luY1BvaW50VHJlZS5jaGlsZHJlbi5nZXQoY2hpbGROYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUgJiYgY2hpbGRPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRTZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlXG4gICAgICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkV3JpdGVzQ2FjaGUgPSB3cml0ZXNDYWNoZS5jaGlsZChjaGlsZE5hbWUpO1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodGhpcy5hcHBseU9wZXJhdGlvbkhlbHBlcl8oY2hpbGRPcGVyYXRpb24sIGNoaWxkVHJlZSwgY2hpbGRTZXJ2ZXJDYWNoZSwgY2hpbGRXcml0ZXNDYWNoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN5bmNQb2ludCkge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1BvaW50LmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgaGVscGVyIGZvciBhcHBseU9wZXJhdGlvblRvU3luY1BvaW50c19cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge0ltbXV0YWJsZVRyZWUuPCFTeW5jUG9pbnQ+fSBzeW5jUG9pbnRUcmVlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gc2VydmVyQ2FjaGVcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5hcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3luY1BvaW50ID0gc3luY1BvaW50VHJlZS5nZXQoUGF0aF8xLlBhdGguRW1wdHkpO1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGNhY2hlZCBzZXJ2ZXIgZGF0YSwgc2VlIGlmIHdlIGNhbiBnZXQgaXQgZnJvbSB0aGlzIFN5bmNQb2ludC5cbiAgICAgICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlcnZlckNhY2hlID0gc3luY1BvaW50LmdldENvbXBsZXRlU2VydmVyQ2FjaGUoUGF0aF8xLlBhdGguRW1wdHkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgc3luY1BvaW50VHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkU2VydmVyQ2FjaGUgPSBzZXJ2ZXJDYWNoZVxuICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBjaGlsZFdyaXRlc0NhY2hlID0gd3JpdGVzQ2FjaGUuY2hpbGQoY2hpbGROYW1lKTtcbiAgICAgICAgICAgIHZhciBjaGlsZE9wZXJhdGlvbiA9IG9wZXJhdGlvbi5vcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpO1xuICAgICAgICAgICAgaWYgKGNoaWxkT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChfdGhpcy5hcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhjaGlsZE9wZXJhdGlvbiwgY2hpbGRUcmVlLCBjaGlsZFNlcnZlckNhY2hlLCBjaGlsZFdyaXRlc0NhY2hlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3luY1BvaW50KSB7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNQb2ludC5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGF0aWMgdHJhY2tlciBmb3IgbmV4dCBxdWVyeSB0YWcuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN5bmNUcmVlLm5leHRRdWVyeVRhZ18gPSAxO1xuICAgIHJldHVybiBTeW5jVHJlZTtcbn0oKSk7XG5leHBvcnRzLlN5bmNUcmVlID0gU3luY1RyZWU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5bmNUcmVlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4vdXRpbC9QYXRoXCIpO1xudmFyIENvbXBvdW5kV3JpdGVfMSA9IHJlcXVpcmUoXCIuL0NvbXBvdW5kV3JpdGVcIik7XG52YXIgUHJpb3JpdHlJbmRleF8xID0gcmVxdWlyZShcIi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG52YXIgQ2hpbGRyZW5Ob2RlXzEgPSByZXF1aXJlKFwiLi9zbmFwL0NoaWxkcmVuTm9kZVwiKTtcbi8qKlxuICogV3JpdGVUcmVlIHRyYWNrcyBhbGwgcGVuZGluZyB1c2VyLWluaXRpYXRlZCB3cml0ZXMgYW5kIGhhcyBtZXRob2RzIHRvIGNhbGN1bGF0ZSB0aGUgcmVzdWx0IG9mIG1lcmdpbmcgdGhlbVxuICogd2l0aCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhICh0byBjcmVhdGUgXCJldmVudCBjYWNoZVwiIGRhdGEpLiAgUGVuZGluZyB3cml0ZXMgYXJlIGFkZGVkIHdpdGggYWRkT3ZlcndyaXRlKClcbiAqIGFuZCBhZGRNZXJnZSgpLCBhbmQgcmVtb3ZlZCB3aXRoIHJlbW92ZVdyaXRlKCkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBXcml0ZVRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV3JpdGVUcmVlKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB0cmVlIHRyYWNraW5nIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYWxsIHZpc2libGUgd3JpdGVzLiAgVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRyYW5zYWN0aW9ucyB3aXRoXG4gICAgICAgICAqIGFwcGx5TG9jYWxseT1mYWxzZSBvciB3cml0ZXMgdGhhdCBhcmUgY29tcGxldGVseSBzaGFkb3dlZCBieSBvdGhlciB3cml0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHshQ29tcG91bmRXcml0ZX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZVdyaXRlc18gPSBDb21wb3VuZFdyaXRlXzEuQ29tcG91bmRXcml0ZS5FbXB0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBhbGwgcGVuZGluZyB3cml0ZXMsIHJlZ2FyZGxlc3Mgb2YgdmlzaWJpbGl0eSBhbmQgc2hhZG93ZWQtbmVzcy4gIFVzZWQgdG8gY2FsY3VsYXRlIGFyYml0cmFyeVxuICAgICAgICAgKiBzZXRzIG9mIHRoZSBjaGFuZ2VkIGRhdGEsIHN1Y2ggYXMgaGlkZGVuIHdyaXRlcyAoZnJvbSB0cmFuc2FjdGlvbnMpIG9yIGNoYW5nZXMgd2l0aCBjZXJ0YWluIHdyaXRlcyBleGNsdWRlZCAoYWxzb1xuICAgICAgICAgKiB1c2VkIGJ5IHRyYW5zYWN0aW9ucykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPCFXcml0ZVJlY29yZD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbFdyaXRlc18gPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0V3JpdGVJZF8gPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFdyaXRlVHJlZVJlZiBmb3IgdGhlIGdpdmVuIHBhdGguIEZvciB1c2Ugd2l0aCBhIG5ldyBzeW5jIHBvaW50IGF0IHRoZSBnaXZlbiBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEByZXR1cm4geyFXcml0ZVRyZWVSZWZ9XG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5jaGlsZFdyaXRlcyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVUcmVlUmVmKHBhdGgsIHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjb3JkIGEgbmV3IG92ZXJ3cml0ZSBmcm9tIHVzZXIgY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBzbmFwXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdmlzaWJsZSBUaGlzIGlzIHNldCB0byBmYWxzZSBieSBzb21lIHRyYW5zYWN0aW9ucy4gSXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gZXZlbnQgY2FjaGVzXG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5hZGRPdmVyd3JpdGUgPSBmdW5jdGlvbiAocGF0aCwgc25hcCwgd3JpdGVJZCwgdmlzaWJsZSkge1xuICAgICAgICB1dGlsXzIuYXNzZXJ0KHdyaXRlSWQgPiB0aGlzLmxhc3RXcml0ZUlkXywgJ1N0YWNraW5nIGFuIG9sZGVyIHdyaXRlIG9uIHRvcCBvZiBuZXdlciBvbmVzJyk7XG4gICAgICAgIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsV3JpdGVzXy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBzbmFwOiBzbmFwLFxuICAgICAgICAgICAgd3JpdGVJZDogd3JpdGVJZCxcbiAgICAgICAgICAgIHZpc2libGU6IHZpc2libGVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVXcml0ZXNfID0gdGhpcy52aXNpYmxlV3JpdGVzXy5hZGRXcml0ZShwYXRoLCBzbmFwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RXcml0ZUlkXyA9IHdyaXRlSWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWNvcmQgYSBuZXcgbWVyZ2UgZnJvbSB1c2VyIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5hZGRNZXJnZSA9IGZ1bmN0aW9uIChwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpIHtcbiAgICAgICAgdXRpbF8yLmFzc2VydCh3cml0ZUlkID4gdGhpcy5sYXN0V3JpdGVJZF8sICdTdGFja2luZyBhbiBvbGRlciBtZXJnZSBvbiB0b3Agb2YgbmV3ZXIgb25lcycpO1xuICAgICAgICB0aGlzLmFsbFdyaXRlc18ucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoYW5nZWRDaGlsZHJlbixcbiAgICAgICAgICAgIHdyaXRlSWQ6IHdyaXRlSWQsXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpc2libGVXcml0ZXNfID0gdGhpcy52aXNpYmxlV3JpdGVzXy5hZGRXcml0ZXMocGF0aCwgY2hhbmdlZENoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5sYXN0V3JpdGVJZF8gPSB3cml0ZUlkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAgICogQHJldHVybiB7P1dyaXRlUmVjb3JkfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuZ2V0V3JpdGUgPSBmdW5jdGlvbiAod3JpdGVJZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWxsV3JpdGVzXy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRoaXMuYWxsV3JpdGVzX1tpXTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQud3JpdGVJZCA9PT0gd3JpdGVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB3cml0ZSAoZWl0aGVyIGFuIG92ZXJ3cml0ZSBvciBtZXJnZSkgdGhhdCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgYWNrbm93bGVkZ2UgYnkgdGhlIHNlcnZlci4gUmVjYWxjdWxhdGVzXG4gICAgICogdGhlIHRyZWUgaWYgbmVjZXNzYXJ5LiAgV2UgcmV0dXJuIHRydWUgaWYgaXQgbWF5IGhhdmUgYmVlbiB2aXNpYmxlLCBtZWFuaW5nIHZpZXdzIG5lZWQgdG8gcmVldmFsdWF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gd3JpdGVJZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHdyaXRlIG1heSBoYXZlIGJlZW4gdmlzaWJsZSAobWVhbmluZyB3ZSdsbCBuZWVkIHRvIHJlZXZhbHVhdGUgLyByYWlzZVxuICAgICAqIGV2ZW50cyBhcyBhIHJlc3VsdCkuXG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5yZW1vdmVXcml0ZSA9IGZ1bmN0aW9uICh3cml0ZUlkKSB7XG4gICAgICAgIC8vIE5vdGU6IGRpc2FibGluZyB0aGlzIGNoZWNrLiBJdCBjb3VsZCBiZSBhIHRyYW5zYWN0aW9uIHRoYXQgcHJlZW1wdGVkIGFub3RoZXIgdHJhbnNhY3Rpb24sIGFuZCB0aHVzIHdhcyBhcHBsaWVkXG4gICAgICAgIC8vIG91dCBvZiBvcmRlci5cbiAgICAgICAgLy9jb25zdCB2YWxpZENsZWFyID0gcmV2ZXJ0IHx8IHRoaXMuYWxsV3JpdGVzXy5sZW5ndGggPT09IDAgfHwgd3JpdGVJZCA8PSB0aGlzLmFsbFdyaXRlc19bMF0ud3JpdGVJZDtcbiAgICAgICAgLy9hc3NlcnQodmFsaWRDbGVhciwgXCJFaXRoZXIgd2UgZG9uJ3QgaGF2ZSB0aGlzIHdyaXRlLCBvciBpdCdzIHRoZSBmaXJzdCBvbmUgaW4gdGhlIHF1ZXVlXCIpO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hbGxXcml0ZXNfLmZpbmRJbmRleChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIHMud3JpdGVJZCA9PT0gd3JpdGVJZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHV0aWxfMi5hc3NlcnQoaWR4ID49IDAsICdyZW1vdmVXcml0ZSBjYWxsZWQgd2l0aCBub25leGlzdGVudCB3cml0ZUlkLicpO1xuICAgICAgICB2YXIgd3JpdGVUb1JlbW92ZSA9IHRoaXMuYWxsV3JpdGVzX1tpZHhdO1xuICAgICAgICB0aGlzLmFsbFdyaXRlc18uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHZhciByZW1vdmVkV3JpdGVXYXNWaXNpYmxlID0gd3JpdGVUb1JlbW92ZS52aXNpYmxlO1xuICAgICAgICB2YXIgcmVtb3ZlZFdyaXRlT3ZlcmxhcHNXaXRoT3RoZXJXcml0ZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmFsbFdyaXRlc18ubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKHJlbW92ZWRXcml0ZVdhc1Zpc2libGUgJiYgaSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFdyaXRlID0gdGhpcy5hbGxXcml0ZXNfW2ldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRXcml0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gaWR4ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkQ29udGFpbnNQYXRoXyhjdXJyZW50V3JpdGUsIHdyaXRlVG9SZW1vdmUucGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlbW92ZWQgd3JpdGUgd2FzIGNvbXBsZXRlbHkgc2hhZG93ZWQgYnkgYSBzdWJzZXF1ZW50IHdyaXRlLlxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkV3JpdGVXYXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdyaXRlVG9SZW1vdmUucGF0aC5jb250YWlucyhjdXJyZW50V3JpdGUucGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIHdlJ3JlIGNvdmVyaW5nIHNvbWUgd3JpdGVzIG9yIHRoZXkncmUgY292ZXJpbmcgcGFydCBvZiB1cyAoZGVwZW5kaW5nIG9uIHdoaWNoIGNhbWUgZmlyc3QpLlxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlbW92ZWRXcml0ZU92ZXJsYXBzV2l0aE90aGVyV3JpdGVzKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIHNvbWUgc2hhZG93aW5nIGdvaW5nIG9uLiBKdXN0IHJlYnVpbGQgdGhlIHZpc2libGUgd3JpdGVzIGZyb20gc2NyYXRjaC5cbiAgICAgICAgICAgIHRoaXMucmVzZXRUcmVlXygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIHNoYWRvd2luZy4gIFdlIGNhbiBzYWZlbHkganVzdCByZW1vdmUgdGhlIHdyaXRlKHMpIGZyb20gdmlzaWJsZVdyaXRlcy5cbiAgICAgICAgICAgIGlmICh3cml0ZVRvUmVtb3ZlLnNuYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVXcml0ZXNfID0gdGhpcy52aXNpYmxlV3JpdGVzXy5yZW1vdmVXcml0ZSh3cml0ZVRvUmVtb3ZlLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gd3JpdGVUb1JlbW92ZS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB1dGlsXzEuZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aXNpYmxlV3JpdGVzXyA9IF90aGlzLnZpc2libGVXcml0ZXNfLnJlbW92ZVdyaXRlKHdyaXRlVG9SZW1vdmUucGF0aC5jaGlsZChjaGlsZE5hbWUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb21wbGV0ZSBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIHBhdGggaWYgdGhlcmUncyB2aXNpYmxlIHdyaXRlIGRhdGEgYXQgdGhhdCBwYXRoLCBlbHNlIG51bGwuXG4gICAgICogTm8gc2VydmVyIGRhdGEgaXMgY29uc2lkZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLmdldENvbXBsZXRlV3JpdGVEYXRhID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVdyaXRlc18uZ2V0Q29tcGxldGVOb2RlKHBhdGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gb3B0aW9uYWwsIHVuZGVybHlpbmcgc2VydmVyIGRhdGEsIGFuZCBhbiBvcHRpb25hbCBzZXQgb2YgY29uc3RyYWludHMgKGV4Y2x1ZGUgc29tZSBzZXRzLCBpbmNsdWRlIGhpZGRlblxuICAgICAqIHdyaXRlcyksIGF0dGVtcHQgdG8gY2FsY3VsYXRlIGEgY29tcGxldGUgc25hcHNob3QgZm9yIHRoZSBnaXZlbiBwYXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSB0cmVlUGF0aFxuICAgICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlU2VydmVyQ2FjaGVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gd3JpdGVJZHNUb0V4Y2x1ZGUgQW4gb3B0aW9uYWwgc2V0IHRvIGJlIGV4Y2x1ZGVkXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZUhpZGRlbldyaXRlcyBEZWZhdWx0cyB0byBmYWxzZSwgd2hldGhlciBvciBub3QgdG8gbGF5ZXIgb24gd3JpdGVzIHdpdGggdmlzaWJsZSBzZXQgdG8gZmFsc2VcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUgPSBmdW5jdGlvbiAodHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XG4gICAgICAgIGlmICghd3JpdGVJZHNUb0V4Y2x1ZGUgJiYgIWluY2x1ZGVIaWRkZW5Xcml0ZXMpIHtcbiAgICAgICAgICAgIHZhciBzaGFkb3dpbmdOb2RlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5nZXRDb21wbGV0ZU5vZGUodHJlZVBhdGgpO1xuICAgICAgICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dpbmdOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Yk1lcmdlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5jaGlsZENvbXBvdW5kV3JpdGUodHJlZVBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJNZXJnZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlU2VydmVyQ2FjaGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2FjaGUgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhc3ViTWVyZ2UuaGFzQ29tcGxldGVXcml0ZShQYXRoXzEuUGF0aC5FbXB0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd291bGRuJ3QgaGF2ZSBhIGNvbXBsZXRlIHNuYXBzaG90LCBzaW5jZSB0aGVyZSdzIG5vIHVuZGVybHlpbmcgZGF0YSBhbmQgbm8gY29tcGxldGUgc2hhZG93XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVyZWRDYWNoZSA9IGNvbXBsZXRlU2VydmVyQ2FjaGUgfHwgQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJNZXJnZS5hcHBseShsYXllcmVkQ2FjaGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtZXJnZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uY2hpbGRDb21wb3VuZFdyaXRlKHRyZWVQYXRoKTtcbiAgICAgICAgICAgIGlmICghaW5jbHVkZUhpZGRlbldyaXRlcyAmJiBtZXJnZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGVTZXJ2ZXJDYWNoZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgY2FjaGUgaXMgbnVsbCwgYW5kIHdlIGRvbid0IGhhdmUgYSBjb21wbGV0ZSBjYWNoZSwgd2UgbmVlZCB0byByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgIGlmICghaW5jbHVkZUhpZGRlbldyaXRlcyAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVNlcnZlckNhY2hlID09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgIW1lcmdlLmhhc0NvbXBsZXRlV3JpdGUoUGF0aF8xLlBhdGguRW1wdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IGZ1bmN0aW9uICh3cml0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgod3JpdGUudmlzaWJsZSB8fCBpbmNsdWRlSGlkZGVuV3JpdGVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghd3JpdGVJZHNUb0V4Y2x1ZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIX53cml0ZUlkc1RvRXhjbHVkZS5pbmRleE9mKHdyaXRlLndyaXRlSWQpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3cml0ZS5wYXRoLmNvbnRhaW5zKHRyZWVQYXRoKSB8fCB0cmVlUGF0aC5jb250YWlucyh3cml0ZS5wYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVyZ2VBdFBhdGggPSBXcml0ZVRyZWUubGF5ZXJUcmVlXyh0aGlzLmFsbFdyaXRlc18sIGZpbHRlciwgdHJlZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXJlZENhY2hlID0gY29tcGxldGVTZXJ2ZXJDYWNoZSB8fCBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlQXRQYXRoLmFwcGx5KGxheWVyZWRDYWNoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaXRoIG9wdGlvbmFsLCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhLCBhdHRlbXB0IHRvIHJldHVybiBhIGNoaWxkcmVuIG5vZGUgb2YgY2hpbGRyZW4gdGhhdCB3ZSBoYXZlIGNvbXBsZXRlIGRhdGEgZm9yLlxuICAgICAqIFVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmlld3MsIHRvIHByZS1maWxsIHRoZWlyIGNvbXBsZXRlIGV2ZW50IGNoaWxkcmVuIHNuYXBzaG90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gdHJlZVBhdGhcbiAgICAgKiBAcGFyYW0gez9DaGlsZHJlbk5vZGV9IGNvbXBsZXRlU2VydmVyQ2hpbGRyZW5cbiAgICAgKiBAcmV0dXJuIHshQ2hpbGRyZW5Ob2RlfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuY2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbiA9IGZ1bmN0aW9uICh0cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xuICAgICAgICB2YXIgY29tcGxldGVDaGlsZHJlbiA9IENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICB2YXIgdG9wTGV2ZWxTZXQgPSB0aGlzLnZpc2libGVXcml0ZXNfLmdldENvbXBsZXRlTm9kZSh0cmVlUGF0aCk7XG4gICAgICAgIGlmICh0b3BMZXZlbFNldCkge1xuICAgICAgICAgICAgaWYgKCF0b3BMZXZlbFNldC5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBzaGFkb3dpbmcgZXZlcnl0aGluZy4gUmV0dXJuIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICB0b3BMZXZlbFNldC5mb3JFYWNoQ2hpbGQoUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZFNuYXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVDaGlsZHJlbiA9IGNvbXBsZXRlQ2hpbGRyZW4udXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBjaGlsZFNuYXApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlQ2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xuICAgICAgICAgICAgLy8gTGF5ZXIgYW55IGNoaWxkcmVuIHdlIGhhdmUgb24gdG9wIG9mIHRoaXNcbiAgICAgICAgICAgIC8vIFdlIGtub3cgd2UgZG9uJ3QgaGF2ZSBhIHRvcC1sZXZlbCBzZXQsIHNvIGp1c3QgZW51bWVyYXRlIGV4aXN0aW5nIGNoaWxkcmVuXG4gICAgICAgICAgICB2YXIgbWVyZ2VfMSA9IHRoaXMudmlzaWJsZVdyaXRlc18uY2hpbGRDb21wb3VuZFdyaXRlKHRyZWVQYXRoKTtcbiAgICAgICAgICAgIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4uZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGNoaWxkTmFtZSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBtZXJnZV8xXG4gICAgICAgICAgICAgICAgICAgIC5jaGlsZENvbXBvdW5kV3JpdGUobmV3IFBhdGhfMS5QYXRoKGNoaWxkTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBseShjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFkZCBhbnkgY29tcGxldGUgY2hpbGRyZW4gd2UgaGF2ZSBmcm9tIHRoZSBzZXRcbiAgICAgICAgICAgIG1lcmdlXzEuZ2V0Q29tcGxldGVDaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKG5hbWVkTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5hbWVkTm9kZS5uYW1lLCBuYW1lZE5vZGUubm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBsYXllciBvbiB0b3Agb2YuIExheWVyIG9uIGFueSBjaGlsZHJlbiB3ZSBoYXZlXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2UgY2FuIHJldHVybiBhbiBlbXB0eSBzbmFwIGlmIHdlIGhhdmUgYSBkZWZpbmVkIGRlbGV0ZVxuICAgICAgICAgICAgdmFyIG1lcmdlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5jaGlsZENvbXBvdW5kV3JpdGUodHJlZVBhdGgpO1xuICAgICAgICAgICAgbWVyZ2UuZ2V0Q29tcGxldGVDaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKG5hbWVkTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5hbWVkTm9kZS5uYW1lLCBuYW1lZE5vZGUubm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGF0IHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGhhcyB1cGRhdGVkLCBkZXRlcm1pbmUgd2hhdCwgaWYgYW55dGhpbmcsIG5lZWRzIHRvIGJlXG4gICAgICogYXBwbGllZCB0byB0aGUgZXZlbnQgY2FjaGUuXG4gICAgICpcbiAgICAgKiBQb3NzaWJpbGl0aWVzOlxuICAgICAqXG4gICAgICogMS4gTm8gd3JpdGVzIGFyZSBzaGFkb3dpbmcuIEV2ZW50cyBzaG91bGQgYmUgcmFpc2VkLCB0aGUgc25hcCB0byBiZSBhcHBsaWVkIGNvbWVzIGZyb20gdGhlIHNlcnZlciBkYXRhXG4gICAgICpcbiAgICAgKiAyLiBTb21lIHdyaXRlIGlzIGNvbXBsZXRlbHkgc2hhZG93aW5nLiBObyBldmVudHMgdG8gYmUgcmFpc2VkXG4gICAgICpcbiAgICAgKiAzLiBJcyBwYXJ0aWFsbHkgc2hhZG93ZWQuIEV2ZW50c1xuICAgICAqXG4gICAgICogRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSB0cmVlUGF0aFxuICAgICAqIEBwYXJhbSB7IVBhdGh9IGNoaWxkUGF0aFxuICAgICAqIEBwYXJhbSB7P05vZGV9IGV4aXN0aW5nRXZlbnRTbmFwXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gZXhpc3RpbmdTZXJ2ZXJTbmFwXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5jYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlID0gZnVuY3Rpb24gKHRyZWVQYXRoLCBjaGlsZFBhdGgsIGV4aXN0aW5nRXZlbnRTbmFwLCBleGlzdGluZ1NlcnZlclNuYXApIHtcbiAgICAgICAgdXRpbF8yLmFzc2VydChleGlzdGluZ0V2ZW50U25hcCB8fCBleGlzdGluZ1NlcnZlclNuYXAsICdFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3QnKTtcbiAgICAgICAgdmFyIHBhdGggPSB0cmVlUGF0aC5jaGlsZChjaGlsZFBhdGgpO1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlV3JpdGVzXy5oYXNDb21wbGV0ZVdyaXRlKHBhdGgpKSB7XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGNhbiBwcm9iYWJseSBndWFyYW50ZWUgdGhhdCB3ZSdyZSBpbiBjYXNlIDIsIG1lYW5pbmcgbm8gZXZlbnRzXG4gICAgICAgICAgICAvLyBNYXkgbmVlZCB0byBjaGVjayB2aXNpYmlsaXR5IHdoaWxlIGRvaW5nIHRoZSBmaW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGggY2FsbFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBjb21wbGV0ZSBzaGFkb3dpbmcuIFdlJ3JlIGVpdGhlciBwYXJ0aWFsbHkgc2hhZG93aW5nIG9yIG5vdCBzaGFkb3dpbmcgYXQgYWxsLlxuICAgICAgICAgICAgdmFyIGNoaWxkTWVyZ2UgPSB0aGlzLnZpc2libGVXcml0ZXNfLmNoaWxkQ29tcG91bmRXcml0ZShwYXRoKTtcbiAgICAgICAgICAgIGlmIChjaGlsZE1lcmdlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBzaGFkb3dpbmcgYXQgYWxsLiBDYXNlIDFcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldENoaWxkKGNoaWxkUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIG1vcmUgZWZmaWNpZW50IGlmIHRoZSBzZXJ2ZXJOb2RlICsgdXBkYXRlcyBkb2Vzbid0IGNoYW5nZSB0aGUgZXZlbnRTbmFwXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciB0aGlzIGlzIHRyaWNreSB0byBmaW5kIG91dCwgc2luY2UgdXNlciB1cGRhdGVzIGRvbid0IG5lY2Vzc2FyeSBjaGFuZ2UgdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIC8vIHNuYXAsIGUuZy4gcHJpb3JpdHkgdXBkYXRlcyBvbiBlbXB0eSBub2Rlcywgb3IgZGVlcCBkZWxldGVzLiBBbm90aGVyIHNwZWNpYWwgY2FzZSBpcyBpZiB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgLy8gYWRkcyBub2RlcywgYnV0IGRvZXNuJ3QgY2hhbmdlIGFueSBleGlzdGluZyB3cml0ZXMuIEl0IGlzIHRoZXJlZm9yZSBub3QgZW5vdWdoIHRvXG4gICAgICAgICAgICAgICAgLy8gb25seSBjaGVjayBpZiB0aGUgdXBkYXRlcyBjaGFuZ2UgdGhlIHNlcnZlck5vZGUuXG4gICAgICAgICAgICAgICAgLy8gTWF5YmUgY2hlY2sgaWYgdGhlIG1lcmdlIHRyZWUgY29udGFpbnMgdGhlc2Ugc3BlY2lhbCBjYXNlcyBhbmQgb25seSBkbyBhIGZ1bGwgb3ZlcndyaXRlIGluIHRoYXQgY2FzZT9cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRNZXJnZS5hcHBseShleGlzdGluZ1NlcnZlclNuYXAuZ2V0Q2hpbGQoY2hpbGRQYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb21wbGV0ZSBjaGlsZCBmb3IgYSBnaXZlbiBzZXJ2ZXIgc25hcCBhZnRlciBhcHBseWluZyBhbGwgdXNlciB3cml0ZXMgb3IgbnVsbCBpZiB0aGVyZSBpcyBub1xuICAgICAqIGNvbXBsZXRlIGNoaWxkIGZvciB0aGlzIENoaWxkS2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gdHJlZVBhdGhcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGNoaWxkS2V5XG4gICAgICogQHBhcmFtIHshQ2FjaGVOb2RlfSBleGlzdGluZ1NlcnZlclNuYXBcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLmNhbGNDb21wbGV0ZUNoaWxkID0gZnVuY3Rpb24gKHRyZWVQYXRoLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XG4gICAgICAgIHZhciBwYXRoID0gdHJlZVBhdGguY2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICB2YXIgc2hhZG93aW5nTm9kZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uZ2V0Q29tcGxldGVOb2RlKHBhdGgpO1xuICAgICAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hhZG93aW5nTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1NlcnZlclNuYXAuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE1lcmdlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5jaGlsZENvbXBvdW5kV3JpdGUocGF0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTWVyZ2UuYXBwbHkoZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBub2RlIGlmIHRoZXJlIGlzIGEgY29tcGxldGUgb3ZlcndyaXRlIGZvciB0aGlzIHBhdGguIE1vcmUgc3BlY2lmaWNhbGx5LCBpZiB0aGVyZSBpcyBhIHdyaXRlIGF0XG4gICAgICogYSBoaWdoZXIgcGF0aCwgdGhpcyB3aWxsIHJldHVybiB0aGUgY2hpbGQgb2YgdGhhdCB3cml0ZSByZWxhdGl2ZSB0byB0aGUgd3JpdGUgYW5kIHRoaXMgcGF0aC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gd3JpdGUgYXQgdGhpcyBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuc2hhZG93aW5nV3JpdGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlV3JpdGVzXy5nZXRDb21wbGV0ZU5vZGUocGF0aCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHdoZW4gcHJvY2Vzc2luZyBjaGlsZCByZW1vdmUgZXZlbnRzIG9uIGEgcXVlcnkuIElmIHdlIGNhbiwgd2UgcHVsbCBpbiBjaGlsZHJlbiB0aGF0IHdlcmUgb3V0c2lkZVxuICAgICAqIHRoZSB3aW5kb3csIGJ1dCBtYXkgbm93IGJlIGluIHRoZSB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSB0cmVlUGF0aFxuICAgICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlU2VydmVyRGF0YVxuICAgICAqIEBwYXJhbSB7IU5hbWVkTm9kZX0gc3RhcnRQb3N0XG4gICAgICogQHBhcmFtIHshbnVtYmVyfSBjb3VudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZVxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleFxuICAgICAqIEByZXR1cm4geyFBcnJheS48IU5hbWVkTm9kZT59XG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5jYWxjSW5kZXhlZFNsaWNlID0gZnVuY3Rpb24gKHRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KSB7XG4gICAgICAgIHZhciB0b0l0ZXJhdGU7XG4gICAgICAgIHZhciBtZXJnZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uY2hpbGRDb21wb3VuZFdyaXRlKHRyZWVQYXRoKTtcbiAgICAgICAgdmFyIHNoYWRvd2luZ05vZGUgPSBtZXJnZS5nZXRDb21wbGV0ZU5vZGUoUGF0aF8xLlBhdGguRW1wdHkpO1xuICAgICAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0b0l0ZXJhdGUgPSBzaGFkb3dpbmdOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0b0l0ZXJhdGUgPSBtZXJnZS5hcHBseShjb21wbGV0ZVNlcnZlckRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gY2hpbGRyZW4gdG8gaXRlcmF0ZSBvblxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHRvSXRlcmF0ZSA9IHRvSXRlcmF0ZS53aXRoSW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAoIXRvSXRlcmF0ZS5pc0VtcHR5KCkgJiYgIXRvSXRlcmF0ZS5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNtcCA9IGluZGV4LmdldENvbXBhcmUoKTtcbiAgICAgICAgICAgIHZhciBpdGVyID0gcmV2ZXJzZVxuICAgICAgICAgICAgICAgID8gdG9JdGVyYXRlLmdldFJldmVyc2VJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBpbmRleClcbiAgICAgICAgICAgICAgICA6IHRvSXRlcmF0ZS5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgbm9kZXMubGVuZ3RoIDwgY291bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY21wKG5leHQsIHN0YXJ0UG9zdCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFXcml0ZVJlY29yZH0gd3JpdGVSZWNvcmRcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUucmVjb3JkQ29udGFpbnNQYXRoXyA9IGZ1bmN0aW9uICh3cml0ZVJlY29yZCwgcGF0aCkge1xuICAgICAgICBpZiAod3JpdGVSZWNvcmQuc25hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlUmVjb3JkLnBhdGguY29udGFpbnMocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmaW5kS2V5IGNhbiByZXR1cm4gdW5kZWZpbmVkLCBzbyB1c2UgISEgdG8gY29lcmNlIHRvIGJvb2xlYW5cbiAgICAgICAgICAgIHJldHVybiAhIXV0aWxfMS5maW5kS2V5KHdyaXRlUmVjb3JkLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGRTbmFwLCBjaGlsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVSZWNvcmQucGF0aC5jaGlsZChjaGlsZE5hbWUpLmNvbnRhaW5zKHBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlLWxheWVyIHRoZSB3cml0ZXMgYW5kIG1lcmdlcyBpbnRvIGEgdHJlZSBzbyB3ZSBjYW4gZWZmaWNpZW50bHkgY2FsY3VsYXRlIGV2ZW50IHNuYXBzaG90c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5yZXNldFRyZWVfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpc2libGVXcml0ZXNfID0gV3JpdGVUcmVlLmxheWVyVHJlZV8odGhpcy5hbGxXcml0ZXNfLCBXcml0ZVRyZWUuRGVmYXVsdEZpbHRlcl8sIFBhdGhfMS5QYXRoLkVtcHR5KTtcbiAgICAgICAgaWYgKHRoaXMuYWxsV3JpdGVzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RXcml0ZUlkXyA9IHRoaXMuYWxsV3JpdGVzX1t0aGlzLmFsbFdyaXRlc18ubGVuZ3RoIC0gMV0ud3JpdGVJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFdyaXRlSWRfID0gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZpbHRlciB1c2VkIHdoZW4gY29uc3RydWN0aW5nIHRoZSB0cmVlLiBLZWVwIGV2ZXJ5dGhpbmcgdGhhdCdzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFXcml0ZVJlY29yZH0gd3JpdGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV3JpdGVUcmVlLkRlZmF1bHRGaWx0ZXJfID0gZnVuY3Rpb24gKHdyaXRlKSB7XG4gICAgICAgIHJldHVybiB3cml0ZS52aXNpYmxlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZC4gR2l2ZW4gYW4gYXJyYXkgb2YgV3JpdGVSZWNvcmRzLCBhIGZpbHRlciBmb3Igd2hpY2ggb25lcyB0byBpbmNsdWRlLCBhbmQgYSBwYXRoLCBjb25zdHJ1Y3QgdGhlIHRyZWUgb2ZcbiAgICAgKiBldmVudCBkYXRhIGF0IHRoYXQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhV3JpdGVSZWNvcmQ+fSB3cml0ZXNcbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbighV3JpdGVSZWNvcmQpOmJvb2xlYW59IGZpbHRlclxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHRyZWVSb290XG4gICAgICogQHJldHVybiB7IUNvbXBvdW5kV3JpdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBXcml0ZVRyZWUubGF5ZXJUcmVlXyA9IGZ1bmN0aW9uICh3cml0ZXMsIGZpbHRlciwgdHJlZVJvb3QpIHtcbiAgICAgICAgdmFyIGNvbXBvdW5kV3JpdGUgPSBDb21wb3VuZFdyaXRlXzEuQ29tcG91bmRXcml0ZS5FbXB0eTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3cml0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB3cml0ZSA9IHdyaXRlc1tpXTtcbiAgICAgICAgICAgIC8vIFRoZW9yeSwgYSBsYXRlciBzZXQgd2lsbCBlaXRoZXI6XG4gICAgICAgICAgICAvLyBhKSBhYm9ydCBhIHJlbGV2YW50IHRyYW5zYWN0aW9uLCBzbyBubyBuZWVkIHRvIHdvcnJ5IGFib3V0IGV4Y2x1ZGluZyBpdCBmcm9tIGNhbGN1bGF0aW5nIHRoYXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIGIpIG5vdCBiZSByZWxldmFudCB0byBhIHRyYW5zYWN0aW9uIChzZXBhcmF0ZSBicmFuY2gpLCBzbyBhZ2FpbiB3aWxsIG5vdCBhZmZlY3QgdGhlIGRhdGEgZm9yIHRoYXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIGlmIChmaWx0ZXIod3JpdGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdyaXRlUGF0aCA9IHdyaXRlLnBhdGg7XG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aXZlUGF0aCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAod3JpdGUuc25hcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJlZVJvb3QuY29udGFpbnMod3JpdGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gUGF0aF8xLlBhdGgucmVsYXRpdmVQYXRoKHRyZWVSb290LCB3cml0ZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGUuYWRkV3JpdGUocmVsYXRpdmVQYXRoLCB3cml0ZS5zbmFwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh3cml0ZVBhdGguY29udGFpbnModHJlZVJvb3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBQYXRoXzEuUGF0aC5yZWxhdGl2ZVBhdGgod3JpdGVQYXRoLCB0cmVlUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZS5hZGRXcml0ZShQYXRoXzEuUGF0aC5FbXB0eSwgd3JpdGUuc25hcC5nZXRDaGlsZChyZWxhdGl2ZVBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG92ZXJsYXAgYmV0d2VlbiByb290IHBhdGggYW5kIHdyaXRlIHBhdGgsIGlnbm9yZSB3cml0ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdyaXRlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmVlUm9vdC5jb250YWlucyh3cml0ZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBQYXRoXzEuUGF0aC5yZWxhdGl2ZVBhdGgodHJlZVJvb3QsIHdyaXRlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZS5hZGRXcml0ZXMocmVsYXRpdmVQYXRoLCB3cml0ZS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAod3JpdGVQYXRoLmNvbnRhaW5zKHRyZWVSb290KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gUGF0aF8xLlBhdGgucmVsYXRpdmVQYXRoKHdyaXRlUGF0aCwgdHJlZVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZS5hZGRXcml0ZXMoUGF0aF8xLlBhdGguRW1wdHksIHdyaXRlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHV0aWxfMS5zYWZlR2V0KHdyaXRlLmNoaWxkcmVuLCByZWxhdGl2ZVBhdGguZ2V0RnJvbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGV4aXN0cyBhIGNoaWxkIGluIHRoaXMgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIHJvb3QgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVlcE5vZGUgPSBjaGlsZC5nZXRDaGlsZChyZWxhdGl2ZVBhdGgucG9wRnJvbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlLmFkZFdyaXRlKFBhdGhfMS5QYXRoLkVtcHR5LCBkZWVwTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gb3ZlcmxhcCBiZXR3ZWVuIHJvb3QgcGF0aCBhbmQgd3JpdGUgcGF0aCwgaWdub3JlIHdyaXRlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHV0aWxfMi5hc3NlcnRpb25FcnJvcignV3JpdGVSZWNvcmQgc2hvdWxkIGhhdmUgLnNuYXAgb3IgLmNoaWxkcmVuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlVHJlZTtcbn0oKSk7XG5leHBvcnRzLldyaXRlVHJlZSA9IFdyaXRlVHJlZTtcbi8qKlxuICogQSBXcml0ZVRyZWVSZWYgd3JhcHMgYSBXcml0ZVRyZWUgYW5kIGEgcGF0aCwgZm9yIGNvbnZlbmllbnQgYWNjZXNzIHRvIGEgcGFydGljdWxhciBzdWJ0cmVlLiAgQWxsIG9mIHRoZSBtZXRob2RzXG4gKiBqdXN0IHByb3h5IHRvIHRoZSB1bmRlcmx5aW5nIFdyaXRlVHJlZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFdyaXRlVHJlZVJlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlfSB3cml0ZVRyZWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXcml0ZVRyZWVSZWYocGF0aCwgd3JpdGVUcmVlKSB7XG4gICAgICAgIHRoaXMudHJlZVBhdGhfID0gcGF0aDtcbiAgICAgICAgdGhpcy53cml0ZVRyZWVfID0gd3JpdGVUcmVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBwb3NzaWJsZSwgcmV0dXJucyBhIGNvbXBsZXRlIGV2ZW50IGNhY2hlLCB1c2luZyB0aGUgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSBpZiBwb3NzaWJsZS4gSW4gYWRkaXRpb24sIGNhbiBiZSB1c2VkXG4gICAgICogdG8gZ2V0IGEgY2FjaGUgdGhhdCBpbmNsdWRlcyBoaWRkZW4gd3JpdGVzLCBhbmQgZXhjbHVkZXMgYXJiaXRyYXJ5IHdyaXRlcy4gTm90ZSB0aGF0IGN1c3RvbWl6aW5nIHRoZSByZXR1cm5lZCBub2RlXG4gICAgICogY2FuIGxlYWQgdG8gYSBtb3JlIGV4cGVuc2l2ZSBjYWxjdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlU2VydmVyQ2FjaGVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gd3JpdGVJZHNUb0V4Y2x1ZGUgT3B0aW9uYWwgd3JpdGVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZUhpZGRlbldyaXRlcyBEZWZhdWx0cyB0byBmYWxzZSwgd2hldGhlciBvciBub3QgdG8gbGF5ZXIgb24gd3JpdGVzIHdpdGggdmlzaWJsZSBzZXQgdG8gZmFsc2VcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWVSZWYucHJvdG90eXBlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUgPSBmdW5jdGlvbiAoY29tcGxldGVTZXJ2ZXJDYWNoZSwgd3JpdGVJZHNUb0V4Y2x1ZGUsIGluY2x1ZGVIaWRkZW5Xcml0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVUcmVlXy5jYWxjQ29tcGxldGVFdmVudENhY2hlKHRoaXMudHJlZVBhdGhfLCBjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiBwb3NzaWJsZSwgcmV0dXJucyBhIGNoaWxkcmVuIG5vZGUgY29udGFpbmluZyBhbGwgb2YgdGhlIGNvbXBsZXRlIGNoaWxkcmVuIHdlIGhhdmUgZGF0YSBmb3IuIFRoZSByZXR1cm5lZCBkYXRhIGlzIGFcbiAgICAgKiBtaXggb2YgdGhlIGdpdmVuIHNlcnZlciBkYXRhIGFuZCB3cml0ZSBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/Q2hpbGRyZW5Ob2RlfSBjb21wbGV0ZVNlcnZlckNoaWxkcmVuXG4gICAgICogQHJldHVybiB7IUNoaWxkcmVuTm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWVSZWYucHJvdG90eXBlLmNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4gPSBmdW5jdGlvbiAoY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVRyZWVfLmNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4odGhpcy50cmVlUGF0aF8sIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhhdCBlaXRoZXIgdGhlIHVuZGVybHlpbmcgc2VydmVyIGRhdGEgaGFzIHVwZGF0ZWQgb3IgdGhlIG91dHN0YW5kaW5nIHdyaXRlcyBoYXZlIHVwZGF0ZWQsIGRldGVybWluZSB3aGF0LFxuICAgICAqIGlmIGFueXRoaW5nLCBuZWVkcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBldmVudCBjYWNoZS5cbiAgICAgKlxuICAgICAqIFBvc3NpYmlsaXRpZXM6XG4gICAgICpcbiAgICAgKiAxLiBObyB3cml0ZXMgYXJlIHNoYWRvd2luZy4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWQsIHRoZSBzbmFwIHRvIGJlIGFwcGxpZWQgY29tZXMgZnJvbSB0aGUgc2VydmVyIGRhdGFcbiAgICAgKlxuICAgICAqIDIuIFNvbWUgd3JpdGUgaXMgY29tcGxldGVseSBzaGFkb3dpbmcuIE5vIGV2ZW50cyB0byBiZSByYWlzZWRcbiAgICAgKlxuICAgICAqIDMuIElzIHBhcnRpYWxseSBzaGFkb3dlZC4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWRcbiAgICAgKlxuICAgICAqIEVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdCwgdGhpcyBpcyB2YWxpZGF0ZWQgdmlhIGFuIGFzc2VydFxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7P05vZGV9IGV4aXN0aW5nRXZlbnRTbmFwXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gZXhpc3RpbmdTZXJ2ZXJTbmFwXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgV3JpdGVUcmVlUmVmLnByb3RvdHlwZS5jYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlID0gZnVuY3Rpb24gKHBhdGgsIGV4aXN0aW5nRXZlbnRTbmFwLCBleGlzdGluZ1NlcnZlclNuYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVUcmVlXy5jYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHRoaXMudHJlZVBhdGhfLCBwYXRoLCBleGlzdGluZ0V2ZW50U25hcCwgZXhpc3RpbmdTZXJ2ZXJTbmFwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBub2RlIGlmIHRoZXJlIGlzIGEgY29tcGxldGUgb3ZlcndyaXRlIGZvciB0aGlzIHBhdGguIE1vcmUgc3BlY2lmaWNhbGx5LCBpZiB0aGVyZSBpcyBhIHdyaXRlIGF0XG4gICAgICogYSBoaWdoZXIgcGF0aCwgdGhpcyB3aWxsIHJldHVybiB0aGUgY2hpbGQgb2YgdGhhdCB3cml0ZSByZWxhdGl2ZSB0byB0aGUgd3JpdGUgYW5kIHRoaXMgcGF0aC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gd3JpdGUgYXQgdGhpcyBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZVJlZi5wcm90b3R5cGUuc2hhZG93aW5nV3JpdGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVRyZWVfLnNoYWRvd2luZ1dyaXRlKHRoaXMudHJlZVBhdGhfLmNoaWxkKHBhdGgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgd2hlbiBwcm9jZXNzaW5nIGNoaWxkIHJlbW92ZSBldmVudHMgb24gYSBxdWVyeS4gSWYgd2UgY2FuLCB3ZSBwdWxsIGluIGNoaWxkcmVuIHRoYXQgd2VyZSBvdXRzaWRlXG4gICAgICogdGhlIHdpbmRvdywgYnV0IG1heSBub3cgYmUgaW4gdGhlIHdpbmRvd1xuICAgICAqXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gY29tcGxldGVTZXJ2ZXJEYXRhXG4gICAgICogQHBhcmFtIHshTmFtZWROb2RlfSBzdGFydFBvc3RcbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IGNvdW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXZlcnNlXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4XG4gICAgICogQHJldHVybiB7IUFycmF5LjwhTmFtZWROb2RlPn1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWVSZWYucHJvdG90eXBlLmNhbGNJbmRleGVkU2xpY2UgPSBmdW5jdGlvbiAoY29tcGxldGVTZXJ2ZXJEYXRhLCBzdGFydFBvc3QsIGNvdW50LCByZXZlcnNlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVRyZWVfLmNhbGNJbmRleGVkU2xpY2UodGhpcy50cmVlUGF0aF8sIGNvbXBsZXRlU2VydmVyRGF0YSwgc3RhcnRQb3N0LCBjb3VudCwgcmV2ZXJzZSwgaW5kZXgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvbXBsZXRlIGNoaWxkIGZvciBhIGdpdmVuIHNlcnZlciBzbmFwIGFmdGVyIGFwcGx5aW5nIGFsbCB1c2VyIHdyaXRlcyBvciBudWxsIGlmIHRoZXJlIGlzIG5vXG4gICAgICogY29tcGxldGUgY2hpbGQgZm9yIHRoaXMgQ2hpbGRLZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGNoaWxkS2V5XG4gICAgICogQHBhcmFtIHshQ2FjaGVOb2RlfSBleGlzdGluZ1NlcnZlckNhY2hlXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgV3JpdGVUcmVlUmVmLnByb3RvdHlwZS5jYWxjQ29tcGxldGVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJDYWNoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVRyZWVfLmNhbGNDb21wbGV0ZUNoaWxkKHRoaXMudHJlZVBhdGhfLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJDYWNoZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBXcml0ZVRyZWVSZWYgZm9yIGEgY2hpbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpbGROYW1lXG4gICAgICogQHJldHVybiB7IVdyaXRlVHJlZVJlZn1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWVSZWYucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlVHJlZVJlZih0aGlzLnRyZWVQYXRoXy5jaGlsZChjaGlsZE5hbWUpLCB0aGlzLndyaXRlVHJlZV8pO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlVHJlZVJlZjtcbn0oKSk7XG5leHBvcnRzLldyaXRlVHJlZVJlZiA9IFdyaXRlVHJlZVJlZjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V3JpdGVUcmVlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9QYXRoXCIpO1xudmFyIE9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vT3BlcmF0aW9uXCIpO1xudmFyIEFja1VzZXJXcml0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFJbW11dGFibGVUcmVlPCFib29sZWFuPn0gYWZmZWN0ZWRUcmVlIEEgdHJlZSBjb250YWluaW5nIHRydWUgZm9yIGVhY2ggYWZmZWN0ZWQgcGF0aC4gQWZmZWN0ZWQgcGF0aHMgY2FuJ3Qgb3ZlcmxhcC5cbiAgICAgKiBAcGFyYW0geyFib29sZWFufSByZXZlcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBY2tVc2VyV3JpdGUoXG4gICAgICAgIC8qKkBpbmhlcml0RG9jICovIHBhdGgsIFxuICAgICAgICAvKipAaW5oZXJpdERvYyAqLyBhZmZlY3RlZFRyZWUsIFxuICAgICAgICAvKipAaW5oZXJpdERvYyAqLyByZXZlcnQpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5hZmZlY3RlZFRyZWUgPSBhZmZlY3RlZFRyZWU7XG4gICAgICAgIHRoaXMucmV2ZXJ0ID0gcmV2ZXJ0O1xuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uXzEuT3BlcmF0aW9uVHlwZS5BQ0tfVVNFUl9XUklURTtcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgICAgIHRoaXMuc291cmNlID0gT3BlcmF0aW9uXzEuT3BlcmF0aW9uU291cmNlLlVzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQWNrVXNlcldyaXRlLnByb3RvdHlwZS5vcGVyYXRpb25Gb3JDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMucGF0aC5nZXRGcm9udCgpID09PSBjaGlsZE5hbWUsICdvcGVyYXRpb25Gb3JDaGlsZCBjYWxsZWQgZm9yIHVucmVsYXRlZCBjaGlsZC4nKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWNrVXNlcldyaXRlKHRoaXMucGF0aC5wb3BGcm9udCgpLCB0aGlzLmFmZmVjdGVkVHJlZSwgdGhpcy5yZXZlcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWZmZWN0ZWRUcmVlLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQodGhpcy5hZmZlY3RlZFRyZWUuY2hpbGRyZW4uaXNFbXB0eSgpLCAnYWZmZWN0ZWRUcmVlIHNob3VsZCBub3QgaGF2ZSBvdmVybGFwcGluZyBhZmZlY3RlZCBwYXRocy4nKTtcbiAgICAgICAgICAgIC8vIEFsbCBjaGlsZCBsb2NhdGlvbnMgYXJlIGFmZmVjdGVkIGFzIHdlbGw7IGp1c3QgcmV0dXJuIHNhbWUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRUcmVlID0gdGhpcy5hZmZlY3RlZFRyZWUuc3VidHJlZShuZXcgUGF0aF8xLlBhdGgoY2hpbGROYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFja1VzZXJXcml0ZShQYXRoXzEuUGF0aC5FbXB0eSwgY2hpbGRUcmVlLCB0aGlzLnJldmVydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBY2tVc2VyV3JpdGU7XG59KCkpO1xuZXhwb3J0cy5BY2tVc2VyV3JpdGUgPSBBY2tVc2VyV3JpdGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFja1VzZXJXcml0ZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9QYXRoXCIpO1xudmFyIE9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vT3BlcmF0aW9uXCIpO1xuLyoqXG4gKiBAcGFyYW0geyFPcGVyYXRpb25Tb3VyY2V9IHNvdXJjZVxuICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7T3BlcmF0aW9ufVxuICovXG52YXIgTGlzdGVuQ29tcGxldGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlzdGVuQ29tcGxldGUoc291cmNlLCBwYXRoKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uXzEuT3BlcmF0aW9uVHlwZS5MSVNURU5fQ09NUExFVEU7XG4gICAgfVxuICAgIExpc3RlbkNvbXBsZXRlLnByb3RvdHlwZS5vcGVyYXRpb25Gb3JDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdGVuQ29tcGxldGUodGhpcy5zb3VyY2UsIFBhdGhfMS5QYXRoLkVtcHR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdGVuQ29tcGxldGUodGhpcy5zb3VyY2UsIHRoaXMucGF0aC5wb3BGcm9udCgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIExpc3RlbkNvbXBsZXRlO1xufSgpKTtcbmV4cG9ydHMuTGlzdGVuQ29tcGxldGUgPSBMaXN0ZW5Db21wbGV0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlzdGVuQ29tcGxldGUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9PcGVyYXRpb25cIik7XG52YXIgT3ZlcndyaXRlXzEgPSByZXF1aXJlKFwiLi9PdmVyd3JpdGVcIik7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4uL3V0aWwvUGF0aFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIEBwYXJhbSB7IU9wZXJhdGlvblNvdXJjZX0gc291cmNlXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gKiBAcGFyYW0geyFJbW11dGFibGVUcmVlLjwhTm9kZT59IGNoaWxkcmVuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtPcGVyYXRpb259XG4gKi9cbnZhciBNZXJnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZShcbiAgICAgICAgLyoqQGluaGVyaXREb2MgKi8gc291cmNlLCBcbiAgICAgICAgLyoqQGluaGVyaXREb2MgKi8gcGF0aCwgXG4gICAgICAgIC8qKkBpbmhlcml0RG9jICovIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25fMS5PcGVyYXRpb25UeXBlLk1FUkdFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIE1lcmdlLnByb3RvdHlwZS5vcGVyYXRpb25Gb3JDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFRyZWUgPSB0aGlzLmNoaWxkcmVuLnN1YnRyZWUobmV3IFBhdGhfMS5QYXRoKGNoaWxkTmFtZSkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIHVuYWZmZWN0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBzbmFwc2hvdCBmb3IgdGhlIGNoaWxkIGluIHF1ZXN0aW9uLiAgVGhpcyBiZWNvbWVzIGFuIG92ZXJ3cml0ZSBvZiB0aGUgY2hpbGQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGVfMS5PdmVyd3JpdGUodGhpcy5zb3VyY2UsIFBhdGhfMS5QYXRoLkVtcHR5LCBjaGlsZFRyZWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG1lcmdlIGF0IGEgZGVlcGVyIGxldmVsXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXJnZSh0aGlzLnNvdXJjZSwgUGF0aF8xLlBhdGguRW1wdHksIGNoaWxkVHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMucGF0aC5nZXRGcm9udCgpID09PSBjaGlsZE5hbWUsIFwiQ2FuJ3QgZ2V0IGEgbWVyZ2UgZm9yIGEgY2hpbGQgbm90IG9uIHRoZSBwYXRoIG9mIHRoZSBvcGVyYXRpb25cIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lcmdlKHRoaXMuc291cmNlLCB0aGlzLnBhdGgucG9wRnJvbnQoKSwgdGhpcy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTWVyZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCdPcGVyYXRpb24oJyArXG4gICAgICAgICAgICB0aGlzLnBhdGggK1xuICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS50b1N0cmluZygpICtcbiAgICAgICAgICAgICcgbWVyZ2U6ICcgK1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi50b1N0cmluZygpICtcbiAgICAgICAgICAgICcpJyk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2U7XG59KCkpO1xuZXhwb3J0cy5NZXJnZSA9IE1lcmdlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXJnZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqXG4gKiBAZW51bVxuICovXG52YXIgT3BlcmF0aW9uVHlwZTtcbihmdW5jdGlvbiAoT3BlcmF0aW9uVHlwZSkge1xuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIk9WRVJXUklURVwiXSA9IDBdID0gXCJPVkVSV1JJVEVcIjtcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJNRVJHRVwiXSA9IDFdID0gXCJNRVJHRVwiO1xuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIkFDS19VU0VSX1dSSVRFXCJdID0gMl0gPSBcIkFDS19VU0VSX1dSSVRFXCI7XG4gICAgT3BlcmF0aW9uVHlwZVtPcGVyYXRpb25UeXBlW1wiTElTVEVOX0NPTVBMRVRFXCJdID0gM10gPSBcIkxJU1RFTl9DT01QTEVURVwiO1xufSkoT3BlcmF0aW9uVHlwZSA9IGV4cG9ydHMuT3BlcmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5PcGVyYXRpb25UeXBlID0ge30pKTtcbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBmcm9tVXNlclxuICogQHBhcmFtIHtib29sZWFufSBmcm9tU2VydmVyXG4gKiBAcGFyYW0gez9zdHJpbmd9IHF1ZXJ5SWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdGFnZ2VkXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE9wZXJhdGlvblNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcGVyYXRpb25Tb3VyY2UoZnJvbVVzZXIsIGZyb21TZXJ2ZXIsIHF1ZXJ5SWQsIHRhZ2dlZCkge1xuICAgICAgICB0aGlzLmZyb21Vc2VyID0gZnJvbVVzZXI7XG4gICAgICAgIHRoaXMuZnJvbVNlcnZlciA9IGZyb21TZXJ2ZXI7XG4gICAgICAgIHRoaXMucXVlcnlJZCA9IHF1ZXJ5SWQ7XG4gICAgICAgIHRoaXMudGFnZ2VkID0gdGFnZ2VkO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KCF0YWdnZWQgfHwgZnJvbVNlcnZlciwgJ1RhZ2dlZCBxdWVyaWVzIG11c3QgYmUgZnJvbSBzZXJ2ZXIuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHshT3BlcmF0aW9uU291cmNlfVxuICAgICAqL1xuICAgIE9wZXJhdGlvblNvdXJjZS5Vc2VyID0gbmV3IE9wZXJhdGlvblNvdXJjZShcbiAgICAvKmZyb21Vc2VyPSovIHRydWUsIGZhbHNlLCBudWxsLCBcbiAgICAvKnRhZ2dlZD0qLyBmYWxzZSk7XG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUgeyFPcGVyYXRpb25Tb3VyY2V9XG4gICAgICovXG4gICAgT3BlcmF0aW9uU291cmNlLlNlcnZlciA9IG5ldyBPcGVyYXRpb25Tb3VyY2UoZmFsc2UsIFxuICAgIC8qZnJvbVNlcnZlcj0qLyB0cnVlLCBudWxsLCBcbiAgICAvKnRhZ2dlZD0qLyBmYWxzZSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5SWRcbiAgICAgKiBAcmV0dXJuIHshT3BlcmF0aW9uU291cmNlfVxuICAgICAqL1xuICAgIE9wZXJhdGlvblNvdXJjZS5mb3JTZXJ2ZXJUYWdnZWRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3BlcmF0aW9uU291cmNlKGZhbHNlLCBcbiAgICAgICAgLypmcm9tU2VydmVyPSovIHRydWUsIHF1ZXJ5SWQsIFxuICAgICAgICAvKnRhZ2dlZD0qLyB0cnVlKTtcbiAgICB9O1xuICAgIHJldHVybiBPcGVyYXRpb25Tb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5PcGVyYXRpb25Tb3VyY2UgPSBPcGVyYXRpb25Tb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9wZXJhdGlvbi5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL09wZXJhdGlvblwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9QYXRoXCIpO1xuLyoqXG4gKiBAcGFyYW0geyFPcGVyYXRpb25Tb3VyY2V9IHNvdXJjZVxuICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICogQHBhcmFtIHshTm9kZX0gc25hcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7T3BlcmF0aW9ufVxuICovXG52YXIgT3ZlcndyaXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJ3cml0ZShzb3VyY2UsIHBhdGgsIHNuYXApIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25fMS5PcGVyYXRpb25UeXBlLk9WRVJXUklURTtcbiAgICB9XG4gICAgT3ZlcndyaXRlLnByb3RvdHlwZS5vcGVyYXRpb25Gb3JDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBQYXRoXzEuUGF0aC5FbXB0eSwgdGhpcy5zbmFwLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGUodGhpcy5zb3VyY2UsIHRoaXMucGF0aC5wb3BGcm9udCgpLCB0aGlzLnNuYXApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT3ZlcndyaXRlO1xufSgpKTtcbmV4cG9ydHMuT3ZlcndyaXRlID0gT3ZlcndyaXRlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PdmVyd3JpdGUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbFwiKTtcbnZhciBTb3J0ZWRNYXBfMSA9IHJlcXVpcmUoXCIuLi91dGlsL1NvcnRlZE1hcFwiKTtcbnZhciBOb2RlXzEgPSByZXF1aXJlKFwiLi9Ob2RlXCIpO1xudmFyIHNuYXBfMSA9IHJlcXVpcmUoXCIuL3NuYXBcIik7XG52YXIgUHJpb3JpdHlJbmRleF8xID0gcmVxdWlyZShcIi4vaW5kZXhlcy9Qcmlvcml0eUluZGV4XCIpO1xudmFyIEtleUluZGV4XzEgPSByZXF1aXJlKFwiLi9pbmRleGVzL0tleUluZGV4XCIpO1xudmFyIEluZGV4TWFwXzEgPSByZXF1aXJlKFwiLi9JbmRleE1hcFwiKTtcbnZhciBMZWFmTm9kZV8xID0gcmVxdWlyZShcIi4vTGVhZk5vZGVcIik7XG52YXIgY29tcGFyYXRvcnNfMSA9IHJlcXVpcmUoXCIuL2NvbXBhcmF0b3JzXCIpO1xuLy8gVE9ETzogRm9yIG1lbW9yeSBzYXZpbmdzLCBkb24ndCBzdG9yZSBwcmlvcml0eU5vZGVfIGlmIGl0J3MgZW1wdHkuXG52YXIgRU1QVFlfTk9ERTtcbi8qKlxuICogQ2hpbGRyZW5Ob2RlIGlzIGEgY2xhc3MgZm9yIHN0b3JpbmcgaW50ZXJuYWwgbm9kZXMgaW4gYSBEYXRhU25hcHNob3RcbiAqIChpLmUuIG5vZGVzIHdpdGggY2hpbGRyZW4pLiAgSXQgaW1wbGVtZW50cyBOb2RlIGFuZCBzdG9yZXMgdGhlXG4gKiBsaXN0IG9mIGNoaWxkcmVuIGluIHRoZSBjaGlsZHJlbiBwcm9wZXJ0eSwgc29ydGVkIGJ5IGNoaWxkIG5hbWUuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7Tm9kZX1cbiAqL1xudmFyIENoaWxkcmVuTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVNvcnRlZE1hcC48c3RyaW5nLCAhTm9kZT59IGNoaWxkcmVuXyBMaXN0IG9mIGNoaWxkcmVuXG4gICAgICogb2YgdGhpcyBub2RlLi5cbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBwcmlvcml0eU5vZGVfIFRoZSBwcmlvcml0eSBvZiB0aGlzIG5vZGUgKGFzIGEgc25hcHNob3Qgbm9kZSkuXG4gICAgICogQHBhcmFtIHshSW5kZXhNYXB9IGluZGV4TWFwX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENoaWxkcmVuTm9kZShjaGlsZHJlbl8sIHByaW9yaXR5Tm9kZV8sIGluZGV4TWFwXykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuXyA9IGNoaWxkcmVuXztcbiAgICAgICAgdGhpcy5wcmlvcml0eU5vZGVfID0gcHJpb3JpdHlOb2RlXztcbiAgICAgICAgdGhpcy5pbmRleE1hcF8gPSBpbmRleE1hcF87XG4gICAgICAgIHRoaXMubGF6eUhhc2hfID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGU6IFRoZSBvbmx5IHJlYXNvbiB3ZSBhbGxvdyBudWxsIHByaW9yaXR5IGlzIGZvciBFTVBUWV9OT0RFLCBzaW5jZSB3ZSBjYW4ndCB1c2VcbiAgICAgICAgICogRU1QVFlfTk9ERSBhcyB0aGUgcHJpb3JpdHkgb2YgRU1QVFlfTk9ERS4gIFdlIG1pZ2h0IHdhbnQgdG8gY29uc2lkZXIgbWFraW5nIEVNUFRZX05PREUgaXRzIG93blxuICAgICAgICAgKiBjbGFzcyBpbnN0ZWFkIG9mIGFuIGVtcHR5IENoaWxkcmVuTm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLnByaW9yaXR5Tm9kZV8pIHtcbiAgICAgICAgICAgIHNuYXBfMS52YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoIXRoaXMucHJpb3JpdHlOb2RlXyB8fCB0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpLCAnQW4gZW1wdHkgbm9kZSBjYW5ub3QgaGF2ZSBhIHByaW9yaXR5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoaWxkcmVuTm9kZSwgXCJFTVBUWV9OT0RFXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKEVNUFRZX05PREUgfHxcbiAgICAgICAgICAgICAgICAoRU1QVFlfTk9ERSA9IG5ldyBDaGlsZHJlbk5vZGUobmV3IFNvcnRlZE1hcF8xLlNvcnRlZE1hcChjb21wYXJhdG9yc18xLk5BTUVfQ09NUEFSQVRPUiksIG51bGwsIEluZGV4TWFwXzEuSW5kZXhNYXAuRGVmYXVsdCkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5pc0xlYWZOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmdldFByaW9yaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfIHx8IEVNUFRZX05PREU7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLnVwZGF0ZVByaW9yaXR5ID0gZnVuY3Rpb24gKG5ld1ByaW9yaXR5Tm9kZSkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBhbGxvdyBwcmlvcml0aWVzIG9uIGVtcHR5IG5vZGVzXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKHRoaXMuY2hpbGRyZW5fLCBuZXdQcmlvcml0eU5vZGUsIHRoaXMuaW5kZXhNYXBfKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRJbW1lZGlhdGVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgLy8gSGFjayB0byB0cmVhdCBwcmlvcml0eSBhcyBhIHJlZ3VsYXIgY2hpbGRcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByaW9yaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuXy5nZXQoY2hpbGROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gbnVsbCA/IEVNUFRZX05PREUgOiBjaGlsZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBmcm9udCA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEltbWVkaWF0ZUNoaWxkKGZyb250KS5nZXRDaGlsZChwYXRoLnBvcEZyb250KCkpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5oYXNDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZE5hbWUpICE9PSBudWxsO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS51cGRhdGVJbW1lZGlhdGVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSkge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KG5ld0NoaWxkTm9kZSwgJ1dlIHNob3VsZCBhbHdheXMgYmUgcGFzc2luZyBzbmFwc2hvdCBub2RlcycpO1xuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUHJpb3JpdHkobmV3Q2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuYW1lZE5vZGUgPSBuZXcgTm9kZV8xLk5hbWVkTm9kZShjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSk7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDAsIG5ld0luZGV4TWFwID0gdm9pZCAwLCBuZXdQcmlvcml0eSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuXy5yZW1vdmUoY2hpbGROYW1lKTtcbiAgICAgICAgICAgICAgICBuZXdJbmRleE1hcCA9IHRoaXMuaW5kZXhNYXBfLnJlbW92ZUZyb21JbmRleGVzKG5hbWVkTm9kZSwgdGhpcy5jaGlsZHJlbl8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuXy5pbnNlcnQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIG5ld0luZGV4TWFwID0gdGhpcy5pbmRleE1hcF8uYWRkVG9JbmRleGVzKG5hbWVkTm9kZSwgdGhpcy5jaGlsZHJlbl8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UHJpb3JpdHkgPSBuZXdDaGlsZHJlbi5pc0VtcHR5KCkgPyBFTVBUWV9OT0RFIDogdGhpcy5wcmlvcml0eU5vZGVfO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGlsZHJlbk5vZGUobmV3Q2hpbGRyZW4sIG5ld1ByaW9yaXR5LCBuZXdJbmRleE1hcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUudXBkYXRlQ2hpbGQgPSBmdW5jdGlvbiAocGF0aCwgbmV3Q2hpbGROb2RlKSB7XG4gICAgICAgIHZhciBmcm9udCA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbF8xLmFzc2VydChwYXRoLmdldEZyb250KCkgIT09ICcucHJpb3JpdHknIHx8IHBhdGguZ2V0TGVuZ3RoKCkgPT09IDEsICcucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGgnKTtcbiAgICAgICAgICAgIHZhciBuZXdJbW1lZGlhdGVDaGlsZCA9IHRoaXMuZ2V0SW1tZWRpYXRlQ2hpbGQoZnJvbnQpLnVwZGF0ZUNoaWxkKHBhdGgucG9wRnJvbnQoKSwgbmV3Q2hpbGROb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGZyb250LCBuZXdJbW1lZGlhdGVDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUubnVtQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5jb3VudCgpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoZXhwb3J0Rm9ybWF0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIHZhciBudW1LZXlzID0gMCwgbWF4S2V5ID0gMCwgYWxsSW50ZWdlcktleXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvckVhY2hDaGlsZChQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgsIGZ1bmN0aW9uIChrZXksIGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBjaGlsZE5vZGUudmFsKGV4cG9ydEZvcm1hdCk7XG4gICAgICAgICAgICBudW1LZXlzKys7XG4gICAgICAgICAgICBpZiAoYWxsSW50ZWdlcktleXMgJiYgQ2hpbGRyZW5Ob2RlLklOVEVHRVJfUkVHRVhQXy50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBtYXhLZXkgPSBNYXRoLm1heChtYXhLZXksIE51bWJlcihrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFsbEludGVnZXJLZXlzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWV4cG9ydEZvcm1hdCAmJiBhbGxJbnRlZ2VyS2V5cyAmJiBtYXhLZXkgPCAyICogbnVtS2V5cykge1xuICAgICAgICAgICAgLy8gY29udmVydCB0byBhcnJheS5cbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICAgICAgICBhcnJheVtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXhwb3J0Rm9ybWF0ICYmICF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgb2JqWycucHJpb3JpdHknXSA9IHRoaXMuZ2V0UHJpb3JpdHkoKS52YWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGF6eUhhc2hfID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgdG9IYXNoXzEgPSAnJztcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICB0b0hhc2hfMSArPVxuICAgICAgICAgICAgICAgICAgICAncHJpb3JpdHk6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwXzEucHJpb3JpdHlIYXNoVGV4dCh0aGlzLmdldFByaW9yaXR5KCkudmFsKCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc6JztcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkSGFzaCA9IGNoaWxkTm9kZS5oYXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkSGFzaCAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIHRvSGFzaF8xICs9ICc6JyArIGtleSArICc6JyArIGNoaWxkSGFzaDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSB0b0hhc2hfMSA9PT0gJycgPyAnJyA6IHV0aWxfMi5zaGExKHRvSGFzaF8xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXp5SGFzaF87XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmdldFByZWRlY2Vzc29yQ2hpbGROYW1lID0gZnVuY3Rpb24gKGNoaWxkTmFtZSwgY2hpbGROb2RlLCBpbmRleCkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4KTtcbiAgICAgICAgaWYgKGlkeCkge1xuICAgICAgICAgICAgdmFyIHByZWRlY2Vzc29yID0gaWR4LmdldFByZWRlY2Vzc29yS2V5KG5ldyBOb2RlXzEuTmFtZWROb2RlKGNoaWxkTmFtZSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICByZXR1cm4gcHJlZGVjZXNzb3IgPyBwcmVkZWNlc3Nvci5uYW1lIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5nZXRQcmVkZWNlc3NvcktleShjaGlsZE5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmdldEZpcnN0Q2hpbGROYW1lID0gZnVuY3Rpb24gKGluZGV4RGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbik7XG4gICAgICAgIGlmIChpZHgpIHtcbiAgICAgICAgICAgIHZhciBtaW5LZXkgPSBpZHgubWluS2V5KCk7XG4gICAgICAgICAgICByZXR1cm4gbWluS2V5ICYmIG1pbktleS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLm1pbktleSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7P05hbWVkTm9kZX1cbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmdldEZpcnN0Q2hpbGQgPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBtaW5LZXkgPSB0aGlzLmdldEZpcnN0Q2hpbGROYW1lKGluZGV4RGVmaW5pdGlvbik7XG4gICAgICAgIGlmIChtaW5LZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZV8xLk5hbWVkTm9kZShtaW5LZXksIHRoaXMuY2hpbGRyZW5fLmdldChtaW5LZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBpbmRleCwgcmV0dXJuIHRoZSBrZXkgbmFtZSBvZiB0aGUgbGFyZ2VzdCB2YWx1ZSB3ZSBoYXZlLCBhY2NvcmRpbmcgdG8gdGhhdCBpbmRleFxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0TGFzdENoaWxkTmFtZSA9IGZ1bmN0aW9uIChpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xuICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICB2YXIgbWF4S2V5ID0gaWR4Lm1heEtleSgpO1xuICAgICAgICAgICAgcmV0dXJuIG1heEtleSAmJiBtYXhLZXkubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5tYXhLZXkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4gez9OYW1lZE5vZGV9XG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRMYXN0Q2hpbGQgPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBtYXhLZXkgPSB0aGlzLmdldExhc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcbiAgICAgICAgaWYgKG1heEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlXzEuTmFtZWROb2RlKG1heEtleSwgdGhpcy5jaGlsZHJlbl8uZ2V0KG1heEtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoaW5kZXgsIGFjdGlvbikge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4KTtcbiAgICAgICAgaWYgKGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkeC5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uICh3cmFwcGVkTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24od3JhcHBlZE5vZGUubmFtZSwgd3JhcHBlZE5vZGUubm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHtTb3J0ZWRNYXBJdGVyYXRvcn1cbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24gKGluZGV4RGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVyYXRvckZyb20oaW5kZXhEZWZpbml0aW9uLm1pblBvc3QoKSwgaW5kZXhEZWZpbml0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHshTmFtZWROb2RlfSBzdGFydFBvc3RcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7IVNvcnRlZE1hcEl0ZXJhdG9yfVxuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0SXRlcmF0b3JGcm9tID0gZnVuY3Rpb24gKHN0YXJ0UG9zdCwgaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcbiAgICAgICAgaWYgKGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkeC5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5jaGlsZHJlbl8uZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdC5uYW1lLCBOb2RlXzEuTmFtZWROb2RlLldyYXApO1xuICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPSBudWxsICYmIGluZGV4RGVmaW5pdGlvbi5jb21wYXJlKG5leHQsIHN0YXJ0UG9zdCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHshU29ydGVkTWFwSXRlcmF0b3J9XG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRSZXZlcnNlSXRlcmF0b3IgPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJldmVyc2VJdGVyYXRvckZyb20oaW5kZXhEZWZpbml0aW9uLm1heFBvc3QoKSwgaW5kZXhEZWZpbml0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5hbWVkTm9kZX0gZW5kUG9zdFxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHshU29ydGVkTWFwSXRlcmF0b3J9XG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tID0gZnVuY3Rpb24gKGVuZFBvc3QsIGluZGV4RGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbik7XG4gICAgICAgIGlmIChpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBpZHguZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0LCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5jaGlsZHJlbl8uZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0Lm5hbWUsIE5vZGVfMS5OYW1lZE5vZGUuV3JhcCk7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLnBlZWsoKTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9IG51bGwgJiYgaW5kZXhEZWZpbml0aW9uLmNvbXBhcmUobmV4dCwgZW5kUG9zdCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBpZiAob3RoZXIuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIuaXNMZWFmTm9kZSgpIHx8IG90aGVyLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPT09IGV4cG9ydHMuTUFYX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE11c3QgYmUgYW5vdGhlciBub2RlIHdpdGggY2hpbGRyZW4uXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLndpdGhJbmRleCA9IGZ1bmN0aW9uIChpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKGluZGV4RGVmaW5pdGlvbiA9PT0gS2V5SW5kZXhfMS5LRVlfSU5ERVggfHxcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBfLmhhc0luZGV4KGluZGV4RGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5ld0luZGV4TWFwID0gdGhpcy5pbmRleE1hcF8uYWRkSW5kZXgoaW5kZXhEZWZpbml0aW9uLCB0aGlzLmNoaWxkcmVuXyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZSh0aGlzLmNoaWxkcmVuXywgdGhpcy5wcmlvcml0eU5vZGVfLCBuZXdJbmRleE1hcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5pc0luZGV4ZWQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSBLZXlJbmRleF8xLktFWV9JTkRFWCB8fCB0aGlzLmluZGV4TWFwXy5oYXNJbmRleChpbmRleCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJDaGlsZHJlbk5vZGUgPSBvdGhlcjtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRQcmlvcml0eSgpLmVxdWFscyhvdGhlckNoaWxkcmVuTm9kZS5nZXRQcmlvcml0eSgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2hpbGRyZW5fLmNvdW50KCkgPT09IG90aGVyQ2hpbGRyZW5Ob2RlLmNoaWxkcmVuXy5jb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNJdGVyID0gdGhpcy5nZXRJdGVyYXRvcihQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgpO1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckl0ZXIgPSBvdGhlckNoaWxkcmVuTm9kZS5nZXRJdGVyYXRvcihQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgpO1xuICAgICAgICAgICAgICAgIHZhciB0aGlzQ3VycmVudCA9IHRoaXNJdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJDdXJyZW50ID0gb3RoZXJJdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpc0N1cnJlbnQgJiYgb3RoZXJDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzQ3VycmVudC5uYW1lICE9PSBvdGhlckN1cnJlbnQubmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXNDdXJyZW50Lm5vZGUuZXF1YWxzKG90aGVyQ3VycmVudC5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNDdXJyZW50ID0gdGhpc0l0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBvdGhlckN1cnJlbnQgPSBvdGhlckl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0N1cnJlbnQgPT09IG51bGwgJiYgb3RoZXJDdXJyZW50ID09PSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgU29ydGVkTWFwIG9yZGVyZWQgYnkgaW5kZXgsIG9yIG51bGwgaWYgdGhlIGRlZmF1bHQgKGJ5LWtleSkgb3JkZXJpbmcgY2FuIGJlIHVzZWRcbiAgICAgKiBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7P1NvcnRlZE1hcC48TmFtZWROb2RlLCBOb2RlPn1cbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLnJlc29sdmVJbmRleF8gPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIGlmIChpbmRleERlZmluaXRpb24gPT09IEtleUluZGV4XzEuS0VZX0lOREVYKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFwXy5nZXQoaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLklOVEVHRVJfUkVHRVhQXyA9IC9eKDB8WzEtOV1cXGQqKSQvO1xuICAgIHJldHVybiBDaGlsZHJlbk5vZGU7XG59KCkpO1xuZXhwb3J0cy5DaGlsZHJlbk5vZGUgPSBDaGlsZHJlbk5vZGU7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0NoaWxkcmVuTm9kZX1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBNYXhOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXhOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1heE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgU29ydGVkTWFwXzEuU29ydGVkTWFwKGNvbXBhcmF0b3JzXzEuTkFNRV9DT01QQVJBVE9SKSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIEluZGV4TWFwXzEuSW5kZXhNYXAuRGVmYXVsdCkgfHwgdGhpcztcbiAgICB9XG4gICAgTWF4Tm9kZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF4Tm9kZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIC8vIE5vdCB0aGF0IHdlIGV2ZXJ5IGNvbXBhcmUgaXQsIGJ1dCBNQVhfTk9ERSBpcyBvbmx5IGV2ZXIgZXF1YWwgdG8gaXRzZWxmXG4gICAgICAgIHJldHVybiBvdGhlciA9PT0gdGhpcztcbiAgICB9O1xuICAgIE1heE5vZGUucHJvdG90eXBlLmdldFByaW9yaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1heE5vZGUucHJvdG90eXBlLmdldEltbWVkaWF0ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICByZXR1cm4gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgfTtcbiAgICBNYXhOb2RlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gTWF4Tm9kZTtcbn0oQ2hpbGRyZW5Ob2RlKSk7XG5leHBvcnRzLk1heE5vZGUgPSBNYXhOb2RlO1xuLyoqXG4gKiBNYXJrZXIgdGhhdCB3aWxsIHNvcnQgaGlnaGVyIHRoYW4gYW55IG90aGVyIHNuYXBzaG90LlxuICogQHR5cGUgeyFNQVhfTk9ERX1cbiAqIEBjb25zdFxuICovXG5leHBvcnRzLk1BWF9OT0RFID0gbmV3IE1heE5vZGUoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE5vZGVfMS5OYW1lZE5vZGUsIHtcbiAgICBNSU46IHtcbiAgICAgICAgdmFsdWU6IG5ldyBOb2RlXzEuTmFtZWROb2RlKHV0aWxfMi5NSU5fTkFNRSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpXG4gICAgfSxcbiAgICBNQVg6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBOb2RlXzEuTmFtZWROb2RlKHV0aWxfMi5NQVhfTkFNRSwgZXhwb3J0cy5NQVhfTk9ERSlcbiAgICB9XG59KTtcbi8qKlxuICogUmVmZXJlbmNlIEV4dGVuc2lvbnNcbiAqL1xuS2V5SW5kZXhfMS5LZXlJbmRleC5fX0VNUFRZX05PREUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbkxlYWZOb2RlXzEuTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvciA9IENoaWxkcmVuTm9kZTtcbnNuYXBfMS5zZXRNYXhOb2RlKGV4cG9ydHMuTUFYX05PREUpO1xuUHJpb3JpdHlJbmRleF8xLnNldE1heE5vZGUoZXhwb3J0cy5NQVhfTk9ERSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoaWxkcmVuTm9kZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgY2hpbGRTZXRfMSA9IHJlcXVpcmUoXCIuL2NoaWxkU2V0XCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBOb2RlXzEgPSByZXF1aXJlKFwiLi9Ob2RlXCIpO1xudmFyIFByaW9yaXR5SW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4ZXMvUHJpb3JpdHlJbmRleFwiKTtcbnZhciBLZXlJbmRleF8xID0gcmVxdWlyZShcIi4vaW5kZXhlcy9LZXlJbmRleFwiKTtcbnZhciBfZGVmYXVsdEluZGV4TWFwO1xudmFyIGZhbGxiYWNrT2JqZWN0ID0ge307XG4vKipcbiAqXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBGYWxsYmFja1R5cGV8U29ydGVkTWFwLjxOYW1lZE5vZGUsIE5vZGU+Pn0gaW5kZXhlc1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgSW5kZXg+fSBpbmRleFNldFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBJbmRleE1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmRleE1hcChpbmRleGVzXywgaW5kZXhTZXRfKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc18gPSBpbmRleGVzXztcbiAgICAgICAgdGhpcy5pbmRleFNldF8gPSBpbmRleFNldF87XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleE1hcCwgXCJEZWZhdWx0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IEluZGV4TWFwIGZvciBub2RlcyB3aXRob3V0IGEgcHJpb3JpdHlcbiAgICAgICAgICogQHR5cGUgeyFJbmRleE1hcH1cbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoZmFsbGJhY2tPYmplY3QgJiYgUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYLCAnQ2hpbGRyZW5Ob2RlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcbiAgICAgICAgICAgIF9kZWZhdWx0SW5kZXhNYXAgPVxuICAgICAgICAgICAgICAgIF9kZWZhdWx0SW5kZXhNYXAgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV3IEluZGV4TWFwKHsgJy5wcmlvcml0eSc6IGZhbGxiYWNrT2JqZWN0IH0sIHsgJy5wcmlvcml0eSc6IFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCB9KTtcbiAgICAgICAgICAgIHJldHVybiBfZGVmYXVsdEluZGV4TWFwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gaW5kZXhLZXlcbiAgICAgKiBAcmV0dXJuIHs/U29ydGVkTWFwLjxOYW1lZE5vZGUsIE5vZGU+fVxuICAgICAqL1xuICAgIEluZGV4TWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXhLZXkpIHtcbiAgICAgICAgdmFyIHNvcnRlZE1hcCA9IHV0aWxfMi5zYWZlR2V0KHRoaXMuaW5kZXhlc18sIGluZGV4S2V5KTtcbiAgICAgICAgaWYgKCFzb3J0ZWRNYXApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGluZGV4IGRlZmluZWQgZm9yICcgKyBpbmRleEtleSk7XG4gICAgICAgIGlmIChzb3J0ZWRNYXAgPT09IGZhbGxiYWNrT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBUaGUgaW5kZXggZXhpc3RzLCBidXQgaXQgZmFsbHMgYmFjayB0byBqdXN0IG5hbWUgY29tcGFyaXNvbi4gUmV0dXJuIG51bGwgc28gdGhhdCB0aGUgY2FsbGluZyBjb2RlIHVzZXMgdGhlXG4gICAgICAgICAgICAvLyByZWd1bGFyIGNoaWxkIG1hcFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydGVkTWFwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBJbmRleE1hcC5wcm90b3R5cGUuaGFzSW5kZXggPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB1dGlsXzIuY29udGFpbnModGhpcy5pbmRleFNldF8sIGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcGFyYW0geyFTb3J0ZWRNYXAuPHN0cmluZywgIU5vZGU+fSBleGlzdGluZ0NoaWxkcmVuXG4gICAgICogQHJldHVybiB7IUluZGV4TWFwfVxuICAgICAqL1xuICAgIEluZGV4TWFwLnByb3RvdHlwZS5hZGRJbmRleCA9IGZ1bmN0aW9uIChpbmRleERlZmluaXRpb24sIGV4aXN0aW5nQ2hpbGRyZW4pIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydChpbmRleERlZmluaXRpb24gIT09IEtleUluZGV4XzEuS0VZX0lOREVYLCBcIktleUluZGV4IGFsd2F5cyBleGlzdHMgYW5kIGlzbid0IG1lYW50IHRvIGJlIGFkZGVkIHRvIHRoZSBJbmRleE1hcC5cIik7XG4gICAgICAgIHZhciBjaGlsZExpc3QgPSBbXTtcbiAgICAgICAgdmFyIHNhd0luZGV4ZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgaXRlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0SXRlcmF0b3IoTm9kZV8xLk5hbWVkTm9kZS5XcmFwKTtcbiAgICAgICAgdmFyIG5leHQgPSBpdGVyLmdldE5leHQoKTtcbiAgICAgICAgd2hpbGUgKG5leHQpIHtcbiAgICAgICAgICAgIHNhd0luZGV4ZWRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgc2F3SW5kZXhlZFZhbHVlIHx8IGluZGV4RGVmaW5pdGlvbi5pc0RlZmluZWRPbihuZXh0Lm5vZGUpO1xuICAgICAgICAgICAgY2hpbGRMaXN0LnB1c2gobmV4dCk7XG4gICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0luZGV4O1xuICAgICAgICBpZiAoc2F3SW5kZXhlZFZhbHVlKSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IGNoaWxkU2V0XzEuYnVpbGRDaGlsZFNldChjaGlsZExpc3QsIGluZGV4RGVmaW5pdGlvbi5nZXRDb21wYXJlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3SW5kZXggPSBmYWxsYmFja09iamVjdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXhOYW1lID0gaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBuZXdJbmRleFNldCA9IHV0aWxfMi5jbG9uZSh0aGlzLmluZGV4U2V0Xyk7XG4gICAgICAgIG5ld0luZGV4U2V0W2luZGV4TmFtZV0gPSBpbmRleERlZmluaXRpb247XG4gICAgICAgIHZhciBuZXdJbmRleGVzID0gdXRpbF8yLmNsb25lKHRoaXMuaW5kZXhlc18pO1xuICAgICAgICBuZXdJbmRleGVzW2luZGV4TmFtZV0gPSBuZXdJbmRleDtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE1hcChuZXdJbmRleGVzLCBuZXdJbmRleFNldCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCB0aGlzIG5vZGUgaXMgcHJvcGVybHkgdHJhY2tlZCBpbiBhbnkgaW5kZXhlcyB0aGF0IHdlJ3JlIG1haW50YWluaW5nXG4gICAgICogQHBhcmFtIHshTmFtZWROb2RlfSBuYW1lZE5vZGVcbiAgICAgKiBAcGFyYW0geyFTb3J0ZWRNYXAuPHN0cmluZywgIU5vZGU+fSBleGlzdGluZ0NoaWxkcmVuXG4gICAgICogQHJldHVybiB7IUluZGV4TWFwfVxuICAgICAqL1xuICAgIEluZGV4TWFwLnByb3RvdHlwZS5hZGRUb0luZGV4ZXMgPSBmdW5jdGlvbiAobmFtZWROb2RlLCBleGlzdGluZ0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuZXdJbmRleGVzID0gdXRpbF8yLm1hcCh0aGlzLmluZGV4ZXNfLCBmdW5jdGlvbiAoaW5kZXhlZENoaWxkcmVuLCBpbmRleE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHV0aWxfMi5zYWZlR2V0KF90aGlzLmluZGV4U2V0XywgaW5kZXhOYW1lKTtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoaW5kZXgsICdNaXNzaW5nIGluZGV4IGltcGxlbWVudGF0aW9uIGZvciAnICsgaW5kZXhOYW1lKTtcbiAgICAgICAgICAgIGlmIChpbmRleGVkQ2hpbGRyZW4gPT09IGZhbGxiYWNrT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gaW5kZXggZXZlcnl0aGluZ1xuICAgICAgICAgICAgICAgIGlmIChpbmRleC5pc0RlZmluZWRPbihuYW1lZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBidWlsZCB0aGlzIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZExpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldEl0ZXJhdG9yKE5vZGVfMS5OYW1lZE5vZGUuV3JhcCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5uYW1lICE9IG5hbWVkTm9kZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRMaXN0LnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hpbGRMaXN0LnB1c2gobmFtZWROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkU2V0XzEuYnVpbGRDaGlsZFNldChjaGlsZExpc3QsIGluZGV4LmdldENvbXBhcmUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBjaGFuZ2UsIHRoaXMgcmVtYWlucyBhIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFja09iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdTbmFwID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmFtZWROb2RlLm5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IGluZGV4ZWRDaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdTbmFwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gbmV3Q2hpbGRyZW4ucmVtb3ZlKG5ldyBOb2RlXzEuTmFtZWROb2RlKG5hbWVkTm9kZS5uYW1lLCBleGlzdGluZ1NuYXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuLmluc2VydChuYW1lZE5vZGUsIG5hbWVkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhNYXAobmV3SW5kZXhlcywgdGhpcy5pbmRleFNldF8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEluZGV4TWFwIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIHZhbHVlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0geyFOYW1lZE5vZGV9IG5hbWVkTm9kZVxuICAgICAqIEBwYXJhbSB7IVNvcnRlZE1hcC48c3RyaW5nLCAhTm9kZT59IGV4aXN0aW5nQ2hpbGRyZW5cbiAgICAgKiBAcmV0dXJuIHshSW5kZXhNYXB9XG4gICAgICovXG4gICAgSW5kZXhNYXAucHJvdG90eXBlLnJlbW92ZUZyb21JbmRleGVzID0gZnVuY3Rpb24gKG5hbWVkTm9kZSwgZXhpc3RpbmdDaGlsZHJlbikge1xuICAgICAgICB2YXIgbmV3SW5kZXhlcyA9IHV0aWxfMi5tYXAodGhpcy5pbmRleGVzXywgZnVuY3Rpb24gKGluZGV4ZWRDaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGluZGV4ZWRDaGlsZHJlbiA9PT0gZmFsbGJhY2tPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmYWxsYmFjay4gSnVzdCByZXR1cm4gaXQsIG5vdGhpbmcgdG8gZG8gaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ZWRDaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ1NuYXAgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuYW1lZE5vZGUubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU25hcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuLnJlbW92ZShuZXcgTm9kZV8xLk5hbWVkTm9kZShuYW1lZE5vZGUubmFtZSwgZXhpc3RpbmdTbmFwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyByZWNvcmQgb2YgdGhpcyBjaGlsZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhNYXAobmV3SW5kZXhlcywgdGhpcy5pbmRleFNldF8pO1xuICAgIH07XG4gICAgcmV0dXJuIEluZGV4TWFwO1xufSgpKTtcbmV4cG9ydHMuSW5kZXhNYXAgPSBJbmRleE1hcDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5kZXhNYXAuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuLi91dGlsL3V0aWxcIik7XG52YXIgc25hcF8xID0gcmVxdWlyZShcIi4vc25hcFwiKTtcbnZhciBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yO1xuLyoqXG4gKiBMZWFmTm9kZSBpcyBhIGNsYXNzIGZvciBzdG9yaW5nIGxlYWYgbm9kZXMgaW4gYSBEYXRhU25hcHNob3QuICBJdFxuICogaW1wbGVtZW50cyBOb2RlIGFuZCBzdG9yZXMgdGhlIHZhbHVlIG9mIHRoZSBub2RlIChhIHN0cmluZyxcbiAqIG51bWJlciwgb3IgYm9vbGVhbikgYWNjZXNzaWJsZSB2aWEgZ2V0VmFsdWUoKS5cbiAqL1xudmFyIExlYWZOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7IShzdHJpbmd8bnVtYmVyfGJvb2xlYW58T2JqZWN0KX0gdmFsdWVfIFRoZSB2YWx1ZSB0byBzdG9yZSBpbiB0aGlzIGxlYWYgbm9kZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCB0eXBlIGlzIHBvc3NpYmxlIGluIHRoZSBldmVudCBvZiBhIGRlZmVycmVkIHZhbHVlXG4gICAgICogQHBhcmFtIHshTm9kZT19IHByaW9yaXR5Tm9kZV8gVGhlIHByaW9yaXR5IG9mIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMZWFmTm9kZSh2YWx1ZV8sIHByaW9yaXR5Tm9kZV8pIHtcbiAgICAgICAgaWYgKHByaW9yaXR5Tm9kZV8gPT09IHZvaWQgMCkgeyBwcmlvcml0eU5vZGVfID0gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFOyB9XG4gICAgICAgIHRoaXMudmFsdWVfID0gdmFsdWVfO1xuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8gPSBwcmlvcml0eU5vZGVfO1xuICAgICAgICB0aGlzLmxhenlIYXNoXyA9IG51bGw7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodGhpcy52YWx1ZV8gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbHVlXyAhPT0gbnVsbCwgXCJMZWFmTm9kZSBzaG91bGRuJ3QgYmUgY3JlYXRlZCB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlLlwiKTtcbiAgICAgICAgc25hcF8xLnZhbGlkYXRlUHJpb3JpdHlOb2RlKHRoaXMucHJpb3JpdHlOb2RlXyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZWFmTm9kZSwgXCJfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuaXNMZWFmTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuZ2V0UHJpb3JpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaW9yaXR5Tm9kZV87XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUudXBkYXRlUHJpb3JpdHkgPSBmdW5jdGlvbiAobmV3UHJpb3JpdHlOb2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUodGhpcy52YWx1ZV8sIG5ld1ByaW9yaXR5Tm9kZSk7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuZ2V0SW1tZWRpYXRlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGROYW1lKSB7XG4gICAgICAgIC8vIEhhY2sgdG8gdHJlYXQgcHJpb3JpdHkgYXMgYSByZWd1bGFyIGNoaWxkXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXRoLmdldEZyb250KCkgPT09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuaGFzQ2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5nZXRQcmVkZWNlc3NvckNoaWxkTmFtZSA9IGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS51cGRhdGVJbW1lZGlhdGVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSkge1xuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUHJpb3JpdHkobmV3Q2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpICYmIGNoaWxkTmFtZSAhPT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERVxuICAgICAgICAgICAgICAgIC51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSlcbiAgICAgICAgICAgICAgICAudXBkYXRlUHJpb3JpdHkodGhpcy5wcmlvcml0eU5vZGVfKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLnVwZGF0ZUNoaWxkID0gZnVuY3Rpb24gKHBhdGgsIG5ld0NoaWxkTm9kZSkge1xuICAgICAgICB2YXIgZnJvbnQgPSBwYXRoLmdldEZyb250KCk7XG4gICAgICAgIGlmIChmcm9udCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpICYmIGZyb250ICE9PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KGZyb250ICE9PSAnLnByaW9yaXR5JyB8fCBwYXRoLmdldExlbmd0aCgpID09PSAxLCAnLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVJbW1lZGlhdGVDaGlsZChmcm9udCwgTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHBhdGgucG9wRnJvbnQoKSwgbmV3Q2hpbGROb2RlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUubnVtQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uIChleHBvcnRGb3JtYXQpIHtcbiAgICAgICAgaWYgKGV4cG9ydEZvcm1hdCAmJiAhdGhpcy5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJy52YWx1ZSc6IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgICAgICAnLnByaW9yaXR5JzogdGhpcy5nZXRQcmlvcml0eSgpLnZhbCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxhenlIYXNoXyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHRvSGFzaCA9ICcnO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgIHRvSGFzaCArPVxuICAgICAgICAgICAgICAgICAgICAncHJpb3JpdHk6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwXzEucHJpb3JpdHlIYXNoVGV4dCh0aGlzLnByaW9yaXR5Tm9kZV8udmFsKCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc6JztcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHRoaXMudmFsdWVfO1xuICAgICAgICAgICAgdG9IYXNoICs9IHR5cGUgKyAnOic7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz0gdXRpbF8yLmRvdWJsZVRvSUVFRTc1NFN0cmluZyh0aGlzLnZhbHVlXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz0gdGhpcy52YWx1ZV87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhenlIYXNoXyA9IHV0aWxfMi5zaGExKHRvSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGF6eUhhc2hfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGxlYWYgbm9kZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R8c3RyaW5nfG51bWJlcnxib29sZWFufSBUaGUgdmFsdWUgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09PSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyIGluc3RhbmNlb2YgTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbF8xLmFzc2VydChvdGhlci5pc0xlYWZOb2RlKCksICdVbmtub3duIG5vZGUgdHlwZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvTGVhZk5vZGVfKG90aGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyaXNvbiBzcGVjaWZpY2FsbHkgZm9yIHR3byBsZWFmIG5vZGVzXG4gICAgICogQHBhcmFtIHshTGVhZk5vZGV9IG90aGVyTGVhZlxuICAgICAqIEByZXR1cm4geyFudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuY29tcGFyZVRvTGVhZk5vZGVfID0gZnVuY3Rpb24gKG90aGVyTGVhZikge1xuICAgICAgICB2YXIgb3RoZXJMZWFmVHlwZSA9IHR5cGVvZiBvdGhlckxlYWYudmFsdWVfO1xuICAgICAgICB2YXIgdGhpc0xlYWZUeXBlID0gdHlwZW9mIHRoaXMudmFsdWVfO1xuICAgICAgICB2YXIgb3RoZXJJbmRleCA9IExlYWZOb2RlLlZBTFVFX1RZUEVfT1JERVIuaW5kZXhPZihvdGhlckxlYWZUeXBlKTtcbiAgICAgICAgdmFyIHRoaXNJbmRleCA9IExlYWZOb2RlLlZBTFVFX1RZUEVfT1JERVIuaW5kZXhPZih0aGlzTGVhZlR5cGUpO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KG90aGVySW5kZXggPj0gMCwgJ1Vua25vd24gbGVhZiB0eXBlOiAnICsgb3RoZXJMZWFmVHlwZSk7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodGhpc0luZGV4ID49IDAsICdVbmtub3duIGxlYWYgdHlwZTogJyArIHRoaXNMZWFmVHlwZSk7XG4gICAgICAgIGlmIChvdGhlckluZGV4ID09PSB0aGlzSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFNhbWUgdHlwZSwgY29tcGFyZSB2YWx1ZXNcbiAgICAgICAgICAgIGlmICh0aGlzTGVhZlR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmZXJyZWQgdmFsdWUgbm9kZXMgYXJlIGFsbCBlcXVhbCwgYnV0IHdlIHNob3VsZCBhbHNvIG5ldmVyIGdldCB0byB0aGlzIHBvaW50Li4uXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3b3JrcyBiZWNhdXNlIHRydWUgPiBmYWxzZSwgYWxsIG90aGVycyBhcmUgbnVtYmVyIG9yIHN0cmluZyBjb21wYXJpc29uc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlXyA8IG90aGVyTGVhZi52YWx1ZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnZhbHVlXyA9PT0gb3RoZXJMZWFmLnZhbHVlXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzSW5kZXggLSBvdGhlckluZGV4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS53aXRoSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuaXNJbmRleGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGluaGVyaXREb2NcbiAgICAgICAgICovXG4gICAgICAgIGlmIChvdGhlciA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJMZWFmID0gb3RoZXI7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWVfID09PSBvdGhlckxlYWYudmFsdWVfICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wcmlvcml0eU5vZGVfLmVxdWFscyhvdGhlckxlYWYucHJpb3JpdHlOb2RlXykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgc29ydCBvcmRlciBmb3IgY29tcGFyaW5nIGxlYWYgbm9kZXMgb2YgZGlmZmVyZW50IHR5cGVzLiBJZiB0d28gbGVhZiBub2RlcyBoYXZlXG4gICAgICogdGhlIHNhbWUgdHlwZSwgdGhlIGNvbXBhcmlzb24gZmFsbHMgYmFjayB0byB0aGVpciB2YWx1ZVxuICAgICAqIEB0eXBlIHtBcnJheS48IXN0cmluZz59XG4gICAgICogQGNvbnN0XG4gICAgICovXG4gICAgTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUiA9IFsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZyddO1xuICAgIHJldHVybiBMZWFmTm9kZTtcbn0oKSk7XG5leHBvcnRzLkxlYWZOb2RlID0gTGVhZk5vZGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlYWZOb2RlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIE5hbWVkTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOYW1lZE5vZGUobmFtZSwgbm9kZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJuIHtOYW1lZE5vZGV9XG4gICAgICovXG4gICAgTmFtZWROb2RlLldyYXAgPSBmdW5jdGlvbiAobmFtZSwgbm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBub2RlKTtcbiAgICB9O1xuICAgIHJldHVybiBOYW1lZE5vZGU7XG59KCkpO1xuZXhwb3J0cy5OYW1lZE5vZGUgPSBOYW1lZE5vZGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vZGUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU29ydGVkTWFwXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9Tb3J0ZWRNYXBcIik7XG52YXIgU29ydGVkTWFwXzIgPSByZXF1aXJlKFwiLi4vdXRpbC9Tb3J0ZWRNYXBcIik7XG52YXIgTE9HXzIgPSBNYXRoLmxvZygyKTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBCYXNlMTJOdW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJhc2UxMk51bShsZW5ndGgpIHtcbiAgICAgICAgdmFyIGxvZ0Jhc2UyID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KChNYXRoLmxvZyhudW0pIC8gTE9HXzIpLCAxMCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiaXRNYXNrID0gZnVuY3Rpb24gKGJpdHMpIHsgcmV0dXJuIHBhcnNlSW50KEFycmF5KGJpdHMgKyAxKS5qb2luKCcxJyksIDIpOyB9O1xuICAgICAgICB0aGlzLmNvdW50ID0gbG9nQmFzZTIobGVuZ3RoICsgMSk7XG4gICAgICAgIHRoaXMuY3VycmVudF8gPSB0aGlzLmNvdW50IC0gMTtcbiAgICAgICAgdmFyIG1hc2sgPSBiaXRNYXNrKHRoaXMuY291bnQpO1xuICAgICAgICB0aGlzLmJpdHNfID0gKGxlbmd0aCArIDEpICYgbWFzaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBCYXNlMTJOdW0ucHJvdG90eXBlLm5leHRCaXRJc09uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNCaXR3aXNlT3BlcmF0b3JVc2FnZVxuICAgICAgICB2YXIgcmVzdWx0ID0gISh0aGlzLmJpdHNfICYgKDB4MSA8PCB0aGlzLmN1cnJlbnRfKSk7XG4gICAgICAgIHRoaXMuY3VycmVudF8tLTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlMTJOdW07XG59KCkpO1xuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2YgY2hpbGQgbm9kZXMgYW5kIGNvbnN0cnVjdHMgYSBTb3J0ZWRTZXQgdXNpbmcgdGhlIGdpdmVuIGNvbXBhcmlzb25cbiAqIGZ1bmN0aW9uXG4gKlxuICogVXNlcyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBpbiB0aGUgcGFwZXIgbGlua2VkIGhlcmU6XG4gKiBodHRwOi8vY2l0ZXNlZXJ4LmlzdC5wc3UuZWR1L3ZpZXdkb2Mvc3VtbWFyeT9kb2k9MTAuMS4xLjQ2LjE0NThcbiAqXG4gKiBAdGVtcGxhdGUgSywgVlxuICogQHBhcmFtIHtBcnJheS48IU5hbWVkTm9kZT59IGNoaWxkTGlzdCBVbnNvcnRlZCBsaXN0IG9mIGNoaWxkcmVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCFOYW1lZE5vZGUsICFOYW1lZE5vZGUpOm51bWJlcn0gY21wIFRoZSBjb21wYXJpc29uIG1ldGhvZCB0byBiZSB1c2VkXG4gKiBAcGFyYW0geyhmdW5jdGlvbihOYW1lZE5vZGUpOkspPX0ga2V5Rm4gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZXh0cmFjdCBLIGZyb20gYSBub2RlIHdyYXBwZXIsIGlmIEsnc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgaXMgbm90IE5hbWVkTm9kZVxuICogQHBhcmFtIHsoZnVuY3Rpb24oSywgSyk6bnVtYmVyKT19IG1hcFNvcnRGbiBBbiBvcHRpb25hbCBvdmVycmlkZSBmb3IgY29tcGFyYXRvciB1c2VkIGJ5IHRoZSBnZW5lcmF0ZWQgc29ydGVkIG1hcFxuICogQHJldHVybiB7U29ydGVkTWFwLjxLLCBWPn1cbiAqL1xuZXhwb3J0cy5idWlsZENoaWxkU2V0ID0gZnVuY3Rpb24gKGNoaWxkTGlzdCwgY21wLCBrZXlGbiwgbWFwU29ydEZuKSB7XG4gICAgY2hpbGRMaXN0LnNvcnQoY21wKTtcbiAgICB2YXIgYnVpbGRCYWxhbmNlZFRyZWUgPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBoaWdoIC0gbG93O1xuICAgICAgICB2YXIgbmFtZWROb2RlO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBpZiAobGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBuYW1lZE5vZGUgPSBjaGlsZExpc3RbbG93XTtcbiAgICAgICAgICAgIGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwXzEuTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgU29ydGVkTWFwXzEuTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1pZGRsZSA9IHBhcnNlSW50KChsZW5ndGggLyAyKSwgMTApICsgbG93O1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBidWlsZEJhbGFuY2VkVHJlZShsb3csIG1pZGRsZSk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBidWlsZEJhbGFuY2VkVHJlZShtaWRkbGUgKyAxLCBoaWdoKTtcbiAgICAgICAgICAgIG5hbWVkTm9kZSA9IGNoaWxkTGlzdFttaWRkbGVdO1xuICAgICAgICAgICAga2V5ID0ga2V5Rm4gPyBrZXlGbihuYW1lZE5vZGUpIDogbmFtZWROb2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBfMS5MTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBTb3J0ZWRNYXBfMS5MTFJCTm9kZS5CTEFDSywgbGVmdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYnVpbGRGcm9tMTJBcnJheSA9IGZ1bmN0aW9uIChiYXNlMTIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xuICAgICAgICB2YXIgcm9vdCA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IGNoaWxkTGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBidWlsZFBlbm5hbnQgPSBmdW5jdGlvbiAoY2h1bmtTaXplLCBjb2xvcikge1xuICAgICAgICAgICAgdmFyIGxvdyA9IGluZGV4IC0gY2h1bmtTaXplO1xuICAgICAgICAgICAgdmFyIGhpZ2ggPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4IC09IGNodW5rU2l6ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZFRyZWUgPSBidWlsZEJhbGFuY2VkVHJlZShsb3cgKyAxLCBoaWdoKTtcbiAgICAgICAgICAgIHZhciBuYW1lZE5vZGUgPSBjaGlsZExpc3RbbG93XTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiBuYW1lZE5vZGU7XG4gICAgICAgICAgICBhdHRhY2hQZW5uYW50KG5ldyBTb3J0ZWRNYXBfMS5MTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBjb2xvciwgbnVsbCwgY2hpbGRUcmVlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhdHRhY2hQZW5uYW50ID0gZnVuY3Rpb24gKHBlbm5hbnQpIHtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sZWZ0ID0gcGVubmFudDtcbiAgICAgICAgICAgICAgICBub2RlID0gcGVubmFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QgPSBwZW5uYW50O1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwZW5uYW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2UxMi5jb3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXNPbmUgPSBiYXNlMTIubmV4dEJpdElzT25lKCk7XG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIG5vZGVzIHRha2VuIGluIGVhY2ggc2xpY2UgaXMgMl4oYXJyLmxlbmd0aCAtIChpICsgMSkpXG4gICAgICAgICAgICB2YXIgY2h1bmtTaXplID0gTWF0aC5wb3coMiwgYmFzZTEyLmNvdW50IC0gKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAoaXNPbmUpIHtcbiAgICAgICAgICAgICAgICBidWlsZFBlbm5hbnQoY2h1bmtTaXplLCBTb3J0ZWRNYXBfMS5MTFJCTm9kZS5CTEFDSyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50ID09IDJcbiAgICAgICAgICAgICAgICBidWlsZFBlbm5hbnQoY2h1bmtTaXplLCBTb3J0ZWRNYXBfMS5MTFJCTm9kZS5CTEFDSyk7XG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgU29ydGVkTWFwXzEuTExSQk5vZGUuUkVEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuICAgIHZhciBiYXNlMTIgPSBuZXcgQmFzZTEyTnVtKGNoaWxkTGlzdC5sZW5ndGgpO1xuICAgIHZhciByb290ID0gYnVpbGRGcm9tMTJBcnJheShiYXNlMTIpO1xuICAgIHJldHVybiBuZXcgU29ydGVkTWFwXzIuU29ydGVkTWFwKG1hcFNvcnRGbiB8fCBjbXAsIHJvb3QpO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hpbGRTZXQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbFwiKTtcbmZ1bmN0aW9uIE5BTUVfT05MWV9DT01QQVJBVE9SKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHV0aWxfMS5uYW1lQ29tcGFyZShsZWZ0Lm5hbWUsIHJpZ2h0Lm5hbWUpO1xufVxuZXhwb3J0cy5OQU1FX09OTFlfQ09NUEFSQVRPUiA9IE5BTUVfT05MWV9DT01QQVJBVE9SO1xuZnVuY3Rpb24gTkFNRV9DT01QQVJBVE9SKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHV0aWxfMS5uYW1lQ29tcGFyZShsZWZ0LCByaWdodCk7XG59XG5leHBvcnRzLk5BTUVfQ09NUEFSQVRPUiA9IE5BTUVfQ09NUEFSQVRPUjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGFyYXRvcnMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTm9kZV8xID0gcmVxdWlyZShcIi4uL05vZGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvdXRpbFwiKTtcbi8qKlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSW5kZXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5kZXgoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKCFOYW1lZE5vZGUsICFOYW1lZE5vZGUpOm51bWJlcn0gQSBzdGFuZGFsb25lIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yXG4gICAgICogdGhpcyBpbmRleFxuICAgICAqL1xuICAgIEluZGV4LnByb3RvdHlwZS5nZXRDb21wYXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlLmJpbmQodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGJlZm9yZSBhbmQgYWZ0ZXIgdmFsdWUgZm9yIGEgbm9kZSwgZGV0ZXJtaW5lIGlmIHRoZSBpbmRleGVkIHZhbHVlIGhhcyBjaGFuZ2VkLiBFdmVuIGlmIHRoZXkgYXJlIGRpZmZlcmVudCxcbiAgICAgKiBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNoYW5nZXMgYXJlIGlzb2xhdGVkIHRvIHBhcnRzIG9mIHRoZSBzbmFwc2hvdCB0aGF0IGFyZSBub3QgaW5kZXhlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG9sZE5vZGVcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBuZXdOb2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcG9ydGlvbiBvZiB0aGUgc25hcHNob3QgYmVpbmcgaW5kZXhlZCBjaGFuZ2VkIGJldHdlZW4gb2xkTm9kZSBhbmQgbmV3Tm9kZVxuICAgICAqL1xuICAgIEluZGV4LnByb3RvdHlwZS5pbmRleGVkVmFsdWVDaGFuZ2VkID0gZnVuY3Rpb24gKG9sZE5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgdmFyIG9sZFdyYXBwZWQgPSBuZXcgTm9kZV8xLk5hbWVkTm9kZSh1dGlsXzEuTUlOX05BTUUsIG9sZE5vZGUpO1xuICAgICAgICB2YXIgbmV3V3JhcHBlZCA9IG5ldyBOb2RlXzEuTmFtZWROb2RlKHV0aWxfMS5NSU5fTkFNRSwgbmV3Tm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob2xkV3JhcHBlZCwgbmV3V3JhcHBlZCkgIT09IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfSBhIG5vZGUgd3JhcHBlciB0aGF0IHdpbGwgc29ydCBlcXVhbCB0byBvciBsZXNzIHRoYW5cbiAgICAgKiBhbnkgb3RoZXIgbm9kZSB3cmFwcGVyLCB1c2luZyB0aGlzIGluZGV4XG4gICAgICovXG4gICAgSW5kZXgucHJvdG90eXBlLm1pblBvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBOb2RlXzEuTmFtZWROb2RlLk1JTjtcbiAgICB9O1xuICAgIHJldHVybiBJbmRleDtcbn0oKSk7XG5leHBvcnRzLkluZGV4ID0gSW5kZXg7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgSW5kZXhfMSA9IHJlcXVpcmUoXCIuL0luZGV4XCIpO1xudmFyIE5vZGVfMSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIF9fRU1QVFlfTk9ERTtcbnZhciBLZXlJbmRleCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5SW5kZXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gS2V5SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtleUluZGV4LCBcIl9fRU1QVFlfTk9ERVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fRU1QVFlfTk9ERTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBfX0VNUFRZX05PREUgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgS2V5SW5kZXgucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdXRpbF8xLm5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgS2V5SW5kZXgucHJvdG90eXBlLmlzRGVmaW5lZE9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgLy8gV2UgY291bGQgcHJvYmFibHkgcmV0dXJuIHRydWUgaGVyZSAoc2luY2UgZXZlcnkgbm9kZSBoYXMgYSBrZXkpLCBidXQgaXQncyBuZXZlciBjYWxsZWRcbiAgICAgICAgLy8gc28ganVzdCBsZWF2aW5nIHVuaW1wbGVtZW50ZWQgZm9yIG5vdy5cbiAgICAgICAgdGhyb3cgdXRpbF8yLmFzc2VydGlvbkVycm9yKCdLZXlJbmRleC5pc0RlZmluZWRPbiBub3QgZXhwZWN0ZWQgdG8gYmUgY2FsbGVkLicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBLZXlJbmRleC5wcm90b3R5cGUuaW5kZXhlZFZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGROb2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVGhlIGtleSBmb3IgYSBub2RlIG5ldmVyIGNoYW5nZXMuXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEtleUluZGV4LnByb3RvdHlwZS5taW5Qb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTm9kZV8xLk5hbWVkTm9kZS5NSU47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEtleUluZGV4LnByb3RvdHlwZS5tYXhQb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZWFsbHkgYmUgY3JlYXRlZCBvbmNlIGFuZCBjYWNoZWQgaW4gYSBzdGF0aWMgcHJvcGVydHksIGJ1dFxuICAgICAgICAvLyBOYW1lZE5vZGUgaXNuJ3QgZGVmaW5lZCB5ZXQsIHNvIEkgY2FuJ3QgdXNlIGl0IGluIGEgc3RhdGljLiAgQmxlaC5cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlXzEuTmFtZWROb2RlKHV0aWxfMS5NQVhfTkFNRSwgX19FTVBUWV9OT0RFKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXhWYWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7IU5hbWVkTm9kZX1cbiAgICAgKi9cbiAgICBLZXlJbmRleC5wcm90b3R5cGUubWFrZVBvc3QgPSBmdW5jdGlvbiAoaW5kZXhWYWx1ZSwgbmFtZSkge1xuICAgICAgICB1dGlsXzIuYXNzZXJ0KHR5cGVvZiBpbmRleFZhbHVlID09PSAnc3RyaW5nJywgJ0tleUluZGV4IGluZGV4VmFsdWUgbXVzdCBhbHdheXMgYmUgYSBzdHJpbmcuJyk7XG4gICAgICAgIC8vIFdlIGp1c3QgdXNlIGVtcHR5IG5vZGUsIGJ1dCBpdCdsbCBuZXZlciBiZSBjb21wYXJlZCwgc2luY2Ugb3VyIGNvbXBhcmF0b3Igb25seSBsb29rcyBhdCBuYW1lLlxuICAgICAgICByZXR1cm4gbmV3IE5vZGVfMS5OYW1lZE5vZGUoaW5kZXhWYWx1ZSwgX19FTVBUWV9OT0RFKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xuICAgICAqL1xuICAgIEtleUluZGV4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcua2V5JztcbiAgICB9O1xuICAgIHJldHVybiBLZXlJbmRleDtcbn0oSW5kZXhfMS5JbmRleCkpO1xuZXhwb3J0cy5LZXlJbmRleCA9IEtleUluZGV4O1xuZXhwb3J0cy5LRVlfSU5ERVggPSBuZXcgS2V5SW5kZXgoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2V5SW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvdXRpbFwiKTtcbnZhciBJbmRleF8xID0gcmVxdWlyZShcIi4vSW5kZXhcIik7XG52YXIgQ2hpbGRyZW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIE5vZGVfMSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xudmFyIG5vZGVGcm9tSlNPTl8xID0gcmVxdWlyZShcIi4uL25vZGVGcm9tSlNPTlwiKTtcbi8qKlxuICogQHBhcmFtIHshUGF0aH0gaW5kZXhQYXRoXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtJbmRleH1cbiAqL1xudmFyIFBhdGhJbmRleCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGF0aEluZGV4LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhdGhJbmRleChpbmRleFBhdGhfKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmluZGV4UGF0aF8gPSBpbmRleFBhdGhfO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KCFpbmRleFBhdGhfLmlzRW1wdHkoKSAmJiBpbmRleFBhdGhfLmdldEZyb250KCkgIT09ICcucHJpb3JpdHknLCBcIkNhbid0IGNyZWF0ZSBQYXRoSW5kZXggd2l0aCBlbXB0eSBwYXRoIG9yIC5wcmlvcml0eSBrZXlcIik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gc25hcFxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBQYXRoSW5kZXgucHJvdG90eXBlLmV4dHJhY3RDaGlsZCA9IGZ1bmN0aW9uIChzbmFwKSB7XG4gICAgICAgIHJldHVybiBzbmFwLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBhdGhJbmRleC5wcm90b3R5cGUuaXNEZWZpbmVkT24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gIW5vZGUuZ2V0Q2hpbGQodGhpcy5pbmRleFBhdGhfKS5pc0VtcHR5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBhdGhJbmRleC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBhQ2hpbGQgPSB0aGlzLmV4dHJhY3RDaGlsZChhLm5vZGUpO1xuICAgICAgICB2YXIgYkNoaWxkID0gdGhpcy5leHRyYWN0Q2hpbGQoYi5ub2RlKTtcbiAgICAgICAgdmFyIGluZGV4Q21wID0gYUNoaWxkLmNvbXBhcmVUbyhiQ2hpbGQpO1xuICAgICAgICBpZiAoaW5kZXhDbXAgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzIubmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4Q21wO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBhdGhJbmRleC5wcm90b3R5cGUubWFrZVBvc3QgPSBmdW5jdGlvbiAoaW5kZXhWYWx1ZSwgbmFtZSkge1xuICAgICAgICB2YXIgdmFsdWVOb2RlID0gbm9kZUZyb21KU09OXzEubm9kZUZyb21KU09OKGluZGV4VmFsdWUpO1xuICAgICAgICB2YXIgbm9kZSA9IENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHRoaXMuaW5kZXhQYXRoXywgdmFsdWVOb2RlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlXzEuTmFtZWROb2RlKG5hbWUsIG5vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQYXRoSW5kZXgucHJvdG90eXBlLm1heFBvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUudXBkYXRlQ2hpbGQodGhpcy5pbmRleFBhdGhfLCBDaGlsZHJlbk5vZGVfMS5NQVhfTk9ERSk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZV8xLk5hbWVkTm9kZSh1dGlsXzIuTUFYX05BTUUsIG5vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQYXRoSW5kZXgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFBhdGhfLnNsaWNlKCkuam9pbignLycpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhdGhJbmRleDtcbn0oSW5kZXhfMS5JbmRleCkpO1xuZXhwb3J0cy5QYXRoSW5kZXggPSBQYXRoSW5kZXg7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhdGhJbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEluZGV4XzEgPSByZXF1aXJlKFwiLi9JbmRleFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC91dGlsXCIpO1xudmFyIE5vZGVfMSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xudmFyIExlYWZOb2RlXzEgPSByZXF1aXJlKFwiLi4vTGVhZk5vZGVcIik7XG52YXIgbm9kZUZyb21KU09OO1xudmFyIE1BWF9OT0RFO1xuZnVuY3Rpb24gc2V0Tm9kZUZyb21KU09OKHZhbCkge1xuICAgIG5vZGVGcm9tSlNPTiA9IHZhbDtcbn1cbmV4cG9ydHMuc2V0Tm9kZUZyb21KU09OID0gc2V0Tm9kZUZyb21KU09OO1xuZnVuY3Rpb24gc2V0TWF4Tm9kZSh2YWwpIHtcbiAgICBNQVhfTk9ERSA9IHZhbDtcbn1cbmV4cG9ydHMuc2V0TWF4Tm9kZSA9IHNldE1heE5vZGU7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0luZGV4fVxuICogQHByaXZhdGVcbiAqL1xudmFyIFByaW9yaXR5SW5kZXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByaW9yaXR5SW5kZXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJpb3JpdHlJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFByaW9yaXR5SW5kZXgucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYVByaW9yaXR5ID0gYS5ub2RlLmdldFByaW9yaXR5KCk7XG4gICAgICAgIHZhciBiUHJpb3JpdHkgPSBiLm5vZGUuZ2V0UHJpb3JpdHkoKTtcbiAgICAgICAgdmFyIGluZGV4Q21wID0gYVByaW9yaXR5LmNvbXBhcmVUbyhiUHJpb3JpdHkpO1xuICAgICAgICBpZiAoaW5kZXhDbXAgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEubmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4Q21wO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFByaW9yaXR5SW5kZXgucHJvdG90eXBlLmlzRGVmaW5lZE9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFub2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQcmlvcml0eUluZGV4LnByb3RvdHlwZS5pbmRleGVkVmFsdWVDaGFuZ2VkID0gZnVuY3Rpb24gKG9sZE5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgcmV0dXJuICFvbGROb2RlLmdldFByaW9yaXR5KCkuZXF1YWxzKG5ld05vZGUuZ2V0UHJpb3JpdHkoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFByaW9yaXR5SW5kZXgucHJvdG90eXBlLm1pblBvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBOb2RlXzEuTmFtZWROb2RlLk1JTjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUHJpb3JpdHlJbmRleC5wcm90b3R5cGUubWF4UG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlXzEuTmFtZWROb2RlKHV0aWxfMS5NQVhfTkFNRSwgbmV3IExlYWZOb2RlXzEuTGVhZk5vZGUoJ1tQUklPUklUWS1QT1NUXScsIE1BWF9OT0RFKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGluZGV4VmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm4geyFOYW1lZE5vZGV9XG4gICAgICovXG4gICAgUHJpb3JpdHlJbmRleC5wcm90b3R5cGUubWFrZVBvc3QgPSBmdW5jdGlvbiAoaW5kZXhWYWx1ZSwgbmFtZSkge1xuICAgICAgICB2YXIgcHJpb3JpdHlOb2RlID0gbm9kZUZyb21KU09OKGluZGV4VmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVfMS5OYW1lZE5vZGUobmFtZSwgbmV3IExlYWZOb2RlXzEuTGVhZk5vZGUoJ1tQUklPUklUWS1QT1NUXScsIHByaW9yaXR5Tm9kZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IXN0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXG4gICAgICovXG4gICAgUHJpb3JpdHlJbmRleC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnLnByaW9yaXR5JztcbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eUluZGV4O1xufShJbmRleF8xLkluZGV4KSk7XG5leHBvcnRzLlByaW9yaXR5SW5kZXggPSBQcmlvcml0eUluZGV4O1xuZXhwb3J0cy5QUklPUklUWV9JTkRFWCA9IG5ldyBQcmlvcml0eUluZGV4KCk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByaW9yaXR5SW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJbmRleF8xID0gcmVxdWlyZShcIi4vSW5kZXhcIik7XG52YXIgTm9kZV8xID0gcmVxdWlyZShcIi4uL05vZGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvdXRpbFwiKTtcbnZhciBub2RlRnJvbUpTT05fMSA9IHJlcXVpcmUoXCIuLi9ub2RlRnJvbUpTT05cIik7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0luZGV4fVxuICogQHByaXZhdGVcbiAqL1xudmFyIFZhbHVlSW5kZXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZhbHVlSW5kZXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFsdWVJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlSW5kZXgucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgaW5kZXhDbXAgPSBhLm5vZGUuY29tcGFyZVRvKGIubm9kZSk7XG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5uYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVJbmRleC5wcm90b3R5cGUuaXNEZWZpbmVkT24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVJbmRleC5wcm90b3R5cGUuaW5kZXhlZFZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGROb2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIHJldHVybiAhb2xkTm9kZS5lcXVhbHMobmV3Tm9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlSW5kZXgucHJvdG90eXBlLm1pblBvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBOb2RlXzEuTmFtZWROb2RlLk1JTjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVJbmRleC5wcm90b3R5cGUubWF4UG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5vZGVfMS5OYW1lZE5vZGUuTUFYO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbmRleFZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfVxuICAgICAqL1xuICAgIFZhbHVlSW5kZXgucHJvdG90eXBlLm1ha2VQb3N0ID0gZnVuY3Rpb24gKGluZGV4VmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdmFyIHZhbHVlTm9kZSA9IG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihpbmRleFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlXzEuTmFtZWROb2RlKG5hbWUsIHZhbHVlTm9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshc3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGluY2x1c2lvbiBpbiBhIHF1ZXJ5IHNwZWNcbiAgICAgKi9cbiAgICBWYWx1ZUluZGV4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcudmFsdWUnO1xuICAgIH07XG4gICAgcmV0dXJuIFZhbHVlSW5kZXg7XG59KEluZGV4XzEuSW5kZXgpKTtcbmV4cG9ydHMuVmFsdWVJbmRleCA9IFZhbHVlSW5kZXg7XG5leHBvcnRzLlZBTFVFX0lOREVYID0gbmV3IFZhbHVlSW5kZXgoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFsdWVJbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDaGlsZHJlbk5vZGVfMSA9IHJlcXVpcmUoXCIuL0NoaWxkcmVuTm9kZVwiKTtcbnZhciBMZWFmTm9kZV8xID0gcmVxdWlyZShcIi4vTGVhZk5vZGVcIik7XG52YXIgTm9kZV8xID0gcmVxdWlyZShcIi4vTm9kZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIGNoaWxkU2V0XzEgPSByZXF1aXJlKFwiLi9jaGlsZFNldFwiKTtcbnZhciBjb21wYXJhdG9yc18xID0gcmVxdWlyZShcIi4vY29tcGFyYXRvcnNcIik7XG52YXIgSW5kZXhNYXBfMSA9IHJlcXVpcmUoXCIuL0luZGV4TWFwXCIpO1xudmFyIFByaW9yaXR5SW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4ZXMvUHJpb3JpdHlJbmRleFwiKTtcbnZhciBVU0VfSElOWkUgPSB0cnVlO1xuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgc25hcHNob3Qgbm9kZSByZXByZXNlbnRpbmcgdGhlIHBhc3NlZCBKU09OIGFuZCByZXR1cm5zIGl0LlxuICogQHBhcmFtIHsqfSBqc29uIEpTT04gdG8gY3JlYXRlIGEgbm9kZSBmb3IuXG4gKiBAcGFyYW0gez9zdHJpbmd8P251bWJlcj19IHByaW9yaXR5IE9wdGlvbmFsIHByaW9yaXR5IHRvIHVzZS4gIFRoaXMgd2lsbCBiZSBpZ25vcmVkIGlmIHRoZVxuICogcGFzc2VkIEpTT04gY29udGFpbnMgYSAucHJpb3JpdHkgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHshTm9kZX1cbiAqL1xuZnVuY3Rpb24gbm9kZUZyb21KU09OKGpzb24sIHByaW9yaXR5KSB7XG4gICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHsgcHJpb3JpdHkgPSBudWxsOyB9XG4gICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmICcucHJpb3JpdHknIGluIGpzb24pIHtcbiAgICAgICAgcHJpb3JpdHkgPSBqc29uWycucHJpb3JpdHknXTtcbiAgICB9XG4gICAgdXRpbF8yLmFzc2VydChwcmlvcml0eSA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiYgJy5zdicgaW4gcHJpb3JpdHkpLCAnSW52YWxpZCBwcmlvcml0eSB0eXBlIGZvdW5kOiAnICsgdHlwZW9mIHByaW9yaXR5KTtcbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmICcudmFsdWUnIGluIGpzb24gJiYganNvblsnLnZhbHVlJ10gIT09IG51bGwpIHtcbiAgICAgICAganNvbiA9IGpzb25bJy52YWx1ZSddO1xuICAgIH1cbiAgICAvLyBWYWxpZCBsZWFmIG5vZGVzIGluY2x1ZGUgbm9uLW9iamVjdHMgb3Igc2VydmVyLXZhbHVlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICh0eXBlb2YganNvbiAhPT0gJ29iamVjdCcgfHwgJy5zdicgaW4ganNvbikge1xuICAgICAgICB2YXIganNvbkxlYWYgPSBqc29uO1xuICAgICAgICByZXR1cm4gbmV3IExlYWZOb2RlXzEuTGVhZk5vZGUoanNvbkxlYWYsIG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xuICAgIH1cbiAgICBpZiAoIShqc29uIGluc3RhbmNlb2YgQXJyYXkpICYmIFVTRV9ISU5aRSkge1xuICAgICAgICB2YXIgY2hpbGRyZW5fMSA9IFtdO1xuICAgICAgICB2YXIgY2hpbGRyZW5IYXZlUHJpb3JpdHlfMSA9IGZhbHNlO1xuICAgICAgICB2YXIgaGluemVKc29uT2JqXzEgPSBqc29uO1xuICAgICAgICB1dGlsXzEuZm9yRWFjaChoaW56ZUpzb25PYmpfMSwgZnVuY3Rpb24gKGtleSwgY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCBrZXkuc3Vic3RyaW5nKDAsIDEpICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgbWV0YWRhdGEgbm9kZXNcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gbm9kZUZyb21KU09OKGhpbnplSnNvbk9ial8xW2tleV0pO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkhhdmVQcmlvcml0eV8xID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuSGF2ZVByaW9yaXR5XzEgfHwgIWNoaWxkTm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5fMS5wdXNoKG5ldyBOb2RlXzEuTmFtZWROb2RlKGtleSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNoaWxkcmVuXzEubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRTZXQgPSBjaGlsZFNldF8xLmJ1aWxkQ2hpbGRTZXQoY2hpbGRyZW5fMSwgY29tcGFyYXRvcnNfMS5OQU1FX09OTFlfQ09NUEFSQVRPUiwgZnVuY3Rpb24gKG5hbWVkTm9kZSkgeyByZXR1cm4gbmFtZWROb2RlLm5hbWU7IH0sIGNvbXBhcmF0b3JzXzEuTkFNRV9DT01QQVJBVE9SKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuSGF2ZVByaW9yaXR5XzEpIHtcbiAgICAgICAgICAgIHZhciBzb3J0ZWRDaGlsZFNldCA9IGNoaWxkU2V0XzEuYnVpbGRDaGlsZFNldChjaGlsZHJlbl8xLCBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVguZ2V0Q29tcGFyZSgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlKGNoaWxkU2V0LCBub2RlRnJvbUpTT04ocHJpb3JpdHkpLCBuZXcgSW5kZXhNYXBfMS5JbmRleE1hcCh7ICcucHJpb3JpdHknOiBzb3J0ZWRDaGlsZFNldCB9LCB7ICcucHJpb3JpdHknOiBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVggfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUoY2hpbGRTZXQsIG5vZGVGcm9tSlNPTihwcmlvcml0eSksIEluZGV4TWFwXzEuSW5kZXhNYXAuRGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBub2RlXzEgPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgdmFyIGpzb25PYmpfMSA9IGpzb247XG4gICAgICAgIHV0aWxfMS5mb3JFYWNoKGpzb25PYmpfMSwgZnVuY3Rpb24gKGtleSwgY2hpbGREYXRhKSB7XG4gICAgICAgICAgICBpZiAodXRpbF8xLmNvbnRhaW5zKGpzb25PYmpfMSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyaW5nKDAsIDEpICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG1ldGFkYXRhIG5vZGVzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gbm9kZUZyb21KU09OKGNoaWxkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaXNMZWFmTm9kZSgpIHx8ICFjaGlsZE5vZGUuaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZV8xID0gbm9kZV8xLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGtleSwgY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZV8xLnVwZGF0ZVByaW9yaXR5KG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xuICAgIH1cbn1cbmV4cG9ydHMubm9kZUZyb21KU09OID0gbm9kZUZyb21KU09OO1xuUHJpb3JpdHlJbmRleF8xLnNldE5vZGVGcm9tSlNPTihub2RlRnJvbUpTT04pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlRnJvbUpTT04uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuLi91dGlsL3V0aWxcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIE1BWF9OT0RFO1xuZnVuY3Rpb24gc2V0TWF4Tm9kZSh2YWwpIHtcbiAgICBNQVhfTk9ERSA9IHZhbDtcbn1cbmV4cG9ydHMuc2V0TWF4Tm9kZSA9IHNldE1heE5vZGU7XG4vKipcbiAqIEBwYXJhbSB7KCFzdHJpbmd8IW51bWJlcil9IHByaW9yaXR5XG4gKiBAcmV0dXJuIHshc3RyaW5nfVxuICovXG5leHBvcnRzLnByaW9yaXR5SGFzaFRleHQgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuICdudW1iZXI6JyArIHV0aWxfMi5kb3VibGVUb0lFRUU3NTRTdHJpbmcocHJpb3JpdHkpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuICdzdHJpbmc6JyArIHByaW9yaXR5O1xufTtcbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYSBwcmlvcml0eSBzbmFwc2hvdCBOb2RlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7IU5vZGV9IHByaW9yaXR5Tm9kZVxuICovXG5leHBvcnRzLnZhbGlkYXRlUHJpb3JpdHlOb2RlID0gZnVuY3Rpb24gKHByaW9yaXR5Tm9kZSkge1xuICAgIGlmIChwcmlvcml0eU5vZGUuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgIHZhciB2YWwgPSBwcmlvcml0eU5vZGUudmFsKCk7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdXRpbF8zLmNvbnRhaW5zKHZhbCwgJy5zdicpKSwgJ1ByaW9yaXR5IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydChwcmlvcml0eU5vZGUgPT09IE1BWF9OT0RFIHx8IHByaW9yaXR5Tm9kZS5pc0VtcHR5KCksICdwcmlvcml0eSBvZiB1bmV4cGVjdGVkIHR5cGUuJyk7XG4gICAgfVxuICAgIC8vIERvbid0IGNhbGwgZ2V0UHJpb3JpdHkoKSBvbiBNQVhfTk9ERSB0byBhdm9pZCBoaXR0aW5nIGFzc2VydGlvbi5cbiAgICB1dGlsXzEuYXNzZXJ0KHByaW9yaXR5Tm9kZSA9PT0gTUFYX05PREUgfHwgcHJpb3JpdHlOb2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpLCBcIlByaW9yaXR5IG5vZGVzIGNhbid0IGhhdmUgYSBwcmlvcml0eSBvZiB0aGVpciBvd24uXCIpO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c25hcC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBUcmFja3MgYSBjb2xsZWN0aW9uIG9mIHN0YXRzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU3RhdHNDb2xsZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRzQ29sbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb3VudGVyc18gPSB7fTtcbiAgICB9XG4gICAgU3RhdHNDb2xsZWN0aW9uLnByb3RvdHlwZS5pbmNyZW1lbnRDb3VudGVyID0gZnVuY3Rpb24gKG5hbWUsIGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIHsgYW1vdW50ID0gMTsgfVxuICAgICAgICBpZiAoIXV0aWxfMi5jb250YWlucyh0aGlzLmNvdW50ZXJzXywgbmFtZSkpXG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJzX1tuYW1lXSA9IDA7XG4gICAgICAgIHRoaXMuY291bnRlcnNfW25hbWVdICs9IGFtb3VudDtcbiAgICB9O1xuICAgIFN0YXRzQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbF8xLmRlZXBDb3B5KHRoaXMuY291bnRlcnNfKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0c0NvbGxlY3Rpb247XG59KCkpO1xuZXhwb3J0cy5TdGF0c0NvbGxlY3Rpb24gPSBTdGF0c0NvbGxlY3Rpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRzQ29sbGVjdGlvbi5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIFJldHVybnMgdGhlIGRlbHRhIGZyb20gdGhlIHByZXZpb3VzIGNhbGwgdG8gZ2V0IHN0YXRzLlxuICpcbiAqIEBwYXJhbSBjb2xsZWN0aW9uXyBUaGUgY29sbGVjdGlvbiB0byBcImxpc3RlblwiIHRvLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTdGF0c0xpc3RlbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRzTGlzdGVuZXIoY29sbGVjdGlvbl8pIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uXyA9IGNvbGxlY3Rpb25fO1xuICAgICAgICB0aGlzLmxhc3RfID0gbnVsbDtcbiAgICB9XG4gICAgU3RhdHNMaXN0ZW5lci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3U3RhdHMgPSB0aGlzLmNvbGxlY3Rpb25fLmdldCgpO1xuICAgICAgICB2YXIgZGVsdGEgPSB1dGlsXzEuY2xvbmUobmV3U3RhdHMpO1xuICAgICAgICBpZiAodGhpcy5sYXN0Xykge1xuICAgICAgICAgICAgdXRpbF8xLmZvckVhY2godGhpcy5sYXN0XywgZnVuY3Rpb24gKHN0YXQsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVsdGFbc3RhdF0gPSBkZWx0YVtzdGF0XSAtIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0XyA9IG5ld1N0YXRzO1xuICAgICAgICByZXR1cm4gZGVsdGE7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdHNMaXN0ZW5lcjtcbn0oKSk7XG5leHBvcnRzLlN0YXRzTGlzdGVuZXIgPSBTdGF0c0xpc3RlbmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0c0xpc3RlbmVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN0YXRzQ29sbGVjdGlvbl8xID0gcmVxdWlyZShcIi4vU3RhdHNDb2xsZWN0aW9uXCIpO1xudmFyIFN0YXRzTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0c01hbmFnZXIoKSB7XG4gICAgfVxuICAgIFN0YXRzTWFuYWdlci5nZXRDb2xsZWN0aW9uID0gZnVuY3Rpb24gKHJlcG9JbmZvKSB7XG4gICAgICAgIHZhciBoYXNoU3RyaW5nID0gcmVwb0luZm8udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbGxlY3Rpb25zX1toYXNoU3RyaW5nXSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uc19baGFzaFN0cmluZ10gPSBuZXcgU3RhdHNDb2xsZWN0aW9uXzEuU3RhdHNDb2xsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbnNfW2hhc2hTdHJpbmddO1xuICAgIH07XG4gICAgU3RhdHNNYW5hZ2VyLmdldE9yQ3JlYXRlUmVwb3J0ZXIgPSBmdW5jdGlvbiAocmVwb0luZm8sIGNyZWF0b3JGdW5jdGlvbikge1xuICAgICAgICB2YXIgaGFzaFN0cmluZyA9IHJlcG9JbmZvLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghdGhpcy5yZXBvcnRlcnNfW2hhc2hTdHJpbmddKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydGVyc19baGFzaFN0cmluZ10gPSBjcmVhdG9yRnVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXBvcnRlcnNfW2hhc2hTdHJpbmddO1xuICAgIH07XG4gICAgU3RhdHNNYW5hZ2VyLmNvbGxlY3Rpb25zXyA9IHt9O1xuICAgIFN0YXRzTWFuYWdlci5yZXBvcnRlcnNfID0ge307XG4gICAgcmV0dXJuIFN0YXRzTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLlN0YXRzTWFuYWdlciA9IFN0YXRzTWFuYWdlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhdHNNYW5hZ2VyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiLi4vdXRpbC91dGlsXCIpO1xudmFyIFN0YXRzTGlzdGVuZXJfMSA9IHJlcXVpcmUoXCIuL1N0YXRzTGlzdGVuZXJcIik7XG4vLyBBc3N1bWluZyBzb21lIGFwcHMgbWF5IGhhdmUgYSBzaG9ydCBhbW91bnQgb2YgdGltZSBvbiBwYWdlLCBhbmQgYSBidWxrIG9mIGZpcmViYXNlIG9wZXJhdGlvbnMgcHJvYmFibHlcbi8vIGhhcHBlbiBvbiBwYWdlIGxvYWQsIHdlIHRyeSB0byByZXBvcnQgb3VyIGZpcnN0IHNldCBvZiBzdGF0cyBwcmV0dHkgcXVpY2tseSwgYnV0IHdlIHdhaXQgYXQgbGVhc3QgMTBcbi8vIHNlY29uZHMgdG8gdHJ5IHRvIGVuc3VyZSB0aGUgRmlyZWJhc2UgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCAvIHNldHRsZWQuXG52YXIgRklSU1RfU1RBVFNfTUlOX1RJTUUgPSAxMCAqIDEwMDA7XG52YXIgRklSU1RfU1RBVFNfTUFYX1RJTUUgPSAzMCAqIDEwMDA7XG4vLyBXZSdsbCBjb250aW51ZSB0byByZXBvcnQgc3RhdHMgb24gYXZlcmFnZSBldmVyeSA1IG1pbnV0ZXMuXG52YXIgUkVQT1JUX1NUQVRTX0lOVEVSVkFMID0gNSAqIDYwICogMTAwMDtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTdGF0c1JlcG9ydGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHNlcnZlcl9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0c1JlcG9ydGVyKGNvbGxlY3Rpb24sIHNlcnZlcl8pIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXJfID0gc2VydmVyXztcbiAgICAgICAgdGhpcy5zdGF0c1RvUmVwb3J0XyA9IHt9O1xuICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbmV3IFN0YXRzTGlzdGVuZXJfMS5TdGF0c0xpc3RlbmVyKGNvbGxlY3Rpb24pO1xuICAgICAgICB2YXIgdGltZW91dCA9IEZJUlNUX1NUQVRTX01JTl9USU1FICtcbiAgICAgICAgICAgIChGSVJTVF9TVEFUU19NQVhfVElNRSAtIEZJUlNUX1NUQVRTX01JTl9USU1FKSAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHV0aWxfMi5zZXRUaW1lb3V0Tm9uQmxvY2tpbmcodGhpcy5yZXBvcnRTdGF0c18uYmluZCh0aGlzKSwgTWF0aC5mbG9vcih0aW1lb3V0KSk7XG4gICAgfVxuICAgIFN0YXRzUmVwb3J0ZXIucHJvdG90eXBlLmluY2x1ZGVTdGF0ID0gZnVuY3Rpb24gKHN0YXQpIHtcbiAgICAgICAgdGhpcy5zdGF0c1RvUmVwb3J0X1tzdGF0XSA9IHRydWU7XG4gICAgfTtcbiAgICBTdGF0c1JlcG9ydGVyLnByb3RvdHlwZS5yZXBvcnRTdGF0c18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0cyA9IHRoaXMuc3RhdHNMaXN0ZW5lcl8uZ2V0KCk7XG4gICAgICAgIHZhciByZXBvcnRlZFN0YXRzID0ge307XG4gICAgICAgIHZhciBoYXZlU3RhdHNUb1JlcG9ydCA9IGZhbHNlO1xuICAgICAgICB1dGlsXzEuZm9yRWFjaChzdGF0cywgZnVuY3Rpb24gKHN0YXQsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiAwICYmIHV0aWxfMS5jb250YWlucyhfdGhpcy5zdGF0c1RvUmVwb3J0Xywgc3RhdCkpIHtcbiAgICAgICAgICAgICAgICByZXBvcnRlZFN0YXRzW3N0YXRdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaGF2ZVN0YXRzVG9SZXBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhdmVTdGF0c1RvUmVwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZlcl8ucmVwb3J0U3RhdHMocmVwb3J0ZWRTdGF0cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcXVldWUgb3VyIG5leHQgcnVuLlxuICAgICAgICB1dGlsXzIuc2V0VGltZW91dE5vbkJsb2NraW5nKHRoaXMucmVwb3J0U3RhdHNfLmJpbmQodGhpcyksIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIgKiBSRVBPUlRfU1RBVFNfSU5URVJWQUwpKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0c1JlcG9ydGVyO1xufSgpKTtcbmV4cG9ydHMuU3RhdHNSZXBvcnRlciA9IFN0YXRzUmVwb3J0ZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRzUmVwb3J0ZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBXcmFwcyBhIERPTSBTdG9yYWdlIG9iamVjdCBhbmQ6XG4gKiAtIGF1dG9tYXRpY2FsbHkgZW5jb2RlIG9iamVjdHMgYXMgSlNPTiBzdHJpbmdzIGJlZm9yZSBzdG9yaW5nIHRoZW0gdG8gYWxsb3cgdXMgdG8gc3RvcmUgYXJiaXRyYXJ5IHR5cGVzLlxuICogLSBwcmVmaXhlcyBuYW1lcyB3aXRoIFwiZmlyZWJhc2U6XCIgdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIGFwcCBkYXRhLlxuICpcbiAqIFdlIGF1dG9tYXRpY2FsbHkgKHNlZSBzdG9yYWdlLmpzKSBjcmVhdGUgdHdvIHN1Y2ggd3JhcHBlcnMsIG9uZSBmb3Igc2Vzc2lvblN0b3JhZ2UsXG4gKiBhbmQgb25lIGZvciBsb2NhbFN0b3JhZ2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBET01TdG9yYWdlV3JhcHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2V9IGRvbVN0b3JhZ2VfIFRoZSB1bmRlcmx5aW5nIHN0b3JhZ2Ugb2JqZWN0IChlLmcuIGxvY2FsU3RvcmFnZSBvciBzZXNzaW9uU3RvcmFnZSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBET01TdG9yYWdlV3JhcHBlcihkb21TdG9yYWdlXykge1xuICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfID0gZG9tU3RvcmFnZV87XG4gICAgICAgIC8vIFVzZSBhIHByZWZpeCB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggb3RoZXIgc3R1ZmYgc2F2ZWQgYnkgdGhlIGFwcC5cbiAgICAgICAgdGhpcy5wcmVmaXhfID0gJ2ZpcmViYXNlOic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzYXZlIHRoZSB2YWx1ZSB1bmRlclxuICAgICAqIEBwYXJhbSB7P09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIGJlaW5nIHN0b3JlZCwgb3IgbnVsbCB0byByZW1vdmUgdGhlIGtleS5cbiAgICAgKi9cbiAgICBET01TdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tU3RvcmFnZV8ucmVtb3ZlSXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfLnNldEl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSksIHV0aWxfMS5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSB0aGF0IHdhcyBzdG9yZWQgdW5kZXIgdGhpcyBrZXksIG9yIG51bGxcbiAgICAgKi9cbiAgICBET01TdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgc3RvcmVkVmFsID0gdGhpcy5kb21TdG9yYWdlXy5nZXRJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcbiAgICAgICAgaWYgKHN0b3JlZFZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuanNvbkV2YWwoc3RvcmVkVmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqL1xuICAgIERPTVN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMuZG9tU3RvcmFnZV8ucmVtb3ZlSXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBET01TdG9yYWdlV3JhcHBlci5wcm90b3R5cGUucHJlZml4ZWROYW1lXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWZpeF8gKyBuYW1lO1xuICAgIH07XG4gICAgRE9NU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb21TdG9yYWdlXy50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIERPTVN0b3JhZ2VXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuRE9NU3RvcmFnZVdyYXBwZXIgPSBET01TdG9yYWdlV3JhcHBlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RE9NU3RvcmFnZVdyYXBwZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBBbiBpbi1tZW1vcnkgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiB0aGF0IG1hdGNoZXMgdGhlIEFQSSBvZiBET01TdG9yYWdlV3JhcHBlclxuICogKFRPRE86IGNyZWF0ZSBpbnRlcmZhY2UgZm9yIGJvdGggdG8gaW1wbGVtZW50KS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1lbW9yeVN0b3JhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVtb3J5U3RvcmFnZSgpIHtcbiAgICAgICAgdGhpcy5jYWNoZV8gPSB7fTtcbiAgICAgICAgdGhpcy5pc0luTWVtb3J5U3RvcmFnZSA9IHRydWU7XG4gICAgfVxuICAgIE1lbW9yeVN0b3JhZ2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVfW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVtb3J5U3RvcmFnZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodXRpbF8xLmNvbnRhaW5zKHRoaXMuY2FjaGVfLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE1lbW9yeVN0b3JhZ2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVfW2tleV07XG4gICAgfTtcbiAgICByZXR1cm4gTWVtb3J5U3RvcmFnZTtcbn0oKSk7XG5leHBvcnRzLk1lbW9yeVN0b3JhZ2UgPSBNZW1vcnlTdG9yYWdlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZW1vcnlTdG9yYWdlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERPTVN0b3JhZ2VXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi9ET01TdG9yYWdlV3JhcHBlclwiKTtcbnZhciBNZW1vcnlTdG9yYWdlXzEgPSByZXF1aXJlKFwiLi9NZW1vcnlTdG9yYWdlXCIpO1xuLyoqXG4gKiBIZWxwZXIgdG8gY3JlYXRlIGEgRE9NU3RvcmFnZVdyYXBwZXIgb3IgZWxzZSBmYWxsIGJhY2sgdG8gTWVtb3J5U3RvcmFnZS5cbiAqIFRPRE86IE9uY2UgTWVtb3J5U3RvcmFnZSBhbmQgRE9NU3RvcmFnZVdyYXBwZXIgaGF2ZSBhIHNoYXJlZCBpbnRlcmZhY2UgdGhpcyBtZXRob2QgYW5ub3RhdGlvbiBzaG91bGQgY2hhbmdlXG4gKiB0byByZWZsZWN0IHRoaXMgdHlwZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21TdG9yYWdlTmFtZSBOYW1lIG9mIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2Ugb2JqZWN0XG4gKiAgIChlLmcuICdsb2NhbFN0b3JhZ2UnIG9yICdzZXNzaW9uU3RvcmFnZScpLlxuICogQHJldHVybiB7P30gVHVybmluZyBvZmYgdHlwZSBpbmZvcm1hdGlvbiB1bnRpbCBhIGNvbW1vbiBpbnRlcmZhY2UgaXMgZGVmaW5lZC5cbiAqL1xudmFyIGNyZWF0ZVN0b3JhZ2Vmb3IgPSBmdW5jdGlvbiAoZG9tU3RvcmFnZU5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBOT1RFOiBqdXN0IGFjY2Vzc2luZyBcImxvY2FsU3RvcmFnZVwiIG9yIFwid2luZG93Wydsb2NhbFN0b3JhZ2UnXVwiIG1heSB0aHJvdyBhIHNlY3VyaXR5IGV4Y2VwdGlvbixcbiAgICAgICAgLy8gc28gaXQgbXVzdCBiZSBpbnNpZGUgdGhlIHRyeS9jYXRjaC5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93W2RvbVN0b3JhZ2VOYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gdGVzdCBjYWNoZS4gSnVzdCBiZWNhdXNlIGl0J3MgaGVyZSBkb2Vzbid0IG1lYW4gaXQgd29ya3NcbiAgICAgICAgICAgIHZhciBkb21TdG9yYWdlID0gd2luZG93W2RvbVN0b3JhZ2VOYW1lXTtcbiAgICAgICAgICAgIGRvbVN0b3JhZ2Uuc2V0SXRlbSgnZmlyZWJhc2U6c2VudGluZWwnLCAnY2FjaGUnKTtcbiAgICAgICAgICAgIGRvbVN0b3JhZ2UucmVtb3ZlSXRlbSgnZmlyZWJhc2U6c2VudGluZWwnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRE9NU3RvcmFnZVdyYXBwZXJfMS5ET01TdG9yYWdlV3JhcHBlcihkb21TdG9yYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgLy8gRmFpbGVkIHRvIGNyZWF0ZSB3cmFwcGVyLiAgSnVzdCByZXR1cm4gaW4tbWVtb3J5IHN0b3JhZ2UuXG4gICAgLy8gVE9ETzogbG9nP1xuICAgIHJldHVybiBuZXcgTWVtb3J5U3RvcmFnZV8xLk1lbW9yeVN0b3JhZ2UoKTtcbn07XG4vKiogQSBzdG9yYWdlIG9iamVjdCB0aGF0IGxhc3RzIGFjcm9zcyBzZXNzaW9ucyAqL1xuZXhwb3J0cy5QZXJzaXN0ZW50U3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2Vmb3IoJ2xvY2FsU3RvcmFnZScpO1xuLyoqIEEgc3RvcmFnZSBvYmplY3QgdGhhdCBvbmx5IGxhc3RzIG9uZSBzZXNzaW9uICovXG5leHBvcnRzLlNlc3Npb25TdG9yYWdlID0gY3JlYXRlU3RvcmFnZWZvcignc2Vzc2lvblN0b3JhZ2UnKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RvcmFnZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIEltcGxlbWVudHMgYSBzZXQgd2l0aCBhIGNvdW50IG9mIGVsZW1lbnRzLlxuICpcbiAqIEB0ZW1wbGF0ZSBLLCBWXG4gKi9cbnZhciBDb3VudGVkU2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvdW50ZWRTZXQoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUt9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge1Z9IHZhbFxuICAgICAqL1xuICAgIENvdW50ZWRTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtLCB2YWwpIHtcbiAgICAgICAgdGhpcy5zZXRbaXRlbV0gPSB2YWwgIT09IG51bGwgPyB2YWwgOiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshS30ga2V5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBDb3VudGVkU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5jb250YWlucyh0aGlzLnNldCwga2V5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUt9IGl0ZW1cbiAgICAgKiBAcmV0dXJuIHtWfVxuICAgICAqL1xuICAgIENvdW50ZWRTZXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zKGl0ZW0pID8gdGhpcy5zZXRbaXRlbV0gOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFLfSBpdGVtXG4gICAgICovXG4gICAgQ291bnRlZFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2V0W2l0ZW1dO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBldmVyeXRoaW5nIGluIHRoZSBzZXRcbiAgICAgKi9cbiAgICBDb3VudGVkU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXQgPSB7fTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSBzZXRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIENvdW50ZWRTZXQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsXzEuaXNFbXB0eSh0aGlzLnNldCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHNldFxuICAgICAqL1xuICAgIENvdW50ZWRTZXQucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbF8xLmdldENvdW50KHRoaXMuc2V0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJ1biBhIGZ1bmN0aW9uIG9uIGVhY2ggayx2IHBhaXIgaW4gdGhlIHNldFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oSywgVil9IGZuXG4gICAgICovXG4gICAgQ291bnRlZFNldC5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB1dGlsXzEuZm9yRWFjaCh0aGlzLnNldCwgZnVuY3Rpb24gKGssIHYpIHsgcmV0dXJuIGZuKGssIHYpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vc3RseSBmb3IgZGVidWdnaW5nXG4gICAgICogQHJldHVybiB7QXJyYXkuPEs+fSBUaGUga2V5cyBwcmVzZW50IGluIHRoaXMgQ291bnRlZFNldFxuICAgICAqL1xuICAgIENvdW50ZWRTZXQucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIHV0aWxfMS5mb3JFYWNoKHRoaXMuc2V0LCBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcbiAgICByZXR1cm4gQ291bnRlZFNldDtcbn0oKSk7XG5leHBvcnRzLkNvdW50ZWRTZXQgPSBDb3VudGVkU2V0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db3VudGVkU2V0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogQmFzZSBjbGFzcyB0byBiZSB1c2VkIGlmIHlvdSB3YW50IHRvIGVtaXQgZXZlbnRzLiBDYWxsIHRoZSBjb25zdHJ1Y3RvciB3aXRoXG4gKiB0aGUgc2V0IG9mIGFsbG93ZWQgZXZlbnQgbmFtZXMuXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGFsbG93ZWRFdmVudHNfXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKGFsbG93ZWRFdmVudHNfKSB7XG4gICAgICAgIHRoaXMuYWxsb3dlZEV2ZW50c18gPSBhbGxvd2VkRXZlbnRzXztcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfID0ge307XG4gICAgICAgIHV0aWxfMS5hc3NlcnQoQXJyYXkuaXNBcnJheShhbGxvd2VkRXZlbnRzXykgJiYgYWxsb3dlZEV2ZW50c18ubGVuZ3RoID4gMCwgJ1JlcXVpcmVzIGEgbm9uLWVtcHR5IGFycmF5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIGNhbGxlZCBieSBkZXJpdmVkIGNsYXNzZXMgdG8gdHJpZ2dlciBldmVudHMuXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICB2YXIgdmFyX2FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhcl9hcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdKSkge1xuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGxpc3QsIHNpbmNlIGNhbGxiYWNrcyBjb3VsZCBhZGQvcmVtb3ZlIGxpc3RlbmVycy5cbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXS5zbGljZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbGJhY2suYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIHZhcl9hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdID0gdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0gfHwgW107XG4gICAgICAgIHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdLnB1c2goeyBjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQgfSk7XG4gICAgICAgIHZhciBldmVudERhdGEgPSB0aGlzLmdldEluaXRpYWxFdmVudChldmVudFR5cGUpO1xuICAgICAgICBpZiAoZXZlbnREYXRhKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShjb250ZXh0LCBldmVudERhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSk7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgKCFjb250ZXh0IHx8IGNvbnRleHQgPT09IGxpc3RlbmVyc1tpXS5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnZhbGlkYXRlRXZlbnRUeXBlXyA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydCh0aGlzLmFsbG93ZWRFdmVudHNfLmZpbmQoZnVuY3Rpb24gKGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXQgPT09IGV2ZW50VHlwZTtcbiAgICAgICAgfSksICdVbmtub3duIGV2ZW50OiAnICsgZXZlbnRUeXBlKTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCkpO1xuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50RW1pdHRlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTb3J0ZWRNYXBfMSA9IHJlcXVpcmUoXCIuL1NvcnRlZE1hcFwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIGVtcHR5Q2hpbGRyZW5TaW5nbGV0b247XG4vKipcbiAqIFNpbmdsZXRvbiBlbXB0eSBjaGlsZHJlbiBjb2xsZWN0aW9uLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUgeyFTb3J0ZWRNYXAuPHN0cmluZywgIUltbXV0YWJsZVRyZWUuPD8+Pn1cbiAqL1xudmFyIEVtcHR5Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFlbXB0eUNoaWxkcmVuU2luZ2xldG9uKSB7XG4gICAgICAgIGVtcHR5Q2hpbGRyZW5TaW5nbGV0b24gPSBuZXcgU29ydGVkTWFwXzEuU29ydGVkTWFwKHV0aWxfMS5zdHJpbmdDb21wYXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5Q2hpbGRyZW5TaW5nbGV0b247XG59O1xuLyoqXG4gKiBBIHRyZWUgd2l0aCBpbW11dGFibGUgZWxlbWVudHMuXG4gKi9cbnZhciBJbW11dGFibGVUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/VH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1NvcnRlZE1hcC48c3RyaW5nLCAhSW1tdXRhYmxlVHJlZS48VD4+PX0gY2hpbGRyZW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbW11dGFibGVUcmVlKHZhbHVlLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkgeyBjaGlsZHJlbiA9IEVtcHR5Q2hpbGRyZW4oKTsgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgIVQ+fSBvYmpcbiAgICAgKiBAcmV0dXJuIHshSW1tdXRhYmxlVHJlZS48IVQ+fVxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIHRyZWUgPSBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICB1dGlsXzIuZm9yRWFjaChvYmosIGZ1bmN0aW9uIChjaGlsZFBhdGgsIGNoaWxkU25hcCkge1xuICAgICAgICAgICAgdHJlZSA9IHRyZWUuc2V0KG5ldyBQYXRoXzEuUGF0aChjaGlsZFBhdGgpLCBjaGlsZFNuYXApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eSBhbmQgdGhlcmUgYXJlIG5vIGNoaWxkcmVuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gbnVsbCAmJiB0aGlzLmNoaWxkcmVuLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcGF0aCBhbmQgcHJlZGljYXRlLCByZXR1cm4gdGhlIGZpcnN0IG5vZGUgYW5kIHRoZSBwYXRoIHRvIHRoYXQgbm9kZVxuICAgICAqIHdoZXJlIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxuICAgICAqXG4gICAgICogVE9ETyBEbyBhIHBlcmYgdGVzdCAtLSBJZiB3ZSdyZSBjcmVhdGluZyBhIGJ1bmNoIG9mIHtwYXRoOiB2YWx1ZTp9IG9iamVjdHNcbiAgICAgKiBvbiB0aGUgd2F5IGJhY2sgb3V0LCBpdCBtYXkgYmUgYmV0dGVyIHRvIHBhc3MgZG93biBhIHBhdGhTb0ZhciBvYmouXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSByZWxhdGl2ZVBhdGggVGhlIHJlbWFpbmRlciBvZiB0aGUgcGF0aFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6Ym9vbGVhbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gc2F0aXNmeSB0byByZXR1cm4gYVxuICAgICAqICAgbm9kZVxuICAgICAqIEByZXR1cm4gez97cGF0aDohUGF0aCwgdmFsdWU6IVR9fVxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZpbmRSb290TW9zdE1hdGNoaW5nUGF0aEFuZFZhbHVlID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9IG51bGwgJiYgcHJlZGljYXRlKHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBQYXRoXzEuUGF0aC5FbXB0eSwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbnQgPSByZWxhdGl2ZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlID0gY2hpbGQuZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocmVsYXRpdmVQYXRoLnBvcEZyb250KCksIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdWxsUGF0aCA9IG5ldyBQYXRoXzEuUGF0aChmcm9udCkuY2hpbGQoY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGZ1bGxQYXRoLCB2YWx1ZTogY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZS52YWx1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZCwgaWYgaXQgZXhpc3RzLCB0aGUgc2hvcnRlc3Qgc3VicGF0aCBvZiB0aGUgZ2l2ZW4gcGF0aCB0aGF0IHBvaW50cyBhIGRlZmluZWRcbiAgICAgKiB2YWx1ZSBpbiB0aGUgdHJlZVxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHJlbGF0aXZlUGF0aFxuICAgICAqIEByZXR1cm4gez97cGF0aDogIVBhdGgsIHZhbHVlOiAhVH19XG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kUm9vdE1vc3RNYXRjaGluZ1BhdGhBbmRWYWx1ZShyZWxhdGl2ZVBhdGgsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcmVsYXRpdmVQYXRoXG4gICAgICogQHJldHVybiB7IUltbXV0YWJsZVRyZWUuPFQ+fSBUaGUgc3VidHJlZSBhdCB0aGUgZ2l2ZW4gcGF0aFxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLnN1YnRyZWUgPSBmdW5jdGlvbiAocmVsYXRpdmVQYXRoKSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRUcmVlLnN1YnRyZWUocmVsYXRpdmVQYXRoLnBvcEZyb250KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSByZWxhdGl2ZVBhdGggUGF0aCB0byBzZXQgdmFsdWUgYXQuXG4gICAgICogQHBhcmFtIHs/VH0gdG9TZXQgVmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm4geyFJbW11dGFibGVUcmVlLjxUPn0gUmVzdWx0aW5nIHRyZWUuXG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgdG9TZXQpIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0b1NldCwgdGhpcy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZnJvbnQgPSByZWxhdGl2ZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KSB8fCBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gY2hpbGQuc2V0KHJlbGF0aXZlUGF0aC5wb3BGcm9udCgpLCB0b1NldCk7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmluc2VydChmcm9udCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcmVsYXRpdmVQYXRoIFBhdGggdG8gdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4geyFJbW11dGFibGVUcmVlLjxUPn0gUmVzdWx0aW5nIHRyZWUuXG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCkge1xuICAgICAgICBpZiAocmVsYXRpdmVQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCwgdGhpcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZnJvbnQgPSByZWxhdGl2ZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdDaGlsZCA9IGNoaWxkLnJlbW92ZShyZWxhdGl2ZVBhdGgucG9wRnJvbnQoKSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnJlbW92ZShmcm9udCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsICYmIG5ld0NoaWxkcmVuLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW1tdXRhYmxlVHJlZS5FbXB0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0aGlzLnZhbHVlLCBuZXdDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcmVsYXRpdmVQYXRoIFBhdGggdG8gZ2V0IHZhbHVlIGZvci5cbiAgICAgKiBAcmV0dXJuIHs/VH0gVmFsdWUgYXQgcGF0aCwgb3IgbnVsbC5cbiAgICAgKi9cbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocmVsYXRpdmVQYXRoKSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmdldChyZWxhdGl2ZVBhdGgucG9wRnJvbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgc3VidHJlZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCB0aGUgZ2l2ZW4gbmV3IHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSByZWxhdGl2ZVBhdGggUGF0aCB0byByZXBsYWNlIHN1YnRyZWUgZm9yLlxuICAgICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWV9IG5ld1RyZWUgTmV3IHRyZWUuXG4gICAgICogQHJldHVybiB7IUltbXV0YWJsZVRyZWV9IFJlc3VsdGluZyB0cmVlLlxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLnNldFRyZWUgPSBmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBuZXdUcmVlKSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3VHJlZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpIHx8IEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSBjaGlsZC5zZXRUcmVlKHJlbGF0aXZlUGF0aC5wb3BGcm9udCgpLCBuZXdUcmVlKTtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ucmVtb3ZlKGZyb250KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5pbnNlcnQoZnJvbnQsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0aGlzLnZhbHVlLCBuZXdDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVwdGggZmlyc3QgZm9sZCBvbiB0aGlzIHRyZWUuIFRyYW5zZm9ybXMgYSB0cmVlIGludG8gYSBzaW5nbGVcbiAgICAgKiB2YWx1ZSwgZ2l2ZW4gYSBmdW5jdGlvbiB0aGF0IG9wZXJhdGVzIG9uIHRoZSBwYXRoIHRvIGEgbm9kZSwgYW4gb3B0aW9uYWxcbiAgICAgKiBjdXJyZW50IHZhbHVlLCBhbmQgYSBtYXAgb2YgY2hpbGQgbmFtZXMgdG8gZm9sZGVkIHN1YnRyZWVzXG4gICAgICogQHRlbXBsYXRlIFZcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFBhdGgsID9ULCBPYmplY3QuPHN0cmluZywgVj4pOlZ9IGZuXG4gICAgICogQHJldHVybiB7Vn1cbiAgICAgKi9cbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbGRfKFBhdGhfMS5QYXRoLkVtcHR5LCBmbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgaGVscGVyIGZvciBwdWJsaWMtZmFjaW5nIGZvbGQoKSBtZXRob2RcbiAgICAgKiBAdGVtcGxhdGUgVlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhTb0ZhclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oUGF0aCwgP1QsIE9iamVjdC48c3RyaW5nLCBWPik6Vn0gZm5cbiAgICAgKiBAcmV0dXJuIHtWfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZm9sZF8gPSBmdW5jdGlvbiAocGF0aFNvRmFyLCBmbikge1xuICAgICAgICB2YXIgYWNjdW0gPSB7fTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZEtleSwgY2hpbGRUcmVlKSB7XG4gICAgICAgICAgICBhY2N1bVtjaGlsZEtleV0gPSBjaGlsZFRyZWUuZm9sZF8ocGF0aFNvRmFyLmNoaWxkKGNoaWxkS2V5KSwgZm4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZuKHBhdGhTb0ZhciwgdGhpcy52YWx1ZSwgYWNjdW0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgZmlyc3QgbWF0Y2hpbmcgdmFsdWUgb24gdGhlIGdpdmVuIHBhdGguIFJldHVybiB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGYgdG8gaXQuXG4gICAgICogQHRlbXBsYXRlIFZcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oIVBhdGgsICFUKTo/Vn0gZlxuICAgICAqIEByZXR1cm4gez9WfVxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZpbmRPblBhdGggPSBmdW5jdGlvbiAocGF0aCwgZikge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kT25QYXRoXyhwYXRoLCBQYXRoXzEuUGF0aC5FbXB0eSwgZik7XG4gICAgfTtcbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5maW5kT25QYXRoXyA9IGZ1bmN0aW9uIChwYXRoVG9Gb2xsb3csIHBhdGhTb0ZhciwgZikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy52YWx1ZSA/IGYocGF0aFNvRmFyLCB0aGlzLnZhbHVlKSA6IGZhbHNlO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhdGhUb0ZvbGxvdy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmcm9udCA9IHBhdGhUb0ZvbGxvdy5nZXRGcm9udCgpO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENoaWxkLmZpbmRPblBhdGhfKHBhdGhUb0ZvbGxvdy5wb3BGcm9udCgpLCBwYXRoU29GYXIuY2hpbGQoZnJvbnQpLCBmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oIVBhdGgsICFUKX0gZlxuICAgICAqIEByZXR1cm5zIHshSW1tdXRhYmxlVHJlZS48VD59XG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZm9yZWFjaE9uUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcmVhY2hPblBhdGhfKHBhdGgsIFBhdGhfMS5QYXRoLkVtcHR5LCBmKTtcbiAgICB9O1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZvcmVhY2hPblBhdGhfID0gZnVuY3Rpb24gKHBhdGhUb0ZvbGxvdywgY3VycmVudFJlbGF0aXZlUGF0aCwgZikge1xuICAgICAgICBpZiAocGF0aFRvRm9sbG93LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGYoY3VycmVudFJlbGF0aXZlUGF0aCwgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnJvbnQgPSBwYXRoVG9Gb2xsb3cuZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XG4gICAgICAgICAgICBpZiAobmV4dENoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaGlsZC5mb3JlYWNoT25QYXRoXyhwYXRoVG9Gb2xsb3cucG9wRnJvbnQoKSwgY3VycmVudFJlbGF0aXZlUGF0aC5jaGlsZChmcm9udCksIGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBub2RlIGluIHRoZSB0cmVlIHRoYXQgaGFzIGEgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFQYXRoLCAhVCl9IGYgQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aFxuICAgICAqICAgdGhlIHBhdGggZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZSB0byBhIG5vZGUsIGFuZCB0aGUgdmFsdWUgYXQgdGhhdCBub2RlLlxuICAgICAqICAgQ2FsbGVkIGluIGRlcHRoLWZpcnN0IG9yZGVyLlxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZvcmVhY2ggPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB0aGlzLmZvcmVhY2hfKFBhdGhfMS5QYXRoLkVtcHR5LCBmKTtcbiAgICB9O1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZvcmVhY2hfID0gZnVuY3Rpb24gKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGYpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgY2hpbGRUcmVlLmZvcmVhY2hfKGN1cnJlbnRSZWxhdGl2ZVBhdGguY2hpbGQoY2hpbGROYW1lKSwgZik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgZihjdXJyZW50UmVsYXRpdmVQYXRoLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgIVQpfSBmXG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZm9yZWFjaENoaWxkID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGYoY2hpbGROYW1lLCBjaGlsZFRyZWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEltbXV0YWJsZVRyZWUuRW1wdHkgPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcbiAgICByZXR1cm4gSW1tdXRhYmxlVHJlZTtcbn0oKSk7XG5leHBvcnRzLkltbXV0YWJsZVRyZWUgPSBJbW11dGFibGVUcmVlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbW11dGFibGVUcmVlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogRmFuY3kgSUQgZ2VuZXJhdG9yIHRoYXQgY3JlYXRlcyAyMC1jaGFyYWN0ZXIgc3RyaW5nIGlkZW50aWZpZXJzIHdpdGggdGhlXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAxLiBUaGV5J3JlIGJhc2VkIG9uIHRpbWVzdGFtcCBzbyB0aGF0IHRoZXkgc29ydCAqYWZ0ZXIqIGFueSBleGlzdGluZyBpZHMuXG4gKiAyLiBUaGV5IGNvbnRhaW4gNzItYml0cyBvZiByYW5kb20gZGF0YSBhZnRlciB0aGUgdGltZXN0YW1wIHNvIHRoYXQgSURzIHdvbid0XG4gKiAgICBjb2xsaWRlIHdpdGggb3RoZXIgY2xpZW50cycgSURzLlxuICogMy4gVGhleSBzb3J0ICpsZXhpY29ncmFwaGljYWxseSogKHNvIHRoZSB0aW1lc3RhbXAgaXMgY29udmVydGVkIHRvIGNoYXJhY3RlcnNcbiAqICAgIHRoYXQgd2lsbCBzb3J0IHByb3Blcmx5KS5cbiAqIDQuIFRoZXkncmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLiBFdmVuIGlmIHlvdSBnZW5lcmF0ZSBtb3JlIHRoYW4gb25lIGluXG4gKiAgICB0aGUgc2FtZSB0aW1lc3RhbXAsIHRoZSBsYXR0ZXIgb25lcyB3aWxsIHNvcnQgYWZ0ZXIgdGhlIGZvcm1lciBvbmVzLiBXZSBkb1xuICogICAgdGhpcyBieSB1c2luZyB0aGUgcHJldmlvdXMgcmFuZG9tIGJpdHMgYnV0IFwiaW5jcmVtZW50aW5nXCIgdGhlbSBieSAxIChvbmx5XG4gKiAgICBpbiB0aGUgY2FzZSBvZiBhIHRpbWVzdGFtcCBjb2xsaXNpb24pLlxuICovXG5leHBvcnRzLm5leHRQdXNoSWQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIE1vZGVsZWQgYWZ0ZXIgYmFzZTY0IHdlYi1zYWZlIGNoYXJzLCBidXQgb3JkZXJlZCBieSBBU0NJSS5cbiAgICB2YXIgUFVTSF9DSEFSUyA9ICctMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaX2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcbiAgICAvLyBUaW1lc3RhbXAgb2YgbGFzdCBwdXNoLCB1c2VkIHRvIHByZXZlbnQgbG9jYWwgY29sbGlzaW9ucyBpZiB5b3UgcHVzaCB0d2ljZVxuICAgIC8vIGluIG9uZSBtcy5cbiAgICB2YXIgbGFzdFB1c2hUaW1lID0gMDtcbiAgICAvLyBXZSBnZW5lcmF0ZSA3Mi1iaXRzIG9mIHJhbmRvbW5lc3Mgd2hpY2ggZ2V0IHR1cm5lZCBpbnRvIDEyIGNoYXJhY3RlcnMgYW5kXG4gICAgLy8gYXBwZW5kZWQgdG8gdGhlIHRpbWVzdGFtcCB0byBwcmV2ZW50IGNvbGxpc2lvbnMgd2l0aCBvdGhlciBjbGllbnRzLiBXZVxuICAgIC8vIHN0b3JlIHRoZSBsYXN0IGNoYXJhY3RlcnMgd2UgZ2VuZXJhdGVkIGJlY2F1c2UgaW4gdGhlIGV2ZW50IG9mIGEgY29sbGlzaW9uLFxuICAgIC8vIHdlJ2xsIHVzZSB0aG9zZSBzYW1lIGNoYXJhY3RlcnMgZXhjZXB0IFwiaW5jcmVtZW50ZWRcIiBieSBvbmUuXG4gICAgdmFyIGxhc3RSYW5kQ2hhcnMgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vdykge1xuICAgICAgICB2YXIgZHVwbGljYXRlVGltZSA9IG5vdyA9PT0gbGFzdFB1c2hUaW1lO1xuICAgICAgICBsYXN0UHVzaFRpbWUgPSBub3c7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgdGltZVN0YW1wQ2hhcnMgPSBuZXcgQXJyYXkoOCk7XG4gICAgICAgIGZvciAoaSA9IDc7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aW1lU3RhbXBDaGFyc1tpXSA9IFBVU0hfQ0hBUlMuY2hhckF0KG5vdyAlIDY0KTtcbiAgICAgICAgICAgIC8vIE5PVEU6IENhbid0IHVzZSA8PCBoZXJlIGJlY2F1c2UgamF2YXNjcmlwdCB3aWxsIGNvbnZlcnQgdG8gaW50IGFuZCBsb3NlXG4gICAgICAgICAgICAvLyB0aGUgdXBwZXIgYml0cy5cbiAgICAgICAgICAgIG5vdyA9IE1hdGguZmxvb3Iobm93IC8gNjQpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWxfMS5hc3NlcnQobm93ID09PSAwLCAnQ2Fubm90IHB1c2ggYXQgdGltZSA9PSAwJyk7XG4gICAgICAgIHZhciBpZCA9IHRpbWVTdGFtcENoYXJzLmpvaW4oJycpO1xuICAgICAgICBpZiAoIWR1cGxpY2F0ZVRpbWUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDY0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0aW1lc3RhbXAgaGFzbid0IGNoYW5nZWQgc2luY2UgbGFzdCBwdXNoLCB1c2UgdGhlIHNhbWUgcmFuZG9tXG4gICAgICAgICAgICAvLyBudW1iZXIsIGV4Y2VwdCBpbmNyZW1lbnRlZCBieSAxLlxuICAgICAgICAgICAgZm9yIChpID0gMTE7IGkgPj0gMCAmJiBsYXN0UmFuZENoYXJzW2ldID09PSA2MzsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0UmFuZENoYXJzW2ldKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIGlkICs9IFBVU0hfQ0hBUlMuY2hhckF0KGxhc3RSYW5kQ2hhcnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWxfMS5hc3NlcnQoaWQubGVuZ3RoID09PSAyMCwgJ25leHRQdXNoSWQ6IExlbmd0aCBzaG91bGQgYmUgMjAuJyk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xufSkoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV4dFB1c2hJZC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RW1pdHRlclwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIE1vbml0b3JzIG9ubGluZSBzdGF0ZSAoYXMgcmVwb3J0ZWQgYnkgd2luZG93Lm9ubGluZS9vZmZsaW5lIGV2ZW50cykuXG4gKlxuICogVGhlIGV4cGVjdGF0aW9uIGlzIHRoYXQgdGhpcyBjb3VsZCBoYXZlIG1hbnkgZmFsc2UgcG9zaXRpdmVzICh0aGlua3Mgd2UgYXJlIG9ubGluZVxuICogd2hlbiB3ZSdyZSBub3QpLCBidXQgbm8gZmFsc2UgbmVnYXRpdmVzLiAgU28gd2UgY2FuIHNhZmVseSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoZW5cbiAqIHdlIGRlZmluaXRlbHkgY2Fubm90IHJlYWNoIHRoZSBpbnRlcm5ldC5cbiAqXG4gKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyfVxuICovXG52YXIgT25saW5lTW9uaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT25saW5lTW9uaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPbmxpbmVNb25pdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBbJ29ubGluZSddKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vbmxpbmVfID0gdHJ1ZTtcbiAgICAgICAgLy8gV2UndmUgaGFkIHJlcGVhdGVkIGNvbXBsYWludHMgdGhhdCBDb3Jkb3ZhIGFwcHMgY2FuIGdldCBzdHVjayBcIm9mZmxpbmVcIiwgZS5nLlxuICAgICAgICAvLyBodHRwczovL2ZvcnVtLmlvbmljZnJhbWV3b3JrLmNvbS90L2ZpcmViYXNlLWNvbm5lY3Rpb24taXMtbG9zdC1hbmQtbmV2ZXItY29tZS1iYWNrLzQzODEwXG4gICAgICAgIC8vIEl0IHdvdWxkIHNlZW0gdGhhdCB0aGUgJ29ubGluZScgZXZlbnQgZG9lcyBub3QgYWx3YXlzIGZpcmUgY29uc2lzdGVudGx5LiBTbyB3ZSBkaXNhYmxlIGl0XG4gICAgICAgIC8vIGZvciBDb3Jkb3ZhLlxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICF1dGlsXzIuaXNNb2JpbGVDb3Jkb3ZhKCkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vbmxpbmVfKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9ubGluZV8gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyKCdvbmxpbmUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25saW5lXykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmxpbmVfID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXIoJ29ubGluZScsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPbmxpbmVNb25pdG9yLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE9ubGluZU1vbml0b3IoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlXG4gICAgICogQHJldHVybiB7QXJyYXkuPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIE9ubGluZU1vbml0b3IucHJvdG90eXBlLmdldEluaXRpYWxFdmVudCA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydChldmVudFR5cGUgPT09ICdvbmxpbmUnLCAnVW5rbm93biBldmVudCB0eXBlOiAnICsgZXZlbnRUeXBlKTtcbiAgICAgICAgcmV0dXJuIFt0aGlzLm9ubGluZV9dO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBPbmxpbmVNb25pdG9yLnByb3RvdHlwZS5jdXJyZW50bHlPbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ubGluZV87XG4gICAgfTtcbiAgICByZXR1cm4gT25saW5lTW9uaXRvcjtcbn0oRXZlbnRFbWl0dGVyXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLk9ubGluZU1vbml0b3IgPSBPbmxpbmVNb25pdG9yO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PbmxpbmVNb25pdG9yLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIHBhcnNlZCBwYXRoLiAgSXQncyBpbW11dGFibGUgc28gdGhhdCB5b3VcbiAqIGNhbiBwYXNzIHRoZW0gYXJvdW5kIHRvIG90aGVyIGZ1bmN0aW9ucyB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHRoZW0gY2hhbmdpbmdcbiAqIGl0LlxuICovXG52YXIgUGF0aCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcGF0aE9yU3RyaW5nIFBhdGggc3RyaW5nIHRvIHBhcnNlLFxuICAgICAqICAgICAgb3IgYW5vdGhlciBwYXRoLCBvciB0aGUgcmF3IHRva2VucyBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcGllY2VOdW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXRoKHBhdGhPclN0cmluZywgcGllY2VOdW0pIHtcbiAgICAgICAgaWYgKHBpZWNlTnVtID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMucGllY2VzXyA9IHBhdGhPclN0cmluZy5zcGxpdCgnLycpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGVtcHR5IHBpZWNlcy5cbiAgICAgICAgICAgIHZhciBjb3B5VG8gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5waWVjZXNfW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waWVjZXNfW2NvcHlUb10gPSB0aGlzLnBpZWNlc19baV07XG4gICAgICAgICAgICAgICAgICAgIGNvcHlUbysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGllY2VzXy5sZW5ndGggPSBjb3B5VG87XG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBpZWNlc18gPSBwYXRoT3JTdHJpbmc7XG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IHBpZWNlTnVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXRoLCBcIkVtcHR5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbmdsZXRvbiB0byByZXByZXNlbnQgYW4gZW1wdHkgcGF0aFxuICAgICAgICAgKlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRoKCcnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUGF0aC5wcm90b3R5cGUuZ2V0RnJvbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpZWNlTnVtXyA+PSB0aGlzLnBpZWNlc18ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnBpZWNlc19bdGhpcy5waWVjZU51bV9dO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGllY2VzXy5sZW5ndGggLSB0aGlzLnBpZWNlTnVtXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFQYXRofVxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLnBvcEZyb250ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGllY2VOdW0gPSB0aGlzLnBpZWNlTnVtXztcbiAgICAgICAgaWYgKHBpZWNlTnVtIDwgdGhpcy5waWVjZXNfLmxlbmd0aCkge1xuICAgICAgICAgICAgcGllY2VOdW0rKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGgodGhpcy5waWVjZXNfLCBwaWVjZU51bSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmdldEJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpZWNlTnVtXyA8IHRoaXMucGllY2VzXy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5waWVjZXNfW3RoaXMucGllY2VzXy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBQYXRoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5waWVjZXNfW2ldICE9PSAnJylcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nICs9ICcvJyArIHRoaXMucGllY2VzX1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyB8fCAnLyc7XG4gICAgfTtcbiAgICBQYXRoLnByb3RvdHlwZS50b1VybEVuY29kZWRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBpZWNlTnVtXzsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMucGllY2VzX1tpXSAhPT0gJycpXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyArPSAnLycgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHRoaXMucGllY2VzX1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoU3RyaW5nIHx8ICcvJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNoYWxsb3cgY29weSBvZiB0aGUgcGFydHMgb2YgdGhlIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luXG4gICAgICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgUGF0aC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoYmVnaW4pIHtcbiAgICAgICAgaWYgKGJlZ2luID09PSB2b2lkIDApIHsgYmVnaW4gPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBpZWNlc18uc2xpY2UodGhpcy5waWVjZU51bV8gKyBiZWdpbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/UGF0aH1cbiAgICAgKi9cbiAgICBQYXRoLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpZWNlTnVtXyA+PSB0aGlzLnBpZWNlc18ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBwaWVjZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHRoaXMucGllY2VzX1tpXSk7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aChwaWVjZXMsIDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8IVBhdGh9IGNoaWxkUGF0aE9ialxuICAgICAqIEByZXR1cm4geyFQYXRofVxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gKGNoaWxkUGF0aE9iaikge1xuICAgICAgICB2YXIgcGllY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBpZWNlTnVtXzsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHRoaXMucGllY2VzX1tpXSk7XG4gICAgICAgIGlmIChjaGlsZFBhdGhPYmogaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRQYXRoT2JqLnBpZWNlTnVtXzsgaSA8IGNoaWxkUGF0aE9iai5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGllY2VzLnB1c2goY2hpbGRQYXRoT2JqLnBpZWNlc19baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoaWxkUGllY2VzID0gY2hpbGRQYXRoT2JqLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkUGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkUGllY2VzW2ldLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHBpZWNlcy5wdXNoKGNoaWxkUGllY2VzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGgocGllY2VzLCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlcmUgYXJlIG5vIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpZWNlTnVtXyA+PSB0aGlzLnBpZWNlc18ubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gb3V0ZXJQYXRoXG4gICAgICogQHBhcmFtIHshUGF0aH0gaW5uZXJQYXRoXG4gICAgICogQHJldHVybiB7IVBhdGh9IFRoZSBwYXRoIGZyb20gb3V0ZXJQYXRoIHRvIGlubmVyUGF0aFxuICAgICAqL1xuICAgIFBhdGgucmVsYXRpdmVQYXRoID0gZnVuY3Rpb24gKG91dGVyUGF0aCwgaW5uZXJQYXRoKSB7XG4gICAgICAgIHZhciBvdXRlciA9IG91dGVyUGF0aC5nZXRGcm9udCgpLCBpbm5lciA9IGlubmVyUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICBpZiAob3V0ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbm5lclBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3V0ZXIgPT09IGlubmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gUGF0aC5yZWxhdGl2ZVBhdGgob3V0ZXJQYXRoLnBvcEZyb250KCksIGlubmVyUGF0aC5wb3BGcm9udCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSU5URVJOQUwgRVJST1I6IGlubmVyUGF0aCAoJyArXG4gICAgICAgICAgICAgICAgaW5uZXJQYXRoICtcbiAgICAgICAgICAgICAgICAnKSBpcyBub3Qgd2l0aGluICcgK1xuICAgICAgICAgICAgICAgICdvdXRlclBhdGggKCcgK1xuICAgICAgICAgICAgICAgIG91dGVyUGF0aCArXG4gICAgICAgICAgICAgICAgJyknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gbGVmdFxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHJpZ2h0XG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtMSwgMCwgMSBpZiBsZWZ0IGlzIGxlc3MsIGVxdWFsLCBvciBncmVhdGVyIHRoYW4gdGhlIHJpZ2h0LlxuICAgICAqL1xuICAgIFBhdGguY29tcGFyZVBhdGhzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBsZWZ0S2V5cyA9IGxlZnQuc2xpY2UoKTtcbiAgICAgICAgdmFyIHJpZ2h0S2V5cyA9IHJpZ2h0LnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbXAgPSB1dGlsXzEubmFtZUNvbXBhcmUobGVmdEtleXNbaV0sIHJpZ2h0S2V5c1tpXSk7XG4gICAgICAgICAgICBpZiAoY21wICE9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnRLZXlzLmxlbmd0aCA9PT0gcmlnaHRLZXlzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gbGVmdEtleXMubGVuZ3RoIDwgcmlnaHRLZXlzLmxlbmd0aCA/IC0xIDogMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXRofSBvdGhlclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgcGF0aHMgYXJlIHRoZSBzYW1lLlxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5nZXRMZW5ndGgoKSAhPT0gb3RoZXIuZ2V0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5waWVjZU51bV8sIGogPSBvdGhlci5waWVjZU51bV87IGkgPD0gdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrLCBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpZWNlc19baV0gIT09IG90aGVyLnBpZWNlc19bal0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IG90aGVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHBhdGggaXMgYSBwYXJlbnQgKG9yIHRoZSBzYW1lIGFzKSBvdGhlclxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5waWVjZU51bV87XG4gICAgICAgIHZhciBqID0gb3RoZXIucGllY2VOdW1fO1xuICAgICAgICBpZiAodGhpcy5nZXRMZW5ndGgoKSA+IG90aGVyLmdldExlbmd0aCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnBpZWNlc18ubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5waWVjZXNfW2ldICE9PSBvdGhlci5waWVjZXNfW2pdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgKytqO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIFBhdGg7XG59KCkpOyAvLyBlbmQgUGF0aFxuZXhwb3J0cy5QYXRoID0gUGF0aDtcbi8qKlxuICogRHluYW1pYyAobXV0YWJsZSkgcGF0aCB1c2VkIHRvIGNvdW50IHBhdGggbGVuZ3Rocy5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gZWZmaWNpZW50bHkgY2hlY2sgcGF0aHMgZm9yIHZhbGlkXG4gKiBsZW5ndGggKGluIFVURjggYnl0ZXMpIGFuZCBkZXB0aCAodXNlZCBpbiBwYXRoIHZhbGlkYXRpb24pLlxuICpcbiAqIFRocm93cyBFcnJvciBleGNlcHRpb24gaWYgcGF0aCBpcyBldmVyIGludmFsaWQuXG4gKlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBwYXRoIGFsd2F5cyBiZWdpbnMgd2l0aCAnLycuXG4gKi9cbnZhciBWYWxpZGF0aW9uUGF0aCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIEluaXRpYWwgUGF0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JQcmVmaXhfIFByZWZpeCBmb3IgYW55IGVycm9yIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25QYXRoKHBhdGgsIGVycm9yUHJlZml4Xykge1xuICAgICAgICB0aGlzLmVycm9yUHJlZml4XyA9IGVycm9yUHJlZml4XztcbiAgICAgICAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgICAgICAgdGhpcy5wYXJ0c18gPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBJbml0aWFsaXplIHRvIG51bWJlciBvZiAnLycgY2hhcnMgbmVlZGVkIGluIHBhdGguICovXG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gPSBNYXRoLm1heCgxLCB0aGlzLnBhcnRzXy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFydHNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGhfICs9IHV0aWxfMi5zdHJpbmdMZW5ndGgodGhpcy5wYXJ0c19baV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tWYWxpZF8oKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbGlkYXRpb25QYXRoLCBcIk1BWF9QQVRIX0RFUFRIXCIsIHtcbiAgICAgICAgLyoqIEBjb25zdCB7bnVtYmVyfSBNYXhpbXVtIGtleSBkZXB0aC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWxpZGF0aW9uUGF0aCwgXCJNQVhfUEFUSF9MRU5HVEhfQllURVNcIiwge1xuICAgICAgICAvKiogQGNvbnN0IHtudW1iZXJ9IE1heGltdW0gbnVtYmVyIG9mIChVVEY4KSBieXRlcyBpbiBhIEZpcmViYXNlIHBhdGguICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDc2ODtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZCAqL1xuICAgIFZhbGlkYXRpb25QYXRoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIC8vIENvdW50IHRoZSBuZWVkZWQgJy8nXG4gICAgICAgIGlmICh0aGlzLnBhcnRzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGhfICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0c18ucHVzaChjaGlsZCk7XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gKz0gdXRpbF8yLnN0cmluZ0xlbmd0aChjaGlsZCk7XG4gICAgICAgIHRoaXMuY2hlY2tWYWxpZF8oKTtcbiAgICB9O1xuICAgIFZhbGlkYXRpb25QYXRoLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5wYXJ0c18ucG9wKCk7XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gLT0gdXRpbF8yLnN0cmluZ0xlbmd0aChsYXN0KTtcbiAgICAgICAgLy8gVW4tY291bnQgdGhlIHByZXZpb3VzICcvJ1xuICAgICAgICBpZiAodGhpcy5wYXJ0c18ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoXyAtPSAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWYWxpZGF0aW9uUGF0aC5wcm90b3R5cGUuY2hlY2tWYWxpZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ5dGVMZW5ndGhfID4gVmFsaWRhdGlvblBhdGguTUFYX1BBVEhfTEVOR1RIX0JZVEVTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5lcnJvclByZWZpeF8gK1xuICAgICAgICAgICAgICAgICdoYXMgYSBrZXkgcGF0aCBsb25nZXIgdGhhbiAnICtcbiAgICAgICAgICAgICAgICBWYWxpZGF0aW9uUGF0aC5NQVhfUEFUSF9MRU5HVEhfQllURVMgK1xuICAgICAgICAgICAgICAgICcgYnl0ZXMgKCcgK1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gK1xuICAgICAgICAgICAgICAgICcpLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcnRzXy5sZW5ndGggPiBWYWxpZGF0aW9uUGF0aC5NQVhfUEFUSF9ERVBUSCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JQcmVmaXhfICtcbiAgICAgICAgICAgICAgICAncGF0aCBzcGVjaWZpZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBkZXB0aCB0aGF0IGNhbiBiZSB3cml0dGVuICgnICtcbiAgICAgICAgICAgICAgICBWYWxpZGF0aW9uUGF0aC5NQVhfUEFUSF9ERVBUSCArXG4gICAgICAgICAgICAgICAgJykgb3Igb2JqZWN0IGNvbnRhaW5zIGEgY3ljbGUgJyArXG4gICAgICAgICAgICAgICAgdGhpcy50b0Vycm9yU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdHJpbmcgZm9yIHVzZSBpbiBlcnJvciBtZXNzYWdlcyAtIHVzZXMgJy4nIG5vdGF0aW9uIGZvciBwYXRoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIFZhbGlkYXRpb25QYXRoLnByb3RvdHlwZS50b0Vycm9yU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0c18ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJpbiBwcm9wZXJ0eSAnXCIgKyB0aGlzLnBhcnRzXy5qb2luKCcuJykgKyBcIidcIjtcbiAgICB9O1xuICAgIHJldHVybiBWYWxpZGF0aW9uUGF0aDtcbn0oKSk7XG5leHBvcnRzLlZhbGlkYXRpb25QYXRoID0gVmFsaWRhdGlvblBhdGg7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhdGguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG52YXIgU3BhcnNlU25hcHNob3RUcmVlXzEgPSByZXF1aXJlKFwiLi4vU3BhcnNlU25hcHNob3RUcmVlXCIpO1xudmFyIExlYWZOb2RlXzEgPSByZXF1aXJlKFwiLi4vc25hcC9MZWFmTm9kZVwiKTtcbnZhciBub2RlRnJvbUpTT05fMSA9IHJlcXVpcmUoXCIuLi9zbmFwL25vZGVGcm9tSlNPTlwiKTtcbnZhciBQcmlvcml0eUluZGV4XzEgPSByZXF1aXJlKFwiLi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG4vKipcbiAqIEdlbmVyYXRlIHBsYWNlaG9sZGVycyBmb3IgZGVmZXJyZWQgdmFsdWVzLlxuICogQHBhcmFtIHs/T2JqZWN0fSB2YWx1ZXNcbiAqIEByZXR1cm4geyFPYmplY3R9XG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVXaXRoVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHZhbHVlcyA9IHZhbHVlcyB8fCB7fTtcbiAgICB2YWx1ZXNbJ3RpbWVzdGFtcCddID0gdmFsdWVzWyd0aW1lc3RhbXAnXSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICByZXR1cm4gdmFsdWVzO1xufTtcbi8qKlxuICogVmFsdWUgdG8gdXNlIHdoZW4gZmlyaW5nIGxvY2FsIGV2ZW50cy4gV2hlbiB3cml0aW5nIHNlcnZlciB2YWx1ZXMsIGZpcmVcbiAqIGxvY2FsIGV2ZW50cyB3aXRoIGFuIGFwcHJveGltYXRlIHZhbHVlLCBvdGhlcndpc2UgcmV0dXJuIHZhbHVlIGFzLWlzLlxuICogQHBhcmFtIHsoT2JqZWN0fHN0cmluZ3xudW1iZXJ8Ym9vbGVhbil9IHZhbHVlXG4gKiBAcGFyYW0geyFPYmplY3R9IHNlcnZlclZhbHVlc1xuICogQHJldHVybiB7IShzdHJpbmd8bnVtYmVyfGJvb2xlYW4pfVxuICovXG5leHBvcnRzLnJlc29sdmVEZWZlcnJlZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBzZXJ2ZXJWYWx1ZXMpIHtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydCgnLnN2JyBpbiB2YWx1ZSwgJ1VuZXhwZWN0ZWQgbGVhZiBub2RlIG9yIHByaW9yaXR5IGNvbnRlbnRzJyk7XG4gICAgICAgIHJldHVybiBzZXJ2ZXJWYWx1ZXNbdmFsdWVbJy5zdiddXTtcbiAgICB9XG59O1xuLyoqXG4gKiBSZWN1cnNpdmVseSByZXBsYWNlIGFsbCBkZWZlcnJlZCB2YWx1ZXMgYW5kIHByaW9yaXRpZXMgaW4gdGhlIHRyZWUgd2l0aCB0aGVcbiAqIHNwZWNpZmllZCBnZW5lcmF0ZWQgcmVwbGFjZW1lbnQgdmFsdWVzLlxuICogQHBhcmFtIHshU3BhcnNlU25hcHNob3RUcmVlfSB0cmVlXG4gKiBAcGFyYW0geyFPYmplY3R9IHNlcnZlclZhbHVlc1xuICogQHJldHVybiB7IVNwYXJzZVNuYXBzaG90VHJlZX1cbiAqL1xuZXhwb3J0cy5yZXNvbHZlRGVmZXJyZWRWYWx1ZVRyZWUgPSBmdW5jdGlvbiAodHJlZSwgc2VydmVyVmFsdWVzKSB7XG4gICAgdmFyIHJlc29sdmVkVHJlZSA9IG5ldyBTcGFyc2VTbmFwc2hvdFRyZWVfMS5TcGFyc2VTbmFwc2hvdFRyZWUoKTtcbiAgICB0cmVlLmZvckVhY2hUcmVlKG5ldyBQYXRoXzEuUGF0aCgnJyksIGZ1bmN0aW9uIChwYXRoLCBub2RlKSB7XG4gICAgICAgIHJlc29sdmVkVHJlZS5yZW1lbWJlcihwYXRoLCBleHBvcnRzLnJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3Qobm9kZSwgc2VydmVyVmFsdWVzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc29sdmVkVHJlZTtcbn07XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgYWxsIGRlZmVycmVkIHZhbHVlcyBhbmQgcHJpb3JpdGllcyBpbiB0aGUgbm9kZSB3aXRoIHRoZVxuICogc3BlY2lmaWVkIGdlbmVyYXRlZCByZXBsYWNlbWVudCB2YWx1ZXMuICBJZiB0aGVyZSBhcmUgbm8gc2VydmVyIHZhbHVlcyBpbiB0aGUgbm9kZSxcbiAqIGl0J2xsIGJlIHJldHVybmVkIGFzLWlzLlxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICogQHBhcmFtIHshT2JqZWN0fSBzZXJ2ZXJWYWx1ZXNcbiAqIEByZXR1cm4geyFOb2RlfVxuICovXG5leHBvcnRzLnJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QgPSBmdW5jdGlvbiAobm9kZSwgc2VydmVyVmFsdWVzKSB7XG4gICAgdmFyIHJhd1ByaSA9IG5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKTtcbiAgICB2YXIgcHJpb3JpdHkgPSBleHBvcnRzLnJlc29sdmVEZWZlcnJlZFZhbHVlKHJhd1ByaSwgc2VydmVyVmFsdWVzKTtcbiAgICB2YXIgbmV3Tm9kZTtcbiAgICBpZiAobm9kZS5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgdmFyIGxlYWZOb2RlID0gbm9kZTtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwb3J0cy5yZXNvbHZlRGVmZXJyZWRWYWx1ZShsZWFmTm9kZS5nZXRWYWx1ZSgpLCBzZXJ2ZXJWYWx1ZXMpO1xuICAgICAgICBpZiAodmFsdWUgIT09IGxlYWZOb2RlLmdldFZhbHVlKCkgfHxcbiAgICAgICAgICAgIHByaW9yaXR5ICE9PSBsZWFmTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExlYWZOb2RlXzEuTGVhZk5vZGUodmFsdWUsIG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSBub2RlO1xuICAgICAgICBuZXdOb2RlID0gY2hpbGRyZW5Ob2RlO1xuICAgICAgICBpZiAocHJpb3JpdHkgIT09IGNoaWxkcmVuTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XG4gICAgICAgICAgICBuZXdOb2RlID0gbmV3Tm9kZS51cGRhdGVQcmlvcml0eShuZXcgTGVhZk5vZGVfMS5MZWFmTm9kZShwcmlvcml0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuTm9kZS5mb3JFYWNoQ2hpbGQoUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZE5vZGUgPSBleHBvcnRzLnJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QoY2hpbGROb2RlLCBzZXJ2ZXJWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkTm9kZSAhPT0gY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IG5ld05vZGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VydmVyVmFsdWVzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBbiBpdGVyYXRvciBvdmVyIGFuIExMUkJOb2RlLlxuICovXG52YXIgU29ydGVkTWFwSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIEssIFYsIFRcbiAgICAgKiBAcGFyYW0ge0xMUkJOb2RlfExMUkJFbXB0eU5vZGV9IG5vZGUgTm9kZSB0byBpdGVyYXRlLlxuICAgICAqIEBwYXJhbSB7P0t9IHN0YXJ0S2V5XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihLLCBLKTogbnVtYmVyfSBjb21wYXJhdG9yXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1JldmVyc2VfIFdoZXRoZXIgb3Igbm90IHRvIGl0ZXJhdGUgaW4gcmV2ZXJzZVxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uKEssIFYpOlQpPX0gcmVzdWx0R2VuZXJhdG9yX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNvcnRlZE1hcEl0ZXJhdG9yKG5vZGUsIHN0YXJ0S2V5LCBjb21wYXJhdG9yLCBpc1JldmVyc2VfLCByZXN1bHRHZW5lcmF0b3JfKSB7XG4gICAgICAgIGlmIChyZXN1bHRHZW5lcmF0b3JfID09PSB2b2lkIDApIHsgcmVzdWx0R2VuZXJhdG9yXyA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5pc1JldmVyc2VfID0gaXNSZXZlcnNlXztcbiAgICAgICAgdGhpcy5yZXN1bHRHZW5lcmF0b3JfID0gcmVzdWx0R2VuZXJhdG9yXztcbiAgICAgICAgLyoqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48IUxMUkJOb2RlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZVN0YWNrXyA9IFtdO1xuICAgICAgICB2YXIgY21wID0gMTtcbiAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGU7XG4gICAgICAgICAgICBjbXAgPSBzdGFydEtleSA/IGNvbXBhcmF0b3Iobm9kZS5rZXksIHN0YXJ0S2V5KSA6IDE7XG4gICAgICAgICAgICAvLyBmbGlwIHRoZSBjb21wYXJpc29uIGlmIHdlJ3JlIGdvaW5nIGluIHJldmVyc2VcbiAgICAgICAgICAgIGlmIChpc1JldmVyc2VfKVxuICAgICAgICAgICAgICAgIGNtcCAqPSAtMTtcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGxlc3MgdGhhbiBvdXIgc3RhcnQga2V5LiBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgZXhhY3RseSBlcXVhbCB0byBvdXIgc3RhcnQga2V5LiBQdXNoIGl0IG9uIHRoZSBzdGFjaywgYnV0IHN0b3AgaXRlcmF0aW5nO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGdyZWF0ZXIgdGhhbiBvdXIgc3RhcnQga2V5LCBhZGQgaXQgdG8gdGhlIHN0YWNrIGFuZCBtb3ZlIHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBTb3J0ZWRNYXBJdGVyYXRvci5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZVN0YWNrXy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVTdGFja18ucG9wKCk7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdEdlbmVyYXRvcl8pXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdEdlbmVyYXRvcl8obm9kZS5rZXksIG5vZGUudmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQgPSB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XG4gICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZV8pIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTb3J0ZWRNYXBJdGVyYXRvci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVN0YWNrXy5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgU29ydGVkTWFwSXRlcmF0b3IucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVTdGFja18ubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlU3RhY2tfW3RoaXMubm9kZVN0YWNrXy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0R2VuZXJhdG9yXykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0R2VuZXJhdG9yXyhub2RlLmtleSwgbm9kZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU29ydGVkTWFwSXRlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5Tb3J0ZWRNYXBJdGVyYXRvciA9IFNvcnRlZE1hcEl0ZXJhdG9yO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgbm9kZSBpbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2sgdHJlZS5cbiAqL1xudmFyIExMUkJOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBLLCBWXG4gICAgICogQHBhcmFtIHshS30ga2V5IEtleSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLlxuICAgICAqIEBwYXJhbSB7IVZ9IHZhbHVlIFZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuXG4gICAgICogQHBhcmFtIHs/Ym9vbGVhbn0gY29sb3IgV2hldGhlciB0aGlzIG5vZGUgaXMgcmVkLlxuICAgICAqIEBwYXJhbSB7PyhMTFJCTm9kZXxMTFJCRW1wdHlOb2RlKT19IGxlZnQgTGVmdCBjaGlsZC5cbiAgICAgKiBAcGFyYW0gez8oTExSQk5vZGV8TExSQkVtcHR5Tm9kZSk9fSByaWdodCBSaWdodCBjaGlsZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMTFJCTm9kZShrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yICE9IG51bGwgPyBjb2xvciA6IExMUkJOb2RlLlJFRDtcbiAgICAgICAgdGhpcy5sZWZ0ID1cbiAgICAgICAgICAgIGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBTb3J0ZWRNYXAuRU1QVFlfTk9ERTtcbiAgICAgICAgdGhpcy5yaWdodCA9XG4gICAgICAgICAgICByaWdodCAhPSBudWxsID8gcmlnaHQgOiBTb3J0ZWRNYXAuRU1QVFlfTk9ERTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgbm9kZSwgb3B0aW9uYWxseSByZXBsYWNpbmcgcGllY2VzIG9mIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/S30ga2V5IE5ldyBrZXkgZm9yIHRoZSBub2RlLCBvciBudWxsLlxuICAgICAqIEBwYXJhbSB7P1Z9IHZhbHVlIE5ldyB2YWx1ZSBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXG4gICAgICogQHBhcmFtIHs/Ym9vbGVhbn0gY29sb3IgTmV3IGNvbG9yIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cbiAgICAgKiBAcGFyYW0gez9MTFJCTm9kZXxMTFJCRW1wdHlOb2RlfSBsZWZ0IE5ldyBsZWZ0IGNoaWxkIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cbiAgICAgKiBAcGFyYW0gez9MTFJCTm9kZXxMTFJCRW1wdHlOb2RlfSByaWdodCBOZXcgcmlnaHQgY2hpbGQgZm9yIHRoZSBub2RlLCBvciBudWxsLlxuICAgICAqIEByZXR1cm4geyFMTFJCTm9kZX0gVGhlIG5vZGUgY29weS5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXkgIT0gbnVsbCA/IGtleSA6IHRoaXMua2V5LCB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLnZhbHVlLCBjb2xvciAhPSBudWxsID8gY29sb3IgOiB0aGlzLmNvbG9yLCBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogdGhpcy5sZWZ0LCByaWdodCAhPSBudWxsID8gcmlnaHQgOiB0aGlzLnJpZ2h0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY291bnQoKSArIDEgKyB0aGlzLnJpZ2h0LmNvdW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB0cmVlIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgICAqIGZvciBlYWNoIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFLLCAhVik6Kn0gYWN0aW9uIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaFxuICAgICAqICAgbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxuICAgICAqICAgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLmlub3JkZXJUcmF2ZXJzYWwgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sZWZ0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB8fFxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxuICAgICAgICAgICAgdGhpcy5yaWdodC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgICAqIGZvciBlYWNoIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFPYmplY3QsICFPYmplY3QpfSBhY3Rpb24gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXG4gICAgICogbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXG4gICAgICogQHJldHVybiB7Kn0gVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLnJldmVyc2VUcmF2ZXJzYWwgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5yaWdodC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikgfHxcbiAgICAgICAgICAgIGFjdGlvbih0aGlzLmtleSwgdGhpcy52YWx1ZSkgfHxcbiAgICAgICAgICAgIHRoaXMubGVmdC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IU9iamVjdH0gVGhlIG1pbmltdW0gbm9kZSBpbiB0aGUgdHJlZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5taW5fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Lm1pbl8oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IUt9IFRoZSBtYXhpbXVtIGtleSBpbiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUubWluS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5fKCkua2V5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IUt9IFRoZSBtYXhpbXVtIGtleSBpbiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUubWF4S2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yaWdodC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Lm1heEtleSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0ga2V5IEtleSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIHtDb21wYXJhdG9yfSBjb21wYXJhdG9yIENvbXBhcmF0b3IuXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgd2l0aCB0aGUga2V5L3ZhbHVlIGFkZGVkLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgICAgICB2YXIgY21wLCBuO1xuICAgICAgICBuID0gdGhpcztcbiAgICAgICAgY21wID0gY29tcGFyYXRvcihrZXksIG4ua2V5KTtcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIHZhbHVlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5pbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHshTExSQk5vZGV8TExSQkVtcHR5Tm9kZX0gTmV3IHRyZWUsIHdpdGggdGhlIG1pbmltdW0ga2V5IHJlbW92ZWQuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLnJlbW92ZU1pbl8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlZnQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gU29ydGVkTWFwLkVNUFRZX05PREU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSB0aGlzO1xuICAgICAgICBpZiAoIW4ubGVmdC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWRfKCkpXG4gICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdF8oKTtcbiAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQucmVtb3ZlTWluXygpLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG4uZml4VXBfKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0NvbXBhcmF0b3J9IGNvbXBhcmF0b3IgQ29tcGFyYXRvci5cbiAgICAgKiBAcmV0dXJuIHshTExSQk5vZGV8TExSQkVtcHR5Tm9kZX0gTmV3IHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBpdGVtIHJlbW92ZWQuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXksIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIG4sIHNtYWxsZXN0O1xuICAgICAgICBuID0gdGhpcztcbiAgICAgICAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuLmtleSkgPCAwKSB7XG4gICAgICAgICAgICBpZiAoIW4ubGVmdC5pc0VtcHR5KCkgJiYgIW4ubGVmdC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcbiAgICAgICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdF8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkpXG4gICAgICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHRfKCk7XG4gICAgICAgICAgICBpZiAoIW4ucmlnaHQuaXNFbXB0eSgpICYmICFuLnJpZ2h0LmlzUmVkXygpICYmICFuLnJpZ2h0LmxlZnQuaXNSZWRfKCkpIHtcbiAgICAgICAgICAgICAgICBuID0gbi5tb3ZlUmVkUmlnaHRfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChuLnJpZ2h0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU29ydGVkTWFwLkVNUFRZX05PREU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdCA9IG4ucmlnaHQubWluXygpO1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5jb3B5KHNtYWxsZXN0LmtleSwgc21hbGxlc3QudmFsdWUsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlTWluXygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlKGtleSwgY29tcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgYSBSRUQgbm9kZS5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUuaXNSZWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSBhZnRlciBwZXJmb3JtaW5nIGFueSBuZWVkZWQgcm90YXRpb25zLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5maXhVcF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcztcbiAgICAgICAgaWYgKG4ucmlnaHQuaXNSZWRfKCkgJiYgIW4ubGVmdC5pc1JlZF8oKSlcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnRfKCk7XG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkgJiYgbi5sZWZ0LmxlZnQuaXNSZWRfKCkpXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZF8oKSAmJiBuLnJpZ2h0LmlzUmVkXygpKVxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgYWZ0ZXIgbW92ZVJlZExlZnQuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLm1vdmVSZWRMZWZ0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNvbG9yRmxpcF8oKTtcbiAgICAgICAgaWYgKG4ucmlnaHQubGVmdC5pc1JlZF8oKSkge1xuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJvdGF0ZVJpZ2h0XygpKTtcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnRfKCk7XG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4geyFMTFJCTm9kZX0gTmV3IHRyZWUsIGFmdGVyIG1vdmVSZWRSaWdodC5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUubW92ZVJlZFJpZ2h0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNvbG9yRmxpcF8oKTtcbiAgICAgICAgaWYgKG4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcF8oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgYWZ0ZXIgcm90YXRlTGVmdC5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUucm90YXRlTGVmdF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBubCA9IHRoaXMuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5SRUQsIG51bGwsIHRoaXMucmlnaHQubGVmdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgbmwsIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHshTExSQk5vZGV9IE5ldyB0cmVlLCBhZnRlciByb3RhdGVSaWdodC5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUucm90YXRlUmlnaHRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbnIgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCB0aGlzLmxlZnQucmlnaHQsIG51bGwpO1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgbnVsbCwgbnIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHshTExSQk5vZGV9IE5ldyB0cmVlLCBhZnRlciBjb2xvckZsaXAuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLmNvbG9yRmxpcF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5sZWZ0LmNvcHkobnVsbCwgbnVsbCwgIXRoaXMubGVmdC5jb2xvciwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmlnaHQuY29weShudWxsLCBudWxsLCAhdGhpcy5yaWdodC5jb2xvciwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkobnVsbCwgbnVsbCwgIXRoaXMuY29sb3IsIGxlZnQsIHJpZ2h0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvciB0ZXN0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFsbCBpcyB3ZWxsLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5jaGVja01heERlcHRoXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJsYWNrRGVwdGggPSB0aGlzLmNoZWNrXygpO1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coMi4wLCBibGFja0RlcHRoKSA8PSB0aGlzLmNvdW50KCkgKyAxO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5vdCBzdXJlIHdoYXQgdGhpcyByZXR1cm5zIGV4YWN0bHkuIDotKS5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUuY2hlY2tfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmxhY2tEZXB0aDtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWRfKCkgJiYgdGhpcy5sZWZ0LmlzUmVkXygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZCBub2RlIGhhcyByZWQgY2hpbGQoJyArIHRoaXMua2V5ICsgJywnICsgdGhpcy52YWx1ZSArICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNSZWRfKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmlnaHQgY2hpbGQgb2YgKCcgKyB0aGlzLmtleSArICcsJyArIHRoaXMudmFsdWUgKyAnKSBpcyByZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBibGFja0RlcHRoID0gdGhpcy5sZWZ0LmNoZWNrXygpO1xuICAgICAgICBpZiAoYmxhY2tEZXB0aCAhPT0gdGhpcy5yaWdodC5jaGVja18oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbGFjayBkZXB0aHMgZGlmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYmxhY2tEZXB0aCArICh0aGlzLmlzUmVkXygpID8gMCA6IDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMTFJCTm9kZS5SRUQgPSB0cnVlO1xuICAgIExMUkJOb2RlLkJMQUNLID0gZmFsc2U7XG4gICAgcmV0dXJuIExMUkJOb2RlO1xufSgpKTtcbmV4cG9ydHMuTExSQk5vZGUgPSBMTFJCTm9kZTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBlbXB0eSBub2RlIChhIGxlYWYgbm9kZSBpbiB0aGUgUmVkLUJsYWNrIFRyZWUpLlxuICovXG52YXIgTExSQkVtcHR5Tm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMTFJCRW1wdHlOb2RlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IUxMUkJFbXB0eU5vZGV9IFRoZSBub2RlIGNvcHkuXG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUt9IGtleSBLZXkgdG8gYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIHshVn0gdmFsdWUgVmFsdWUgdG8gYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIHtDb21wYXJhdG9yfSBjb21wYXJhdG9yIENvbXBhcmF0b3IuXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgd2l0aCBpdGVtIGFkZGVkLlxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCB2YWx1ZSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshS30ga2V5IFRoZSBrZXkgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7Q29tcGFyYXRvcn0gY29tcGFyYXRvciBDb21wYXJhdG9yLlxuICAgICAqIEByZXR1cm4geyFMTFJCRW1wdHlOb2RlfSBOZXcgdHJlZSwgd2l0aCBpdGVtIHJlbW92ZWQuXG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBMTFJCRW1wdHlOb2RlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB0cmVlIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cbiAgICAgKiBmb3IgZWFjaCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighSywgIVYpOip9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcbiAgICAgKiBub2RlLiAgSWYgaXQgcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBMTFJCRW1wdHlOb2RlLnByb3RvdHlwZS5pbm9yZGVyVHJhdmVyc2FsID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXG4gICAgICogZm9yIGVhY2ggbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUssICFWKX0gYWN0aW9uIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaFxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLnJldmVyc2VUcmF2ZXJzYWwgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bGx9XG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUubWluS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bGx9XG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUubWF4S2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBOb3Qgc3VyZSB3aGF0IHRoaXMgcmV0dXJucyBleGFjdGx5LiA6LSkuXG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUuY2hlY2tfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG5vZGUgaXMgcmVkLlxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLmlzUmVkXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIExMUkJFbXB0eU5vZGU7XG59KCkpO1xuZXhwb3J0cy5MTFJCRW1wdHlOb2RlID0gTExSQkVtcHR5Tm9kZTtcbi8qKlxuICogQW4gaW1tdXRhYmxlIHNvcnRlZCBtYXAgaW1wbGVtZW50YXRpb24sIGJhc2VkIG9uIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFja1xuICogdHJlZS5cbiAqL1xudmFyIFNvcnRlZE1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgSywgVlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oSywgSyk6bnVtYmVyfSBjb21wYXJhdG9yXyBLZXkgY29tcGFyYXRvci5cbiAgICAgKiBAcGFyYW0ge0xMUkJOb2RlPX0gcm9vdF8gKE9wdGlvbmFsKSBSb290IG5vZGUgZm9yIHRoZSBtYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU29ydGVkTWFwKGNvbXBhcmF0b3JfLCByb290Xykge1xuICAgICAgICBpZiAocm9vdF8gPT09IHZvaWQgMCkgeyByb290XyA9IFNvcnRlZE1hcC5FTVBUWV9OT0RFOyB9XG4gICAgICAgIHRoaXMuY29tcGFyYXRvcl8gPSBjb21wYXJhdG9yXztcbiAgICAgICAgdGhpcy5yb290XyA9IHJvb3RfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFwLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5L3ZhbHVlIGFkZGVkIG9yIHJlcGxhY2VkLlxuICAgICAqIChUT0RPOiBXZSBzaG91bGQgcGVyaGFwcyByZW5hbWUgdGhpcyBtZXRob2QgdG8gJ3B1dCcpXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFLfSBrZXkgS2V5IHRvIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSB7IVZ9IHZhbHVlIFZhbHVlIHRvIGJlIGFkZGVkLlxuICAgICAqIEByZXR1cm4geyFTb3J0ZWRNYXAuPEssIFY+fSBOZXcgbWFwLCB3aXRoIGl0ZW0gYWRkZWQuXG4gICAgICovXG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3JfLCB0aGlzLnJvb3RfXG4gICAgICAgICAgICAuaW5zZXJ0KGtleSwgdmFsdWUsIHRoaXMuY29tcGFyYXRvcl8pXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshS30ga2V5IFRoZSBrZXkgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4geyFTb3J0ZWRNYXAuPEssIFY+fSBOZXcgbWFwLCB3aXRoIGl0ZW0gcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yXywgdGhpcy5yb290X1xuICAgICAgICAgICAgLnJlbW92ZShrZXksIHRoaXMuY29tcGFyYXRvcl8pXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshS30ga2V5IFRoZSBrZXkgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJuIHs/Vn0gVGhlIHZhbHVlIG9mIHRoZSBub2RlIHdpdGggdGhlIGdpdmVuIGtleSwgb3IgbnVsbCBpZiB0aGVcbiAgICAgKiBrZXkgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGNtcDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnJvb3RfO1xuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBjbXAgPSB0aGlzLmNvbXBhcmF0b3JfKGtleSwgbm9kZS5rZXkpO1xuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGl0ZW0gKmJlZm9yZSogdGhlIHNwZWNpZmllZCBrZXksIG9yIG51bGwgaWYga2V5IGlzIHRoZSBmaXJzdCBpdGVtLlxuICAgICAqIEBwYXJhbSB7S30ga2V5IFRoZSBrZXkgdG8gZmluZCB0aGUgcHJlZGVjZXNzb3Igb2ZcbiAgICAgKiBAcmV0dXJuIHs/S30gVGhlIHByZWRlY2Vzc29yIGtleS5cbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLmdldFByZWRlY2Vzc29yS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgY21wLCBub2RlID0gdGhpcy5yb290XywgcmlnaHRQYXJlbnQgPSBudWxsO1xuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBjbXAgPSB0aGlzLmNvbXBhcmF0b3JfKGtleSwgbm9kZS5rZXkpO1xuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWZ0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIW5vZGUucmlnaHQuaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0UGFyZW50LmtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBmaXJzdCBpdGVtLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgICAgIHJpZ2h0UGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBmaW5kIHByZWRlY2Vzc29yIGtleSBmb3IgYSBub25leGlzdGVudCBrZXkuICBXaGF0IGdpdmVzPycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWFwIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uaXNFbXB0eSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBtYXAuXG4gICAgICovXG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uY291bnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez9LfSBUaGUgbWluaW11bSBrZXkgaW4gdGhlIG1hcC5cbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLm1pbktleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ubWluS2V5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/S30gVGhlIG1heGltdW0ga2V5IGluIHRoZSBtYXAuXG4gICAgICovXG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5tYXhLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLm1heEtleSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRoZSBtYXAgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighSywgIVYpOip9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcbiAgICAgKiAgIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvblxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUuaW5vcmRlclRyYXZlcnNhbCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRoZSBtYXAgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXG4gICAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFPYmplY3QsICFPYmplY3QpfSBhY3Rpb24gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuICBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAgKiBAcmV0dXJuIHsqfSBUcnVlIGlmIHRoZSB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXG4gICAgICovXG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5yZXZlcnNlVHJhdmVyc2FsID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIFNvcnRlZE1hcC5cbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uKEssIFYpOlQpPX0gcmVzdWx0R2VuZXJhdG9yXG4gICAgICogQHJldHVybiB7U29ydGVkTWFwSXRlcmF0b3IuPEssIFYsIFQ+fSBUaGUgaXRlcmF0b3IuXG4gICAgICovXG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChyZXN1bHRHZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBudWxsLCB0aGlzLmNvbXBhcmF0b3JfLCBmYWxzZSwgcmVzdWx0R2VuZXJhdG9yKTtcbiAgICB9O1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUuZ2V0SXRlcmF0b3JGcm9tID0gZnVuY3Rpb24gKGtleSwgcmVzdWx0R2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290Xywga2V5LCB0aGlzLmNvbXBhcmF0b3JfLCBmYWxzZSwgcmVzdWx0R2VuZXJhdG9yKTtcbiAgICB9O1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbSA9IGZ1bmN0aW9uIChrZXksIHJlc3VsdEdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIGtleSwgdGhpcy5jb21wYXJhdG9yXywgdHJ1ZSwgcmVzdWx0R2VuZXJhdG9yKTtcbiAgICB9O1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUuZ2V0UmV2ZXJzZUl0ZXJhdG9yID0gZnVuY3Rpb24gKHJlc3VsdEdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIG51bGwsIHRoaXMuY29tcGFyYXRvcl8sIHRydWUsIHJlc3VsdEdlbmVyYXRvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbHdheXMgdXNlIHRoZSBzYW1lIGVtcHR5IG5vZGUsIHRvIHJlZHVjZSBtZW1vcnkuXG4gICAgICogQGNvbnN0XG4gICAgICovXG4gICAgU29ydGVkTWFwLkVNUFRZX05PREUgPSBuZXcgTExSQkVtcHR5Tm9kZSgpO1xuICAgIHJldHVybiBTb3J0ZWRNYXA7XG59KCkpO1xuZXhwb3J0cy5Tb3J0ZWRNYXAgPSBTb3J0ZWRNYXA7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNvcnRlZE1hcC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIE5vZGUgaW4gYSBUcmVlLlxuICovXG52YXIgVHJlZU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJlZU5vZGUoKSB7XG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIG1ha2luZyBhY2Nlc3NvcnMgdGhhdCBjcmVhdGUgY2hpbGRyZW4gYW5kIHZhbHVlIGxhemlseSBvclxuICAgICAgICAvLyBzZXBhcmF0ZSBJbnRlcm5hbCAvIExlYWYgJ3R5cGVzJy5cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHt9O1xuICAgICAgICB0aGlzLmNoaWxkQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFRyZWVOb2RlO1xufSgpKTtcbmV4cG9ydHMuVHJlZU5vZGUgPSBUcmVlTm9kZTtcbi8qKlxuICogQSBsaWdodC13ZWlnaHQgdHJlZSwgdHJhdmVyc2FibGUgYnkgcGF0aC4gIE5vZGVzIGNhbiBoYXZlIGJvdGggdmFsdWVzIGFuZCBjaGlsZHJlbi5cbiAqIE5vZGVzIGFyZSBub3QgZW51bWVyYXRlZCAoYnkgZm9yRWFjaENoaWxkKSB1bmxlc3MgdGhleSBoYXZlIGEgdmFsdWUgb3Igbm9uLWVtcHR5XG4gKiBjaGlsZHJlbi5cbiAqL1xudmFyIFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWVfIE9wdGlvbmFsIG5hbWUgb2YgdGhlIG5vZGUuXG4gICAgICogQHBhcmFtIHtUcmVlPX0gcGFyZW50XyBPcHRpb25hbCBwYXJlbnQgbm9kZS5cbiAgICAgKiBAcGFyYW0ge1RyZWVOb2RlPX0gbm9kZV8gT3B0aW9uYWwgbm9kZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyZWUobmFtZV8sIHBhcmVudF8sIG5vZGVfKSB7XG4gICAgICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7IG5hbWVfID0gJyc7IH1cbiAgICAgICAgaWYgKHBhcmVudF8gPT09IHZvaWQgMCkgeyBwYXJlbnRfID0gbnVsbDsgfVxuICAgICAgICBpZiAobm9kZV8gPT09IHZvaWQgMCkgeyBub2RlXyA9IG5ldyBUcmVlTm9kZSgpOyB9XG4gICAgICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgICAgICAgdGhpcy5wYXJlbnRfID0gcGFyZW50XztcbiAgICAgICAgdGhpcy5ub2RlXyA9IG5vZGVfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3ViLVRyZWUgZm9yIHRoZSBnaXZlbiBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshKHN0cmluZ3xQYXRoKX0gcGF0aE9iaiBQYXRoIHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybiB7IVRyZWUuPFQ+fSBUcmVlIGZvciBwYXRoLlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLnN1YlRyZWUgPSBmdW5jdGlvbiAocGF0aE9iaikge1xuICAgICAgICAvLyBUT0RPOiBSZXF1aXJlIHBhdGhPYmogdG8gYmUgUGF0aD9cbiAgICAgICAgdmFyIHBhdGggPSBwYXRoT2JqIGluc3RhbmNlb2YgUGF0aF8xLlBhdGggPyBwYXRoT2JqIDogbmV3IFBhdGhfMS5QYXRoKHBhdGhPYmopO1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLCBuZXh0O1xuICAgICAgICB3aGlsZSAoKG5leHQgPSBwYXRoLmdldEZyb250KCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gdXRpbF8yLnNhZmVHZXQoY2hpbGQubm9kZV8uY2hpbGRyZW4sIG5leHQpIHx8IG5ldyBUcmVlTm9kZSgpO1xuICAgICAgICAgICAgY2hpbGQgPSBuZXcgVHJlZShuZXh0LCBjaGlsZCwgY2hpbGROb2RlKTtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnBvcEZyb250KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0cmVlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/VH0gVGhlIGRhdGEgb3IgbnVsbCBpZiBubyBkYXRhIGV4aXN0cy5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV8udmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGRhdGEgdG8gdGhpcyB0cmVlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFUfSB2YWx1ZSBWYWx1ZSB0byBzZXQuXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydCh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnLCAnQ2Fubm90IHNldCB2YWx1ZSB0byB1bmRlZmluZWQnKTtcbiAgICAgICAgdGhpcy5ub2RlXy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudHNfKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNvbnRlbnRzIG9mIHRoZSB0cmVlIG5vZGUgKGl0cyB2YWx1ZSBhbmQgYWxsIGNoaWxkcmVuKS5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub2RlXy52YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMubm9kZV8uY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgdGhpcy5ub2RlXy5jaGlsZENvdW50ID0gMDtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRzXygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdHJlZSBoYXMgYW55IGNoaWxkcmVuLlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLmhhc0NoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXy5jaGlsZENvdW50ID4gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRyZWUgaXMgZW1wdHkgKG5vIHZhbHVlIG9yIGNoaWxkcmVuKS5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpID09PSBudWxsICYmICF0aGlzLmhhc0NoaWxkcmVuKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxscyBhY3Rpb24gZm9yIGVhY2ggY2hpbGQgb2YgdGhpcyB0cmVlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFUcmVlLjxUPil9IGFjdGlvbiBBY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoIGNoaWxkLlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbF8yLmZvckVhY2godGhpcy5ub2RlXy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBjaGlsZFRyZWUpIHtcbiAgICAgICAgICAgIGFjdGlvbihuZXcgVHJlZShjaGlsZCwgX3RoaXMsIGNoaWxkVHJlZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERvZXMgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb2YgdGhpcyBub2RlJ3MgZGVzY2VuZGFudHMsIGNhbGxpbmcgYWN0aW9uIGZvciBlYWNoIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIVRyZWUuPFQ+KX0gYWN0aW9uIEFjdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZVNlbGYgV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiB0aGlzIG5vZGUgYXMgd2VsbC4gRGVmYXVsdHMgdG9cbiAgICAgKiAgIGZhbHNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGNoaWxkcmVuRmlyc3QgV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiBjaGlsZHJlbiBiZWZvcmUgY2FsbGluZyBpdCBvblxuICAgICAqICAgcGFyZW50LlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLmZvckVhY2hEZXNjZW5kYW50ID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5jbHVkZVNlbGYsIGNoaWxkcmVuRmlyc3QpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVTZWxmICYmICFjaGlsZHJlbkZpcnN0KVxuICAgICAgICAgICAgYWN0aW9uKHRoaXMpO1xuICAgICAgICB0aGlzLmZvckVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLmZvckVhY2hEZXNjZW5kYW50KGFjdGlvbiwgLyppbmNsdWRlU2VsZj0qLyB0cnVlLCBjaGlsZHJlbkZpcnN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbmNsdWRlU2VsZiAmJiBjaGlsZHJlbkZpcnN0KVxuICAgICAgICAgICAgYWN0aW9uKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYWN0aW9uIG9uIGVhY2ggYW5jZXN0b3Igbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIVRyZWUuPFQ+KX0gYWN0aW9uIEFjdGlvbiB0byBiZSBjYWxsZWQgb24gZWFjaCBwYXJlbnQ7IHJldHVyblxuICAgICAqICAgdHJ1ZSB0byBhYm9ydC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbmNsdWRlU2VsZiBXaGV0aGVyIHRvIGNhbGwgYWN0aW9uIG9uIHRoaXMgbm9kZSBhcyB3ZWxsLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFjdGlvbiBjYWxsYmFjayByZXR1cm5lZCB0cnVlLlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLmZvckVhY2hBbmNlc3RvciA9IGZ1bmN0aW9uIChhY3Rpb24sIGluY2x1ZGVTZWxmKSB7XG4gICAgICAgIHZhciBub2RlID0gaW5jbHVkZVNlbGYgPyB0aGlzIDogdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERvZXMgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb2YgdGhpcyBub2RlJ3MgZGVzY2VuZGFudHMuICBXaGVuIGEgZGVzY2VuZGFudCB3aXRoIGEgdmFsdWVcbiAgICAgKiBpcyBmb3VuZCwgYWN0aW9uIGlzIGNhbGxlZCBvbiBpdCBhbmQgdHJhdmVyc2FsIGRvZXMgbm90IGNvbnRpbnVlIGluc2lkZSB0aGUgbm9kZS5cbiAgICAgKiBBY3Rpb24gaXMgKm5vdCogY2FsbGVkIG9uIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIVRyZWUuPFQ+KX0gYWN0aW9uIEFjdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQuXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuZm9yRWFjaEltbWVkaWF0ZURlc2NlbmRhbnRXaXRoVmFsdWUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLmdldFZhbHVlKCkgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgYWN0aW9uKGNoaWxkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGlsZC5mb3JFYWNoSW1tZWRpYXRlRGVzY2VuZGFudFdpdGhWYWx1ZShhY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFQYXRofSBUaGUgcGF0aCBvZiB0aGlzIHRyZWUgbm9kZSwgYXMgYSBQYXRoLlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aF8xLlBhdGgodGhpcy5wYXJlbnRfID09PSBudWxsXG4gICAgICAgICAgICA/IHRoaXMubmFtZV9cbiAgICAgICAgICAgIDogdGhpcy5wYXJlbnRfLnBhdGgoKSArICcvJyArIHRoaXMubmFtZV8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdHJlZSBub2RlLlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P1RyZWV9IFRoZSBwYXJlbnQgdHJlZSBub2RlLCBvciBudWxsIGlmIHRoaXMgaXMgdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBvciByZW1vdmVzIHRoaXMgY2hpbGQgZnJvbSBpdHMgcGFyZW50IGJhc2VkIG9uIHdoZXRoZXIgaXQncyBlbXB0eSBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLnVwZGF0ZVBhcmVudHNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRfICE9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5wYXJlbnRfLnVwZGF0ZUNoaWxkXyh0aGlzLm5hbWVfLCB0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgb3IgcmVtb3ZlcyB0aGUgcGFzc2VkIGNoaWxkIHRvIHRoaXMgdHJlZSBub2RlLCBkZXBlbmRpbmcgb24gd2hldGhlciBpdCdzIGVtcHR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkTmFtZSBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7IVRyZWUuPFQ+fSBjaGlsZCBUaGUgY2hpbGQgdG8gdXBkYXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUudXBkYXRlQ2hpbGRfID0gZnVuY3Rpb24gKGNoaWxkTmFtZSwgY2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkRW1wdHkgPSBjaGlsZC5pc0VtcHR5KCk7XG4gICAgICAgIHZhciBjaGlsZEV4aXN0cyA9IHV0aWxfMi5jb250YWlucyh0aGlzLm5vZGVfLmNoaWxkcmVuLCBjaGlsZE5hbWUpO1xuICAgICAgICBpZiAoY2hpbGRFbXB0eSAmJiBjaGlsZEV4aXN0cykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZV8uY2hpbGRyZW5bY2hpbGROYW1lXTtcbiAgICAgICAgICAgIHRoaXMubm9kZV8uY2hpbGRDb3VudC0tO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRzXygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaGlsZEVtcHR5ICYmICFjaGlsZEV4aXN0cykge1xuICAgICAgICAgICAgdGhpcy5ub2RlXy5jaGlsZHJlbltjaGlsZE5hbWVdID0gY2hpbGQubm9kZV87XG4gICAgICAgICAgICB0aGlzLm5vZGVfLmNoaWxkQ291bnQrKztcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFyZW50c18oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRyZWU7XG59KCkpO1xuZXhwb3J0cy5UcmVlID0gVHJlZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJlZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4vRXZlbnRFbWl0dGVyXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogQGV4dGVuZHMge0V2ZW50RW1pdHRlcn1cbiAqL1xudmFyIFZpc2liaWxpdHlNb25pdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaXNpYmlsaXR5TW9uaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaXNpYmlsaXR5TW9uaXRvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgWyd2aXNpYmxlJ10pIHx8IHRoaXM7XG4gICAgICAgIHZhciBoaWRkZW47XG4gICAgICAgIHZhciB2aXNpYmlsaXR5Q2hhbmdlO1xuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50WydoaWRkZW4nXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBPcGVyYSAxMi4xMCBhbmQgRmlyZWZveCAxOCBhbmQgbGF0ZXIgc3VwcG9ydFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnRbJ21vekhpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnbW96dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ21vekhpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnRbJ21zSGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICdtc3Zpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdtc0hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnRbJ3dlYmtpdEhpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ3dlYmtpdEhpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGx5LCB3ZSBhbHdheXMgYXNzdW1lIHdlIGFyZSB2aXNpYmxlLiBUaGlzIGVuc3VyZXMgdGhhdCBpbiBicm93c2Vyc1xuICAgICAgICAvLyB3aXRob3V0IHBhZ2UgdmlzaWJpbGl0eSBzdXBwb3J0IG9yIGluIGNhc2VzIHdoZXJlIHdlIGFyZSBuZXZlciB2aXNpYmxlXG4gICAgICAgIC8vIChlLmcuIGNocm9tZSBleHRlbnNpb24pLCB3ZSBhY3QgYXMgaWYgd2UgYXJlIHZpc2libGUsIGkuZS4gZG9uJ3QgZGVsYXlcbiAgICAgICAgLy8gcmVjb25uZWN0c1xuICAgICAgICBfdGhpcy52aXNpYmxlXyA9IHRydWU7XG4gICAgICAgIGlmICh2aXNpYmlsaXR5Q2hhbmdlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHZpc2liaWxpdHlDaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZSA9ICFkb2N1bWVudFtoaWRkZW5dO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlICE9PSBfdGhpcy52aXNpYmxlXykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aXNpYmxlXyA9IHZpc2libGU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXIoJ3Zpc2libGUnLCB2aXNpYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWaXNpYmlsaXR5TW9uaXRvci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWaXNpYmlsaXR5TW9uaXRvcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48Ym9vbGVhbj59XG4gICAgICovXG4gICAgVmlzaWJpbGl0eU1vbml0b3IucHJvdG90eXBlLmdldEluaXRpYWxFdmVudCA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydChldmVudFR5cGUgPT09ICd2aXNpYmxlJywgJ1Vua25vd24gZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZSk7XG4gICAgICAgIHJldHVybiBbdGhpcy52aXNpYmxlX107XG4gICAgfTtcbiAgICByZXR1cm4gVmlzaWJpbGl0eU1vbml0b3I7XG59KEV2ZW50RW1pdHRlcl8xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5WaXNpYmlsaXR5TW9uaXRvciA9IFZpc2liaWxpdHlNb25pdG9yO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaXNpYmlsaXR5TW9uaXRvci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcbnZhciBSZXBvSW5mb18xID0gcmVxdWlyZShcIi4uLy4uL1JlcG9JbmZvXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhTdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoU3RyaW5nKSB7XG4gICAgdmFyIHBhdGhTdHJpbmdEZWNvZGVkID0gJyc7XG4gICAgdmFyIHBpZWNlcyA9IHBhdGhTdHJpbmcuc3BsaXQoJy8nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGllY2VzW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwaWVjZSA9IHBpZWNlc1tpXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGllY2UgPSBkZWNvZGVVUklDb21wb25lbnQocGllY2UucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgcGF0aFN0cmluZ0RlY29kZWQgKz0gJy8nICsgcGllY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGhTdHJpbmdEZWNvZGVkO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBkYXRhVVJMXG4gKiBAcmV0dXJuIHt7cmVwb0luZm86ICFSZXBvSW5mbywgcGF0aDogIVBhdGh9fVxuICovXG5leHBvcnRzLnBhcnNlUmVwb0luZm8gPSBmdW5jdGlvbiAoZGF0YVVSTCkge1xuICAgIHZhciBwYXJzZWRVcmwgPSBleHBvcnRzLnBhcnNlVVJMKGRhdGFVUkwpLCBuYW1lc3BhY2UgPSBwYXJzZWRVcmwuc3ViZG9tYWluO1xuICAgIGlmIChwYXJzZWRVcmwuZG9tYWluID09PSAnZmlyZWJhc2UnKSB7XG4gICAgICAgIHV0aWxfMS5mYXRhbChwYXJzZWRVcmwuaG9zdCArXG4gICAgICAgICAgICAnIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSB1c2UgPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tIGluc3RlYWQnKTtcbiAgICB9XG4gICAgLy8gQ2F0Y2ggY29tbW9uIGVycm9yIG9mIHVuaW5pdGlhbGl6ZWQgbmFtZXNwYWNlIHZhbHVlLlxuICAgIGlmICghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB1dGlsXzEuZmF0YWwoJ0Nhbm5vdCBwYXJzZSBGaXJlYmFzZSB1cmwuIFBsZWFzZSB1c2UgaHR0cHM6Ly88WU9VUiBGSVJFQkFTRT4uZmlyZWJhc2Vpby5jb20nKTtcbiAgICB9XG4gICAgaWYgKCFwYXJzZWRVcmwuc2VjdXJlKSB7XG4gICAgICAgIHV0aWxfMS53YXJuSWZQYWdlSXNTZWN1cmUoKTtcbiAgICB9XG4gICAgdmFyIHdlYlNvY2tldE9ubHkgPSBwYXJzZWRVcmwuc2NoZW1lID09PSAnd3MnIHx8IHBhcnNlZFVybC5zY2hlbWUgPT09ICd3c3MnO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcG9JbmZvOiBuZXcgUmVwb0luZm9fMS5SZXBvSW5mbyhwYXJzZWRVcmwuaG9zdCwgcGFyc2VkVXJsLnNlY3VyZSwgbmFtZXNwYWNlLCB3ZWJTb2NrZXRPbmx5KSxcbiAgICAgICAgcGF0aDogbmV3IFBhdGhfMS5QYXRoKHBhcnNlZFVybC5wYXRoU3RyaW5nKVxuICAgIH07XG59O1xuLyoqXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBkYXRhVVJMXG4gKiBAcmV0dXJuIHt7aG9zdDogc3RyaW5nLCBwb3J0OiBudW1iZXIsIGRvbWFpbjogc3RyaW5nLCBzdWJkb21haW46IHN0cmluZywgc2VjdXJlOiBib29sZWFuLCBzY2hlbWU6IHN0cmluZywgcGF0aFN0cmluZzogc3RyaW5nfX1cbiAqL1xuZXhwb3J0cy5wYXJzZVVSTCA9IGZ1bmN0aW9uIChkYXRhVVJMKSB7XG4gICAgLy8gRGVmYXVsdCB0byBlbXB0eSBzdHJpbmdzIGluIHRoZSBldmVudCBvZiBhIG1hbGZvcm1lZCBzdHJpbmcuXG4gICAgdmFyIGhvc3QgPSAnJywgZG9tYWluID0gJycsIHN1YmRvbWFpbiA9ICcnLCBwYXRoU3RyaW5nID0gJyc7XG4gICAgLy8gQWx3YXlzIGRlZmF1bHQgdG8gU1NMLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAgICB2YXIgc2VjdXJlID0gdHJ1ZSwgc2NoZW1lID0gJ2h0dHBzJywgcG9ydCA9IDQ0MztcbiAgICAvLyBEb24ndCBkbyBhbnkgdmFsaWRhdGlvbiBoZXJlLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSByZXN1bHQgb2YgcGFyc2luZy5cbiAgICBpZiAodHlwZW9mIGRhdGFVUkwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFBhcnNlIHNjaGVtZS5cbiAgICAgICAgdmFyIGNvbG9uSW5kID0gZGF0YVVSTC5pbmRleE9mKCcvLycpO1xuICAgICAgICBpZiAoY29sb25JbmQgPj0gMCkge1xuICAgICAgICAgICAgc2NoZW1lID0gZGF0YVVSTC5zdWJzdHJpbmcoMCwgY29sb25JbmQgLSAxKTtcbiAgICAgICAgICAgIGRhdGFVUkwgPSBkYXRhVVJMLnN1YnN0cmluZyhjb2xvbkluZCArIDIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIGhvc3QgYW5kIHBhdGguXG4gICAgICAgIHZhciBzbGFzaEluZCA9IGRhdGFVUkwuaW5kZXhPZignLycpO1xuICAgICAgICBpZiAoc2xhc2hJbmQgPT09IC0xKSB7XG4gICAgICAgICAgICBzbGFzaEluZCA9IGRhdGFVUkwubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGhvc3QgPSBkYXRhVVJMLnN1YnN0cmluZygwLCBzbGFzaEluZCk7XG4gICAgICAgIHBhdGhTdHJpbmcgPSBkZWNvZGVQYXRoKGRhdGFVUkwuc3Vic3RyaW5nKHNsYXNoSW5kKSk7XG4gICAgICAgIHZhciBwYXJ0cyA9IGhvc3Quc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIG5hbWVzcGFjZXMgdG8gbG93ZXJjYXNlIHRvIHNoYXJlIHN0b3JhZ2UgLyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgZG9tYWluID0gcGFydHNbMV07XG4gICAgICAgICAgICBzdWJkb21haW4gPSBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgZG9tYWluID0gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnQsIHVzZSBzY2hlbWUgZm9yIGRldGVybWluaW5nIGlmIGl0J3Mgc2VjdXJlLlxuICAgICAgICBjb2xvbkluZCA9IGhvc3QuaW5kZXhPZignOicpO1xuICAgICAgICBpZiAoY29sb25JbmQgPj0gMCkge1xuICAgICAgICAgICAgc2VjdXJlID0gc2NoZW1lID09PSAnaHR0cHMnIHx8IHNjaGVtZSA9PT0gJ3dzcyc7XG4gICAgICAgICAgICBwb3J0ID0gcGFyc2VJbnQoaG9zdC5zdWJzdHJpbmcoY29sb25JbmQgKyAxKSwgMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICAgIHBvcnQ6IHBvcnQsXG4gICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICBzdWJkb21haW46IHN1YmRvbWFpbixcbiAgICAgICAgc2VjdXJlOiBzZWN1cmUsXG4gICAgICAgIHNjaGVtZTogc2NoZW1lLFxuICAgICAgICBwYXRoU3RyaW5nOiBwYXRoU3RyaW5nXG4gICAgfTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMyA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzQgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF81ID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfNiA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBzdG9yYWdlXzEgPSByZXF1aXJlKFwiLi4vc3RvcmFnZS9zdG9yYWdlXCIpO1xudmFyIHV0aWxfNyA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogUmV0dXJucyBhIGxvY2FsbHktdW5pcXVlIElEIChnZW5lcmF0ZWQgYnkganVzdCBpbmNyZW1lbnRpbmcgdXAgZnJvbSAwIGVhY2ggdGltZSBpdHMgY2FsbGVkKS5cbiAqIEB0eXBlIHtmdW5jdGlvbigpOiBudW1iZXJ9IEdlbmVyYXRlZCBJRC5cbiAqL1xuZXhwb3J0cy5MVUlER2VuZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWQgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZCsrO1xuICAgIH07XG59KSgpO1xuLyoqXG4gKiBTaGExIGhhc2ggb2YgdGhlIGlucHV0IHN0cmluZ1xuICogQHBhcmFtIHshc3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBoYXNoXG4gKiBAcmV0dXJuIHshc3RyaW5nfSBUaGUgcmVzdWx0aW5nIGhhc2hcbiAqL1xuZXhwb3J0cy5zaGExID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciB1dGY4Qnl0ZXMgPSB1dGlsXzUuc3RyaW5nVG9CeXRlQXJyYXkoc3RyKTtcbiAgICB2YXIgc2hhMSA9IG5ldyB1dGlsXzQuU2hhMSgpO1xuICAgIHNoYTEudXBkYXRlKHV0ZjhCeXRlcyk7XG4gICAgdmFyIHNoYTFCeXRlcyA9IHNoYTEuZGlnZXN0KCk7XG4gICAgcmV0dXJuIHV0aWxfMy5iYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHNoYTFCeXRlcyk7XG59O1xuLyoqXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYnVpbGRMb2dNZXNzYWdlXyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFyX2FyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXJfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFyX2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFyX2FyZ3NbaV0pIHx8XG4gICAgICAgICAgICAodmFyX2FyZ3NbaV0gJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFyX2FyZ3NbaV0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhcl9hcmdzW2ldLmxlbmd0aCA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGJ1aWxkTG9nTWVzc2FnZV8uYXBwbHkobnVsbCwgdmFyX2FyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YXJfYXJnc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gdXRpbF82LnN0cmluZ2lmeSh2YXJfYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IHZhcl9hcmdzW2ldO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgKz0gJyAnO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn07XG4vKipcbiAqIFVzZSB0aGlzIGZvciBhbGwgZGVidWcgbWVzc2FnZXMgaW4gRmlyZWJhc2UuXG4gKiBAdHlwZSB7P2Z1bmN0aW9uKHN0cmluZyl9XG4gKi9cbmV4cG9ydHMubG9nZ2VyID0gbnVsbDtcbi8qKlxuICogRmxhZyB0byBjaGVjayBmb3IgbG9nIGF2YWlsYWJpbGl0eSBvbiBmaXJzdCBsb2cgbWVzc2FnZVxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZmlyc3RMb2dfID0gdHJ1ZTtcbi8qKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIEZpcmViYXNlLmVuYWJsZUxvZ2dpbmcgKGRlZmluZWQgaGVyZSB0byBicmVhayBkZXBlbmRlbmNpZXMpXG4gKiBAcGFyYW0ge2Jvb2xlYW58P2Z1bmN0aW9uKHN0cmluZyl9IGxvZ2dlcl8gQSBmbGFnIHRvIHR1cm4gb24gbG9nZ2luZywgb3IgYSBjdXN0b20gbG9nZ2VyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBwZXJzaXN0ZW50IFdoZXRoZXIgb3Igbm90IHRvIHBlcnNpc3QgbG9nZ2luZyBzZXR0aW5ncyBhY3Jvc3MgcmVmcmVzaGVzXG4gKi9cbmV4cG9ydHMuZW5hYmxlTG9nZ2luZyA9IGZ1bmN0aW9uIChsb2dnZXJfLCBwZXJzaXN0ZW50KSB7XG4gICAgdXRpbF8xLmFzc2VydCghcGVyc2lzdGVudCB8fCAobG9nZ2VyXyA9PT0gdHJ1ZSB8fCBsb2dnZXJfID09PSBmYWxzZSksIFwiQ2FuJ3QgdHVybiBvbiBjdXN0b20gbG9nZ2VycyBwZXJzaXN0ZW50bHkuXCIpO1xuICAgIGlmIChsb2dnZXJfID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmxvZ2dlciA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uc29sZS5sb2cgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgZG9lcyB0aGlzLlxuICAgICAgICAgICAgICAgIGV4cG9ydHMubG9nZ2VyID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGVyc2lzdGVudClcbiAgICAgICAgICAgIHN0b3JhZ2VfMS5TZXNzaW9uU3RvcmFnZS5zZXQoJ2xvZ2dpbmdfZW5hYmxlZCcsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbG9nZ2VyXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBleHBvcnRzLmxvZ2dlciA9IGxvZ2dlcl87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBleHBvcnRzLmxvZ2dlciA9IG51bGw7XG4gICAgICAgIHN0b3JhZ2VfMS5TZXNzaW9uU3RvcmFnZS5yZW1vdmUoJ2xvZ2dpbmdfZW5hYmxlZCcpO1xuICAgIH1cbn07XG4vKipcbiAqXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8QXJndW1lbnRzKX0gdmFyX2FyZ3NcbiAqL1xuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhcl9hcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKGZpcnN0TG9nXyA9PT0gdHJ1ZSkge1xuICAgICAgICBmaXJzdExvZ18gPSBmYWxzZTtcbiAgICAgICAgaWYgKGV4cG9ydHMubG9nZ2VyID09PSBudWxsICYmIHN0b3JhZ2VfMS5TZXNzaW9uU3RvcmFnZS5nZXQoJ2xvZ2dpbmdfZW5hYmxlZCcpID09PSB0cnVlKVxuICAgICAgICAgICAgZXhwb3J0cy5lbmFibGVMb2dnaW5nKHRydWUpO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5sb2dnZXIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBidWlsZExvZ01lc3NhZ2VfLmFwcGx5KG51bGwsIHZhcl9hcmdzKTtcbiAgICAgICAgZXhwb3J0cy5sb2dnZXIobWVzc2FnZSk7XG4gICAgfVxufTtcbi8qKlxuICogQHBhcmFtIHshc3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLlsqXSl9XG4gKi9cbmV4cG9ydHMubG9nV3JhcHBlciA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFyX2FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhcl9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5sb2cuYXBwbHkodm9pZCAwLCBbcHJlZml4XS5jb25jYXQodmFyX2FyZ3MpKTtcbiAgICB9O1xufTtcbi8qKlxuICogQHBhcmFtIHsuLi5zdHJpbmd9IHZhcl9hcmdzXG4gKi9cbmV4cG9ydHMuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhcl9hcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdGSVJFQkFTRSBJTlRFUk5BTCBFUlJPUjogJyArIGJ1aWxkTG9nTWVzc2FnZV8uYXBwbHkodm9pZCAwLCB2YXJfYXJncyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5lcnJvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSB2YXJfYXJnc1xuICovXG5leHBvcnRzLmZhdGFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhcl9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBtZXNzYWdlID0gYnVpbGRMb2dNZXNzYWdlXy5hcHBseSh2b2lkIDAsIHZhcl9hcmdzKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZJUkVCQVNFIEZBVEFMIEVSUk9SOiAnICsgbWVzc2FnZSk7XG59O1xuLyoqXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzXG4gKi9cbmV4cG9ydHMud2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFyX2FyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXJfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ0ZJUkVCQVNFIFdBUk5JTkc6ICcgKyBidWlsZExvZ01lc3NhZ2VfLmFwcGx5KHZvaWQgMCwgdmFyX2FyZ3MpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUud2FybiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogTG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbnRhaW5pbmcgcGFnZSB1c2VzIGh0dHBzLiBDYWxsZWQgd2hlbiBhIGNhbGwgdG8gbmV3IEZpcmViYXNlXG4gKiBkb2VzIG5vdCB1c2UgaHR0cHMuXG4gKi9cbmV4cG9ydHMud2FybklmUGFnZUlzU2VjdXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEJlIHZlcnkgY2FyZWZ1bCBhY2Nlc3NpbmcgYnJvd3NlciBnbG9iYWxzLiBXaG8ga25vd3Mgd2hhdCBtYXkgb3IgbWF5IG5vdCBleGlzdC5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LmxvY2F0aW9uICYmXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cHM6JykgIT09IC0xKSB7XG4gICAgICAgIGV4cG9ydHMud2FybignSW5zZWN1cmUgRmlyZWJhc2UgYWNjZXNzIGZyb20gYSBzZWN1cmUgcGFnZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVzZSBodHRwcyBpbiBjYWxscyB0byBuZXcgRmlyZWJhc2UoKS4nKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAcGFyYW0geyFTdHJpbmd9IG1ldGhvZE5hbWVcbiAqL1xuZXhwb3J0cy53YXJuQWJvdXRVbnN1cHBvcnRlZE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgZXhwb3J0cy53YXJuKG1ldGhvZE5hbWUgK1xuICAgICAgICAnIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSBjaGFuZ2Ugc29vbi4gICcgK1xuICAgICAgICAnUGxlYXNlIGRvIG5vdCB1c2UuJyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZGF0YSBpcyBOYU4sIG9yICsvLSBJbmZpbml0eS5cbiAqIEBwYXJhbSB7Kn0gZGF0YVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0ludmFsaWRKU09OTnVtYmVyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAoZGF0YSAhPSBkYXRhIHx8IC8vIE5hTlxuICAgICAgICAgICAgZGF0YSA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICAgICAgICAgIGRhdGEgPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuXG4gKi9cbmV4cG9ydHMuZXhlY3V0ZVdoZW5ET01SZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICh1dGlsXzcuaXNOb2RlU2RrKCkgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBmbigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTW9kZWxlZCBhZnRlciBqUXVlcnkuIFRyeSBET01Db250ZW50TG9hZGVkIGFuZCBvbnJlYWR5c3RhdGVjaGFuZ2UgKHdoaWNoXG4gICAgICAgIC8vIGZpcmUgYmVmb3JlIG9ubG9hZCksIGJ1dCBmYWxsIGJhY2sgdG8gb25sb2FkLlxuICAgICAgICB2YXIgY2FsbGVkXzEgPSBmYWxzZTtcbiAgICAgICAgdmFyIHdyYXBwZWRGbl8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh3cmFwcGVkRm5fMSwgTWF0aC5mbG9vcigxMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FsbGVkXzEpIHtcbiAgICAgICAgICAgICAgICBjYWxsZWRfMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkRm5fMSwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gb25sb2FkLlxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB3cmFwcGVkRm5fMSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBJRS5cbiAgICAgICAgICAgIGRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRGbl8xKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIG9ubG9hZC5cbiAgICAgICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudCgnb25sb2FkJywgd3JhcHBlZEZuXzEpO1xuICAgICAgICAgICAgLy8galF1ZXJ5IGhhcyBhbiBleHRyYSBoYWNrIGZvciBJRSB0aGF0IHdlIGNvdWxkIGVtcGxveSAoYmFzZWQgb25cbiAgICAgICAgICAgIC8vIGh0dHA6Ly9qYXZhc2NyaXB0Lm53Ym94LmNvbS9JRUNvbnRlbnRMb2FkZWQvKSBCdXQgaXQgbG9va3MgcmVhbGx5IG9sZC5cbiAgICAgICAgICAgIC8vIEknbSBob3Bpbmcgd2UgZG9uJ3QgbmVlZCBpdC5cbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIE1pbmltdW0ga2V5IG5hbWUuIEludmFsaWQgZm9yIGFjdHVhbCBkYXRhLCB1c2VkIGFzIGEgbWFya2VyIHRvIHNvcnQgYmVmb3JlIGFueSB2YWxpZCBuYW1lc1xuICogQHR5cGUgeyFzdHJpbmd9XG4gKi9cbmV4cG9ydHMuTUlOX05BTUUgPSAnW01JTl9OQU1FXSc7XG4vKipcbiAqIE1heGltdW0ga2V5IG5hbWUuIEludmFsaWQgZm9yIGFjdHVhbCBkYXRhLCB1c2VkIGFzIGEgbWFya2VyIHRvIHNvcnQgYWJvdmUgYW55IHZhbGlkIG5hbWVzXG4gKiBAdHlwZSB7IXN0cmluZ31cbiAqL1xuZXhwb3J0cy5NQVhfTkFNRSA9ICdbTUFYX05BTUVdJztcbi8qKlxuICogQ29tcGFyZXMgdmFsaWQgRmlyZWJhc2Uga2V5IG5hbWVzLCBwbHVzIG1pbiBhbmQgbWF4IG5hbWVcbiAqIEBwYXJhbSB7IXN0cmluZ30gYVxuICogQHBhcmFtIHshc3RyaW5nfSBiXG4gKiBAcmV0dXJuIHshbnVtYmVyfVxuICovXG5leHBvcnRzLm5hbWVDb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA9PT0gZXhwb3J0cy5NSU5fTkFNRSB8fCBiID09PSBleHBvcnRzLk1BWF9OQU1FKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYiA9PT0gZXhwb3J0cy5NSU5fTkFNRSB8fCBhID09PSBleHBvcnRzLk1BWF9OQU1FKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFBc0ludCA9IGV4cG9ydHMudHJ5UGFyc2VJbnQoYSksIGJBc0ludCA9IGV4cG9ydHMudHJ5UGFyc2VJbnQoYik7XG4gICAgICAgIGlmIChhQXNJbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChiQXNJbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYUFzSW50IC0gYkFzSW50ID09IDAgPyBhLmxlbmd0aCAtIGIubGVuZ3RoIDogYUFzSW50IC0gYkFzSW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJBc0ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IGFcbiAqIEBwYXJhbSB7IXN0cmluZ30gYlxuICogQHJldHVybiB7IW51bWJlcn0gY29tcGFyaXNvbiByZXN1bHQuXG4gKi9cbmV4cG9ydHMuc3RyaW5nQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydHMucmVxdWlyZUtleSA9IGZ1bmN0aW9uIChrZXksIG9iaikge1xuICAgIGlmIChvYmogJiYga2V5IGluIG9iaikge1xuICAgICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQga2V5ICgnICsga2V5ICsgJykgaW4gb2JqZWN0OiAnICsgdXRpbF82LnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnRzLk9iamVjdFRvVW5pcXVlS2V5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpXG4gICAgICAgIHJldHVybiB1dGlsXzYuc3RyaW5naWZ5KG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICBrZXlzLnB1c2goayk7XG4gICAgfVxuICAgIC8vIEV4cG9ydCBhcyBqc29uLCBidXQgd2l0aCB0aGUga2V5cyBzb3J0ZWQuXG4gICAga2V5cy5zb3J0KCk7XG4gICAgdmFyIGtleSA9ICd7JztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICBrZXkgKz0gJywnO1xuICAgICAgICBrZXkgKz0gdXRpbF82LnN0cmluZ2lmeShrZXlzW2ldKTtcbiAgICAgICAga2V5ICs9ICc6JztcbiAgICAgICAga2V5ICs9IGV4cG9ydHMuT2JqZWN0VG9VbmlxdWVLZXkob2JqW2tleXNbaV1dKTtcbiAgICB9XG4gICAga2V5ICs9ICd9JztcbiAgICByZXR1cm4ga2V5O1xufTtcbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIGludG8gYSBudW1iZXIgb2Ygc21hbGxlciBzZWdtZW50cyBvZiBtYXhpbXVtIHNpemVcbiAqIEBwYXJhbSB7IXN0cmluZ30gc3RyIFRoZSBzdHJpbmdcbiAqIEBwYXJhbSB7IW51bWJlcn0gc2Vnc2l6ZSBUaGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcnMgaW4gdGhlIHN0cmluZy5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBUaGUgc3RyaW5nLCBzcGxpdCBpbnRvIGFwcHJvcHJpYXRlbHktc2l6ZWQgY2h1bmtzXG4gKi9cbmV4cG9ydHMuc3BsaXRTdHJpbmdCeVNpemUgPSBmdW5jdGlvbiAoc3RyLCBzZWdzaXplKSB7XG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKGxlbiA8PSBzZWdzaXplKSB7XG4gICAgICAgIHJldHVybiBbc3RyXTtcbiAgICB9XG4gICAgdmFyIGRhdGFTZWdzID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBsZW47IGMgKz0gc2Vnc2l6ZSkge1xuICAgICAgICBpZiAoYyArIHNlZ3NpemUgPiBsZW4pIHtcbiAgICAgICAgICAgIGRhdGFTZWdzLnB1c2goc3RyLnN1YnN0cmluZyhjLCBsZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFTZWdzLnB1c2goc3RyLnN1YnN0cmluZyhjLCBjICsgc2Vnc2l6ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhU2Vncztcbn07XG4vKipcbiAqIEFwcGx5IGEgZnVuY3Rpb24gdG8gZWFjaCAoa2V5LCB2YWx1ZSkgcGFpciBpbiBhbiBvYmplY3Qgb3JcbiAqIGFwcGx5IGEgZnVuY3Rpb24gdG8gZWFjaCAoaW5kZXgsIHZhbHVlKSBwYWlyIGluIGFuIGFycmF5XG4gKiBAcGFyYW0geyEoT2JqZWN0fEFycmF5KX0gb2JqIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKD8sID8pfSBmbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHlcbiAqL1xuZXhwb3J0cy5lYWNoID0gZnVuY3Rpb24gKG9iaiwgZm4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBmbihpLCBvYmpbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogaW4gdGhlIGNvbnZlcnNpb24gb2YgY29kZSB3ZSByZW1vdmVkIHRoZSBnb29nLm9iamVjdC5mb3JFYWNoXG4gICAgICAgICAqIGZ1bmN0aW9uIHdoaWNoIGRpZCBhIHZhbHVlLGtleSBjYWxsYmFjay4gV2Ugc3RhbmRhcmRpemVkIG9uXG4gICAgICAgICAqIGEgc2luZ2xlIGltcGwgdGhhdCBkb2VzIGEga2V5LCB2YWx1ZSBjYWxsYmFjay4gU28gd2UgaW52ZXJ0XG4gICAgICAgICAqIHRvIG5vdCBoYXZlIHRvIHRvdWNoIHRoZSBgZWFjaGAgY29kZSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHV0aWxfMi5mb3JFYWNoKG9iaiwgZnVuY3Rpb24gKGtleSwgdmFsKSB7IHJldHVybiBmbih2YWwsIGtleSk7IH0pO1xuICAgIH1cbn07XG4vKipcbiAqIExpa2UgZ29vZy5iaW5kLCBidXQgZG9lc24ndCBib3RoZXIgdG8gY3JlYXRlIGEgY2xvc3VyZSBpZiBvcHRfY29udGV4dCBpcyBudWxsL3VuZGVmaW5lZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/T2JqZWN0PX0gY29udGV4dCBPcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigqKX1cbiAqL1xuZXhwb3J0cy5iaW5kQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dCA/IGNhbGxiYWNrLmJpbmQoY29udGV4dCkgOiBjYWxsYmFjaztcbn07XG4vKipcbiAqIEJvcnJvd2VkIGZyb20gaHR0cDovL2hnLnNlY29uZGxpZmUuY29tL2xsc2Qvc3JjL3RpcC9qcy90eXBlZGFycmF5LmpzIChNSVQgTGljZW5zZSlcbiAqIEkgbWFkZSBvbmUgbW9kaWZpY2F0aW9uIGF0IHRoZSBlbmQgYW5kIHJlbW92ZWQgdGhlIE5hTiAvIEluZmluaXR5XG4gKiBoYW5kbGluZyAoc2luY2UgaXQgc2VlbWVkIGJyb2tlbiBbY2F1c2VkIGFuIG92ZXJmbG93XSBhbmQgd2UgZG9uJ3QgbmVlZCBpdCkuICBTZWUgTUpMIGNvbW1lbnRzLlxuICogQHBhcmFtIHshbnVtYmVyfSB2IEEgZG91YmxlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuZG91YmxlVG9JRUVFNzU0U3RyaW5nID0gZnVuY3Rpb24gKHYpIHtcbiAgICB1dGlsXzEuYXNzZXJ0KCFleHBvcnRzLmlzSW52YWxpZEpTT05OdW1iZXIodiksICdJbnZhbGlkIEpTT04gbnVtYmVyJyk7IC8vIE1KTFxuICAgIHZhciBlYml0cyA9IDExLCBmYml0cyA9IDUyO1xuICAgIHZhciBiaWFzID0gKDEgPDwgKGViaXRzIC0gMSkpIC0gMSwgcywgZSwgZiwgbG4sIGksIGJpdHMsIHN0cjtcbiAgICAvLyBDb21wdXRlIHNpZ24sIGV4cG9uZW50LCBmcmFjdGlvblxuICAgIC8vIFNraXAgTmFOIC8gSW5maW5pdHkgaGFuZGxpbmcgLS1NSkwuXG4gICAgaWYgKHYgPT09IDApIHtcbiAgICAgICAgZSA9IDA7XG4gICAgICAgIGYgPSAwO1xuICAgICAgICBzID0gMSAvIHYgPT09IC1JbmZpbml0eSA/IDEgOiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcyA9IHYgPCAwO1xuICAgICAgICB2ID0gTWF0aC5hYnModik7XG4gICAgICAgIGlmICh2ID49IE1hdGgucG93KDIsIDEgLSBiaWFzKSkge1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplZFxuICAgICAgICAgICAgbG4gPSBNYXRoLm1pbihNYXRoLmZsb29yKE1hdGgubG9nKHYpIC8gTWF0aC5MTjIpLCBiaWFzKTtcbiAgICAgICAgICAgIGUgPSBsbiArIGJpYXM7XG4gICAgICAgICAgICBmID0gTWF0aC5yb3VuZCh2ICogTWF0aC5wb3coMiwgZmJpdHMgLSBsbikgLSBNYXRoLnBvdygyLCBmYml0cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVub3JtYWxpemVkXG4gICAgICAgICAgICBlID0gMDtcbiAgICAgICAgICAgIGYgPSBNYXRoLnJvdW5kKHYgLyBNYXRoLnBvdygyLCAxIC0gYmlhcyAtIGZiaXRzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUGFjayBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cbiAgICBiaXRzID0gW107XG4gICAgZm9yIChpID0gZmJpdHM7IGk7IGkgLT0gMSkge1xuICAgICAgICBiaXRzLnB1c2goZiAlIDIgPyAxIDogMCk7XG4gICAgICAgIGYgPSBNYXRoLmZsb29yKGYgLyAyKTtcbiAgICB9XG4gICAgZm9yIChpID0gZWJpdHM7IGk7IGkgLT0gMSkge1xuICAgICAgICBiaXRzLnB1c2goZSAlIDIgPyAxIDogMCk7XG4gICAgICAgIGUgPSBNYXRoLmZsb29yKGUgLyAyKTtcbiAgICB9XG4gICAgYml0cy5wdXNoKHMgPyAxIDogMCk7XG4gICAgYml0cy5yZXZlcnNlKCk7XG4gICAgc3RyID0gYml0cy5qb2luKCcnKTtcbiAgICAvLyBSZXR1cm4gdGhlIGRhdGEgYXMgYSBoZXggc3RyaW5nLiAtLU1KTFxuICAgIHZhciBoZXhCeXRlU3RyaW5nID0gJyc7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpICs9IDgpIHtcbiAgICAgICAgdmFyIGhleEJ5dGUgPSBwYXJzZUludChzdHIuc3Vic3RyKGksIDgpLCAyKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoZXhCeXRlLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIGhleEJ5dGUgPSAnMCcgKyBoZXhCeXRlO1xuICAgICAgICBoZXhCeXRlU3RyaW5nID0gaGV4Qnl0ZVN0cmluZyArIGhleEJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBoZXhCeXRlU3RyaW5nLnRvTG93ZXJDYXNlKCk7XG59O1xuLyoqXG4gKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSdyZSBpbiBhIENocm9tZSBjb250ZW50IHNjcmlwdCAod2hpY2ggZXhlY3V0ZXMgaW4gYW5cbiAqIGlzb2xhdGVkIGVudmlyb25tZW50IHdoZXJlIGxvbmctcG9sbGluZyBkb2Vzbid0IHdvcmspLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0Nocm9tZUV4dGVuc2lvbkNvbnRlbnRTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHdpbmRvd1snY2hyb21lJ10gJiZcbiAgICAgICAgd2luZG93WydjaHJvbWUnXVsnZXh0ZW5zaW9uJ10gJiZcbiAgICAgICAgIS9eY2hyb21lLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKSk7XG59O1xuLyoqXG4gKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSdyZSBpbiBhIFdpbmRvd3MgOCBTdG9yZSBhcHAuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzV2luZG93c1N0b3JlQXBwID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIENoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBjb3VwbGUgV2luUlQgZ2xvYmFsc1xuICAgIHJldHVybiB0eXBlb2YgV2luZG93cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIFdpbmRvd3MuVUkgPT09ICdvYmplY3QnO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBzZXJ2ZXIgZXJyb3IgY29kZSB0byBhIEphdmFzY3JpcHQgRXJyb3JcbiAqIEBwYXJhbSB7IXN0cmluZ30gY29kZVxuICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5lcnJvckZvclNlcnZlckNvZGUgPSBmdW5jdGlvbiAoY29kZSwgcXVlcnkpIHtcbiAgICB2YXIgcmVhc29uID0gJ1Vua25vd24gRXJyb3InO1xuICAgIGlmIChjb2RlID09PSAndG9vX2JpZycpIHtcbiAgICAgICAgcmVhc29uID1cbiAgICAgICAgICAgICdUaGUgZGF0YSByZXF1ZXN0ZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBzaXplICcgK1xuICAgICAgICAgICAgICAgICd0aGF0IGNhbiBiZSBhY2Nlc3NlZCB3aXRoIGEgc2luZ2xlIHJlcXVlc3QuJztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAncGVybWlzc2lvbl9kZW5pZWQnKSB7XG4gICAgICAgIHJlYXNvbiA9IFwiQ2xpZW50IGRvZXNuJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGUgZGVzaXJlZCBkYXRhLlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09ICd1bmF2YWlsYWJsZScpIHtcbiAgICAgICAgcmVhc29uID0gJ1RoZSBzZXJ2aWNlIGlzIHVuYXZhaWxhYmxlJztcbiAgICB9XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGNvZGUgKyAnIGF0ICcgKyBxdWVyeS5wYXRoLnRvU3RyaW5nKCkgKyAnOiAnICsgcmVhc29uKTtcbiAgICBlcnJvci5jb2RlID0gY29kZS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG4vKipcbiAqIFVzZWQgdG8gdGVzdCBmb3IgaW50ZWdlci1sb29raW5nIHN0cmluZ3NcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLklOVEVHRVJfUkVHRVhQXyA9IG5ldyBSZWdFeHAoJ14tP1xcXFxkezEsMTB9JCcpO1xuLyoqXG4gKiBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIGEgMzItYml0IGludGVnZXIsIHJldHVybiBpdC4gIEVsc2UgcmV0dXJuIG51bGwuXG4gKiBAcGFyYW0geyFzdHJpbmd9IHN0clxuICogQHJldHVybiB7P251bWJlcn1cbiAqL1xuZXhwb3J0cy50cnlQYXJzZUludCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoZXhwb3J0cy5JTlRFR0VSX1JFR0VYUF8udGVzdChzdHIpKSB7XG4gICAgICAgIHZhciBpbnRWYWwgPSBOdW1iZXIoc3RyKTtcbiAgICAgICAgaWYgKGludFZhbCA+PSAtMjE0NzQ4MzY0OCAmJiBpbnRWYWwgPD0gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICAgcmV0dXJuIGludFZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIEhlbHBlciB0byBydW4gc29tZSBjb2RlIGJ1dCBjYXRjaCBhbnkgZXhjZXB0aW9ucyBhbmQgcmUtdGhyb3cgdGhlbSBsYXRlci5cbiAqIFVzZWZ1bCBmb3IgcHJldmVudGluZyB1c2VyIGNhbGxiYWNrcyBmcm9tIGJyZWFraW5nIGludGVybmFsIGNvZGUuXG4gKlxuICogUmUtdGhyb3dpbmcgdGhlIGV4Y2VwdGlvbiBmcm9tIGEgc2V0VGltZW91dCBpcyBhIGxpdHRsZSBldmlsLCBidXQgaXQncyB2ZXJ5XG4gKiBjb252ZW5pZW50ICh3ZSBkb24ndCBoYXZlIHRvIHRyeSB0byBmaWd1cmUgb3V0IHdoZW4gaXMgYSBzYWZlIHBvaW50IHRvXG4gKiByZS10aHJvdyBpdCksIGFuZCB0aGUgYmVoYXZpb3Igc2VlbXMgcmVhc29uYWJsZTpcbiAqXG4gKiAqIElmIHlvdSBhcmVuJ3QgcGF1c2luZyBvbiBleGNlcHRpb25zLCB5b3UgZ2V0IGFuIGVycm9yIGluIHRoZSBjb25zb2xlIHdpdGhcbiAqICAgdGhlIGNvcnJlY3Qgc3RhY2sgdHJhY2UuXG4gKiAqIElmIHlvdSdyZSBwYXVzaW5nIG9uIGFsbCBleGNlcHRpb25zLCB0aGUgZGVidWdnZXIgd2lsbCBwYXVzZSBvbiB5b3VyXG4gKiAgIGV4Y2VwdGlvbiBhbmQgdGhlbiBhZ2FpbiB3aGVuIHdlIHJldGhyb3cgaXQuXG4gKiAqIElmIHlvdSdyZSBvbmx5IHBhdXNpbmcgb24gdW5jYXVnaHQgZXhjZXB0aW9ucywgdGhlIGRlYnVnZ2VyIHdpbGwgb25seSBwYXVzZVxuICogICBvbiB1cyByZS10aHJvd2luZyBpdC5cbiAqXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBmbiBUaGUgY29kZSB0byBndWFyZC5cbiAqL1xuZXhwb3J0cy5leGNlcHRpb25HdWFyZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFJlLXRocm93IGV4Y2VwdGlvbiB3aGVuIGl0J3Mgc2FmZS5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJdCB1c2VkIHRvIGJlIHRoYXQgXCJ0aHJvdyBlXCIgd291bGQgcmVzdWx0IGluIGEgZ29vZCBjb25zb2xlIGVycm9yIHdpdGhcbiAgICAgICAgICAgIC8vIHJlbGV2YW50IGNvbnRleHQsIGJ1dCBhcyBvZiBDaHJvbWUgMzksIHlvdSBqdXN0IGdldCB0aGUgZmlyZWJhc2UuanNcbiAgICAgICAgICAgIC8vIGZpbGUvbGluZSBudW1iZXIgd2hlcmUgd2UgcmUtdGhyb3cgaXQsIHdoaWNoIGlzIHVzZWxlc3MuIFNvIHdlIGxvZ1xuICAgICAgICAgICAgLy8gZS5zdGFjayBleHBsaWNpdGx5LlxuICAgICAgICAgICAgdmFyIHN0YWNrID0gZS5zdGFjayB8fCAnJztcbiAgICAgICAgICAgIGV4cG9ydHMud2FybignRXhjZXB0aW9uIHdhcyB0aHJvd24gYnkgdXNlciBjYWxsYmFjay4nLCBzdGFjayk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcbiAgICB9XG59O1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2FmZWx5IGNhbGwgb3B0X2NhbGxiYWNrIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuICBJdDpcbiAqIDEuIFR1cm5zIGludG8gYSBuby1vcCBpZiBvcHRfY2FsbGJhY2sgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiAyLiBXcmFwcyB0aGUgY2FsbCBpbnNpZGUgZXhjZXB0aW9uR3VhcmQgdG8gcHJldmVudCBleGNlcHRpb25zIGZyb20gYnJlYWtpbmcgb3VyIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7P0Z1bmN0aW9uPX0gY2FsbGJhY2sgT3B0aW9uYWwgb25Db21wbGV0ZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQXJiaXRyYXJ5IGFyZ3MgdG8gYmUgcGFzc2VkIHRvIG9wdF9vbkNvbXBsZXRlXG4gKi9cbmV4cG9ydHMuY2FsbFVzZXJDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhcl9hcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGV4cG9ydHMuZXhjZXB0aW9uR3VhcmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCB2YXJfYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgd2UgdGhpbmsgd2UncmUgY3VycmVudGx5IGJlaW5nIGNyYXdsZWQuXG4gKi9cbmV4cG9ydHMuYmVpbmdDcmF3bGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VyQWdlbnQgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgd2luZG93WyduYXZpZ2F0b3InXSAmJlxuICAgICAgICB3aW5kb3dbJ25hdmlnYXRvciddWyd1c2VyQWdlbnQnXSkgfHxcbiAgICAgICAgJyc7XG4gICAgLy8gRm9yIG5vdyB3ZSB3aGl0ZWxpc3QgdGhlIG1vc3QgcG9wdWxhciBjcmF3bGVycy4gIFdlIHNob3VsZCByZWZpbmUgdGhpcyB0byBiZSB0aGUgc2V0IG9mIGNyYXdsZXJzIHdlXG4gICAgLy8gYmVsaWV2ZSB0byBzdXBwb3J0IEphdmFTY3JpcHQvQUpBWCByZW5kZXJpbmcuXG4gICAgLy8gTk9URTogR29vZ2xlIFdlYm1hc3RlciBUb29scyBkb2Vzbid0IHJlYWxseSBiZWxvbmcsIGJ1dCB0aGVpciBcIlRoaXMgaXMgaG93IGEgdmlzaXRvciB0byB5b3VyIHdlYnNpdGVcbiAgICAvLyB3b3VsZCBoYXZlIHNlZW4gdGhlIHBhZ2VcIiBpcyBmbGFreSBpZiB3ZSBkb24ndCB0cmVhdCBpdCBhcyBhIGNyYXdsZXIuXG4gICAgcmV0dXJuICh1c2VyQWdlbnQuc2VhcmNoKC9nb29nbGVib3R8Z29vZ2xlIHdlYm1hc3RlciB0b29sc3xiaW5nYm90fHlhaG9vISBzbHVycHxiYWlkdXNwaWRlcnx5YW5kZXhib3R8ZHVja2R1Y2tib3QvaSkgPj0gMCk7XG59O1xuLyoqXG4gKiBFeHBvcnQgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdXNpbmcgYSBnZXR0ZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpOiAqfSBmbkdldFxuICovXG5leHBvcnRzLmV4cG9ydFByb3BHZXR0ZXIgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBmbkdldCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHsgZ2V0OiBmbkdldCB9KTtcbn07XG4vKipcbiAqIFNhbWUgYXMgc2V0VGltZW91dCgpIGV4Y2VwdCBvbiBOb2RlLkpTIGl0IHdpbGwgL25vdC8gcHJldmVudCB0aGUgcHJvY2VzcyBmcm9tIGV4aXRpbmcuXG4gKlxuICogSXQgaXMgcmVtb3ZlZCB3aXRoIGNsZWFyVGltZW91dCgpIGFzIG5vcm1hbC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBydW4uXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBNaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgcnVubmluZy5cbiAqIEByZXR1cm4ge251bWJlcnxPYmplY3R9IFRoZSBzZXRUaW1lb3V0KCkgcmV0dXJuIHZhbHVlLlxuICovXG5leHBvcnRzLnNldFRpbWVvdXROb25CbG9ja2luZyA9IGZ1bmN0aW9uIChmbiwgdGltZSkge1xuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgdGltZSk7XG4gICAgaWYgKHR5cGVvZiB0aW1lb3V0ID09PSAnb2JqZWN0JyAmJiB0aW1lb3V0Wyd1bnJlZiddKSB7XG4gICAgICAgIHRpbWVvdXRbJ3VucmVmJ10oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVvdXQ7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfNCA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogVHJ1ZSBmb3IgaW52YWxpZCBGaXJlYmFzZSBrZXlzXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5JTlZBTElEX0tFWV9SRUdFWF8gPSAvW1xcW1xcXS4jJFxcL1xcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLztcbi8qKlxuICogVHJ1ZSBmb3IgaW52YWxpZCBGaXJlYmFzZSBwYXRocy5cbiAqIEFsbG93cyAnLycgaW4gcGF0aHMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5JTlZBTElEX1BBVEhfUkVHRVhfID0gL1tcXFtcXF0uIyRcXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87XG4vKipcbiAqIE1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gYWxsb3cgaW4gbGVhZiB2YWx1ZVxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuTUFYX0xFQUZfU0laRV8gPSAxMCAqIDEwMjQgKiAxMDI0O1xuLyoqXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5Lmxlbmd0aCAhPT0gMCAmJiAhZXhwb3J0cy5JTlZBTElEX0tFWV9SRUdFWF8udGVzdChrZXkpKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBwYXRoU3RyaW5nID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBwYXRoU3RyaW5nLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgICAhZXhwb3J0cy5JTlZBTElEX1BBVEhfUkVHRVhfLnRlc3QocGF0aFN0cmluZykpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICBpZiAocGF0aFN0cmluZykge1xuICAgICAgICAvLyBBbGxvdyAnLy5pbmZvLycgYXQgdGhlIGJlZ2lubmluZy5cbiAgICAgICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLmlzVmFsaWRQYXRoU3RyaW5nKHBhdGhTdHJpbmcpO1xufTtcbi8qKlxuICogQHBhcmFtIHsqfSBwcmlvcml0eVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICByZXR1cm4gKHByaW9yaXR5ID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicgJiYgIXV0aWxfMi5pc0ludmFsaWRKU09OTnVtYmVyKHByaW9yaXR5KSkgfHxcbiAgICAgICAgKHByaW9yaXR5ICYmIHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiYgdXRpbF8xLmNvbnRhaW5zKHByaW9yaXR5LCAnLnN2JykpKTtcbn07XG4vKipcbiAqIFByZS12YWxpZGF0ZSBhIGRhdHVtIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byBGaXJlYmFzZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gYXJndW1lbnROdW1iZXJcbiAqIEBwYXJhbSB7Kn0gZGF0YVxuICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25hbFxuICovXG5leHBvcnRzLnZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIGRhdGEsIHBhdGgsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmIGRhdGEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGV4cG9ydHMudmFsaWRhdGVGaXJlYmFzZURhdGEodXRpbF8zLmVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSwgZGF0YSwgcGF0aCk7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZSBhIGRhdGEgb2JqZWN0IGNsaWVudC1zaWRlIGJlZm9yZSBzZW5kaW5nIHRvIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JQcmVmaXhcbiAqIEBwYXJhbSB7Kn0gZGF0YVxuICogQHBhcmFtIHshUGF0aHwhVmFsaWRhdGlvblBhdGh9IHBhdGhfXG4gKi9cbmV4cG9ydHMudmFsaWRhdGVGaXJlYmFzZURhdGEgPSBmdW5jdGlvbiAoZXJyb3JQcmVmaXgsIGRhdGEsIHBhdGhfKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoXyBpbnN0YW5jZW9mIFBhdGhfMS5QYXRoID8gbmV3IFBhdGhfMS5WYWxpZGF0aW9uUGF0aChwYXRoXywgZXJyb3JQcmVmaXgpIDogcGF0aF87XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggKyAnY29udGFpbnMgdW5kZWZpbmVkICcgKyBwYXRoLnRvRXJyb3JTdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xuICAgICAgICAgICAgJ2NvbnRhaW5zIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICAgICBwYXRoLnRvRXJyb3JTdHJpbmcoKSArXG4gICAgICAgICAgICAnIHdpdGggY29udGVudHMgPSAnICtcbiAgICAgICAgICAgIGRhdGEudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh1dGlsXzIuaXNJbnZhbGlkSlNPTk51bWJlcihkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggKyAnY29udGFpbnMgJyArIGRhdGEudG9TdHJpbmcoKSArICcgJyArIHBhdGgudG9FcnJvclN0cmluZygpKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgbWF4IGxlYWYgc2l6ZSwgYnV0IHRyeSB0byBhdm9pZCB0aGUgdXRmOCBjb252ZXJzaW9uIGlmIHdlIGNhbi5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGRhdGEubGVuZ3RoID4gZXhwb3J0cy5NQVhfTEVBRl9TSVpFXyAvIDMgJiZcbiAgICAgICAgdXRpbF80LnN0cmluZ0xlbmd0aChkYXRhKSA+IGV4cG9ydHMuTUFYX0xFQUZfU0laRV8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcbiAgICAgICAgICAgICdjb250YWlucyBhIHN0cmluZyBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgICAgICBleHBvcnRzLk1BWF9MRUFGX1NJWkVfICtcbiAgICAgICAgICAgICcgdXRmOCBieXRlcyAnICtcbiAgICAgICAgICAgIHBhdGgudG9FcnJvclN0cmluZygpICtcbiAgICAgICAgICAgIFwiICgnXCIgK1xuICAgICAgICAgICAgZGF0YS5zdWJzdHJpbmcoMCwgNTApICtcbiAgICAgICAgICAgIFwiLi4uJylcIik7XG4gICAgfVxuICAgIC8vIFRPRE8gPSBQZXJmID0gQ29uc2lkZXIgY29tYmluaW5nIHRoZSByZWN1cnNpdmUgdmFsaWRhdGlvbiBvZiBrZXlzIGludG8gTm9kZUZyb21KU09OXG4gICAgLy8gdG8gc2F2ZSBleHRyYSB3YWxraW5nIG9mIGxhcmdlIG9iamVjdHMuXG4gICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBoYXNEb3RWYWx1ZV8xID0gZmFsc2UsIGhhc0FjdHVhbENoaWxkXzEgPSBmYWxzZTtcbiAgICAgICAgdXRpbF8xLmZvckVhY2goZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICcudmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgaGFzRG90VmFsdWVfMSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcucHJpb3JpdHknICYmIGtleSAhPT0gJy5zdicpIHtcbiAgICAgICAgICAgICAgICBoYXNBY3R1YWxDaGlsZF8xID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4cG9ydHMuaXNWYWxpZEtleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGNvbnRhaW5zIGFuIGludmFsaWQga2V5ICgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgudG9FcnJvclN0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcuICBLZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4LCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc0RvdFZhbHVlXzEgJiYgaGFzQWN0dWFsQ2hpbGRfMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcbiAgICAgICAgICAgICAgICAnIGNvbnRhaW5zIFwiLnZhbHVlXCIgY2hpbGQgJyArXG4gICAgICAgICAgICAgICAgcGF0aC50b0Vycm9yU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICcgaW4gYWRkaXRpb24gdG8gYWN0dWFsIGNoaWxkcmVuLicpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogUHJlLXZhbGlkYXRlIHBhdGhzIHBhc3NlZCBpbiB0aGUgZmlyZWJhc2UgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yUHJlZml4XG4gKiBAcGFyYW0ge0FycmF5PCFQYXRoPn0gbWVyZ2VQYXRoc1xuICovXG5leHBvcnRzLnZhbGlkYXRlRmlyZWJhc2VNZXJnZVBhdGhzID0gZnVuY3Rpb24gKGVycm9yUHJlZml4LCBtZXJnZVBhdGhzKSB7XG4gICAgdmFyIGksIGN1clBhdGg7XG4gICAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VyUGF0aCA9IG1lcmdlUGF0aHNbaV07XG4gICAgICAgIHZhciBrZXlzID0gY3VyUGF0aC5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChrZXlzW2pdID09PSAnLnByaW9yaXR5JyAmJiBqID09PSBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAvLyAucHJpb3JpdHkgaXMgT0tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFleHBvcnRzLmlzVmFsaWRLZXkoa2V5c1tqXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xuICAgICAgICAgICAgICAgICAgICAnY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKCcgK1xuICAgICAgICAgICAgICAgICAgICBrZXlzW2pdICtcbiAgICAgICAgICAgICAgICAgICAgJykgaW4gcGF0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgJy4gS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzICcgK1xuICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgdGhhdCB1cGRhdGUga2V5cyBhcmUgbm90IGRlc2NlbmRhbnRzIG9mIGVhY2ggb3RoZXIuXG4gICAgLy8gV2UgcmVseSBvbiB0aGUgcHJvcGVydHkgdGhhdCBzb3J0aW5nIGd1YXJhbnRlZXMgdGhhdCBhbmNlc3RvcnMgY29tZVxuICAgIC8vIHJpZ2h0IGJlZm9yZSBkZXNjZW5kYW50cy5cbiAgICBtZXJnZVBhdGhzLnNvcnQoUGF0aF8xLlBhdGguY29tcGFyZVBhdGhzKTtcbiAgICB2YXIgcHJldlBhdGggPSBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXJnZVBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1clBhdGggPSBtZXJnZVBhdGhzW2ldO1xuICAgICAgICBpZiAocHJldlBhdGggIT09IG51bGwgJiYgcHJldlBhdGguY29udGFpbnMoY3VyUGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXG4gICAgICAgICAgICAgICAgJ2NvbnRhaW5zIGEgcGF0aCAnICtcbiAgICAgICAgICAgICAgICBwcmV2UGF0aC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAnIHRoYXQgaXMgYW5jZXN0b3Igb2YgYW5vdGhlciBwYXRoICcgK1xuICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlBhdGggPSBjdXJQYXRoO1xuICAgIH1cbn07XG4vKipcbiAqIHByZS12YWxpZGF0ZSBhbiBvYmplY3QgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIGZpcmViYXNlIGZ1bmN0aW9uIChcbiAqIG11c3QgYmUgYW4gb2JqZWN0IC0gZS5nLiBmb3IgZmlyZWJhc2UudXBkYXRlKCkpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmd1bWVudE51bWJlclxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbmFsXG4gKi9cbmV4cG9ydHMudmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZyA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBkYXRhLCBwYXRoLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgZXJyb3JQcmVmaXggPSB1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpO1xuICAgIGlmICghKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArICcgbXVzdCBiZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2hpbGRyZW4gdG8gcmVwbGFjZS4nKTtcbiAgICB9XG4gICAgdmFyIG1lcmdlUGF0aHMgPSBbXTtcbiAgICB1dGlsXzEuZm9yRWFjaChkYXRhLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgY3VyUGF0aCA9IG5ldyBQYXRoXzEuUGF0aChrZXkpO1xuICAgICAgICBleHBvcnRzLnZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4LCB2YWx1ZSwgcGF0aC5jaGlsZChjdXJQYXRoKSk7XG4gICAgICAgIGlmIChjdXJQYXRoLmdldEJhY2soKSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgIGlmICghZXhwb3J0cy5pc1ZhbGlkUHJpb3JpdHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcbiAgICAgICAgICAgICAgICAgICAgXCJjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlIGZvciAnXCIgK1xuICAgICAgICAgICAgICAgICAgICBjdXJQYXRoLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICBcIicsIHdoaWNoIG11c3QgYmUgYSB2YWxpZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICdGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VQYXRocy5wdXNoKGN1clBhdGgpO1xuICAgIH0pO1xuICAgIGV4cG9ydHMudmFsaWRhdGVGaXJlYmFzZU1lcmdlUGF0aHMoZXJyb3JQcmVmaXgsIG1lcmdlUGF0aHMpO1xufTtcbmV4cG9ydHMudmFsaWRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBwcmlvcml0eSwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgcHJpb3JpdHkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh1dGlsXzIuaXNJbnZhbGlkSlNPTk51bWJlcihwcmlvcml0eSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdpcyAnICtcbiAgICAgICAgICAgIHByaW9yaXR5LnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgJywgYnV0IG11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsICcgK1xuICAgICAgICAgICAgJ3NlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIGFsbG93IGltcG9ydGluZyBkYXRhIHdpdGggYSAuc3YuXG4gICAgaWYgKCFleHBvcnRzLmlzVmFsaWRQcmlvcml0eShwcmlvcml0eSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgJyArXG4gICAgICAgICAgICAnKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLicpO1xufTtcbmV4cG9ydHMudmFsaWRhdGVFdmVudFR5cGUgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgZXZlbnRUeXBlLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBldmVudFR5cGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgY2FzZSAnY2hpbGRfYWRkZWQnOlxuICAgICAgICBjYXNlICdjaGlsZF9yZW1vdmVkJzpcbiAgICAgICAgY2FzZSAnY2hpbGRfY2hhbmdlZCc6XG4gICAgICAgIGNhc2UgJ2NoaWxkX21vdmVkJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxfMy5lcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgZXZlbnQgdHlwZSA9IFwidmFsdWVcIiwgXCJjaGlsZF9hZGRlZFwiLCBcImNoaWxkX3JlbW92ZWRcIiwgJyArXG4gICAgICAgICAgICAgICAgJ1wiY2hpbGRfY2hhbmdlZFwiLCBvciBcImNoaWxkX21vdmVkXCIuJyk7XG4gICAgfVxufTtcbmV4cG9ydHMudmFsaWRhdGVLZXkgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwga2V5LCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBrZXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghZXhwb3J0cy5pc1ZhbGlkS2V5KGtleSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICd3YXMgYW4gaW52YWxpZCBrZXkgPSBcIicgK1xuICAgICAgICAgICAga2V5ICtcbiAgICAgICAgICAgICdcIi4gIEZpcmViYXNlIGtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgJyArXG4gICAgICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCIpLicpO1xufTtcbmV4cG9ydHMudmFsaWRhdGVQYXRoU3RyaW5nID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmIHBhdGhTdHJpbmcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghZXhwb3J0cy5pc1ZhbGlkUGF0aFN0cmluZyhwYXRoU3RyaW5nKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxfMy5lcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAgICAgJ3dhcyBhbiBpbnZhbGlkIHBhdGggPSBcIicgK1xuICAgICAgICAgICAgcGF0aFN0cmluZyArXG4gICAgICAgICAgICAnXCIuIFBhdGhzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kICcgK1xuICAgICAgICAgICAgJ2NhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIltcIiwgb3IgXCJdXCInKTtcbn07XG5leHBvcnRzLnZhbGlkYXRlUm9vdFBhdGhTdHJpbmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgcGF0aFN0cmluZywgb3B0aW9uYWwpIHtcbiAgICBpZiAocGF0aFN0cmluZykge1xuICAgICAgICAvLyBBbGxvdyAnLy5pbmZvLycgYXQgdGhlIGJlZ2lubmluZy5cbiAgICAgICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XG4gICAgfVxuICAgIGV4cG9ydHMudmFsaWRhdGVQYXRoU3RyaW5nKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKTtcbn07XG5leHBvcnRzLnZhbGlkYXRlV3JpdGFibGVQYXRoID0gZnVuY3Rpb24gKGZuTmFtZSwgcGF0aCkge1xuICAgIGlmIChwYXRoLmdldEZyb250KCkgPT09ICcuaW5mbycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZuTmFtZSArIFwiIGZhaWxlZCA9IENhbid0IG1vZGlmeSBkYXRhIHVuZGVyIC8uaW5mby9cIik7XG4gICAgfVxufTtcbmV4cG9ydHMudmFsaWRhdGVVcmwgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgcGFyc2VkVXJsKSB7XG4gICAgLy8gVE9ETyA9IFZhbGlkYXRlIHNlcnZlciBiZXR0ZXIuXG4gICAgdmFyIHBhdGhTdHJpbmcgPSBwYXJzZWRVcmwucGF0aC50b1N0cmluZygpO1xuICAgIGlmICghKHR5cGVvZiBwYXJzZWRVcmwucmVwb0luZm8uaG9zdCA9PT0gJ3N0cmluZycpIHx8XG4gICAgICAgIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0Lmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAhZXhwb3J0cy5pc1ZhbGlkS2V5KHBhcnNlZFVybC5yZXBvSW5mby5uYW1lc3BhY2UpIHx8XG4gICAgICAgIChwYXRoU3RyaW5nLmxlbmd0aCAhPT0gMCAmJiAhZXhwb3J0cy5pc1ZhbGlkUm9vdFBhdGhTdHJpbmcocGF0aFN0cmluZykpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgZmFsc2UpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgVVJMIGFuZCAnICtcbiAgICAgICAgICAgICd0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO1xuICAgIH1cbn07XG5leHBvcnRzLnZhbGlkYXRlQ3JlZGVudGlhbCA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBjcmVkLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBjcmVkID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoISh0eXBlb2YgY3JlZCA9PT0gJ3N0cmluZycpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbF8zLmVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGNyZWRlbnRpYWwgKGEgc3RyaW5nKS4nKTtcbn07XG5leHBvcnRzLnZhbGlkYXRlQm9vbGVhbiA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBib29sLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBib29sID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxfMy5lcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgKyAnbXVzdCBiZSBhIGJvb2xlYW4uJyk7XG59O1xuZXhwb3J0cy52YWxpZGF0ZVN0cmluZyA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBzdHJpbmcsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmIHN0cmluZyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCEodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLicpO1xuICAgIH1cbn07XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9iaiwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgb2JqID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIShvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbF8zLmVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIG9iamVjdC4nKTtcbiAgICB9XG59O1xuZXhwb3J0cy52YWxpZGF0ZU9iamVjdENvbnRhaW5zS2V5ID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9iaiwga2V5LCBvcHRpb25hbCwgb3B0X3R5cGUpIHtcbiAgICB2YXIgb2JqZWN0Q29udGFpbnNLZXkgPSBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdXRpbF8xLmNvbnRhaW5zKG9iaiwga2V5KTtcbiAgICBpZiAoIW9iamVjdENvbnRhaW5zS2V5KSB7XG4gICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxfMy5lcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAgICAgICAgICdtdXN0IGNvbnRhaW4gdGhlIGtleSBcIicgK1xuICAgICAgICAgICAgICAgIGtleSArXG4gICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdF90eXBlKSB7XG4gICAgICAgIHZhciB2YWwgPSB1dGlsXzEuc2FmZUdldChvYmosIGtleSk7XG4gICAgICAgIGlmICgob3B0X3R5cGUgPT09ICdudW1iZXInICYmICEodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpKSB8fFxuICAgICAgICAgICAgKG9wdF90eXBlID09PSAnc3RyaW5nJyAmJiAhKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSkgfHxcbiAgICAgICAgICAgIChvcHRfdHlwZSA9PT0gJ2Jvb2xlYW4nICYmICEodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSkgfHxcbiAgICAgICAgICAgIChvcHRfdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB8fFxuICAgICAgICAgICAgKG9wdF90eXBlID09PSAnb2JqZWN0JyAmJiAhKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSAmJiB2YWwpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbF8zLmVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAgICAgICAgICdjb250YWlucyBpbnZhbGlkIHZhbHVlIGZvciBrZXkgXCInICtcbiAgICAgICAgICAgICAgICAgICAga2V5ICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIChtdXN0IGJlIG9mIHR5cGUgXCInICtcbiAgICAgICAgICAgICAgICAgICAgb3B0X3R5cGUgK1xuICAgICAgICAgICAgICAgICAgICAnXCIpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbF8zLmVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAgICAgICAgICdtdXN0IGNvbnRhaW4gdGhlIGtleSBcIicgK1xuICAgICAgICAgICAgICAgICAgICBrZXkgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgd2l0aCB0eXBlIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdF90eXBlICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBIGNhY2hlIG5vZGUgb25seSBzdG9yZXMgY29tcGxldGUgY2hpbGRyZW4uIEFkZGl0aW9uYWxseSBpdCBob2xkcyBhIGZsYWcgd2hldGhlciB0aGUgbm9kZSBjYW4gYmUgY29uc2lkZXJlZCBmdWxseVxuICogaW5pdGlhbGl6ZWQgaW4gdGhlIHNlbnNlIHRoYXQgd2Uga25vdyBhdCBvbmUgcG9pbnQgaW4gdGltZSB0aGlzIHJlcHJlc2VudGVkIGEgdmFsaWQgc3RhdGUgb2YgdGhlIHdvcmxkLCBlLmcuXG4gKiBpbml0aWFsaXplZCB3aXRoIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBvciBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBieSB0aGUgY2xpZW50LiBUaGUgZmlsdGVyZWQgZmxhZyBhbHNvIHRyYWNrc1xuICogd2hldGhlciBhIG5vZGUgcG90ZW50aWFsbHkgaGFkIGNoaWxkcmVuIHJlbW92ZWQgZHVlIHRvIGEgZmlsdGVyLlxuICovXG52YXIgQ2FjaGVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVfXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmdWxseUluaXRpYWxpemVkX1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsdGVyZWRfXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2FjaGVOb2RlKG5vZGVfLCBmdWxseUluaXRpYWxpemVkXywgZmlsdGVyZWRfKSB7XG4gICAgICAgIHRoaXMubm9kZV8gPSBub2RlXztcbiAgICAgICAgdGhpcy5mdWxseUluaXRpYWxpemVkXyA9IGZ1bGx5SW5pdGlhbGl6ZWRfO1xuICAgICAgICB0aGlzLmZpbHRlcmVkXyA9IGZpbHRlcmVkXztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgbm9kZSB3YXMgZnVsbHkgaW5pdGlhbGl6ZWQgd2l0aCBlaXRoZXIgc2VydmVyIGRhdGEgb3IgYSBjb21wbGV0ZSBvdmVyd3JpdGUgYnkgdGhlIGNsaWVudFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgQ2FjaGVOb2RlLnByb3RvdHlwZS5pc0Z1bGx5SW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bGx5SW5pdGlhbGl6ZWRfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgbm9kZSBpcyBwb3RlbnRpYWxseSBtaXNzaW5nIGNoaWxkcmVuIGR1ZSB0byBhIGZpbHRlciBhcHBsaWVkIHRvIHRoZSBub2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBDYWNoZU5vZGUucHJvdG90eXBlLmlzRmlsdGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIENhY2hlTm9kZS5wcm90b3R5cGUuaXNDb21wbGV0ZUZvclBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRnVsbHlJbml0aWFsaXplZCgpICYmICF0aGlzLmZpbHRlcmVkXztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRLZXkgPSBwYXRoLmdldEZyb250KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgQ2FjaGVOb2RlLnByb3RvdHlwZS5pc0NvbXBsZXRlRm9yQ2hpbGQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMuaXNGdWxseUluaXRpYWxpemVkKCkgJiYgIXRoaXMuZmlsdGVyZWRfKSB8fCB0aGlzLm5vZGVfLmhhc0NoaWxkKGtleSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgQ2FjaGVOb2RlLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXztcbiAgICB9O1xuICAgIHJldHVybiBDYWNoZU5vZGU7XG59KCkpO1xuZXhwb3J0cy5DYWNoZU5vZGUgPSBDYWNoZU5vZGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhY2hlTm9kZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKiBAcGFyYW0geyFzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGVcbiAqIEBwYXJhbSB7IU5vZGV9IHNuYXBzaG90Tm9kZSBUaGUgZGF0YVxuICogQHBhcmFtIHtzdHJpbmc9fSBjaGlsZE5hbWUgVGhlIG5hbWUgZm9yIHRoaXMgY2hpbGQsIGlmIGl0J3MgYSBjaGlsZCBldmVudFxuICogQHBhcmFtIHtOb2RlPX0gb2xkU25hcCBVc2VkIGZvciBpbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBvZiBjaGlsZCBjaGFuZ2VkIGV2ZW50c1xuICogQHBhcmFtIHtzdHJpbmc9fSBwcmV2TmFtZSBUaGUgbmFtZSBmb3IgdGhlIHByZXZpb3VzIGNoaWxkLCBpZiBhcHBsaWNhYmxlXG4gKi9cbnZhciBDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbmdlKHR5cGUsIHNuYXBzaG90Tm9kZSwgY2hpbGROYW1lLCBvbGRTbmFwLCBwcmV2TmFtZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNuYXBzaG90Tm9kZSA9IHNuYXBzaG90Tm9kZTtcbiAgICAgICAgdGhpcy5jaGlsZE5hbWUgPSBjaGlsZE5hbWU7XG4gICAgICAgIHRoaXMub2xkU25hcCA9IG9sZFNuYXA7XG4gICAgICAgIHRoaXMucHJldk5hbWUgPSBwcmV2TmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gc25hcHNob3RcbiAgICAgKiBAcmV0dXJuIHshQ2hhbmdlfVxuICAgICAqL1xuICAgIENoYW5nZS52YWx1ZUNoYW5nZSA9IGZ1bmN0aW9uIChzbmFwc2hvdCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZShDaGFuZ2UuVkFMVUUsIHNuYXBzaG90KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZEtleVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IHNuYXBzaG90XG4gICAgICogQHJldHVybiB7IUNoYW5nZX1cbiAgICAgKi9cbiAgICBDaGFuZ2UuY2hpbGRBZGRlZENoYW5nZSA9IGZ1bmN0aW9uIChjaGlsZEtleSwgc25hcHNob3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2UoQ2hhbmdlLkNISUxEX0FEREVELCBzbmFwc2hvdCwgY2hpbGRLZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAgICogQHBhcmFtIHshTm9kZX0gc25hcHNob3RcbiAgICAgKiBAcmV0dXJuIHshQ2hhbmdlfVxuICAgICAqL1xuICAgIENoYW5nZS5jaGlsZFJlbW92ZWRDaGFuZ2UgPSBmdW5jdGlvbiAoY2hpbGRLZXksIHNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlKENoYW5nZS5DSElMRF9SRU1PVkVELCBzbmFwc2hvdCwgY2hpbGRLZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAgICogQHBhcmFtIHshTm9kZX0gbmV3U25hcHNob3RcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBvbGRTbmFwc2hvdFxuICAgICAqIEByZXR1cm4geyFDaGFuZ2V9XG4gICAgICovXG4gICAgQ2hhbmdlLmNoaWxkQ2hhbmdlZENoYW5nZSA9IGZ1bmN0aW9uIChjaGlsZEtleSwgbmV3U25hcHNob3QsIG9sZFNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlKENoYW5nZS5DSElMRF9DSEFOR0VELCBuZXdTbmFwc2hvdCwgY2hpbGRLZXksIG9sZFNuYXBzaG90KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZEtleVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IHNuYXBzaG90XG4gICAgICogQHJldHVybiB7IUNoYW5nZX1cbiAgICAgKi9cbiAgICBDaGFuZ2UuY2hpbGRNb3ZlZENoYW5nZSA9IGZ1bmN0aW9uIChjaGlsZEtleSwgc25hcHNob3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2UoQ2hhbmdlLkNISUxEX01PVkVELCBzbmFwc2hvdCwgY2hpbGRLZXkpO1xuICAgIH07XG4gICAgLy9ldmVudCB0eXBlc1xuICAgIC8qKiBFdmVudCB0eXBlIGZvciBhIGNoaWxkIGFkZGVkICovXG4gICAgQ2hhbmdlLkNISUxEX0FEREVEID0gJ2NoaWxkX2FkZGVkJztcbiAgICAvKiogRXZlbnQgdHlwZSBmb3IgYSBjaGlsZCByZW1vdmVkICovXG4gICAgQ2hhbmdlLkNISUxEX1JFTU9WRUQgPSAnY2hpbGRfcmVtb3ZlZCc7XG4gICAgLyoqIEV2ZW50IHR5cGUgZm9yIGEgY2hpbGQgY2hhbmdlZCAqL1xuICAgIENoYW5nZS5DSElMRF9DSEFOR0VEID0gJ2NoaWxkX2NoYW5nZWQnO1xuICAgIC8qKiBFdmVudCB0eXBlIGZvciBhIGNoaWxkIG1vdmVkICovXG4gICAgQ2hhbmdlLkNISUxEX01PVkVEID0gJ2NoaWxkX21vdmVkJztcbiAgICAvKiogRXZlbnQgdHlwZSBmb3IgYSB2YWx1ZSBjaGFuZ2UgKi9cbiAgICBDaGFuZ2UuVkFMVUUgPSAndmFsdWUnO1xuICAgIHJldHVybiBDaGFuZ2U7XG59KCkpO1xuZXhwb3J0cy5DaGFuZ2UgPSBDaGFuZ2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYW5nZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgQ2hhbmdlXzEgPSByZXF1aXJlKFwiLi9DaGFuZ2VcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENoaWxkQ2hhbmdlQWNjdW11bGF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VNYXBfID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUNoYW5nZX0gY2hhbmdlXG4gICAgICovXG4gICAgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvci5wcm90b3R5cGUudHJhY2tDaGlsZENoYW5nZSA9IGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBjaGFuZ2UudHlwZTtcbiAgICAgICAgdmFyIGNoaWxkS2V5IC8qKiBAdHlwZSB7IXN0cmluZ30gKi8gPSBjaGFuZ2UuY2hpbGROYW1lO1xuICAgICAgICB1dGlsXzIuYXNzZXJ0KHR5cGUgPT0gQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX0FEREVEIHx8XG4gICAgICAgICAgICB0eXBlID09IENoYW5nZV8xLkNoYW5nZS5DSElMRF9DSEFOR0VEIHx8XG4gICAgICAgICAgICB0eXBlID09IENoYW5nZV8xLkNoYW5nZS5DSElMRF9SRU1PVkVELCAnT25seSBjaGlsZCBjaGFuZ2VzIHN1cHBvcnRlZCBmb3IgdHJhY2tpbmcnKTtcbiAgICAgICAgdXRpbF8yLmFzc2VydChjaGlsZEtleSAhPT0gJy5wcmlvcml0eScsICdPbmx5IG5vbi1wcmlvcml0eSBjaGlsZCBjaGFuZ2VzIGNhbiBiZSB0cmFja2VkLicpO1xuICAgICAgICB2YXIgb2xkQ2hhbmdlID0gdXRpbF8xLnNhZmVHZXQodGhpcy5jaGFuZ2VNYXBfLCBjaGlsZEtleSk7XG4gICAgICAgIGlmIChvbGRDaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBvbGRUeXBlID0gb2xkQ2hhbmdlLnR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBDaGFuZ2VfMS5DaGFuZ2UuQ0hJTERfQURERUQgJiYgb2xkVHlwZSA9PSBDaGFuZ2VfMS5DaGFuZ2UuQ0hJTERfUkVNT1ZFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwX1tjaGlsZEtleV0gPSBDaGFuZ2VfMS5DaGFuZ2UuY2hpbGRDaGFuZ2VkQ2hhbmdlKGNoaWxkS2V5LCBjaGFuZ2Uuc25hcHNob3ROb2RlLCBvbGRDaGFuZ2Uuc25hcHNob3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX1JFTU9WRUQgJiZcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09IENoYW5nZV8xLkNoYW5nZS5DSElMRF9BRERFRCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNoYW5nZU1hcF9bY2hpbGRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBDaGFuZ2VfMS5DaGFuZ2UuQ0hJTERfUkVNT1ZFRCAmJlxuICAgICAgICAgICAgICAgIG9sZFR5cGUgPT0gQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX0NIQU5HRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcF9bY2hpbGRLZXldID0gQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkUmVtb3ZlZENoYW5nZShjaGlsZEtleSwgb2xkQ2hhbmdlLm9sZFNuYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBDaGFuZ2VfMS5DaGFuZ2UuQ0hJTERfQ0hBTkdFRCAmJlxuICAgICAgICAgICAgICAgIG9sZFR5cGUgPT0gQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX0FEREVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXBfW2NoaWxkS2V5XSA9IENoYW5nZV8xLkNoYW5nZS5jaGlsZEFkZGVkQ2hhbmdlKGNoaWxkS2V5LCBjaGFuZ2Uuc25hcHNob3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX0NIQU5HRUQgJiZcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09IENoYW5nZV8xLkNoYW5nZS5DSElMRF9DSEFOR0VEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXBfW2NoaWxkS2V5XSA9IENoYW5nZV8xLkNoYW5nZS5jaGlsZENoYW5nZWRDaGFuZ2UoY2hpbGRLZXksIGNoYW5nZS5zbmFwc2hvdE5vZGUsIG9sZENoYW5nZS5vbGRTbmFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IHV0aWxfMi5hc3NlcnRpb25FcnJvcignSWxsZWdhbCBjb21iaW5hdGlvbiBvZiBjaGFuZ2VzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlICtcbiAgICAgICAgICAgICAgICAgICAgJyBvY2N1cnJlZCBhZnRlciAnICtcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwX1tjaGlsZEtleV0gPSBjaGFuZ2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUNoYW5nZT59XG4gICAgICovXG4gICAgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvci5wcm90b3R5cGUuZ2V0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5nZXRWYWx1ZXModGhpcy5jaGFuZ2VNYXBfKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yO1xufSgpKTtcbmV4cG9ydHMuQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvciA9IENoaWxkQ2hhbmdlQWNjdW11bGF0b3I7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoaWxkQ2hhbmdlQWNjdW11bGF0b3IuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2FjaGVOb2RlXzEgPSByZXF1aXJlKFwiLi9DYWNoZU5vZGVcIik7XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIENvbXBsZXRlQ2hpbGRTb3VyY2UgdGhhdCBuZXZlciByZXR1cm5zIGFueSBhZGRpdGlvbmFsIGNoaWxkcmVuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMgQ29tcGxldGVDaGlsZFNvdXJjZVxuICovXG52YXIgTm9Db21wbGV0ZUNoaWxkU291cmNlXyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIE5vQ29tcGxldGVDaGlsZFNvdXJjZV8ucHJvdG90eXBlLmdldENvbXBsZXRlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGRLZXkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIE5vQ29tcGxldGVDaGlsZFNvdXJjZV8ucHJvdG90eXBlLmdldENoaWxkQWZ0ZXJDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCwgY2hpbGQsIHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gTm9Db21wbGV0ZUNoaWxkU291cmNlXztcbn0oKSk7XG5leHBvcnRzLk5vQ29tcGxldGVDaGlsZFNvdXJjZV8gPSBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfO1xuLyoqXG4gKiBTaW5nbGV0b24gaW5zdGFuY2UuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHshQ29tcGxldGVDaGlsZFNvdXJjZX1cbiAqL1xuZXhwb3J0cy5OT19DT01QTEVURV9DSElMRF9TT1VSQ0UgPSBuZXcgTm9Db21wbGV0ZUNoaWxkU291cmNlXygpO1xuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBDb21wbGV0ZUNoaWxkU291cmNlIHRoYXQgdXNlcyBhIFdyaXRlVHJlZSBpbiBhZGRpdGlvbiB0byBhbnkgb3RoZXIgc2VydmVyIGRhdGEgb3JcbiAqIG9sZCBldmVudCBjYWNoZXMgYXZhaWxhYmxlIHRvIGNhbGN1bGF0ZSBjb21wbGV0ZSBjaGlsZHJlbi5cbiAqXG4gKlxuICogQGltcGxlbWVudHMgQ29tcGxldGVDaGlsZFNvdXJjZVxuICovXG52YXIgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc19cbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IHZpZXdDYWNoZV9cbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBvcHRDb21wbGV0ZVNlcnZlckNhY2hlX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uod3JpdGVzXywgdmlld0NhY2hlXywgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8pIHtcbiAgICAgICAgaWYgKG9wdENvbXBsZXRlU2VydmVyQ2FjaGVfID09PSB2b2lkIDApIHsgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBudWxsOyB9XG4gICAgICAgIHRoaXMud3JpdGVzXyA9IHdyaXRlc187XG4gICAgICAgIHRoaXMudmlld0NhY2hlXyA9IHZpZXdDYWNoZV87XG4gICAgICAgIHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlLnByb3RvdHlwZS5nZXRDb21wbGV0ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkS2V5KSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy52aWV3Q2FjaGVfLmdldEV2ZW50Q2FjaGUoKTtcbiAgICAgICAgaWYgKG5vZGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJOb2RlID0gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyAhPSBudWxsXG4gICAgICAgICAgICAgICAgPyBuZXcgQ2FjaGVOb2RlXzEuQ2FjaGVOb2RlKHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8sIHRydWUsIGZhbHNlKVxuICAgICAgICAgICAgICAgIDogdGhpcy52aWV3Q2FjaGVfLmdldFNlcnZlckNhY2hlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0ZXNfLmNhbGNDb21wbGV0ZUNoaWxkKGNoaWxkS2V5LCBzZXJ2ZXJOb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlLnByb3RvdHlwZS5nZXRDaGlsZEFmdGVyQ2hpbGQgPSBmdW5jdGlvbiAoaW5kZXgsIGNoaWxkLCByZXZlcnNlKSB7XG4gICAgICAgIHZhciBjb21wbGV0ZVNlcnZlckRhdGEgPSB0aGlzLm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfICE9IG51bGxcbiAgICAgICAgICAgID8gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlX1xuICAgICAgICAgICAgOiB0aGlzLnZpZXdDYWNoZV8uZ2V0Q29tcGxldGVTZXJ2ZXJTbmFwKCk7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMud3JpdGVzXy5jYWxjSW5kZXhlZFNsaWNlKGNvbXBsZXRlU2VydmVyRGF0YSwgY2hpbGQsIDEsIHJldmVyc2UsIGluZGV4KTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlO1xufSgpKTtcbmV4cG9ydHMuV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSA9IFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBsZXRlQ2hpbGRTb3VyY2UuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIGRhdGEgbmVlZGVkIHRvIHJhaXNlIGFuIGV2ZW50XG4gKiBAaW1wbGVtZW50cyB7RXZlbnR9XG4gKi9cbnZhciBEYXRhRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGUgT25lIG9mOiB2YWx1ZSwgY2hpbGRfYWRkZWQsIGNoaWxkX2NoYW5nZWQsIGNoaWxkX21vdmVkLCBjaGlsZF9yZW1vdmVkXG4gICAgICogQHBhcmFtIHshRXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uIFRoZSBmdW5jdGlvbiB0byBjYWxsIHRvIHdpdGggdGhlIGV2ZW50IGRhdGEuIFVzZXIgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0geyFEYXRhU25hcHNob3R9IHNuYXBzaG90IFRoZSBkYXRhIGJhY2tpbmcgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHs/c3RyaW5nPX0gcHJldk5hbWUgT3B0aW9uYWwsIHRoZSBuYW1lIG9mIHRoZSBwcmV2aW91cyBjaGlsZCBmb3IgY2hpbGRfKiBldmVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YUV2ZW50KGV2ZW50VHlwZSwgZXZlbnRSZWdpc3RyYXRpb24sIHNuYXBzaG90LCBwcmV2TmFtZSkge1xuICAgICAgICB0aGlzLmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcbiAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbiA9IGV2ZW50UmVnaXN0cmF0aW9uO1xuICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICAgIHRoaXMucHJldk5hbWUgPSBwcmV2TmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBEYXRhRXZlbnQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLnNuYXBzaG90LmdldFJlZigpO1xuICAgICAgICBpZiAodGhpcy5ldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiByZWYucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWYuZ2V0UGFyZW50KCkucGF0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBEYXRhRXZlbnQucHJvdG90eXBlLmdldEV2ZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRUeXBlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBEYXRhRXZlbnQucHJvdG90eXBlLmdldEV2ZW50UnVubmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbi5nZXRFdmVudFJ1bm5lcih0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgRGF0YUV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldFBhdGgoKS50b1N0cmluZygpICtcbiAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICB0aGlzLmV2ZW50VHlwZSArXG4gICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgdXRpbF8xLnN0cmluZ2lmeSh0aGlzLnNuYXBzaG90LmV4cG9ydFZhbCgpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YUV2ZW50O1xufSgpKTtcbmV4cG9ydHMuRGF0YUV2ZW50ID0gRGF0YUV2ZW50O1xudmFyIENhbmNlbEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2FuY2VsRXZlbnQoZXZlbnRSZWdpc3RyYXRpb24sIGVycm9yLCBwYXRoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24gPSBldmVudFJlZ2lzdHJhdGlvbjtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENhbmNlbEV2ZW50LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDYW5jZWxFdmVudC5wcm90b3R5cGUuZ2V0RXZlbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENhbmNlbEV2ZW50LnByb3RvdHlwZS5nZXRFdmVudFJ1bm5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24uZ2V0RXZlbnRSdW5uZXIodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENhbmNlbEV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpICsgJzpjYW5jZWwnO1xuICAgIH07XG4gICAgcmV0dXJuIENhbmNlbEV2ZW50O1xufSgpKTtcbmV4cG9ydHMuQ2FuY2VsRXZlbnQgPSBDYW5jZWxFdmVudDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTm9kZV8xID0gcmVxdWlyZShcIi4uL3NuYXAvTm9kZVwiKTtcbnZhciBDaGFuZ2VfMSA9IHJlcXVpcmUoXCIuL0NoYW5nZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIEFuIEV2ZW50R2VuZXJhdG9yIGlzIHVzZWQgdG8gY29udmVydCBcInJhd1wiIGNoYW5nZXMgKENoYW5nZSkgYXMgY29tcHV0ZWQgYnkgdGhlXG4gKiBDYWNoZURpZmZlciBpbnRvIGFjdHVhbCBldmVudHMgKEV2ZW50KSB0aGF0IGNhbiBiZSByYWlzZWQuICBTZWUgZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKClcbiAqIGZvciBkZXRhaWxzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRXZlbnRHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlfXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXZlbnRHZW5lcmF0b3IocXVlcnlfKSB7XG4gICAgICAgIHRoaXMucXVlcnlfID0gcXVlcnlfO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUgeyFJbmRleH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXhfID0gdGhpcy5xdWVyeV8uZ2V0UXVlcnlQYXJhbXMoKS5nZXRJbmRleCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNldCBvZiByYXcgY2hhbmdlcyAobm8gbW92ZWQgZXZlbnRzIGFuZCBwcmV2TmFtZSBub3Qgc3BlY2lmaWVkIHlldCksIGFuZCBhIHNldCBvZlxuICAgICAqIEV2ZW50UmVnaXN0cmF0aW9ucyB0aGF0IHNob3VsZCBiZSBub3RpZmllZCBvZiB0aGVzZSBjaGFuZ2VzLCBnZW5lcmF0ZSB0aGUgYWN0dWFsIGV2ZW50cyB0byBiZSByYWlzZWQuXG4gICAgICpcbiAgICAgKiBOb3RlczpcbiAgICAgKiAgLSBjaGlsZF9tb3ZlZCBldmVudHMgd2lsbCBiZSBzeW50aGVzaXplZCBhdCB0aGlzIHRpbWUgZm9yIGFueSBjaGlsZF9jaGFuZ2VkIGV2ZW50cyB0aGF0IGFmZmVjdFxuICAgICAqICAgIG91ciBpbmRleC5cbiAgICAgKiAgLSBwcmV2TmFtZSB3aWxsIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGluZGV4IG9yZGVyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFDaGFuZ2U+fSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHshTm9kZX0gZXZlbnRDYWNoZVxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhRXZlbnRSZWdpc3RyYXRpb24+fSBldmVudFJlZ2lzdHJhdGlvbnNcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICovXG4gICAgRXZlbnRHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBldmVudENhY2hlLCBldmVudFJlZ2lzdHJhdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgbW92ZXMgPSBbXTtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX0NIQU5HRUQgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmRleF8uaW5kZXhlZFZhbHVlQ2hhbmdlZChjaGFuZ2Uub2xkU25hcCwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBtb3Zlcy5wdXNoKENoYW5nZV8xLkNoYW5nZS5jaGlsZE1vdmVkQ2hhbmdlKGNoYW5nZS5jaGlsZE5hbWUsIGNoYW5nZS5zbmFwc2hvdE5vZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JUeXBlXyhldmVudHMsIENoYW5nZV8xLkNoYW5nZS5DSElMRF9SRU1PVkVELCBjaGFuZ2VzLCBldmVudFJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpO1xuICAgICAgICB0aGlzLmdlbmVyYXRlRXZlbnRzRm9yVHlwZV8oZXZlbnRzLCBDaGFuZ2VfMS5DaGFuZ2UuQ0hJTERfQURERUQsIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JUeXBlXyhldmVudHMsIENoYW5nZV8xLkNoYW5nZS5DSElMRF9NT1ZFRCwgbW92ZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JUeXBlXyhldmVudHMsIENoYW5nZV8xLkNoYW5nZS5DSElMRF9DSEFOR0VELCBjaGFuZ2VzLCBldmVudFJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpO1xuICAgICAgICB0aGlzLmdlbmVyYXRlRXZlbnRzRm9yVHlwZV8oZXZlbnRzLCBDaGFuZ2VfMS5DaGFuZ2UuVkFMVUUsIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBjaGFuZ2VzIG9mIGEgc2luZ2xlIGNoYW5nZSB0eXBlLCBnZW5lcmF0ZSB0aGUgY29ycmVzcG9uZGluZyBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IUV2ZW50Pn0gZXZlbnRzXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IUNoYW5nZT59IGNoYW5nZXNcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IUV2ZW50UmVnaXN0cmF0aW9uPn0gcmVnaXN0cmF0aW9uc1xuICAgICAqIEBwYXJhbSB7IU5vZGV9IGV2ZW50Q2FjaGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEV2ZW50R2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUV2ZW50c0ZvclR5cGVfID0gZnVuY3Rpb24gKGV2ZW50cywgZXZlbnRUeXBlLCBjaGFuZ2VzLCByZWdpc3RyYXRpb25zLCBldmVudENhY2hlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmaWx0ZXJlZENoYW5nZXMgPSBjaGFuZ2VzLmZpbHRlcihmdW5jdGlvbiAoY2hhbmdlKSB7IHJldHVybiBjaGFuZ2UudHlwZSA9PT0gZXZlbnRUeXBlOyB9KTtcbiAgICAgICAgZmlsdGVyZWRDaGFuZ2VzLnNvcnQodGhpcy5jb21wYXJlQ2hhbmdlc18uYmluZCh0aGlzKSk7XG4gICAgICAgIGZpbHRlcmVkQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbGl6ZWRDaGFuZ2UgPSBfdGhpcy5tYXRlcmlhbGl6ZVNpbmdsZUNoYW5nZV8oY2hhbmdlLCBldmVudENhY2hlKTtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5yZXNwb25kc1RvKGNoYW5nZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaChyZWdpc3RyYXRpb24uY3JlYXRlRXZlbnQobWF0ZXJpYWxpemVkQ2hhbmdlLCBfdGhpcy5xdWVyeV8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFDaGFuZ2V9IGNoYW5nZVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IGV2ZW50Q2FjaGVcbiAgICAgKiBAcmV0dXJuIHshQ2hhbmdlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRHZW5lcmF0b3IucHJvdG90eXBlLm1hdGVyaWFsaXplU2luZ2xlQ2hhbmdlXyA9IGZ1bmN0aW9uIChjaGFuZ2UsIGV2ZW50Q2FjaGUpIHtcbiAgICAgICAgaWYgKGNoYW5nZS50eXBlID09PSAndmFsdWUnIHx8IGNoYW5nZS50eXBlID09PSAnY2hpbGRfcmVtb3ZlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UucHJldk5hbWUgPSBldmVudENhY2hlLmdldFByZWRlY2Vzc29yQ2hpbGROYW1lKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHshc3RyaW5nfSAqL1xuICAgICAgICAgICAgY2hhbmdlLmNoaWxkTmFtZSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgdGhpcy5pbmRleF8pO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshQ2hhbmdlfSBhXG4gICAgICogQHBhcmFtIHshQ2hhbmdlfSBiXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRHZW5lcmF0b3IucHJvdG90eXBlLmNvbXBhcmVDaGFuZ2VzXyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhLmNoaWxkTmFtZSA9PSBudWxsIHx8IGIuY2hpbGROYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IHV0aWxfMS5hc3NlcnRpb25FcnJvcignU2hvdWxkIG9ubHkgY29tcGFyZSBjaGlsZF8gZXZlbnRzLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhV3JhcHBlZCA9IG5ldyBOb2RlXzEuTmFtZWROb2RlKGEuY2hpbGROYW1lLCBhLnNuYXBzaG90Tm9kZSk7XG4gICAgICAgIHZhciBiV3JhcHBlZCA9IG5ldyBOb2RlXzEuTmFtZWROb2RlKGIuY2hpbGROYW1lLCBiLnNuYXBzaG90Tm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4Xy5jb21wYXJlKGFXcmFwcGVkLCBiV3JhcHBlZCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRHZW5lcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5FdmVudEdlbmVyYXRvciA9IEV2ZW50R2VuZXJhdG9yO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudEdlbmVyYXRvci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbC91dGlsXCIpO1xuLyoqXG4gKiBUaGUgZXZlbnQgcXVldWUgc2VydmVzIGEgZmV3IHB1cnBvc2VzOlxuICogMS4gSXQgZW5zdXJlcyB3ZSBtYWludGFpbiBldmVudCBvcmRlciBpbiB0aGUgZmFjZSBvZiBldmVudCBjYWxsYmFja3MgZG9pbmcgb3BlcmF0aW9ucyB0aGF0IHJlc3VsdCBpbiBtb3JlXG4gKiAgICBldmVudHMgYmVpbmcgcXVldWVkLlxuICogMi4gcmFpc2VRdWV1ZWRFdmVudHMoKSBoYW5kbGVzIGJlaW5nIGNhbGxlZCByZWVudHJhbnRseSBuaWNlbHkuICBUaGF0IGlzLCBpZiBpbiB0aGUgY291cnNlIG9mIHJhaXNpbmcgZXZlbnRzLFxuICogICAgcmFpc2VRdWV1ZWRFdmVudHMoKSBpcyBjYWxsZWQgYWdhaW4sIHRoZSBcImlubmVyXCIgY2FsbCB3aWxsIHBpY2sgdXAgcmFpc2luZyBldmVudHMgd2hlcmUgdGhlIFwib3V0ZXJcIiBjYWxsXG4gKiAgICBsZWZ0IG9mZiwgZW5zdXJpbmcgdGhhdCB0aGUgZXZlbnRzIGFyZSBzdGlsbCByYWlzZWQgc3luY2hyb25vdXNseSBhbmQgaW4gb3JkZXIuXG4gKiAzLiBZb3UgY2FuIHVzZSByYWlzZUV2ZW50c0F0UGF0aCBhbmQgcmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aCB0byBlbnN1cmUgb25seSByZWxldmFudCBwcmV2aW91c2x5LXF1ZXVlZFxuICogICAgZXZlbnRzIGFyZSByYWlzZWQgc3luY2hyb25vdXNseS5cbiAqXG4gKiBOT1RFOiBUaGlzIGNhbiBhbGwgZ28gYXdheSBpZi93aGVuIHdlIG1vdmUgdG8gYXN5bmMgZXZlbnRzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRXZlbnRRdWV1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudFF1ZXVlKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48RXZlbnRMaXN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRMaXN0c18gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrcyByZWN1cnNpb24gZGVwdGggb2YgcmFpc2VRdWV1ZWRFdmVudHNfLCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7IW51bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVjdXJzaW9uRGVwdGhfID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshQXJyYXkuPEV2ZW50Pn0gZXZlbnREYXRhTGlzdCBUaGUgbmV3IGV2ZW50cyB0byBxdWV1ZS5cbiAgICAgKi9cbiAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5xdWV1ZUV2ZW50cyA9IGZ1bmN0aW9uIChldmVudERhdGFMaXN0KSB7XG4gICAgICAgIC8vIFdlIGdyb3VwIGV2ZW50cyBieSBwYXRoLCBzdG9yaW5nIHRoZW0gaW4gYSBzaW5nbGUgRXZlbnRMaXN0LCB0byBtYWtlIGl0IGVhc2llciB0byBza2lwIG92ZXIgdGhlbSBxdWlja2x5LlxuICAgICAgICB2YXIgY3Vyckxpc3QgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50RGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSBldmVudERhdGFMaXN0W2ldO1xuICAgICAgICAgICAgdmFyIGV2ZW50UGF0aCA9IGV2ZW50RGF0YS5nZXRQYXRoKCk7XG4gICAgICAgICAgICBpZiAoY3Vyckxpc3QgIT09IG51bGwgJiYgIWV2ZW50UGF0aC5lcXVhbHMoY3Vyckxpc3QuZ2V0UGF0aCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0c18ucHVzaChjdXJyTGlzdCk7XG4gICAgICAgICAgICAgICAgY3Vyckxpc3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJMaXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3Vyckxpc3QgPSBuZXcgRXZlbnRMaXN0KGV2ZW50UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyTGlzdC5hZGQoZXZlbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Vyckxpc3QpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0c18ucHVzaChjdXJyTGlzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFF1ZXVlcyB0aGUgc3BlY2lmaWVkIGV2ZW50cyBhbmQgc3luY2hyb25vdXNseSByYWlzZXMgYWxsIGV2ZW50cyAoaW5jbHVkaW5nIHByZXZpb3VzbHkgcXVldWVkIG9uZXMpXG4gICAgICogZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKlxuICAgICAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgbmV3IGV2ZW50cyBhcmUgYWxsIGZvciB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIFRoZSBwYXRoIHRvIHJhaXNlIGV2ZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHshQXJyYXkuPEV2ZW50Pn0gZXZlbnREYXRhTGlzdCBUaGUgbmV3IGV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5yYWlzZUV2ZW50c0F0UGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBldmVudERhdGFMaXN0KSB7XG4gICAgICAgIHRoaXMucXVldWVFdmVudHMoZXZlbnREYXRhTGlzdCk7XG4gICAgICAgIHRoaXMucmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZV8oZnVuY3Rpb24gKGV2ZW50UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50UGF0aC5lcXVhbHMocGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUXVldWVzIHRoZSBzcGVjaWZpZWQgZXZlbnRzIGFuZCBzeW5jaHJvbm91c2x5IHJhaXNlcyBhbGwgZXZlbnRzIChpbmNsdWRpbmcgcHJldmlvdXNseSBxdWV1ZWQgb25lcykgZm9yXG4gICAgICogbG9jYXRpb25zIHJlbGF0ZWQgdG8gdGhlIHNwZWNpZmllZCBjaGFuZ2UgcGF0aCAoaS5lLiBhbGwgYW5jZXN0b3JzIGFuZCBkZXNjZW5kYW50cykuXG4gICAgICpcbiAgICAgKiBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIG5ldyBldmVudHMgYXJlIGFsbCByZWxhdGVkIChhbmNlc3RvciBvciBkZXNjZW5kYW50KSB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBjaGFuZ2VkUGF0aCBUaGUgcGF0aCB0byByYWlzZSBldmVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhRXZlbnQ+fSBldmVudERhdGFMaXN0IFRoZSBldmVudHMgdG8gcmFpc2VcbiAgICAgKi9cbiAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoID0gZnVuY3Rpb24gKGNoYW5nZWRQYXRoLCBldmVudERhdGFMaXN0KSB7XG4gICAgICAgIHRoaXMucXVldWVFdmVudHMoZXZlbnREYXRhTGlzdCk7XG4gICAgICAgIHRoaXMucmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZV8oZnVuY3Rpb24gKGV2ZW50UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50UGF0aC5jb250YWlucyhjaGFuZ2VkUGF0aCkgfHwgY2hhbmdlZFBhdGguY29udGFpbnMoZXZlbnRQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbighUGF0aCk6Ym9vbGVhbn0gcHJlZGljYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5yYWlzZVF1ZXVlZEV2ZW50c01hdGNoaW5nUHJlZGljYXRlXyA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgdGhpcy5yZWN1cnNpb25EZXB0aF8rKztcbiAgICAgICAgdmFyIHNlbnRBbGwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRMaXN0c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudExpc3QgPSB0aGlzLmV2ZW50TGlzdHNfW2ldO1xuICAgICAgICAgICAgaWYgKGV2ZW50TGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFBhdGggPSBldmVudExpc3QuZ2V0UGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoZXZlbnRQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdHNfW2ldLnJhaXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0c19baV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VudEFsbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VudEFsbCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RzXyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjdXJzaW9uRGVwdGhfLS07XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRRdWV1ZTtcbn0oKSk7XG5leHBvcnRzLkV2ZW50UXVldWUgPSBFdmVudFF1ZXVlO1xuLyoqXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV2ZW50TGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudExpc3QocGF0aF8pIHtcbiAgICAgICAgdGhpcy5wYXRoXyA9IHBhdGhfO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48RXZlbnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmVudHNfID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudERhdGFcbiAgICAgKi9cbiAgICBFdmVudExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5ldmVudHNfLnB1c2goZXZlbnREYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGxpc3QgYW5kIHJhaXNlcyBlYWNoIGV2ZW50XG4gICAgICovXG4gICAgRXZlbnRMaXN0LnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB0aGlzLmV2ZW50c19baV07XG4gICAgICAgICAgICBpZiAoZXZlbnREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHNfW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRGbiA9IGV2ZW50RGF0YS5nZXRFdmVudFJ1bm5lcigpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsXzEubG9nZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5sb2coJ2V2ZW50OiAnICsgZXZlbnREYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1dGlsXzEuZXhjZXB0aW9uR3VhcmQoZXZlbnRGbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFQYXRofVxuICAgICAqL1xuICAgIEV2ZW50TGlzdC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aF87XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRMaXN0O1xufSgpKTtcbmV4cG9ydHMuRXZlbnRMaXN0ID0gRXZlbnRMaXN0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFF1ZXVlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERhdGFTbmFwc2hvdF8xID0gcmVxdWlyZShcIi4uLy4uL2FwaS9EYXRhU25hcHNob3RcIik7XG52YXIgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgcmVnaXN0cmF0aW9uIGZvciAndmFsdWUnIGV2ZW50cy5cbiAqL1xudmFyIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oIURhdGFTbmFwc2hvdCl9IGNhbGxiYWNrX1xuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKEVycm9yKX0gY2FuY2VsQ2FsbGJhY2tfXG4gICAgICogQHBhcmFtIHs/T2JqZWN0fSBjb250ZXh0X1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2tfLCBjYW5jZWxDYWxsYmFja18sIGNvbnRleHRfKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2tfO1xuICAgICAgICB0aGlzLmNhbmNlbENhbGxiYWNrXyA9IGNhbmNlbENhbGxiYWNrXztcbiAgICAgICAgdGhpcy5jb250ZXh0XyA9IGNvbnRleHRfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLnJlc3BvbmRzVG8gPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBldmVudFR5cGUgPT09ICd2YWx1ZSc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLmNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gKGNoYW5nZSwgcXVlcnkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5nZXRJbmRleCgpO1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50XzEuRGF0YUV2ZW50KCd2YWx1ZScsIHRoaXMsIG5ldyBEYXRhU25hcHNob3RfMS5EYXRhU25hcHNob3QoY2hhbmdlLnNuYXBzaG90Tm9kZSwgcXVlcnkuZ2V0UmVmKCksIGluZGV4KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLmdldEV2ZW50UnVubmVyID0gZnVuY3Rpb24gKGV2ZW50RGF0YSkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0XztcbiAgICAgICAgaWYgKGV2ZW50RGF0YS5nZXRFdmVudFR5cGUoKSA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgIHV0aWxfMi5hc3NlcnQodGhpcy5jYW5jZWxDYWxsYmFja18sICdSYWlzaW5nIGEgY2FuY2VsIGV2ZW50IG9uIGEgbGlzdGVuZXIgd2l0aCBubyBjYW5jZWwgY2FsbGJhY2snKTtcbiAgICAgICAgICAgIHZhciBjYW5jZWxDQl8xID0gdGhpcy5jYW5jZWxDYWxsYmFja187XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhhdCBlcnJvciBleGlzdHMsIHdlIGNoZWNrZWQgYWJvdmUgdGhhdCB0aGlzIGlzIGEgY2FuY2VsIGV2ZW50XG4gICAgICAgICAgICAgICAgY2FuY2VsQ0JfMS5jYWxsKGN0eCwgZXZlbnREYXRhLmVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2JfMSA9IHRoaXMuY2FsbGJhY2tfO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYl8xLmNhbGwoY3R4LCBldmVudERhdGEuc25hcHNob3QpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uLnByb3RvdHlwZS5jcmVhdGVDYW5jZWxFdmVudCA9IGZ1bmN0aW9uIChlcnJvciwgcGF0aCkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxDYWxsYmFja18pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRfMS5DYW5jZWxFdmVudCh0aGlzLCBlcnJvciwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3RoZXIuY2FsbGJhY2tfIHx8ICF0aGlzLmNhbGxiYWNrXykge1xuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3ZSBjb25zaWRlciBpdCB0byBtYXRjaCBhbnkgY2FsbGJhY2suXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAob3RoZXIuY2FsbGJhY2tfID09PSB0aGlzLmNhbGxiYWNrXyAmJiBvdGhlci5jb250ZXh0XyA9PT0gdGhpcy5jb250ZXh0Xyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUuaGFzQW55Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrXyAhPT0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uO1xufSgpKTtcbmV4cG9ydHMuVmFsdWVFdmVudFJlZ2lzdHJhdGlvbiA9IFZhbHVlRXZlbnRSZWdpc3RyYXRpb247XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHJlZ2lzdHJhdGlvbiBvZiAxIG9yIG1vcmUgY2hpbGRfeHh4IGV2ZW50cy5cbiAqXG4gKiBDdXJyZW50bHksIGl0IGlzIGFsd2F5cyBleGFjdGx5IDEgY2hpbGRfeHh4IGV2ZW50LCBidXQgdGhlIGlkZWEgaXMgd2UgbWlnaHQgbGV0IHlvdVxuICogcmVnaXN0ZXIgYSBncm91cCBvZiBjYWxsYmFja3MgdG9nZXRoZXIgaW4gdGhlIGZ1dHVyZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtFdmVudFJlZ2lzdHJhdGlvbn1cbiAqL1xudmFyIENoaWxkRXZlbnRSZWdpc3RyYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uKCFEYXRhU25hcHNob3QsID9zdHJpbmc9KT59IGNhbGxiYWNrc19cbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbihFcnJvcil9IGNhbmNlbENhbGxiYWNrX1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dF9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKGNhbGxiYWNrc18sIGNhbmNlbENhbGxiYWNrXywgY29udGV4dF8pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3NfID0gY2FsbGJhY2tzXztcbiAgICAgICAgdGhpcy5jYW5jZWxDYWxsYmFja18gPSBjYW5jZWxDYWxsYmFja187XG4gICAgICAgIHRoaXMuY29udGV4dF8gPSBjb250ZXh0XztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uLnByb3RvdHlwZS5yZXNwb25kc1RvID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICB2YXIgZXZlbnRUb0NoZWNrID0gZXZlbnRUeXBlID09PSAnY2hpbGRyZW5fYWRkZWQnID8gJ2NoaWxkX2FkZGVkJyA6IGV2ZW50VHlwZTtcbiAgICAgICAgZXZlbnRUb0NoZWNrID1cbiAgICAgICAgICAgIGV2ZW50VG9DaGVjayA9PT0gJ2NoaWxkcmVuX3JlbW92ZWQnID8gJ2NoaWxkX3JlbW92ZWQnIDogZXZlbnRUb0NoZWNrO1xuICAgICAgICByZXR1cm4gdXRpbF8xLmNvbnRhaW5zKHRoaXMuY2FsbGJhY2tzXywgZXZlbnRUb0NoZWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUuY3JlYXRlQ2FuY2VsRXZlbnQgPSBmdW5jdGlvbiAoZXJyb3IsIHBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsQ2FsbGJhY2tfKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50XzEuQ2FuY2VsRXZlbnQodGhpcywgZXJyb3IsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUuY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiAoY2hhbmdlLCBxdWVyeSkge1xuICAgICAgICB1dGlsXzIuYXNzZXJ0KGNoYW5nZS5jaGlsZE5hbWUgIT0gbnVsbCwgJ0NoaWxkIGV2ZW50cyBzaG91bGQgaGF2ZSBhIGNoaWxkTmFtZS4nKTtcbiAgICAgICAgdmFyIHJlZiA9IHF1ZXJ5LmdldFJlZigpLmNoaWxkKC8qKiBAdHlwZSB7IXN0cmluZ30gKi8gKGNoYW5nZS5jaGlsZE5hbWUpKTtcbiAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5nZXRJbmRleCgpO1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50XzEuRGF0YUV2ZW50KGNoYW5nZS50eXBlLCB0aGlzLCBuZXcgRGF0YVNuYXBzaG90XzEuRGF0YVNuYXBzaG90KGNoYW5nZS5zbmFwc2hvdE5vZGUsIHJlZiwgaW5kZXgpLCBjaGFuZ2UucHJldk5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uLnByb3RvdHlwZS5nZXRFdmVudFJ1bm5lciA9IGZ1bmN0aW9uIChldmVudERhdGEpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dF87XG4gICAgICAgIGlmIChldmVudERhdGEuZ2V0RXZlbnRUeXBlKCkgPT09ICdjYW5jZWwnKSB7XG4gICAgICAgICAgICB1dGlsXzIuYXNzZXJ0KHRoaXMuY2FuY2VsQ2FsbGJhY2tfLCAnUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrJyk7XG4gICAgICAgICAgICB2YXIgY2FuY2VsQ0JfMiA9IHRoaXMuY2FuY2VsQ2FsbGJhY2tfO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoYXQgZXJyb3IgZXhpc3RzLCB3ZSBjaGVja2VkIGFib3ZlIHRoYXQgdGhpcyBpcyBhIGNhbmNlbCBldmVudFxuICAgICAgICAgICAgICAgIGNhbmNlbENCXzIuY2FsbChjdHgsIGV2ZW50RGF0YS5lcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNiXzIgPSB0aGlzLmNhbGxiYWNrc19bZXZlbnREYXRhLmV2ZW50VHlwZV07XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNiXzIuY2FsbChjdHgsIGV2ZW50RGF0YS5zbmFwc2hvdCwgZXZlbnREYXRhLnByZXZOYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzXyB8fCAhb3RoZXIuY2FsbGJhY2tzXykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZXh0XyA9PT0gb3RoZXIuY29udGV4dF8pIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJDb3VudCA9IHV0aWxfMS5nZXRDb3VudChvdGhlci5jYWxsYmFja3NfKTtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0NvdW50ID0gdXRpbF8xLmdldENvdW50KHRoaXMuY2FsbGJhY2tzXyk7XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyQ291bnQgPT09IHRoaXNDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb3VudCBpcyAxLCBkbyBhbiBleGFjdCBtYXRjaCBvbiBldmVudFR5cGUsIGlmIGVpdGhlciBpcyBkZWZpbmVkIGJ1dCBudWxsLCBpdCdzIGEgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIC8vICBJZiBldmVudCB0eXBlcyBkb24ndCBtYXRjaCwgbm90IGEgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgY291bnQgaXMgbm90IDEsIGV4YWN0IG1hdGNoIGFjcm9zcyBhbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlcktleSAvKiogQHR5cGUgeyFzdHJpbmd9ICovID0gdXRpbF8xLmdldEFueUtleShvdGhlci5jYWxsYmFja3NfKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGlzS2V5IC8qKiBAdHlwZSB7IXN0cmluZ30gKi8gPSB1dGlsXzEuZ2V0QW55S2V5KHRoaXMuY2FsbGJhY2tzXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXNLZXkgPT09IG90aGVyS2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFvdGhlci5jYWxsYmFja3NfW290aGVyS2V5XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5jYWxsYmFja3NfW3RoaXNLZXldIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLmNhbGxiYWNrc19bb3RoZXJLZXldID09PSB0aGlzLmNhbGxiYWNrc19bdGhpc0tleV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4YWN0IG1hdGNoIG9uIGVhY2gga2V5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5ldmVyeSh0aGlzLmNhbGxiYWNrc18sIGZ1bmN0aW9uIChldmVudFR5cGUsIGNiKSB7IHJldHVybiBvdGhlci5jYWxsYmFja3NfW2V2ZW50VHlwZV0gPT09IGNiOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENoaWxkRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLmhhc0FueUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsYmFja3NfICE9PSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIENoaWxkRXZlbnRSZWdpc3RyYXRpb247XG59KCkpO1xuZXhwb3J0cy5DaGlsZEV2ZW50UmVnaXN0cmF0aW9uID0gQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRSZWdpc3RyYXRpb24uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuLi91dGlsL3V0aWxcIik7XG52YXIgS2V5SW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9zbmFwL2luZGV4ZXMvS2V5SW5kZXhcIik7XG52YXIgUHJpb3JpdHlJbmRleF8xID0gcmVxdWlyZShcIi4uL3NuYXAvaW5kZXhlcy9Qcmlvcml0eUluZGV4XCIpO1xudmFyIFZhbHVlSW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9zbmFwL2luZGV4ZXMvVmFsdWVJbmRleFwiKTtcbnZhciBQYXRoSW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9zbmFwL2luZGV4ZXMvUGF0aEluZGV4XCIpO1xudmFyIEluZGV4ZWRGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlci9JbmRleGVkRmlsdGVyXCIpO1xudmFyIExpbWl0ZWRGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlci9MaW1pdGVkRmlsdGVyXCIpO1xudmFyIFJhbmdlZEZpbHRlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyL1JhbmdlZEZpbHRlclwiKTtcbnZhciB1dGlsXzMgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgYW4gaW1tdXRhYmxlLWZyb20tdGhlLXB1YmxpYy1hcGkgc3RydWN0IGNvbnRhaW5pbmcgYSBzZXQgb2YgcXVlcnkgcGFyYW1ldGVycyBkZWZpbmluZyBhXG4gKiByYW5nZSB0byBiZSByZXR1cm5lZCBmb3IgYSBwYXJ0aWN1bGFyIGxvY2F0aW9uLiBJdCBpcyBhc3N1bWVkIHRoYXQgdmFsaWRhdGlvbiBvZiBwYXJhbWV0ZXJzIGlzIGRvbmUgYXQgdGhlXG4gKiB1c2VyLWZhY2luZyBBUEkgbGV2ZWwsIHNvIGl0IGlzIG5vdCBkb25lIGhlcmUuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFF1ZXJ5UGFyYW1zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1ZXJ5UGFyYW1zKCkge1xuICAgICAgICB0aGlzLmxpbWl0U2V0XyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0U2V0XyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0TmFtZVNldF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmRTZXRfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kTmFtZVNldF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW1pdF8gPSAwO1xuICAgICAgICB0aGlzLnZpZXdGcm9tXyA9ICcnO1xuICAgICAgICB0aGlzLmluZGV4U3RhcnRWYWx1ZV8gPSBudWxsO1xuICAgICAgICB0aGlzLmluZGV4U3RhcnROYW1lXyA9ICcnO1xuICAgICAgICB0aGlzLmluZGV4RW5kVmFsdWVfID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmRleEVuZE5hbWVfID0gJyc7XG4gICAgICAgIHRoaXMuaW5kZXhfID0gUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5oYXNTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTZXRfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBpdCB3b3VsZCByZXR1cm4gZnJvbSBsZWZ0LlxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5pc1ZpZXdGcm9tTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld0Zyb21fID09PSAnJykge1xuICAgICAgICAgICAgLy8gbGltaXQoKSwgcmF0aGVyIHRoYW4gbGltaXRUb0ZpcnN0IG9yIGxpbWl0VG9MYXN0IHdhcyBjYWxsZWQuXG4gICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgb25seSBvbmUgb2Ygc3RhcnRTZXRfIGFuZCBlbmRTZXRfIGlzIHRydWUuIFVzZSB0aGVtXG4gICAgICAgICAgICAvLyB0byBjYWxjdWxhdGUgd2hpY2ggc2lkZSBvZiB0aGUgdmlldyB0byBhbmNob3IgdG8uIElmIG5laXRoZXIgaXMgc2V0LFxuICAgICAgICAgICAgLy8gYW5jaG9yIHRvIHRoZSBlbmQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNldF87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmlld0Zyb21fID09PSBRdWVyeVBhcmFtcy5XSVJFX1BST1RPQ09MX0NPTlNUQU5UU18uVklFV19GUk9NX0xFRlQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzU3RhcnQoKSByZXR1cm5zIHRydWVcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5nZXRJbmRleFN0YXJ0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodGhpcy5zdGFydFNldF8sICdPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFN0YXJ0VmFsdWVfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc1N0YXJ0KCkgcmV0dXJucyB0cnVlLlxuICAgICAqIFJldHVybnMgdGhlIHN0YXJ0aW5nIGtleSBuYW1lIGZvciB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGVzZSBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybiB7IXN0cmluZ31cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuZ2V0SW5kZXhTdGFydE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodGhpcy5zdGFydFNldF8sICdPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldCcpO1xuICAgICAgICBpZiAodGhpcy5zdGFydE5hbWVTZXRfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleFN0YXJ0TmFtZV87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8yLk1JTl9OQU1FO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5oYXNFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZFNldF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzRW5kKCkgcmV0dXJucyB0cnVlLlxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmdldEluZGV4RW5kVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodGhpcy5lbmRTZXRfLCAnT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4RW5kVmFsdWVfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc0VuZCgpIHJldHVybnMgdHJ1ZS5cbiAgICAgKiBSZXR1cm5zIHRoZSBlbmQga2V5IG5hbWUgZm9yIHRoZSByYW5nZSBkZWZpbmVkIGJ5IHRoZXNlIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJuIHshc3RyaW5nfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5nZXRJbmRleEVuZE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodGhpcy5lbmRTZXRfLCAnT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0Jyk7XG4gICAgICAgIGlmICh0aGlzLmVuZE5hbWVTZXRfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleEVuZE5hbWVfO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMi5NQVhfTkFNRTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuaGFzTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0U2V0XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBsaW1pdCBoYXMgYmVlbiBzZXQgYW5kIGl0IGhhcyBiZWVuIGV4cGxpY2l0bHkgYW5jaG9yZWRcbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuaGFzQW5jaG9yZWRMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXRTZXRfICYmIHRoaXMudmlld0Zyb21fICE9PSAnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNMaW1pdCgpIHJldHVybnMgdHJ1ZVxuICAgICAqIEByZXR1cm4geyFudW1iZXJ9XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmdldExpbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMubGltaXRTZXRfLCAnT25seSB2YWxpZCBpZiBsaW1pdCBoYXMgYmVlbiBzZXQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXRfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IUluZGV4fVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmNvcHlfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBRdWVyeVBhcmFtcygpO1xuICAgICAgICBjb3B5LmxpbWl0U2V0XyA9IHRoaXMubGltaXRTZXRfO1xuICAgICAgICBjb3B5LmxpbWl0XyA9IHRoaXMubGltaXRfO1xuICAgICAgICBjb3B5LnN0YXJ0U2V0XyA9IHRoaXMuc3RhcnRTZXRfO1xuICAgICAgICBjb3B5LmluZGV4U3RhcnRWYWx1ZV8gPSB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XG4gICAgICAgIGNvcHkuc3RhcnROYW1lU2V0XyA9IHRoaXMuc3RhcnROYW1lU2V0XztcbiAgICAgICAgY29weS5pbmRleFN0YXJ0TmFtZV8gPSB0aGlzLmluZGV4U3RhcnROYW1lXztcbiAgICAgICAgY29weS5lbmRTZXRfID0gdGhpcy5lbmRTZXRfO1xuICAgICAgICBjb3B5LmluZGV4RW5kVmFsdWVfID0gdGhpcy5pbmRleEVuZFZhbHVlXztcbiAgICAgICAgY29weS5lbmROYW1lU2V0XyA9IHRoaXMuZW5kTmFtZVNldF87XG4gICAgICAgIGNvcHkuaW5kZXhFbmROYW1lXyA9IHRoaXMuaW5kZXhFbmROYW1lXztcbiAgICAgICAgY29weS5pbmRleF8gPSB0aGlzLmluZGV4XztcbiAgICAgICAgY29weS52aWV3RnJvbV8gPSB0aGlzLnZpZXdGcm9tXztcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IG5ld0xpbWl0XG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5saW1pdCA9IGZ1bmN0aW9uIChuZXdMaW1pdCkge1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gdGhpcy5jb3B5XygpO1xuICAgICAgICBuZXdQYXJhbXMubGltaXRTZXRfID0gdHJ1ZTtcbiAgICAgICAgbmV3UGFyYW1zLmxpbWl0XyA9IG5ld0xpbWl0O1xuICAgICAgICBuZXdQYXJhbXMudmlld0Zyb21fID0gJyc7XG4gICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IG5ld0xpbWl0XG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5saW1pdFRvRmlyc3QgPSBmdW5jdGlvbiAobmV3TGltaXQpIHtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMuY29weV8oKTtcbiAgICAgICAgbmV3UGFyYW1zLmxpbWl0U2V0XyA9IHRydWU7XG4gICAgICAgIG5ld1BhcmFtcy5saW1pdF8gPSBuZXdMaW1pdDtcbiAgICAgICAgbmV3UGFyYW1zLnZpZXdGcm9tXyA9IFF1ZXJ5UGFyYW1zLldJUkVfUFJPVE9DT0xfQ09OU1RBTlRTXy5WSUVXX0ZST01fTEVGVDtcbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gbmV3TGltaXRcbiAgICAgKiBAcmV0dXJuIHshUXVlcnlQYXJhbXN9XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmxpbWl0VG9MYXN0ID0gZnVuY3Rpb24gKG5ld0xpbWl0KSB7XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSB0aGlzLmNvcHlfKCk7XG4gICAgICAgIG5ld1BhcmFtcy5saW1pdFNldF8gPSB0cnVlO1xuICAgICAgICBuZXdQYXJhbXMubGltaXRfID0gbmV3TGltaXQ7XG4gICAgICAgIG5ld1BhcmFtcy52aWV3RnJvbV8gPSBRdWVyeVBhcmFtcy5XSVJFX1BST1RPQ09MX0NPTlNUQU5UU18uVklFV19GUk9NX1JJR0hUO1xuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbmRleFZhbHVlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5XG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5zdGFydEF0ID0gZnVuY3Rpb24gKGluZGV4VmFsdWUsIGtleSkge1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gdGhpcy5jb3B5XygpO1xuICAgICAgICBuZXdQYXJhbXMuc3RhcnRTZXRfID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEoaW5kZXhWYWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgaW5kZXhWYWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbmV3UGFyYW1zLmluZGV4U3RhcnRWYWx1ZV8gPSBpbmRleFZhbHVlO1xuICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5zdGFydE5hbWVTZXRfID0gdHJ1ZTtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3UGFyYW1zLmluZGV4U3RhcnROYW1lXyA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGluZGV4VmFsdWVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmc9fSBrZXlcbiAgICAgKiBAcmV0dXJuIHshUXVlcnlQYXJhbXN9XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmVuZEF0ID0gZnVuY3Rpb24gKGluZGV4VmFsdWUsIGtleSkge1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gdGhpcy5jb3B5XygpO1xuICAgICAgICBuZXdQYXJhbXMuZW5kU2V0XyA9IHRydWU7XG4gICAgICAgIGlmICghKGluZGV4VmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5ld1BhcmFtcy5pbmRleEVuZFZhbHVlXyA9IGluZGV4VmFsdWU7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3UGFyYW1zLmVuZE5hbWVTZXRfID0gdHJ1ZTtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5pbmRleEVuZE5hbWVfID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3UGFyYW1zLmVuZE5hbWVTZXRfID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmROYW1lXyA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHshUXVlcnlQYXJhbXN9XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLm9yZGVyQnkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMuY29weV8oKTtcbiAgICAgICAgbmV3UGFyYW1zLmluZGV4XyA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuZ2V0UXVlcnlPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUyA9IFF1ZXJ5UGFyYW1zLldJUkVfUFJPVE9DT0xfQ09OU1RBTlRTXztcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBpZiAodGhpcy5zdGFydFNldF8pIHtcbiAgICAgICAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9TVEFSVF9WQUxVRV0gPSB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydE5hbWVTZXRfKSB7XG4gICAgICAgICAgICAgICAgb2JqW1dJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX1NUQVJUX05BTUVdID0gdGhpcy5pbmRleFN0YXJ0TmFtZV87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW5kU2V0Xykge1xuICAgICAgICAgICAgb2JqW1dJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX0VORF9WQUxVRV0gPSB0aGlzLmluZGV4RW5kVmFsdWVfO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5kTmFtZVNldF8pIHtcbiAgICAgICAgICAgICAgICBvYmpbV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfRU5EX05BTUVdID0gdGhpcy5pbmRleEVuZE5hbWVfO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbWl0U2V0Xykge1xuICAgICAgICAgICAgb2JqW1dJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLkxJTUlUXSA9IHRoaXMubGltaXRfO1xuICAgICAgICAgICAgdmFyIHZpZXdGcm9tID0gdGhpcy52aWV3RnJvbV87XG4gICAgICAgICAgICBpZiAodmlld0Zyb20gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWaWV3RnJvbUxlZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9MRUZUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld0Zyb20gPSBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fUklHSFQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW1dJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV0gPSB2aWV3RnJvbTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3Igbm93LCBwcmlvcml0eSBpbmRleCBpcyB0aGUgZGVmYXVsdCwgc28gd2Ugb25seSBzcGVjaWZ5IGlmIGl0J3Mgc29tZSBvdGhlciBpbmRleFxuICAgICAgICBpZiAodGhpcy5pbmRleF8gIT09IFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCkge1xuICAgICAgICAgICAgb2JqW1dJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYXSA9IHRoaXMuaW5kZXhfLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmxvYWRzQWxsRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5zdGFydFNldF8gfHwgdGhpcy5lbmRTZXRfIHx8IHRoaXMubGltaXRTZXRfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmlzRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZHNBbGxEYXRhKCkgJiYgdGhpcy5pbmRleF8gPT0gUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IU5vZGVGaWx0ZXJ9XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmdldE5vZGVGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRzQWxsRGF0YSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWRGaWx0ZXJfMS5JbmRleGVkRmlsdGVyKHRoaXMuZ2V0SW5kZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNMaW1pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbWl0ZWRGaWx0ZXJfMS5MaW1pdGVkRmlsdGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZWRGaWx0ZXJfMS5SYW5nZWRGaWx0ZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzZXQgb2YgUkVTVCBxdWVyeSBzdHJpbmcgcGFyYW1ldGVycyByZXByZXNlbnRpbmcgdGhpcyBxdWVyeS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyFPYmplY3QuPHN0cmluZywqPn0gcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUudG9SZXN0UXVlcnlTdHJpbmdQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgUkVTVF9DT05TVEFOVFMgPSBRdWVyeVBhcmFtcy5SRVNUX1FVRVJZX0NPTlNUQU5UU187XG4gICAgICAgIHZhciBxcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5pc0RlZmF1bHQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHFzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmRlckJ5O1xuICAgICAgICBpZiAodGhpcy5pbmRleF8gPT09IFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCkge1xuICAgICAgICAgICAgb3JkZXJCeSA9IFJFU1RfQ09OU1RBTlRTLlBSSU9SSVRZX0lOREVYO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXhfID09PSBWYWx1ZUluZGV4XzEuVkFMVUVfSU5ERVgpIHtcbiAgICAgICAgICAgIG9yZGVyQnkgPSBSRVNUX0NPTlNUQU5UUy5WQUxVRV9JTkRFWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4XyA9PT0gS2V5SW5kZXhfMS5LRVlfSU5ERVgpIHtcbiAgICAgICAgICAgIG9yZGVyQnkgPSBSRVNUX0NPTlNUQU5UUy5LRVlfSU5ERVg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMuaW5kZXhfIGluc3RhbmNlb2YgUGF0aEluZGV4XzEuUGF0aEluZGV4LCAnVW5yZWNvZ25pemVkIGluZGV4IHR5cGUhJyk7XG4gICAgICAgICAgICBvcmRlckJ5ID0gdGhpcy5pbmRleF8udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBxc1tSRVNUX0NPTlNUQU5UUy5PUkRFUl9CWV0gPSB1dGlsXzMuc3RyaW5naWZ5KG9yZGVyQnkpO1xuICAgICAgICBpZiAodGhpcy5zdGFydFNldF8pIHtcbiAgICAgICAgICAgIHFzW1JFU1RfQ09OU1RBTlRTLlNUQVJUX0FUXSA9IHV0aWxfMy5zdHJpbmdpZnkodGhpcy5pbmRleFN0YXJ0VmFsdWVfKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0TmFtZVNldF8pIHtcbiAgICAgICAgICAgICAgICBxc1tSRVNUX0NPTlNUQU5UUy5TVEFSVF9BVF0gKz0gJywnICsgdXRpbF8zLnN0cmluZ2lmeSh0aGlzLmluZGV4U3RhcnROYW1lXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW5kU2V0Xykge1xuICAgICAgICAgICAgcXNbUkVTVF9DT05TVEFOVFMuRU5EX0FUXSA9IHV0aWxfMy5zdHJpbmdpZnkodGhpcy5pbmRleEVuZFZhbHVlXyk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmROYW1lU2V0Xykge1xuICAgICAgICAgICAgICAgIHFzW1JFU1RfQ09OU1RBTlRTLkVORF9BVF0gKz0gJywnICsgdXRpbF8zLnN0cmluZ2lmeSh0aGlzLmluZGV4RW5kTmFtZV8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbWl0U2V0Xykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWaWV3RnJvbUxlZnQoKSkge1xuICAgICAgICAgICAgICAgIHFzW1JFU1RfQ09OU1RBTlRTLkxJTUlUX1RPX0ZJUlNUXSA9IHRoaXMubGltaXRfO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXNbUkVTVF9DT05TVEFOVFMuTElNSVRfVE9fTEFTVF0gPSB0aGlzLmxpbWl0XztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaXJlIFByb3RvY29sIENvbnN0YW50c1xuICAgICAqIEBjb25zdFxuICAgICAqIEBlbnVtIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5XSVJFX1BST1RPQ09MX0NPTlNUQU5UU18gPSB7XG4gICAgICAgIElOREVYX1NUQVJUX1ZBTFVFOiAnc3AnLFxuICAgICAgICBJTkRFWF9TVEFSVF9OQU1FOiAnc24nLFxuICAgICAgICBJTkRFWF9FTkRfVkFMVUU6ICdlcCcsXG4gICAgICAgIElOREVYX0VORF9OQU1FOiAnZW4nLFxuICAgICAgICBMSU1JVDogJ2wnLFxuICAgICAgICBWSUVXX0ZST006ICd2ZicsXG4gICAgICAgIFZJRVdfRlJPTV9MRUZUOiAnbCcsXG4gICAgICAgIFZJRVdfRlJPTV9SSUdIVDogJ3InLFxuICAgICAgICBJTkRFWDogJ2knXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSRVNUIFF1ZXJ5IENvbnN0YW50c1xuICAgICAqIEBjb25zdFxuICAgICAqIEBlbnVtIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5SRVNUX1FVRVJZX0NPTlNUQU5UU18gPSB7XG4gICAgICAgIE9SREVSX0JZOiAnb3JkZXJCeScsXG4gICAgICAgIFBSSU9SSVRZX0lOREVYOiAnJHByaW9yaXR5JyxcbiAgICAgICAgVkFMVUVfSU5ERVg6ICckdmFsdWUnLFxuICAgICAgICBLRVlfSU5ERVg6ICcka2V5JyxcbiAgICAgICAgU1RBUlRfQVQ6ICdzdGFydEF0JyxcbiAgICAgICAgRU5EX0FUOiAnZW5kQXQnLFxuICAgICAgICBMSU1JVF9UT19GSVJTVDogJ2xpbWl0VG9GaXJzdCcsXG4gICAgICAgIExJTUlUX1RPX0xBU1Q6ICdsaW1pdFRvTGFzdCdcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQsIGVtcHR5IHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICAgKiBAdHlwZSB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqIEBjb25zdFxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLkRFRkFVTFQgPSBuZXcgUXVlcnlQYXJhbXMoKTtcbiAgICByZXR1cm4gUXVlcnlQYXJhbXM7XG59KCkpO1xuZXhwb3J0cy5RdWVyeVBhcmFtcyA9IFF1ZXJ5UGFyYW1zO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWVyeVBhcmFtcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJbmRleGVkRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXIvSW5kZXhlZEZpbHRlclwiKTtcbnZhciBWaWV3UHJvY2Vzc29yXzEgPSByZXF1aXJlKFwiLi9WaWV3UHJvY2Vzc29yXCIpO1xudmFyIENoaWxkcmVuTm9kZV8xID0gcmVxdWlyZShcIi4uL3NuYXAvQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIENhY2hlTm9kZV8xID0gcmVxdWlyZShcIi4vQ2FjaGVOb2RlXCIpO1xudmFyIFZpZXdDYWNoZV8xID0gcmVxdWlyZShcIi4vVmlld0NhY2hlXCIpO1xudmFyIEV2ZW50R2VuZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9FdmVudEdlbmVyYXRvclwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgT3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vb3BlcmF0aW9uL09wZXJhdGlvblwiKTtcbnZhciBDaGFuZ2VfMSA9IHJlcXVpcmUoXCIuL0NoYW5nZVwiKTtcbnZhciBQcmlvcml0eUluZGV4XzEgPSByZXF1aXJlKFwiLi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG4vKipcbiAqIEEgdmlldyByZXByZXNlbnRzIGEgc3BlY2lmaWMgbG9jYXRpb24gYW5kIHF1ZXJ5IHRoYXQgaGFzIDEgb3IgbW9yZSBldmVudCByZWdpc3RyYXRpb25zLlxuICpcbiAqIEl0IGRvZXMgc2V2ZXJhbCB0aGluZ3M6XG4gKiAgLSBNYWludGFpbnMgdGhlIGxpc3Qgb2YgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBsb2NhdGlvbi9xdWVyeS5cbiAqICAtIE1haW50YWlucyBhIGNhY2hlIG9mIHRoZSBkYXRhIHZpc2libGUgZm9yIHRoaXMgbG9jYXRpb24vcXVlcnkuXG4gKiAgLSBBcHBsaWVzIG5ldyBvcGVyYXRpb25zICh2aWEgYXBwbHlPcGVyYXRpb24pLCB1cGRhdGVzIHRoZSBjYWNoZSwgYW5kIGJhc2VkIG9uIHRoZSBldmVudFxuICogICAgcmVnaXN0cmF0aW9ucyByZXR1cm5zIHRoZSBzZXQgb2YgZXZlbnRzIHRvIGJlIHJhaXNlZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeV9cbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IGluaXRpYWxWaWV3Q2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3KHF1ZXJ5XywgaW5pdGlhbFZpZXdDYWNoZSkge1xuICAgICAgICB0aGlzLnF1ZXJ5XyA9IHF1ZXJ5XztcbiAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfID0gW107XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnF1ZXJ5Xy5nZXRRdWVyeVBhcmFtcygpO1xuICAgICAgICB2YXIgaW5kZXhGaWx0ZXIgPSBuZXcgSW5kZXhlZEZpbHRlcl8xLkluZGV4ZWRGaWx0ZXIocGFyYW1zLmdldEluZGV4KCkpO1xuICAgICAgICB2YXIgZmlsdGVyID0gcGFyYW1zLmdldE5vZGVGaWx0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtWaWV3UHJvY2Vzc29yfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9jZXNzb3JfID0gbmV3IFZpZXdQcm9jZXNzb3JfMS5WaWV3UHJvY2Vzc29yKGZpbHRlcik7XG4gICAgICAgIHZhciBpbml0aWFsU2VydmVyQ2FjaGUgPSBpbml0aWFsVmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCk7XG4gICAgICAgIHZhciBpbml0aWFsRXZlbnRDYWNoZSA9IGluaXRpYWxWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpO1xuICAgICAgICAvLyBEb24ndCBmaWx0ZXIgc2VydmVyIG5vZGUgd2l0aCBvdGhlciBmaWx0ZXIgdGhhbiBpbmRleCwgd2FpdCBmb3IgdGFnZ2VkIGxpc3RlblxuICAgICAgICB2YXIgc2VydmVyU25hcCA9IGluZGV4RmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBpbml0aWFsU2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLCBudWxsKTtcbiAgICAgICAgdmFyIGV2ZW50U25hcCA9IGZpbHRlci51cGRhdGVGdWxsTm9kZShDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgaW5pdGlhbEV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBudWxsKTtcbiAgICAgICAgdmFyIG5ld1NlcnZlckNhY2hlID0gbmV3IENhY2hlTm9kZV8xLkNhY2hlTm9kZShzZXJ2ZXJTbmFwLCBpbml0aWFsU2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCksIGluZGV4RmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcbiAgICAgICAgdmFyIG5ld0V2ZW50Q2FjaGUgPSBuZXcgQ2FjaGVOb2RlXzEuQ2FjaGVOb2RlKGV2ZW50U25hcCwgaW5pdGlhbEV2ZW50Q2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCksIGZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVZpZXdDYWNoZX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld0NhY2hlXyA9IG5ldyBWaWV3Q2FjaGVfMS5WaWV3Q2FjaGUobmV3RXZlbnRDYWNoZSwgbmV3U2VydmVyQ2FjaGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFFdmVudEdlbmVyYXRvcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRHZW5lcmF0b3JfID0gbmV3IEV2ZW50R2VuZXJhdG9yXzEuRXZlbnRHZW5lcmF0b3IodGhpcy5xdWVyeV8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAgICovXG4gICAgVmlldy5wcm90b3R5cGUuZ2V0UXVlcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFZpZXcucHJvdG90eXBlLmdldFNlcnZlckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3Q2FjaGVfLmdldFNlcnZlckNhY2hlKCkuZ2V0Tm9kZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFZpZXcucHJvdG90eXBlLmdldENvbXBsZXRlU2VydmVyQ2FjaGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLnZpZXdDYWNoZV8uZ2V0Q29tcGxldGVTZXJ2ZXJTbmFwKCk7XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpc24ndCBhIFwibG9hZHNBbGxEYXRhXCIgdmlldywgdGhlbiBjYWNoZSBpc24ndCBhY3R1YWxseSBhIGNvbXBsZXRlIGNhY2hlIGFuZFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBzZWUgaWYgaXQgY29udGFpbnMgdGhlIGNoaWxkIHdlJ3JlIGludGVyZXN0ZWQgaW4uXG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeV8uZ2V0UXVlcnlQYXJhbXMoKS5sb2Fkc0FsbERhdGEoKSB8fFxuICAgICAgICAgICAgICAgICghcGF0aC5pc0VtcHR5KCkgJiYgIWNhY2hlLmdldEltbWVkaWF0ZUNoaWxkKHBhdGguZ2V0RnJvbnQoKSkuaXNFbXB0eSgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXRDaGlsZChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgVmlldy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFFdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgKi9cbiAgICBWaWV3LnByb3RvdHlwZS5hZGRFdmVudFJlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uIChldmVudFJlZ2lzdHJhdGlvbikge1xuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uc18ucHVzaChldmVudFJlZ2lzdHJhdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez9FdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb24gSWYgbnVsbCwgcmVtb3ZlIGFsbCBjYWxsYmFja3MuXG4gICAgICogQHBhcmFtIHtFcnJvcj19IGNhbmNlbEVycm9yIElmIGEgY2FuY2VsRXJyb3IgaXMgcHJvdmlkZWQsIGFwcHJvcHJpYXRlIGNhbmNlbCBldmVudHMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IENhbmNlbCBldmVudHMsIGlmIGNhbmNlbEVycm9yIHdhcyBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBWaWV3LnByb3RvdHlwZS5yZW1vdmVFdmVudFJlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uIChldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgdmFyIGNhbmNlbEV2ZW50cyA9IFtdO1xuICAgICAgICBpZiAoY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoZXZlbnRSZWdpc3RyYXRpb24gPT0gbnVsbCwgJ0EgY2FuY2VsIHNob3VsZCBjYW5jZWwgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMuJyk7XG4gICAgICAgICAgICB2YXIgcGF0aF8xID0gdGhpcy5xdWVyeV8ucGF0aDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxFcnJvciAvKiogQHR5cGUgeyFFcnJvcn0gKi8gPSBjYW5jZWxFcnJvcjtcbiAgICAgICAgICAgICAgICB2YXIgbWF5YmVFdmVudCA9IHJlZ2lzdHJhdGlvbi5jcmVhdGVDYW5jZWxFdmVudChjYW5jZWxFcnJvciwgcGF0aF8xKTtcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxFdmVudHMucHVzaChtYXliZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRSZWdpc3RyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfW2ldO1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcubWF0Y2hlcyhldmVudFJlZ2lzdHJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nLnB1c2goZXhpc3RpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudFJlZ2lzdHJhdGlvbi5oYXNBbnlDYWxsYmFjaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHJlbW92aW5nIGp1c3QgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLmNvbmNhdCh0aGlzLmV2ZW50UmVnaXN0cmF0aW9uc18uc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfID0gcmVtYWluaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbmNlbEV2ZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIE9wZXJhdGlvbiwgdXBkYXRlcyBvdXIgY2FjaGUsIGFuZCByZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPcGVyYXRpb259IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZVNlcnZlckNhY2hlXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgICAqL1xuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5T3BlcmF0aW9uID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25fMS5PcGVyYXRpb25UeXBlLk1FUkdFICYmXG4gICAgICAgICAgICBvcGVyYXRpb24uc291cmNlLnF1ZXJ5SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQodGhpcy52aWV3Q2FjaGVfLmdldENvbXBsZXRlU2VydmVyU25hcCgpLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzJyk7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMudmlld0NhY2hlXy5nZXRDb21wbGV0ZUV2ZW50U25hcCgpLCAnTWlzc2luZyBldmVudCBjYWNoZSwgZXZlbiB0aG91Z2ggd2UgaGF2ZSBhIHNlcnZlciBjYWNoZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRWaWV3Q2FjaGUgPSB0aGlzLnZpZXdDYWNoZV87XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnByb2Nlc3Nvcl8uYXBwbHlPcGVyYXRpb24ob2xkVmlld0NhY2hlLCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JfLmFzc2VydEluZGV4ZWQocmVzdWx0LnZpZXdDYWNoZSk7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQocmVzdWx0LnZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XG4gICAgICAgICAgICAhb2xkVmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKCksICdPbmNlIGEgc2VydmVyIHNuYXAgaXMgY29tcGxldGUsIGl0IHNob3VsZCBuZXZlciBnbyBiYWNrJyk7XG4gICAgICAgIHRoaXMudmlld0NhY2hlXyA9IHJlc3VsdC52aWV3Q2FjaGU7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18ocmVzdWx0LmNoYW5nZXMsIHJlc3VsdC52aWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmdldE5vZGUoKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFFdmVudFJlZ2lzdHJhdGlvbn0gcmVnaXN0cmF0aW9uXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgICAqL1xuICAgIFZpZXcucHJvdG90eXBlLmdldEluaXRpYWxFdmVudHMgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHZhciBldmVudFNuYXAgPSB0aGlzLnZpZXdDYWNoZV8uZ2V0RXZlbnRDYWNoZSgpO1xuICAgICAgICB2YXIgaW5pdGlhbENoYW5nZXMgPSBbXTtcbiAgICAgICAgaWYgKCFldmVudFNuYXAuZ2V0Tm9kZSgpLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50Tm9kZSA9IGV2ZW50U25hcC5nZXROb2RlKCk7XG4gICAgICAgICAgICBldmVudE5vZGUuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbENoYW5nZXMucHVzaChDaGFuZ2VfMS5DaGFuZ2UuY2hpbGRBZGRlZENoYW5nZShrZXksIGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgaW5pdGlhbENoYW5nZXMucHVzaChDaGFuZ2VfMS5DaGFuZ2UudmFsdWVDaGFuZ2UoZXZlbnRTbmFwLmdldE5vZGUoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18oaW5pdGlhbENoYW5nZXMsIGV2ZW50U25hcC5nZXROb2RlKCksIHJlZ2lzdHJhdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQ2hhbmdlPn0gY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7IU5vZGV9IGV2ZW50Q2FjaGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50UmVnaXN0cmF0aW9uPX0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICovXG4gICAgVmlldy5wcm90b3R5cGUuZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzXyA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBldmVudENhY2hlLCBldmVudFJlZ2lzdHJhdGlvbikge1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAgICAgICAgICA/IFtldmVudFJlZ2lzdHJhdGlvbl1cbiAgICAgICAgICAgIDogdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfO1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudEdlbmVyYXRvcl8uZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKGNoYW5nZXMsIGV2ZW50Q2FjaGUsIHJlZ2lzdHJhdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXc7XG59KCkpO1xuZXhwb3J0cy5WaWV3ID0gVmlldztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vmlldy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDaGlsZHJlbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9zbmFwL0NoaWxkcmVuTm9kZVwiKTtcbnZhciBDYWNoZU5vZGVfMSA9IHJlcXVpcmUoXCIuL0NhY2hlTm9kZVwiKTtcbi8qKlxuICogU3RvcmVzIHRoZSBkYXRhIHdlIGhhdmUgY2FjaGVkIGZvciBhIHZpZXcuXG4gKlxuICogc2VydmVyU25hcCBpcyB0aGUgY2FjaGVkIHNlcnZlciBkYXRhLCBldmVudFNuYXAgaXMgdGhlIGNhY2hlZCBldmVudCBkYXRhIChzZXJ2ZXIgZGF0YSBwbHVzIGFueSBsb2NhbCB3cml0ZXMpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVmlld0NhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHshQ2FjaGVOb2RlfSBldmVudENhY2hlX1xuICAgICAqIEBwYXJhbSB7IUNhY2hlTm9kZX0gc2VydmVyQ2FjaGVfXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlld0NhY2hlKGV2ZW50Q2FjaGVfLCBzZXJ2ZXJDYWNoZV8pIHtcbiAgICAgICAgdGhpcy5ldmVudENhY2hlXyA9IGV2ZW50Q2FjaGVfO1xuICAgICAgICB0aGlzLnNlcnZlckNhY2hlXyA9IHNlcnZlckNhY2hlXztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gZXZlbnRTbmFwXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb21wbGV0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsdGVyZWRcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqL1xuICAgIFZpZXdDYWNoZS5wcm90b3R5cGUudXBkYXRlRXZlbnRTbmFwID0gZnVuY3Rpb24gKGV2ZW50U25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld0NhY2hlKG5ldyBDYWNoZU5vZGVfMS5DYWNoZU5vZGUoZXZlbnRTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpLCB0aGlzLnNlcnZlckNhY2hlXyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBzZXJ2ZXJTbmFwXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb21wbGV0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsdGVyZWRcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqL1xuICAgIFZpZXdDYWNoZS5wcm90b3R5cGUudXBkYXRlU2VydmVyU25hcCA9IGZ1bmN0aW9uIChzZXJ2ZXJTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3Q2FjaGUodGhpcy5ldmVudENhY2hlXywgbmV3IENhY2hlTm9kZV8xLkNhY2hlTm9kZShzZXJ2ZXJTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFDYWNoZU5vZGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLnByb3RvdHlwZS5nZXRFdmVudENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudENhY2hlXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFZpZXdDYWNoZS5wcm90b3R5cGUuZ2V0Q29tcGxldGVFdmVudFNuYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50Q2FjaGVfLmlzRnVsbHlJbml0aWFsaXplZCgpXG4gICAgICAgICAgICA/IHRoaXMuZXZlbnRDYWNoZV8uZ2V0Tm9kZSgpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshQ2FjaGVOb2RlfVxuICAgICAqL1xuICAgIFZpZXdDYWNoZS5wcm90b3R5cGUuZ2V0U2VydmVyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlckNhY2hlXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFZpZXdDYWNoZS5wcm90b3R5cGUuZ2V0Q29tcGxldGVTZXJ2ZXJTbmFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJDYWNoZV8uaXNGdWxseUluaXRpYWxpemVkKClcbiAgICAgICAgICAgID8gdGhpcy5zZXJ2ZXJDYWNoZV8uZ2V0Tm9kZSgpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7Vmlld0NhY2hlfVxuICAgICAqL1xuICAgIFZpZXdDYWNoZS5FbXB0eSA9IG5ldyBWaWV3Q2FjaGUobmV3IENhY2hlTm9kZV8xLkNhY2hlTm9kZShDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgXG4gICAgLypmdWxseUluaXRpYWxpemVkPSovIGZhbHNlLCBcbiAgICAvKmZpbHRlcmVkPSovIGZhbHNlKSwgbmV3IENhY2hlTm9kZV8xLkNhY2hlTm9kZShDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgXG4gICAgLypmdWxseUluaXRpYWxpemVkPSovIGZhbHNlLCBcbiAgICAvKmZpbHRlcmVkPSovIGZhbHNlKSk7XG4gICAgcmV0dXJuIFZpZXdDYWNoZTtcbn0oKSk7XG5leHBvcnRzLlZpZXdDYWNoZSA9IFZpZXdDYWNoZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vmlld0NhY2hlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4uL29wZXJhdGlvbi9PcGVyYXRpb25cIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIENoaWxkQ2hhbmdlQWNjdW11bGF0b3JfMSA9IHJlcXVpcmUoXCIuL0NoaWxkQ2hhbmdlQWNjdW11bGF0b3JcIik7XG52YXIgQ2hhbmdlXzEgPSByZXF1aXJlKFwiLi9DaGFuZ2VcIik7XG52YXIgQ2hpbGRyZW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vc25hcC9DaGlsZHJlbk5vZGVcIik7XG52YXIgS2V5SW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9zbmFwL2luZGV4ZXMvS2V5SW5kZXhcIik7XG52YXIgSW1tdXRhYmxlVHJlZV8xID0gcmVxdWlyZShcIi4uL3V0aWwvSW1tdXRhYmxlVHJlZVwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9QYXRoXCIpO1xudmFyIENvbXBsZXRlQ2hpbGRTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0NvbXBsZXRlQ2hpbGRTb3VyY2VcIik7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICovXG52YXIgUHJvY2Vzc29yUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFDaGFuZ2U+fSBjaGFuZ2VzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvY2Vzc29yUmVzdWx0KHZpZXdDYWNoZSwgY2hhbmdlcykge1xuICAgICAgICB0aGlzLnZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICB9XG4gICAgcmV0dXJuIFByb2Nlc3NvclJlc3VsdDtcbn0oKSk7XG5leHBvcnRzLlByb2Nlc3NvclJlc3VsdCA9IFByb2Nlc3NvclJlc3VsdDtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBWaWV3UHJvY2Vzc29yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGVGaWx0ZXJ9IGZpbHRlcl9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3UHJvY2Vzc29yKGZpbHRlcl8pIHtcbiAgICAgICAgdGhpcy5maWx0ZXJfID0gZmlsdGVyXztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICAgKi9cbiAgICBWaWV3UHJvY2Vzc29yLnByb3RvdHlwZS5hc3NlcnRJbmRleGVkID0gZnVuY3Rpb24gKHZpZXdDYWNoZSkge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHZpZXdDYWNoZVxuICAgICAgICAgICAgLmdldEV2ZW50Q2FjaGUoKVxuICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgLmlzSW5kZXhlZCh0aGlzLmZpbHRlcl8uZ2V0SW5kZXgoKSksICdFdmVudCBzbmFwIG5vdCBpbmRleGVkJyk7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodmlld0NhY2hlXG4gICAgICAgICAgICAuZ2V0U2VydmVyQ2FjaGUoKVxuICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgLmlzSW5kZXhlZCh0aGlzLmZpbHRlcl8uZ2V0SW5kZXgoKSksICdTZXJ2ZXIgc25hcCBub3QgaW5kZXhlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSBvbGRWaWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFPcGVyYXRpb259IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZUNhY2hlXG4gICAgICogQHJldHVybiB7IVByb2Nlc3NvclJlc3VsdH1cbiAgICAgKi9cbiAgICBWaWV3UHJvY2Vzc29yLnByb3RvdHlwZS5hcHBseU9wZXJhdGlvbiA9IGZ1bmN0aW9uIChvbGRWaWV3Q2FjaGUsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUpIHtcbiAgICAgICAgdmFyIGFjY3VtdWxhdG9yID0gbmV3IENoaWxkQ2hhbmdlQWNjdW11bGF0b3JfMS5DaGlsZENoYW5nZUFjY3VtdWxhdG9yKCk7XG4gICAgICAgIHZhciBuZXdWaWV3Q2FjaGUsIGZpbHRlclNlcnZlck5vZGU7XG4gICAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uXzEuT3BlcmF0aW9uVHlwZS5PVkVSV1JJVEUpIHtcbiAgICAgICAgICAgIHZhciBvdmVyd3JpdGUgPSBvcGVyYXRpb247XG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlLnNvdXJjZS5mcm9tVXNlcikge1xuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHRoaXMuYXBwbHlVc2VyT3ZlcndyaXRlXyhvbGRWaWV3Q2FjaGUsIG92ZXJ3cml0ZS5wYXRoLCBvdmVyd3JpdGUuc25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQob3ZlcndyaXRlLnNvdXJjZS5mcm9tU2VydmVyLCAnVW5rbm93biBzb3VyY2UuJyk7XG4gICAgICAgICAgICAgICAgLy8gV2UgZmlsdGVyIHRoZSBub2RlIGlmIGl0J3MgYSB0YWdnZWQgdXBkYXRlIG9yIHRoZSBub2RlIGhhcyBiZWVuIHByZXZpb3VzbHkgZmlsdGVyZWQgIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgaXMgbm90IGF0IHRoZSByb290IGluIHdoaWNoIGNhc2UgaXQgaXMgb2sgKGFuZCBuZWNlc3NhcnkpIHRvIG1hcmsgdGhlIG5vZGUgdW5maWx0ZXJlZFxuICAgICAgICAgICAgICAgIC8vIGFnYWluXG4gICAgICAgICAgICAgICAgZmlsdGVyU2VydmVyTm9kZSA9XG4gICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0ZS5zb3VyY2UudGFnZ2VkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAob2xkVmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGaWx0ZXJlZCgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIW92ZXJ3cml0ZS5wYXRoLmlzRW1wdHkoKSk7XG4gICAgICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdGhpcy5hcHBseVNlcnZlck92ZXJ3cml0ZV8ob2xkVmlld0NhY2hlLCBvdmVyd3JpdGUucGF0aCwgb3ZlcndyaXRlLnNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvbl8xLk9wZXJhdGlvblR5cGUuTUVSR0UpIHtcbiAgICAgICAgICAgIHZhciBtZXJnZSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChtZXJnZS5zb3VyY2UuZnJvbVVzZXIpIHtcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB0aGlzLmFwcGx5VXNlck1lcmdlXyhvbGRWaWV3Q2FjaGUsIG1lcmdlLnBhdGgsIG1lcmdlLmNoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLmFzc2VydChtZXJnZS5zb3VyY2UuZnJvbVNlcnZlciwgJ1Vua25vd24gc291cmNlLicpO1xuICAgICAgICAgICAgICAgIC8vIFdlIGZpbHRlciB0aGUgbm9kZSBpZiBpdCdzIGEgdGFnZ2VkIHVwZGF0ZSBvciB0aGUgbm9kZSBoYXMgYmVlbiBwcmV2aW91c2x5IGZpbHRlcmVkXG4gICAgICAgICAgICAgICAgZmlsdGVyU2VydmVyTm9kZSA9XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlLnNvdXJjZS50YWdnZWQgfHwgb2xkVmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGaWx0ZXJlZCgpO1xuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHRoaXMuYXBwbHlTZXJ2ZXJNZXJnZV8ob2xkVmlld0NhY2hlLCBtZXJnZS5wYXRoLCBtZXJnZS5jaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uXzEuT3BlcmF0aW9uVHlwZS5BQ0tfVVNFUl9XUklURSkge1xuICAgICAgICAgICAgdmFyIGFja1VzZXJXcml0ZSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICAgIGlmICghYWNrVXNlcldyaXRlLnJldmVydCkge1xuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHRoaXMuYWNrVXNlcldyaXRlXyhvbGRWaWV3Q2FjaGUsIGFja1VzZXJXcml0ZS5wYXRoLCBhY2tVc2VyV3JpdGUuYWZmZWN0ZWRUcmVlLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdGhpcy5yZXZlcnRVc2VyV3JpdGVfKG9sZFZpZXdDYWNoZSwgYWNrVXNlcldyaXRlLnBhdGgsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvbl8xLk9wZXJhdGlvblR5cGUuTElTVEVOX0NPTVBMRVRFKSB7XG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB0aGlzLmxpc3RlbkNvbXBsZXRlXyhvbGRWaWV3Q2FjaGUsIG9wZXJhdGlvbi5wYXRoLCB3cml0ZXNDYWNoZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdXRpbF8xLmFzc2VydGlvbkVycm9yKCdVbmtub3duIG9wZXJhdGlvbiB0eXBlOiAnICsgb3BlcmF0aW9uLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFuZ2VzID0gYWNjdW11bGF0b3IuZ2V0Q2hhbmdlcygpO1xuICAgICAgICBWaWV3UHJvY2Vzc29yLm1heWJlQWRkVmFsdWVFdmVudF8ob2xkVmlld0NhY2hlLCBuZXdWaWV3Q2FjaGUsIGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4gbmV3IFByb2Nlc3NvclJlc3VsdChuZXdWaWV3Q2FjaGUsIGNoYW5nZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSBvbGRWaWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IG5ld1ZpZXdDYWNoZVxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQ2hhbmdlPn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IubWF5YmVBZGRWYWx1ZUV2ZW50XyA9IGZ1bmN0aW9uIChvbGRWaWV3Q2FjaGUsIG5ld1ZpZXdDYWNoZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgdmFyIGV2ZW50U25hcCA9IG5ld1ZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCk7XG4gICAgICAgIGlmIChldmVudFNuYXAuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgIHZhciBpc0xlYWZPckVtcHR5ID0gZXZlbnRTbmFwLmdldE5vZGUoKS5pc0xlYWZOb2RlKCkgfHwgZXZlbnRTbmFwLmdldE5vZGUoKS5pc0VtcHR5KCk7XG4gICAgICAgICAgICB2YXIgb2xkQ29tcGxldGVTbmFwID0gb2xkVmlld0NhY2hlLmdldENvbXBsZXRlRXZlbnRTbmFwKCk7XG4gICAgICAgICAgICBpZiAoYWNjdW11bGF0b3IubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgICAgICFvbGRWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XG4gICAgICAgICAgICAgICAgKGlzTGVhZk9yRW1wdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWV2ZW50U25hcFxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVxdWFscygvKiogQHR5cGUgeyFOb2RlfSAqLyAob2xkQ29tcGxldGVTbmFwKSkpIHx8XG4gICAgICAgICAgICAgICAgIWV2ZW50U25hcFxuICAgICAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAgICAgICAgIC5nZXRQcmlvcml0eSgpXG4gICAgICAgICAgICAgICAgICAgIC5lcXVhbHMob2xkQ29tcGxldGVTbmFwLmdldFByaW9yaXR5KCkpKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0b3IucHVzaChDaGFuZ2VfMS5DaGFuZ2UudmFsdWVDaGFuZ2UoXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi8gbmV3Vmlld0NhY2hlLmdldENvbXBsZXRlRXZlbnRTbmFwKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFQYXRofSBjaGFuZ2VQYXRoXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7IUNvbXBsZXRlQ2hpbGRTb3VyY2V9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7IUNoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGFjY3VtdWxhdG9yXG4gICAgICogQHJldHVybiB7IVZpZXdDYWNoZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IucHJvdG90eXBlLmdlbmVyYXRlRXZlbnRDYWNoZUFmdGVyU2VydmVyRXZlbnRfID0gZnVuY3Rpb24gKHZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgd3JpdGVzQ2FjaGUsIHNvdXJjZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgdmFyIG9sZEV2ZW50U25hcCA9IHZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCk7XG4gICAgICAgIGlmICh3cml0ZXNDYWNoZS5zaGFkb3dpbmdXcml0ZShjaGFuZ2VQYXRoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGEgc2hhZG93aW5nIHdyaXRlLCBpZ25vcmUgY2hhbmdlc1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdFdmVudENhY2hlID0gdm9pZCAwLCBzZXJ2ZXJOb2RlID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGNoYW5nZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZmlndXJlIG91dCBob3cgdGhpcyBwbGF5cyB3aXRoIFwic2xpZGluZyBhY2sgd2luZG93c1wiXG4gICAgICAgICAgICAgICAgdXRpbF8xLmFzc2VydCh2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgJ0lmIGNoYW5nZSBwYXRoIGlzIGVtcHR5LCB3ZSBtdXN0IGhhdmUgY29tcGxldGUgc2VydmVyIGRhdGEnKTtcbiAgICAgICAgICAgICAgICBpZiAodmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGaWx0ZXJlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc3BlY2lhbCBjYXNlIHRoaXMsIGJlY2F1c2Ugd2UgbmVlZCB0byBvbmx5IGFwcGx5IHdyaXRlcyB0byBjb21wbGV0ZSBjaGlsZHJlbiwgb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbWlnaHQgZW5kIHVwIHJhaXNpbmcgZXZlbnRzIGZvciBpbmNvbXBsZXRlIGNoaWxkcmVuLiBJZiB0aGUgc2VydmVyIGRhdGEgaXMgZmlsdGVyZWQgZGVlcFxuICAgICAgICAgICAgICAgICAgICAvLyB3cml0ZXMgY2Fubm90IGJlIGd1YXJhbnRlZWQgdG8gYmUgY29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcnZlckNhY2hlID0gdmlld0NhY2hlLmdldENvbXBsZXRlU2VydmVyU25hcCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVDaGlsZHJlbiA9IHNlcnZlckNhY2hlIGluc3RhbmNlb2YgQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlcnZlckNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVFdmVudENoaWxkcmVuID0gd3JpdGVzQ2FjaGUuY2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbihjb21wbGV0ZUNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVGdWxsTm9kZSh2aWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmdldE5vZGUoKSwgY29tcGxldGVFdmVudENoaWxkcmVuLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVOb2RlID0gd3JpdGVzQ2FjaGUuY2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh2aWV3Q2FjaGUuZ2V0Q29tcGxldGVTZXJ2ZXJTbmFwKCkpO1xuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUZ1bGxOb2RlKHZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCkuZ2V0Tm9kZSgpLCBjb21wbGV0ZU5vZGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRLZXkgPSBjaGFuZ2VQYXRoLmdldEZyb250KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkS2V5ID09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoY2hhbmdlUGF0aC5nZXRMZW5ndGgoKSA9PSAxLCBcIkNhbid0IGhhdmUgYSBwcmlvcml0eSB3aXRoIGFkZGl0aW9uYWwgcGF0aCBjb21wb25lbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkRXZlbnROb2RlID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyTm9kZSA9IHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbWlnaHQgaGF2ZSBvdmVyd3JpdGVzIGZvciB0aGlzIHByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkUHJpb3JpdHkgPSB3cml0ZXNDYWNoZS5jYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKGNoYW5nZVBhdGgsIG9sZEV2ZW50Tm9kZSwgc2VydmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkUHJpb3JpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVQcmlvcml0eShvbGRFdmVudE5vZGUsIHVwZGF0ZWRQcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmlvcml0eSBkaWRuJ3QgY2hhbmdlLCBrZWVwIG9sZCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkQ2hhbmdlUGF0aCA9IGNoYW5nZVBhdGgucG9wRnJvbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFdmVudENoaWxkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkRXZlbnRTbmFwLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRDaGlsZFVwZGF0ZSA9IHdyaXRlc0NhY2hlLmNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUoY2hhbmdlUGF0aCwgb2xkRXZlbnRTbmFwLmdldE5vZGUoKSwgc2VydmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRDaGlsZFVwZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IG9sZEV2ZW50U25hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgZXZlbnRDaGlsZFVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGNoYW5nZWQsIGp1c3Qga2VlcCB0aGUgb2xkIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IG9sZEV2ZW50U25hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENoaWxkID0gd3JpdGVzQ2FjaGUuY2FsY0NvbXBsZXRlQ2hpbGQoY2hpbGRLZXksIHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RXZlbnRDaGlsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUNoaWxkKG9sZEV2ZW50U25hcC5nZXROb2RlKCksIGNoaWxkS2V5LCBuZXdFdmVudENoaWxkLCBjaGlsZENoYW5nZVBhdGgsIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gY29tcGxldGUgY2hpbGQgYXZhaWxhYmxlIG9yIG5vIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmlld0NhY2hlLnVwZGF0ZUV2ZW50U25hcChuZXdFdmVudENhY2hlLCBvbGRFdmVudFNuYXAuaXNGdWxseUluaXRpYWxpemVkKCkgfHwgY2hhbmdlUGF0aC5pc0VtcHR5KCksIHRoaXMuZmlsdGVyXy5maWx0ZXJzTm9kZXMoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gb2xkVmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshUGF0aH0gY2hhbmdlUGF0aFxuICAgICAqIEBwYXJhbSB7IU5vZGV9IGNoYW5nZWRTbmFwXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlQ2FjaGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbHRlclNlcnZlck5vZGVcbiAgICAgKiBAcGFyYW0geyFDaGlsZENoYW5nZUFjY3VtdWxhdG9yfSBhY2N1bXVsYXRvclxuICAgICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWV3UHJvY2Vzc29yLnByb3RvdHlwZS5hcHBseVNlcnZlck92ZXJ3cml0ZV8gPSBmdW5jdGlvbiAob2xkVmlld0NhY2hlLCBjaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgIHZhciBvbGRTZXJ2ZXJTbmFwID0gb2xkVmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCk7XG4gICAgICAgIHZhciBuZXdTZXJ2ZXJDYWNoZTtcbiAgICAgICAgdmFyIHNlcnZlckZpbHRlciA9IGZpbHRlclNlcnZlck5vZGVcbiAgICAgICAgICAgID8gdGhpcy5maWx0ZXJfXG4gICAgICAgICAgICA6IHRoaXMuZmlsdGVyXy5nZXRJbmRleGVkRmlsdGVyKCk7XG4gICAgICAgIGlmIChjaGFuZ2VQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkU2VydmVyU25hcC5nZXROb2RlKCksIGNoYW5nZWRTbmFwLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZXJ2ZXJGaWx0ZXIuZmlsdGVyc05vZGVzKCkgJiYgIW9sZFNlcnZlclNuYXAuaXNGaWx0ZXJlZCgpKSB7XG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGZpbHRlciB0aGUgc2VydmVyIG5vZGUsIGJ1dCB3ZSBkaWRuJ3QgZmlsdGVyIHRoZSBzZXJ2ZXIgbm9kZSB5ZXQsIHNvIHNpbXVsYXRlIGEgZnVsbCB1cGRhdGVcbiAgICAgICAgICAgIHZhciBuZXdTZXJ2ZXJOb2RlID0gb2xkU2VydmVyU25hcFxuICAgICAgICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAgICAgICAudXBkYXRlQ2hpbGQoY2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xuICAgICAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkU2VydmVyU25hcC5nZXROb2RlKCksIG5ld1NlcnZlck5vZGUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoaWxkS2V5ID0gY2hhbmdlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgaWYgKCFvbGRTZXJ2ZXJTbmFwLmlzQ29tcGxldGVGb3JQYXRoKGNoYW5nZVBhdGgpICYmXG4gICAgICAgICAgICAgICAgY2hhbmdlUGF0aC5nZXRMZW5ndGgoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1cGRhdGUgaW5jb21wbGV0ZSBub2RlcyB3aXRoIHVwZGF0ZXMgaW50ZW5kZWQgZm9yIG90aGVyIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWaWV3Q2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hpbGRDaGFuZ2VQYXRoID0gY2hhbmdlUGF0aC5wb3BGcm9udCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZE5vZGUgPSBjaGlsZE5vZGUudXBkYXRlQ2hpbGQoY2hpbGRDaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCk7XG4gICAgICAgICAgICBpZiAoY2hpbGRLZXkgPT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVQcmlvcml0eShvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgbmV3Q2hpbGROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1NlcnZlckNhY2hlID0gc2VydmVyRmlsdGVyLnVwZGF0ZUNoaWxkKG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3Q2hpbGROb2RlLCBjaGlsZENoYW5nZVBhdGgsIENvbXBsZXRlQ2hpbGRTb3VyY2VfMS5OT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdWaWV3Q2FjaGUgPSBvbGRWaWV3Q2FjaGUudXBkYXRlU2VydmVyU25hcChuZXdTZXJ2ZXJDYWNoZSwgb2xkU2VydmVyU25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBjaGFuZ2VQYXRoLmlzRW1wdHkoKSwgc2VydmVyRmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBDb21wbGV0ZUNoaWxkU291cmNlXzEuV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSh3cml0ZXNDYWNoZSwgbmV3Vmlld0NhY2hlLCBjb21wbGV0ZUNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudF8obmV3Vmlld0NhY2hlLCBjaGFuZ2VQYXRoLCB3cml0ZXNDYWNoZSwgc291cmNlLCBhY2N1bXVsYXRvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IG9sZFZpZXdDYWNoZVxuICAgICAqIEBwYXJhbSB7IVBhdGh9IGNoYW5nZVBhdGhcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBjaGFuZ2VkU25hcFxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZUNhY2hlXG4gICAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUuYXBwbHlVc2VyT3ZlcndyaXRlXyA9IGZ1bmN0aW9uIChvbGRWaWV3Q2FjaGUsIGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgdmFyIG9sZEV2ZW50U25hcCA9IG9sZFZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCk7XG4gICAgICAgIHZhciBuZXdWaWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGU7XG4gICAgICAgIHZhciBzb3VyY2UgPSBuZXcgQ29tcGxldGVDaGlsZFNvdXJjZV8xLldyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uod3JpdGVzQ2FjaGUsIG9sZFZpZXdDYWNoZSwgY29tcGxldGVDYWNoZSk7XG4gICAgICAgIGlmIChjaGFuZ2VQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVGdWxsTm9kZShvbGRWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmdldE5vZGUoKSwgY2hhbmdlZFNuYXAsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IG9sZFZpZXdDYWNoZS51cGRhdGVFdmVudFNuYXAobmV3RXZlbnRDYWNoZSwgdHJ1ZSwgdGhpcy5maWx0ZXJfLmZpbHRlcnNOb2RlcygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEtleSA9IGNoYW5nZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIGlmIChjaGlsZEtleSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZVByaW9yaXR5KG9sZFZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCkuZ2V0Tm9kZSgpLCBjaGFuZ2VkU25hcCk7XG4gICAgICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlLnVwZGF0ZUV2ZW50U25hcChuZXdFdmVudENhY2hlLCBvbGRFdmVudFNuYXAuaXNGdWxseUluaXRpYWxpemVkKCksIG9sZEV2ZW50U25hcC5pc0ZpbHRlcmVkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQ2hhbmdlUGF0aCA9IGNoYW5nZVBhdGgucG9wRnJvbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQ2hpbGQgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ2hhbmdlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hpbGQgb3ZlcndyaXRlLCB3ZSBjYW4gcmVwbGFjZSB0aGUgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjaGFuZ2VkU25hcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBzb3VyY2UuZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkQ2hhbmdlUGF0aC5nZXRCYWNrKCkgPT09ICcucHJpb3JpdHknICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmdldENoaWxkKGNoaWxkQ2hhbmdlUGF0aC5wYXJlbnQoKSkuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHByaW9yaXR5IHVwZGF0ZSBvbiBhbiBlbXB0eSBub2RlLiBJZiB0aGlzIG5vZGUgZXhpc3RzIG9uIHRoZSBzZXJ2ZXIsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcnZlciB3aWxsIHNlbmQgZG93biB0aGUgcHJpb3JpdHkgaW4gdGhlIHVwZGF0ZSwgc28gaWdub3JlIGZvciBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gY29tcGxldGUgY2hpbGQgbm9kZSBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRDaGlsZC5lcXVhbHMobmV3Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFdmVudFNuYXAgPSB0aGlzLmZpbHRlcl8udXBkYXRlQ2hpbGQob2xkRXZlbnRTbmFwLmdldE5vZGUoKSwgY2hpbGRLZXksIG5ld0NoaWxkLCBjaGlsZENoYW5nZVBhdGgsIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSBvbGRWaWV3Q2FjaGUudXBkYXRlRXZlbnRTbmFwKG5ld0V2ZW50U25hcCwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpLCB0aGlzLmZpbHRlcl8uZmlsdGVyc05vZGVzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3Vmlld0NhY2hlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpbGRLZXlcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5jYWNoZUhhc0NoaWxkXyA9IGZ1bmN0aW9uICh2aWV3Q2FjaGUsIGNoaWxkS2V5KSB7XG4gICAgICAgIHJldHVybiB2aWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IHZpZXdDYWNoZVxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0ge0ltbXV0YWJsZVRyZWUuPCFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7P05vZGV9IHNlcnZlckNhY2hlXG4gICAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUuYXBwbHlVc2VyTWVyZ2VfID0gZnVuY3Rpb24gKHZpZXdDYWNoZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEhBQ0s6IEluIHRoZSBjYXNlIG9mIGEgbGltaXQgcXVlcnksIHRoZXJlIG1heSBiZSBzb21lIGNoYW5nZXMgdGhhdCBidW1wIHRoaW5ncyBvdXQgb2YgdGhlXG4gICAgICAgIC8vIHdpbmRvdyBsZWF2aW5nIHJvb20gZm9yIG5ldyBpdGVtcy4gIEl0J3MgaW1wb3J0YW50IHdlIHByb2Nlc3MgdGhlc2UgY2hhbmdlcyBmaXJzdCwgc28gd2VcbiAgICAgICAgLy8gaXRlcmF0ZSB0aGUgY2hhbmdlcyB0d2ljZSwgZmlyc3QgcHJvY2Vzc2luZyBhbnkgdGhhdCBhZmZlY3QgaXRlbXMgY3VycmVudGx5IGluIHZpZXcuXG4gICAgICAgIC8vIFRPRE86IEkgY29uc2lkZXIgYW4gaXRlbSBcImluIHZpZXdcIiBpZiBjYWNoZUhhc0NoaWxkIGlzIHRydWUsIHdoaWNoIGNoZWNrcyBib3RoIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gYW5kIGV2ZW50IHNuYXAuICBJJ20gbm90IHN1cmUgaWYgdGhpcyB3aWxsIHJlc3VsdCBpbiBlZGdlIGNhc2VzIHdoZW4gYSBjaGlsZCBpcyBpbiBvbmUgYnV0XG4gICAgICAgIC8vIG5vdCB0aGUgb3RoZXIuXG4gICAgICAgIHZhciBjdXJWaWV3Q2FjaGUgPSB2aWV3Q2FjaGU7XG4gICAgICAgIGNoYW5nZWRDaGlsZHJlbi5mb3JlYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgdmFyIHdyaXRlUGF0aCA9IHBhdGguY2hpbGQocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgIGlmIChWaWV3UHJvY2Vzc29yLmNhY2hlSGFzQ2hpbGRfKHZpZXdDYWNoZSwgd3JpdGVQYXRoLmdldEZyb250KCkpKSB7XG4gICAgICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gX3RoaXMuYXBwbHlVc2VyT3ZlcndyaXRlXyhjdXJWaWV3Q2FjaGUsIHdyaXRlUGF0aCwgY2hpbGROb2RlLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNoYW5nZWRDaGlsZHJlbi5mb3JlYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgdmFyIHdyaXRlUGF0aCA9IHBhdGguY2hpbGQocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgIGlmICghVmlld1Byb2Nlc3Nvci5jYWNoZUhhc0NoaWxkXyh2aWV3Q2FjaGUsIHdyaXRlUGF0aC5nZXRGcm9udCgpKSkge1xuICAgICAgICAgICAgICAgIGN1clZpZXdDYWNoZSA9IF90aGlzLmFwcGx5VXNlck92ZXJ3cml0ZV8oY3VyVmlld0NhY2hlLCB3cml0ZVBhdGgsIGNoaWxkTm9kZSwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3VyVmlld0NhY2hlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7SW1tdXRhYmxlVHJlZS48IU5vZGU+fSBtZXJnZVxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUuYXBwbHlNZXJnZV8gPSBmdW5jdGlvbiAobm9kZSwgbWVyZ2UpIHtcbiAgICAgICAgbWVyZ2UuZm9yZWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZUNoaWxkKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshSW1tdXRhYmxlVHJlZS48IU5vZGU+fSBjaGFuZ2VkQ2hpbGRyZW5cbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gc2VydmVyQ2FjaGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbHRlclNlcnZlck5vZGVcbiAgICAgKiBAcGFyYW0geyFDaGlsZENoYW5nZUFjY3VtdWxhdG9yfSBhY2N1bXVsYXRvclxuICAgICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWV3UHJvY2Vzc29yLnByb3RvdHlwZS5hcHBseVNlcnZlck1lcmdlXyA9IGZ1bmN0aW9uICh2aWV3Q2FjaGUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2FjaGUgeWV0LCB0aGlzIG1lcmdlIHdhcyBpbnRlbmRlZCBmb3IgYSBwcmV2aW91c2x5IGxpc3RlbiBpbiB0aGUgc2FtZSBsb2NhdGlvbi4gSWdub3JlIGl0IGFuZFxuICAgICAgICAvLyB3YWl0IGZvciB0aGUgY29tcGxldGUgZGF0YSB1cGRhdGUgY29taW5nIHNvb24uXG4gICAgICAgIGlmICh2aWV3Q2FjaGVcbiAgICAgICAgICAgIC5nZXRTZXJ2ZXJDYWNoZSgpXG4gICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAuaXNFbXB0eSgpICYmXG4gICAgICAgICAgICAhdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSEFDSzogSW4gdGhlIGNhc2Ugb2YgYSBsaW1pdCBxdWVyeSwgdGhlcmUgbWF5IGJlIHNvbWUgY2hhbmdlcyB0aGF0IGJ1bXAgdGhpbmdzIG91dCBvZiB0aGVcbiAgICAgICAgLy8gd2luZG93IGxlYXZpbmcgcm9vbSBmb3IgbmV3IGl0ZW1zLiAgSXQncyBpbXBvcnRhbnQgd2UgcHJvY2VzcyB0aGVzZSBjaGFuZ2VzIGZpcnN0LCBzbyB3ZVxuICAgICAgICAvLyBpdGVyYXRlIHRoZSBjaGFuZ2VzIHR3aWNlLCBmaXJzdCBwcm9jZXNzaW5nIGFueSB0aGF0IGFmZmVjdCBpdGVtcyBjdXJyZW50bHkgaW4gdmlldy5cbiAgICAgICAgLy8gVE9ETzogSSBjb25zaWRlciBhbiBpdGVtIFwiaW4gdmlld1wiIGlmIGNhY2hlSGFzQ2hpbGQgaXMgdHJ1ZSwgd2hpY2ggY2hlY2tzIGJvdGggdGhlIHNlcnZlclxuICAgICAgICAvLyBhbmQgZXZlbnQgc25hcC4gIEknbSBub3Qgc3VyZSBpZiB0aGlzIHdpbGwgcmVzdWx0IGluIGVkZ2UgY2FzZXMgd2hlbiBhIGNoaWxkIGlzIGluIG9uZSBidXRcbiAgICAgICAgLy8gbm90IHRoZSBvdGhlci5cbiAgICAgICAgdmFyIGN1clZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcbiAgICAgICAgdmFyIHZpZXdNZXJnZVRyZWU7XG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdmlld01lcmdlVHJlZSA9IGNoYW5nZWRDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXdNZXJnZVRyZWUgPSBJbW11dGFibGVUcmVlXzEuSW1tdXRhYmxlVHJlZS5FbXB0eS5zZXRUcmVlKHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5nZXROb2RlKCk7XG4gICAgICAgIHZpZXdNZXJnZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbChmdW5jdGlvbiAoY2hpbGRLZXksIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgaWYgKHNlcnZlck5vZGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlckNoaWxkID0gdmlld0NhY2hlXG4gICAgICAgICAgICAgICAgICAgIC5nZXRTZXJ2ZXJDYWNoZSgpXG4gICAgICAgICAgICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSBfdGhpcy5hcHBseU1lcmdlXyhzZXJ2ZXJDaGlsZCwgY2hpbGRUcmVlKTtcbiAgICAgICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSBfdGhpcy5hcHBseVNlcnZlck92ZXJ3cml0ZV8oY3VyVmlld0NhY2hlLCBuZXcgUGF0aF8xLlBhdGgoY2hpbGRLZXkpLCBuZXdDaGlsZCwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2aWV3TWVyZ2VUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoZnVuY3Rpb24gKGNoaWxkS2V5LCBjaGlsZE1lcmdlVHJlZSkge1xuICAgICAgICAgICAgdmFyIGlzVW5rbm93bkRlZXBNZXJnZSA9ICF2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpICYmXG4gICAgICAgICAgICAgICAgY2hpbGRNZXJnZVRyZWUudmFsdWUgPT0gbnVsbDtcbiAgICAgICAgICAgIGlmICghc2VydmVyTm9kZS5oYXNDaGlsZChjaGlsZEtleSkgJiYgIWlzVW5rbm93bkRlZXBNZXJnZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJDaGlsZCA9IHZpZXdDYWNoZVxuICAgICAgICAgICAgICAgICAgICAuZ2V0U2VydmVyQ2FjaGUoKVxuICAgICAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gX3RoaXMuYXBwbHlNZXJnZV8oc2VydmVyQ2hpbGQsIGNoaWxkTWVyZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSBfdGhpcy5hcHBseVNlcnZlck92ZXJ3cml0ZV8oY3VyVmlld0NhY2hlLCBuZXcgUGF0aF8xLlBhdGgoY2hpbGRLZXkpLCBuZXdDaGlsZCwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3VyVmlld0NhY2hlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFQYXRofSBhY2tQYXRoXG4gICAgICogQHBhcmFtIHshSW1tdXRhYmxlVHJlZTwhYm9vbGVhbj59IGFmZmVjdGVkVHJlZVxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZUNhY2hlXG4gICAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUuYWNrVXNlcldyaXRlXyA9IGZ1bmN0aW9uICh2aWV3Q2FjaGUsIGFja1BhdGgsIGFmZmVjdGVkVHJlZSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgIGlmICh3cml0ZXNDYWNoZS5zaGFkb3dpbmdXcml0ZShhY2tQYXRoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgZmlsdGVyIHNlcnZlciBub2RlIGlmIGl0IGlzIGN1cnJlbnRseSBmaWx0ZXJlZFxuICAgICAgICB2YXIgZmlsdGVyU2VydmVyTm9kZSA9IHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRmlsdGVyZWQoKTtcbiAgICAgICAgLy8gRXNzZW50aWFsbHkgd2UnbGwganVzdCBnZXQgb3VyIGV4aXN0aW5nIHNlcnZlciBjYWNoZSBmb3IgdGhlIGFmZmVjdGVkIHBhdGhzIGFuZCByZS1hcHBseSBpdCBhcyBhIHNlcnZlciB1cGRhdGVcbiAgICAgICAgLy8gbm93IHRoYXQgaXQgd29uJ3QgYmUgc2hhZG93ZWQuXG4gICAgICAgIHZhciBzZXJ2ZXJDYWNoZSA9IHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpO1xuICAgICAgICBpZiAoYWZmZWN0ZWRUcmVlLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gb3ZlcndyaXRlLlxuICAgICAgICAgICAgaWYgKChhY2tQYXRoLmlzRW1wdHkoKSAmJiBzZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkgfHxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDYWNoZS5pc0NvbXBsZXRlRm9yUGF0aChhY2tQYXRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5U2VydmVyT3ZlcndyaXRlXyh2aWV3Q2FjaGUsIGFja1BhdGgsIHNlcnZlckNhY2hlLmdldE5vZGUoKS5nZXRDaGlsZChhY2tQYXRoKSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFja1BhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGdvb2Z5IGVkZ2UgY2FzZSB3aGVyZSB3ZSBhcmUgYWNraW5nIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBidXQgZG9uJ3QgaGF2ZSBmdWxsIGRhdGEuICBXZVxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBqdXN0IHJlLWFwcGx5IHdoYXRldmVyIHdlIGhhdmUgaW4gb3VyIGNhY2hlIGFzIGEgbWVyZ2UuXG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRDaGlsZHJlbl8xID0gSW1tdXRhYmxlVHJlZV8xLkltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICAgICAgc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmZvckVhY2hDaGlsZChLZXlJbmRleF8xLktFWV9JTkRFWCwgZnVuY3Rpb24gKG5hbWUsIG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENoaWxkcmVuXzEgPSBjaGFuZ2VkQ2hpbGRyZW5fMS5zZXQobmV3IFBhdGhfMS5QYXRoKG5hbWUpLCBub2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVNlcnZlck1lcmdlXyh2aWV3Q2FjaGUsIGFja1BhdGgsIGNoYW5nZWRDaGlsZHJlbl8xLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXJnZS5cbiAgICAgICAgICAgIHZhciBjaGFuZ2VkQ2hpbGRyZW5fMiA9IEltbXV0YWJsZVRyZWVfMS5JbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICAgICAgYWZmZWN0ZWRUcmVlLmZvcmVhY2goZnVuY3Rpb24gKG1lcmdlUGF0aCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VydmVyQ2FjaGVQYXRoID0gYWNrUGF0aC5jaGlsZChtZXJnZVBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJDYWNoZS5pc0NvbXBsZXRlRm9yUGF0aChzZXJ2ZXJDYWNoZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDaGlsZHJlbl8yID0gY2hhbmdlZENoaWxkcmVuXzIuc2V0KG1lcmdlUGF0aCwgc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmdldENoaWxkKHNlcnZlckNhY2hlUGF0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlTZXJ2ZXJNZXJnZV8odmlld0NhY2hlLCBhY2tQYXRoLCBjaGFuZ2VkQ2hpbGRyZW5fMiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7IUNoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGFjY3VtdWxhdG9yXG4gICAgICogQHJldHVybiB7IVZpZXdDYWNoZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IucHJvdG90eXBlLmxpc3RlbkNvbXBsZXRlXyA9IGZ1bmN0aW9uICh2aWV3Q2FjaGUsIHBhdGgsIHdyaXRlc0NhY2hlLCBhY2N1bXVsYXRvcikge1xuICAgICAgICB2YXIgb2xkU2VydmVyTm9kZSA9IHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpO1xuICAgICAgICB2YXIgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlLnVwZGF0ZVNlcnZlclNuYXAob2xkU2VydmVyTm9kZS5nZXROb2RlKCksIG9sZFNlcnZlck5vZGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHwgcGF0aC5pc0VtcHR5KCksIG9sZFNlcnZlck5vZGUuaXNGaWx0ZXJlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudF8obmV3Vmlld0NhY2hlLCBwYXRoLCB3cml0ZXNDYWNoZSwgQ29tcGxldGVDaGlsZFNvdXJjZV8xLk5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSwgYWNjdW11bGF0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlU2VydmVyQ2FjaGVcbiAgICAgKiBAcGFyYW0geyFDaGlsZENoYW5nZUFjY3VtdWxhdG9yfSBhY2N1bXVsYXRvclxuICAgICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWV3UHJvY2Vzc29yLnByb3RvdHlwZS5yZXZlcnRVc2VyV3JpdGVfID0gZnVuY3Rpb24gKHZpZXdDYWNoZSwgcGF0aCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgIHZhciBjb21wbGV0ZTtcbiAgICAgICAgaWYgKHdyaXRlc0NhY2hlLnNoYWRvd2luZ1dyaXRlKHBhdGgpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gbmV3IENvbXBsZXRlQ2hpbGRTb3VyY2VfMS5Xcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCB2aWV3Q2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUpO1xuICAgICAgICAgICAgdmFyIG9sZEV2ZW50Q2FjaGUgPSB2aWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmdldE5vZGUoKTtcbiAgICAgICAgICAgIHZhciBuZXdFdmVudENhY2hlID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHBhdGguaXNFbXB0eSgpIHx8IHBhdGguZ2V0RnJvbnQoKSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAodmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUodmlld0NhY2hlLmdldENvbXBsZXRlU2VydmVyU25hcCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJDaGlsZHJlbiA9IHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmFzc2VydChzZXJ2ZXJDaGlsZHJlbiBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZSwgJ3NlcnZlckNoaWxkcmVuIHdvdWxkIGJlIGNvbXBsZXRlIGlmIGxlYWYgbm9kZScpO1xuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0gd3JpdGVzQ2FjaGUuY2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbihzZXJ2ZXJDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlO1xuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB0aGlzLmZpbHRlcl8udXBkYXRlRnVsbE5vZGUob2xkRXZlbnRDYWNoZSwgbmV3Tm9kZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkS2V5ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdDaGlsZCA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUNoaWxkKGNoaWxkS2V5LCB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkID09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IG9sZEV2ZW50Q2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUNoaWxkKG9sZEV2ZW50Q2FjaGUsIGNoaWxkS2V5LCBuZXdDaGlsZCwgcGF0aC5wb3BGcm9udCgpLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmlld0NhY2hlXG4gICAgICAgICAgICAgICAgICAgIC5nZXRFdmVudENhY2hlKClcbiAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgICAgICAgICAuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbXBsZXRlIGNoaWxkIGF2YWlsYWJsZSwgZGVsZXRlIHRoZSBleGlzdGluZyBvbmUsIGlmIGFueVxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUNoaWxkKG9sZEV2ZW50Q2FjaGUsIGNoaWxkS2V5LCBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgcGF0aC5wb3BGcm9udCgpLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSBvbGRFdmVudENhY2hlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3RXZlbnRDYWNoZS5pc0VtcHR5KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgaGF2ZSByZXZlcnRlZCBhbGwgY2hpbGQgd3JpdGVzLiBNYXliZSB0aGUgb2xkIGV2ZW50IHdhcyBhIGxlYWYgbm9kZVxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUodmlld0NhY2hlLmdldENvbXBsZXRlU2VydmVyU25hcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVGdWxsTm9kZShuZXdFdmVudENhY2hlLCBjb21wbGV0ZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcGxldGUgPVxuICAgICAgICAgICAgICAgIHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlc0NhY2hlLnNoYWRvd2luZ1dyaXRlKFBhdGhfMS5QYXRoLkVtcHR5KSAhPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZS51cGRhdGVFdmVudFNuYXAobmV3RXZlbnRDYWNoZSwgY29tcGxldGUsIHRoaXMuZmlsdGVyXy5maWx0ZXJzTm9kZXMoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBWaWV3UHJvY2Vzc29yO1xufSgpKTtcbmV4cG9ydHMuVmlld1Byb2Nlc3NvciA9IFZpZXdQcm9jZXNzb3I7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZXdQcm9jZXNzb3IuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIENoYW5nZV8xID0gcmVxdWlyZShcIi4uL0NoYW5nZVwiKTtcbnZhciBDaGlsZHJlbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zbmFwL0NoaWxkcmVuTm9kZVwiKTtcbnZhciBQcmlvcml0eUluZGV4XzEgPSByZXF1aXJlKFwiLi4vLi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG4vKipcbiAqIERvZXNuJ3QgcmVhbGx5IGZpbHRlciBub2RlcyBidXQgYXBwbGllcyBhbiBpbmRleCB0byB0aGUgbm9kZSBhbmQga2VlcHMgdHJhY2sgb2YgYW55IGNoYW5nZXNcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtOb2RlRmlsdGVyfVxuICogQHBhcmFtIHshSW5kZXh9IGluZGV4XG4gKi9cbnZhciBJbmRleGVkRmlsdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluZGV4ZWRGaWx0ZXIoaW5kZXhfKSB7XG4gICAgICAgIHRoaXMuaW5kZXhfID0gaW5kZXhfO1xuICAgIH1cbiAgICBJbmRleGVkRmlsdGVyLnByb3RvdHlwZS51cGRhdGVDaGlsZCA9IGZ1bmN0aW9uIChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydChzbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XyksICdBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkJyk7XG4gICAgICAgIHZhciBvbGRDaGlsZCA9IHNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoa2V5KTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55dGhpbmcgYWN0dWFsbHkgY2hhbmdlZC5cbiAgICAgICAgaWYgKG9sZENoaWxkLmdldENoaWxkKGFmZmVjdGVkUGF0aCkuZXF1YWxzKG5ld0NoaWxkLmdldENoaWxkKGFmZmVjdGVkUGF0aCkpKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGNoaWxkIGNhbiBlbnRlciBvciBsZWF2ZSB0aGUgdmlldyBiZWNhdXNlIGFmZmVjdGVkUGF0aCB3YXMgc2V0IHRvIG51bGwuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGFmZmVjdGVkUGF0aCB3aWxsIGFwcGVhciBudWxsIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHNuYXBzaG90cy4gIFNvIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRyZWF0aW5nIHRoZXNlIGNhc2VzIGFzIFwibm90aGluZyBjaGFuZ2VkLlwiXG4gICAgICAgICAgICBpZiAob2xkQ2hpbGQuaXNFbXB0eSgpID09IG5ld0NoaWxkLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc2VydCBzaG91bGQgYmUgdmFsaWQsIGJ1dCBpdCdzIGV4cGVuc2l2ZSAoY2FuIGRvbWluYXRlIHBlcmYgdGVzdGluZykgc28gZG9uJ3QgYWN0dWFsbHkgZG8gaXQuXG4gICAgICAgICAgICAgICAgLy9hc3NlcnQob2xkQ2hpbGQuZXF1YWxzKG5ld0NoaWxkKSwgJ09sZCBhbmQgbmV3IHNuYXBzaG90cyBzaG91bGQgYmUgZXF1YWwuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdENoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc25hcC5oYXNDaGlsZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkUmVtb3ZlZENoYW5nZShrZXksIG9sZENoaWxkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHNuYXAuaXNMZWFmTm9kZSgpLCAnQSBjaGlsZCByZW1vdmUgd2l0aG91dCBhbiBvbGQgY2hpbGQgb25seSBtYWtlcyBzZW5zZSBvbiBhIGxlYWYgbm9kZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9sZENoaWxkLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkQWRkZWRDaGFuZ2Uoa2V5LCBuZXdDaGlsZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShDaGFuZ2VfMS5DaGFuZ2UuY2hpbGRDaGFuZ2VkQ2hhbmdlKGtleSwgbmV3Q2hpbGQsIG9sZENoaWxkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNuYXAuaXNMZWFmTm9kZSgpICYmIG5ld0NoaWxkLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG5vZGUgaXMgaW5kZXhlZFxuICAgICAgICAgICAgcmV0dXJuIHNuYXAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBuZXdDaGlsZCkud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBJbmRleGVkRmlsdGVyLnByb3RvdHlwZS51cGRhdGVGdWxsTm9kZSA9IGZ1bmN0aW9uIChvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xuICAgICAgICBpZiAob3B0Q2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFvbGRTbmFwLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgICAgIG9sZFNuYXAuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3U25hcC5oYXNDaGlsZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZFJlbW92ZWRDaGFuZ2Uoa2V5LCBjaGlsZE5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXdTbmFwLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgICAgIG5ld1NuYXAuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTbmFwLmhhc0NoaWxkKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRDaGlsZCA9IG9sZFNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkQ2hpbGQuZXF1YWxzKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZENoYW5nZWRDaGFuZ2Uoa2V5LCBjaGlsZE5vZGUsIG9sZENoaWxkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZEFkZGVkQ2hhbmdlKGtleSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBJbmRleGVkRmlsdGVyLnByb3RvdHlwZS51cGRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChvbGRTbmFwLCBuZXdQcmlvcml0eSkge1xuICAgICAgICBpZiAob2xkU25hcC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvbGRTbmFwLnVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBJbmRleGVkRmlsdGVyLnByb3RvdHlwZS5maWx0ZXJzTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSW5kZXhlZEZpbHRlci5wcm90b3R5cGUuZ2V0SW5kZXhlZEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEluZGV4ZWRGaWx0ZXIucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleF87XG4gICAgfTtcbiAgICByZXR1cm4gSW5kZXhlZEZpbHRlcjtcbn0oKSk7XG5leHBvcnRzLkluZGV4ZWRGaWx0ZXIgPSBJbmRleGVkRmlsdGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbmRleGVkRmlsdGVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJhbmdlZEZpbHRlcl8xID0gcmVxdWlyZShcIi4vUmFuZ2VkRmlsdGVyXCIpO1xudmFyIENoaWxkcmVuTm9kZV8xID0gcmVxdWlyZShcIi4uLy4uL3NuYXAvQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIE5vZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zbmFwL05vZGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIENoYW5nZV8xID0gcmVxdWlyZShcIi4uL0NoYW5nZVwiKTtcbi8qKlxuICogQXBwbGllcyBhIGxpbWl0IGFuZCBhIHJhbmdlIHRvIGEgbm9kZSBhbmQgdXNlcyBSYW5nZWRGaWx0ZXIgdG8gZG8gdGhlIGhlYXZ5IGxpZnRpbmcgd2hlcmUgcG9zc2libGVcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtOb2RlRmlsdGVyfVxuICovXG52YXIgTGltaXRlZEZpbHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFRdWVyeVBhcmFtc30gcGFyYW1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGltaXRlZEZpbHRlcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5yYW5nZWRGaWx0ZXJfID0gbmV3IFJhbmdlZEZpbHRlcl8xLlJhbmdlZEZpbHRlcihwYXJhbXMpO1xuICAgICAgICB0aGlzLmluZGV4XyA9IHBhcmFtcy5nZXRJbmRleCgpO1xuICAgICAgICB0aGlzLmxpbWl0XyA9IHBhcmFtcy5nZXRMaW1pdCgpO1xuICAgICAgICB0aGlzLnJldmVyc2VfID0gIXBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExpbWl0ZWRGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZUNoaWxkID0gZnVuY3Rpb24gKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xuICAgICAgICBpZiAoIXRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5ldyBOb2RlXzEuTmFtZWROb2RlKGtleSwgbmV3Q2hpbGQpKSkge1xuICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpLmVxdWFscyhuZXdDaGlsZCkpIHtcbiAgICAgICAgICAgIC8vIE5vIGNoYW5nZVxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc25hcC5udW1DaGlsZHJlbigpIDwgdGhpcy5saW1pdF8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlZEZpbHRlcl9cbiAgICAgICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZUNoaWxkKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdWxsTGltaXRVcGRhdGVDaGlsZF8oc25hcCwga2V5LCBuZXdDaGlsZCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGltaXRlZEZpbHRlci5wcm90b3R5cGUudXBkYXRlRnVsbE5vZGUgPSBmdW5jdGlvbiAob2xkU25hcCwgbmV3U25hcCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkO1xuICAgICAgICBpZiAobmV3U25hcC5pc0xlYWZOb2RlKCkgfHwgbmV3U25hcC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgY2hpbGRyZW4gbm9kZSB3aXRoIHRoZSBjb3JyZWN0IGluZGV4LCBub3QgYSBsZWFmIG5vZGU7XG4gICAgICAgICAgICBmaWx0ZXJlZCA9IENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saW1pdF8gKiAyIDwgbmV3U25hcC5udW1DaGlsZHJlbigpICYmXG4gICAgICAgICAgICAgICAgbmV3U25hcC5pc0luZGV4ZWQodGhpcy5pbmRleF8pKSB7XG4gICAgICAgICAgICAgICAgLy8gRWFzaWVyIHRvIGJ1aWxkIHVwIGEgc25hcHNob3QsIHNpbmNlIHdoYXQgd2UncmUgZ2l2ZW4gaGFzIG1vcmUgdGhhbiB0d2ljZSB0aGUgZWxlbWVudHMgd2Ugd2FudFxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IgdG8gdGhlIHN0YXJ0UG9zdCwgZW5kUG9zdCwgb3IgbGFzdCBlbGVtZW50IGFzIGFwcHJvcHJpYXRlXG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRFbmRQb3N0KCksIHRoaXMuaW5kZXhfKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRJdGVyYXRvckZyb20odGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpLCB0aGlzLmluZGV4Xyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLmhhc05leHQoKSAmJiBjb3VudCA8IHRoaXMubGltaXRfKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5SYW5nZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUmFuZ2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpLCBuZXh0KSA8PSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5SYW5nZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleF8uY29tcGFyZShuZXh0LCB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0RW5kUG9zdCgpKSA8PSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHQubmFtZSwgbmV4dC5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBwb3N0LCB3ZSBjYW5ub3Qga2VlcCBhZGRpbmcgZWxlbW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzbmFwIGNvbnRhaW5zIGxlc3MgdGhhbiB0d2ljZSB0aGUgbGltaXQuIEZhc3RlciB0byBkZWxldGUgZnJvbSB0aGUgc25hcCB0aGFuIGJ1aWxkIHVwIGEgbmV3IG9uZVxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVQcmlvcml0eShDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kUG9zdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgY21wID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldFJldmVyc2VJdGVyYXRvcih0aGlzLmluZGV4Xyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zdCA9IHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRFbmRQb3N0KCk7XG4gICAgICAgICAgICAgICAgICAgIGVuZFBvc3QgPSB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleENvbXBhcmVfMSA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY21wID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGluZGV4Q29tcGFyZV8xKGIsIGEpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBmaWx0ZXJlZC5nZXRJdGVyYXRvcih0aGlzLmluZGV4Xyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zdCA9IHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRTdGFydFBvc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kUG9zdCA9IHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRFbmRQb3N0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZm91bmRTdGFydFBvc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kU3RhcnRQb3N0ICYmIGNtcChzdGFydFBvc3QsIG5leHQpIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdGFydFBvc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBpblJhbmdlID0gZm91bmRTdGFydFBvc3QgJiYgY291bnQgPCB0aGlzLmxpbWl0XyAmJiBjbXAobmV4dCwgZW5kUG9zdCkgPD0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHQubmFtZSwgQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlZEZpbHRlcl9cbiAgICAgICAgICAgIC5nZXRJbmRleGVkRmlsdGVyKClcbiAgICAgICAgICAgIC51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBMaW1pdGVkRmlsdGVyLnByb3RvdHlwZS51cGRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChvbGRTbmFwLCBuZXdQcmlvcml0eSkge1xuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xuICAgICAgICByZXR1cm4gb2xkU25hcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGltaXRlZEZpbHRlci5wcm90b3R5cGUuZmlsdGVyc05vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGltaXRlZEZpbHRlci5wcm90b3R5cGUuZ2V0SW5kZXhlZEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRJbmRleGVkRmlsdGVyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExpbWl0ZWRGaWx0ZXIucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBzbmFwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAgICogQHBhcmFtIHshTm9kZX0gY2hpbGRTbmFwXG4gICAgICogQHBhcmFtIHshQ29tcGxldGVDaGlsZFNvdXJjZX0gc291cmNlXG4gICAgICogQHBhcmFtIHs/Q2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gY2hhbmdlQWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExpbWl0ZWRGaWx0ZXIucHJvdG90eXBlLmZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyA9IGZ1bmN0aW9uIChzbmFwLCBjaGlsZEtleSwgY2hpbGRTbmFwLCBzb3VyY2UsIGNoYW5nZUFjY3VtdWxhdG9yKSB7XG4gICAgICAgIC8vIFRPRE86IHJlbmFtZSBhbGwgY2FjaGUgc3R1ZmYgZXRjIHRvIGdlbmVyYWwgc25hcCB0ZXJtaW5vbG9neVxuICAgICAgICB2YXIgY21wO1xuICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xuICAgICAgICAgICAgdmFyIGluZGV4Q21wXzEgPSB0aGlzLmluZGV4Xy5nZXRDb21wYXJlKCk7XG4gICAgICAgICAgICBjbXAgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gaW5kZXhDbXBfMShiLCBhKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkRXZlbnRDYWNoZSA9IHNuYXA7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQob2xkRXZlbnRDYWNoZS5udW1DaGlsZHJlbigpID09IHRoaXMubGltaXRfLCAnJyk7XG4gICAgICAgIHZhciBuZXdDaGlsZE5hbWVkTm9kZSA9IG5ldyBOb2RlXzEuTmFtZWROb2RlKGNoaWxkS2V5LCBjaGlsZFNuYXApO1xuICAgICAgICB2YXIgd2luZG93Qm91bmRhcnkgPSB0aGlzLnJldmVyc2VfXG4gICAgICAgICAgICA/IG9sZEV2ZW50Q2FjaGUuZ2V0Rmlyc3RDaGlsZCh0aGlzLmluZGV4XylcbiAgICAgICAgICAgIDogb2xkRXZlbnRDYWNoZS5nZXRMYXN0Q2hpbGQodGhpcy5pbmRleF8pO1xuICAgICAgICB2YXIgaW5SYW5nZSA9IHRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5ld0NoaWxkTmFtZWROb2RlKTtcbiAgICAgICAgaWYgKG9sZEV2ZW50Q2FjaGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICB2YXIgb2xkQ2hpbGRTbmFwID0gb2xkRXZlbnRDYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgICB2YXIgbmV4dENoaWxkID0gc291cmNlLmdldENoaWxkQWZ0ZXJDaGlsZCh0aGlzLmluZGV4Xywgd2luZG93Qm91bmRhcnksIHRoaXMucmV2ZXJzZV8pO1xuICAgICAgICAgICAgd2hpbGUgKG5leHRDaGlsZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgKG5leHRDaGlsZC5uYW1lID09IGNoaWxkS2V5IHx8IG9sZEV2ZW50Q2FjaGUuaGFzQ2hpbGQobmV4dENoaWxkLm5hbWUpKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgd2VpcmQgZWRnZSBjYXNlIHdoZXJlIGEgbm9kZSBpcyB1cGRhdGVkIGFzIHBhcnQgb2YgYSBtZXJnZSBpbiB0aGUgd3JpdGUgdHJlZSwgYnV0IGhhc24ndFxuICAgICAgICAgICAgICAgIC8vIGJlZW4gYXBwbGllZCB0byB0aGUgbGltaXRlZCBmaWx0ZXIgeWV0LiBJZ25vcmUgdGhpcyBuZXh0IGNoaWxkIHdoaWNoIHdpbGwgYmUgdXBkYXRlZCBsYXRlciBpblxuICAgICAgICAgICAgICAgIC8vIHRoZSBsaW1pdGVkIGZpbHRlci4uLlxuICAgICAgICAgICAgICAgIG5leHRDaGlsZCA9IHNvdXJjZS5nZXRDaGlsZEFmdGVyQ2hpbGQodGhpcy5pbmRleF8sIG5leHRDaGlsZCwgdGhpcy5yZXZlcnNlXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29tcGFyZU5leHQgPSBuZXh0Q2hpbGQgPT0gbnVsbCA/IDEgOiBjbXAobmV4dENoaWxkLCBuZXdDaGlsZE5hbWVkTm9kZSk7XG4gICAgICAgICAgICB2YXIgcmVtYWluc0luV2luZG93ID0gaW5SYW5nZSAmJiAhY2hpbGRTbmFwLmlzRW1wdHkoKSAmJiBjb21wYXJlTmV4dCA+PSAwO1xuICAgICAgICAgICAgaWYgKHJlbWFpbnNJbldpbmRvdykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkQ2hhbmdlZENoYW5nZShjaGlsZEtleSwgY2hpbGRTbmFwLCBvbGRDaGlsZFNuYXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZEV2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIGNoaWxkU25hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZFJlbW92ZWRDaGFuZ2UoY2hpbGRLZXksIG9sZENoaWxkU25hcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkSW5SYW5nZSA9IG5leHRDaGlsZCAhPSBudWxsICYmIHRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5leHRDaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZEluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkQWRkZWRDaGFuZ2UobmV4dENoaWxkLm5hbWUsIG5leHRDaGlsZC5ub2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQobmV4dENoaWxkLm5hbWUsIG5leHRDaGlsZC5ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdFdmVudENhY2hlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZFNuYXAuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSBkZWxldGluZyBhIG5vZGUsIGJ1dCBpdCB3YXMgbm90IGluIHRoZSB3aW5kb3csIHNvIGlnbm9yZSBpdFxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5SYW5nZSkge1xuICAgICAgICAgICAgaWYgKGNtcCh3aW5kb3dCb3VuZGFyeSwgbmV3Q2hpbGROYW1lZE5vZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZFJlbW92ZWRDaGFuZ2Uod2luZG93Qm91bmRhcnkubmFtZSwgd2luZG93Qm91bmRhcnkubm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZEFkZGVkQ2hhbmdlKGNoaWxkS2V5LCBjaGlsZFNuYXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZEV2ZW50Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5LCBjaGlsZFNuYXApXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVJbW1lZGlhdGVDaGlsZCh3aW5kb3dCb3VuZGFyeS5uYW1lLCBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTGltaXRlZEZpbHRlcjtcbn0oKSk7XG5leHBvcnRzLkxpbWl0ZWRGaWx0ZXIgPSBMaW1pdGVkRmlsdGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW1pdGVkRmlsdGVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEluZGV4ZWRGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL0luZGV4ZWRGaWx0ZXJcIik7XG52YXIgUHJpb3JpdHlJbmRleF8xID0gcmVxdWlyZShcIi4uLy4uL3NuYXAvaW5kZXhlcy9Qcmlvcml0eUluZGV4XCIpO1xudmFyIE5vZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL3NuYXAvTm9kZVwiKTtcbnZhciBDaGlsZHJlbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zbmFwL0NoaWxkcmVuTm9kZVwiKTtcbi8qKlxuICogRmlsdGVycyBub2RlcyBieSByYW5nZSBhbmQgdXNlcyBhbiBJbmRleEZpbHRlciB0byB0cmFjayBhbnkgY2hhbmdlcyBhZnRlciBmaWx0ZXJpbmcgdGhlIG5vZGVcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtOb2RlRmlsdGVyfVxuICovXG52YXIgUmFuZ2VkRmlsdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5UGFyYW1zfSBwYXJhbXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSYW5nZWRGaWx0ZXIocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlZEZpbHRlcl8gPSBuZXcgSW5kZXhlZEZpbHRlcl8xLkluZGV4ZWRGaWx0ZXIocGFyYW1zLmdldEluZGV4KCkpO1xuICAgICAgICB0aGlzLmluZGV4XyA9IHBhcmFtcy5nZXRJbmRleCgpO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zdF8gPSBSYW5nZWRGaWx0ZXIuZ2V0U3RhcnRQb3N0XyhwYXJhbXMpO1xuICAgICAgICB0aGlzLmVuZFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldEVuZFBvc3RfKHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFOYW1lZE5vZGV9XG4gICAgICovXG4gICAgUmFuZ2VkRmlsdGVyLnByb3RvdHlwZS5nZXRTdGFydFBvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UG9zdF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfVxuICAgICAqL1xuICAgIFJhbmdlZEZpbHRlci5wcm90b3R5cGUuZ2V0RW5kUG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kUG9zdF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOYW1lZE5vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFJhbmdlZEZpbHRlci5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbmRleF8uY29tcGFyZSh0aGlzLmdldFN0YXJ0UG9zdCgpLCBub2RlKSA8PSAwICYmXG4gICAgICAgICAgICB0aGlzLmluZGV4Xy5jb21wYXJlKG5vZGUsIHRoaXMuZ2V0RW5kUG9zdCgpKSA8PSAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUmFuZ2VkRmlsdGVyLnByb3RvdHlwZS51cGRhdGVDaGlsZCA9IGZ1bmN0aW9uIChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoZXMobmV3IE5vZGVfMS5OYW1lZE5vZGUoa2V5LCBuZXdDaGlsZCkpKSB7XG4gICAgICAgICAgICBuZXdDaGlsZCA9IENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ZWRGaWx0ZXJfLnVwZGF0ZUNoaWxkKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFJhbmdlZEZpbHRlci5wcm90b3R5cGUudXBkYXRlRnVsbE5vZGUgPSBmdW5jdGlvbiAob2xkU25hcCwgbmV3U25hcCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcbiAgICAgICAgaWYgKG5ld1NuYXAuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGNoaWxkcmVuIG5vZGUgd2l0aCB0aGUgY29ycmVjdCBpbmRleCwgbm90IGEgbGVhZiBub2RlO1xuICAgICAgICAgICAgbmV3U25hcCA9IENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IG5ld1NuYXAud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcbiAgICAgICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcbiAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVQcmlvcml0eShDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgbmV3U25hcC5mb3JFYWNoQ2hpbGQoUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbiAoa2V5LCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5tYXRjaGVzKG5ldyBOb2RlXzEuTmFtZWROb2RlKGtleSwgY2hpbGROb2RlKSkpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGtleSwgQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlZEZpbHRlcl8udXBkYXRlRnVsbE5vZGUob2xkU25hcCwgZmlsdGVyZWQsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUmFuZ2VkRmlsdGVyLnByb3RvdHlwZS51cGRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChvbGRTbmFwLCBuZXdQcmlvcml0eSkge1xuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xuICAgICAgICByZXR1cm4gb2xkU25hcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUmFuZ2VkRmlsdGVyLnByb3RvdHlwZS5maWx0ZXJzTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIucHJvdG90eXBlLmdldEluZGV4ZWRGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ZWRGaWx0ZXJfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFRdWVyeVBhcmFtc30gcGFyYW1zXG4gICAgICogQHJldHVybiB7IU5hbWVkTm9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJhbmdlZEZpbHRlci5nZXRTdGFydFBvc3RfID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydE5hbWUoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5tYWtlUG9zdChwYXJhbXMuZ2V0SW5kZXhTdGFydFZhbHVlKCksIHN0YXJ0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWluUG9zdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFRdWVyeVBhcmFtc30gcGFyYW1zXG4gICAgICogQHJldHVybiB7IU5hbWVkTm9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJhbmdlZEZpbHRlci5nZXRFbmRQb3N0XyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNFbmQoKSkge1xuICAgICAgICAgICAgdmFyIGVuZE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhFbmROYW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWFrZVBvc3QocGFyYW1zLmdldEluZGV4RW5kVmFsdWUoKSwgZW5kTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWF4UG9zdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZ2VkRmlsdGVyO1xufSgpKTtcbmV4cG9ydHMuUmFuZ2VkRmlsdGVyID0gUmFuZ2VkRmlsdGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SYW5nZWRGaWx0ZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC91dGlsXCIpO1xudmFyIENvdW50ZWRTZXRfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvQ291bnRlZFNldFwiKTtcbnZhciBTdGF0c01hbmFnZXJfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3N0YXRzL1N0YXRzTWFuYWdlclwiKTtcbnZhciBQYWNrZXRSZWNlaXZlcl8xID0gcmVxdWlyZShcIi4vcG9sbGluZy9QYWNrZXRSZWNlaXZlclwiKTtcbnZhciBDb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL0NvbnN0YW50c1wiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLy8gVVJMIHF1ZXJ5IHBhcmFtZXRlcnMgYXNzb2NpYXRlZCB3aXRoIGxvbmdwb2xsaW5nXG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX1NUQVJUX1BBUkFNID0gJ3N0YXJ0JztcbmV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfQ0xPU0VfQ09NTUFORCA9ICdjbG9zZSc7XG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0NPTU1BTkRfQ0JfTkFNRSA9ICdwTFBDb21tYW5kJztcbmV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfREFUQV9DQl9OQU1FID0gJ3BSVExQQ0InO1xuZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9JRF9QQVJBTSA9ICdpZCc7XG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX1BXX1BBUkFNID0gJ3B3JztcbmV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfU0VSSUFMX1BBUkFNID0gJ3Nlcic7XG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0NBTExCQUNLX0lEX1BBUkFNID0gJ2NiJztcbmV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVF9OVU1fUEFSQU0gPSAnc2VnJztcbmV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVFNfSU5fUEFDS0VUID0gJ3RzJztcbmV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfREFUQV9QQVJBTSA9ICdkJztcbmV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfRElTQ09OTl9GUkFNRV9QQVJBTSA9ICdkaXNjb25uJztcbmV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfRElTQ09OTl9GUkFNRV9SRVFVRVNUX1BBUkFNID0gJ2RmcmFtZSc7XG4vL0RhdGEgc2l6ZSBjb25zdGFudHMuXG4vL1RPRE86IFBlcmY6IHRoZSBtYXhpbXVtIGxlbmd0aCBhY3R1YWxseSBkaWZmZXJzIGZyb20gYnJvd3NlciB0byBicm93c2VyLlxuLy8gV2Ugc2hvdWxkIGNoZWNrIHdoYXQgYnJvd3NlciB3ZSdyZSBvbiBhbmQgc2V0IGFjY29yZGluZ2x5LlxudmFyIE1BWF9VUkxfREFUQV9TSVpFID0gMTg3MDtcbnZhciBTRUdfSEVBREVSX1NJWkUgPSAzMDsgLy9pZTogJnNlZz04Mjk5MjM0JnRzPTk4MjM4OTEyMyZkPVxudmFyIE1BWF9QQVlMT0FEX1NJWkUgPSBNQVhfVVJMX0RBVEFfU0laRSAtIFNFR19IRUFERVJfU0laRTtcbi8qKlxuICogS2VlcGFsaXZlIHBlcmlvZFxuICogc2VuZCBhIGZyZXNoIHJlcXVlc3QgYXQgbWluaW11bSBldmVyeSAyNSBzZWNvbmRzLiBPcGVyYSBoYXMgYSBtYXhpbXVtIHJlcXVlc3RcbiAqIGxlbmd0aCBvZiAzMCBzZWNvbmRzIHRoYXQgd2UgY2FuJ3QgZXhjZWVkLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgS0VFUEFMSVZFX1JFUVVFU1RfSU5URVJWQUwgPSAyNTAwMDtcbi8qKlxuICogSG93IGxvbmcgdG8gd2FpdCBiZWZvcmUgYWJvcnRpbmcgYSBsb25nLXBvbGxpbmcgY29ubmVjdGlvbiBhdHRlbXB0LlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgTFBfQ09OTkVDVF9USU1FT1VUID0gMzAwMDA7XG4vKipcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyBhIHNpbmdsZSBsb25nLXBvbGxpbmcgY29ubmVjdGlvbi5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtUcmFuc3BvcnR9XG4gKi9cbnZhciBCcm93c2VyUG9sbENvbm5lY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbm5JZCBBbiBpZGVudGlmaWVyIGZvciB0aGlzIGNvbm5lY3Rpb24sIHVzZWQgZm9yIGxvZ2dpbmdcbiAgICAgKiBAcGFyYW0ge1JlcG9JbmZvfSByZXBvSW5mbyBUaGUgaW5mbyBmb3IgdGhlIGVuZHBvaW50IHRvIHNlbmQgZGF0YSB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHRyYW5zcG9ydFNlc3Npb25JZCBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uaWQgaWYgd2UgYXJlIHJlY29ubmVjdGluZyBmb3IgYW4gZXhpc3RpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0IHNlc3Npb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19ICBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlIFBlcnNpc3RlbnRDb25uZWN0aW9uIGhhcyBhbHJlYWR5IGNyZWF0ZWQgYVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gcHJldmlvdXNseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJQb2xsQ29ubmVjdGlvbihjb25uSWQsIHJlcG9JbmZvLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQpIHtcbiAgICAgICAgdGhpcy5jb25uSWQgPSBjb25uSWQ7XG4gICAgICAgIHRoaXMucmVwb0luZm8gPSByZXBvSW5mbztcbiAgICAgICAgdGhpcy50cmFuc3BvcnRTZXNzaW9uSWQgPSB0cmFuc3BvcnRTZXNzaW9uSWQ7XG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IGxhc3RTZXNzaW9uSWQ7XG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ID0gMDtcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZ18gPSB1dGlsXzEubG9nV3JhcHBlcihjb25uSWQpO1xuICAgICAgICB0aGlzLnN0YXRzXyA9IFN0YXRzTWFuYWdlcl8xLlN0YXRzTWFuYWdlci5nZXRDb2xsZWN0aW9uKHJlcG9JbmZvKTtcbiAgICAgICAgdGhpcy51cmxGbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBvSW5mby5jb25uZWN0aW9uVVJMKENvbnN0YW50c18xLkxPTkdfUE9MTElORywgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCl9IG9uTWVzc2FnZSBDYWxsYmFjayB3aGVuIG1lc3NhZ2VzIGFycml2ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gb25EaXNjb25uZWN0IENhbGxiYWNrIHdpdGggY29ubmVjdGlvbiBsb3N0LlxuICAgICAqL1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmN1clNlZ21lbnROdW0gPSAwO1xuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBvbkRpc2Nvbm5lY3Q7XG4gICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyID0gbmV3IFBhY2tldFJlY2VpdmVyXzEuUGFja2V0UmVjZWl2ZXIob25NZXNzYWdlKTtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMubG9nXygnVGltZWQgb3V0IHRyeWluZyB0byBjb25uZWN0LicpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGNsZWFyIHRoZSBob3N0IGNhY2hlXG4gICAgICAgICAgICBfdGhpcy5vbkNsb3NlZF8oKTtcbiAgICAgICAgICAgIF90aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gbnVsbDtcbiAgICAgICAgfSwgTWF0aC5mbG9vcihMUF9DT05ORUNUX1RJTUVPVVQpKTtcbiAgICAgICAgLy8gRW5zdXJlIHdlIGRlbGF5IHRoZSBjcmVhdGlvbiBvZiB0aGUgaWZyYW1lIHVudGlsIHRoZSBET00gaXMgbG9hZGVkLlxuICAgICAgICB1dGlsXzEuZXhlY3V0ZVdoZW5ET01SZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNDbG9zZWRfKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vU2V0IHVwIGEgY2FsbGJhY2sgdGhhdCBnZXRzIHRyaWdnZXJlZCBvbmNlIGEgY29ubmVjdGlvbiBpcyBzZXQgdXAuXG4gICAgICAgICAgICBfdGhpcy5zY3JpcHRUYWdIb2xkZXIgPSBuZXcgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29tbWFuZCA9IGFyZ3NbMF0sIGFyZzEgPSBhcmdzWzFdLCBhcmcyID0gYXJnc1syXSwgYXJnMyA9IGFyZ3NbM10sIGFyZzQgPSBhcmdzWzRdO1xuICAgICAgICAgICAgICAgIF90aGlzLmluY3JlbWVudEluY29taW5nQnl0ZXNfKGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc2NyaXB0VGFnSG9sZGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHdlIGNsb3NlZCB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVyQ29ubmVjdGVkXyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQgPT0gZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pZCA9IGFyZzE7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBhc3N3b3JkID0gYXJnMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZCA9PT0gZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9DTE9TRV9DT01NQU5EKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNsZWFyIHRoZSBob3N0IGNhY2hlLiBXZSBnb3QgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHdlIGtub3cgaXQncyByZWFjaGFibGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBleHBlY3RpbmcgYW55IG1vcmUgZGF0YSAob3RoZXIgdGhhbiB3aGF0IHRoZSBzZXJ2ZXIncyBhbHJlYWR5IGluIHRoZSBwcm9jZXNzIG9mIHNlbmRpbmcgdXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm91Z2ggb3VyIGFscmVhZHkgb3BlbiBwb2xscyksIHNvIGRvbid0IHNlbmQgYW55IG1vcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zY3JpcHRUYWdIb2xkZXIuc2VuZE5ld1BvbGxzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmcxIGluIHRoaXMgY2FzZSBpcyB0aGUgbGFzdCByZXNwb25zZSBudW1iZXIgc2VudCBieSB0aGUgc2VydmVyLiBXZSBzaG91bGQgdHJ5IHRvIHJlY2VpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGUgcmVzcG9uc2VzIHVwIHRvIHRoaXMgb25lIGJlZm9yZSBjbG9zaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5teVBhY2tldE9yZGVyZXIuY2xvc2VBZnRlcihhcmcxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25DbG9zZWRfKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBjb21tYW5kIHJlY2VpdmVkOiAnICsgY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcE4gPSBhcmdzWzBdLCBkYXRhID0gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5teVBhY2tldE9yZGVyZXIuaGFuZGxlUmVzcG9uc2UocE4sIGRhdGEpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICAgICAgfSwgX3RoaXMudXJsRm4pO1xuICAgICAgICAgICAgLy9TZW5kIHRoZSBpbml0aWFsIHJlcXVlc3QgdG8gY29ubmVjdC4gVGhlIHNlcmlhbCBudW1iZXIgaXMgc2ltcGx5IHRvIGtlZXAgdGhlIGJyb3dzZXIgZnJvbSBwdWxsaW5nIHByZXZpb3VzIHJlc3VsdHNcbiAgICAgICAgICAgIC8vZnJvbSBjYWNoZS5cbiAgICAgICAgICAgIHZhciB1cmxQYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHVybFBhcmFtc1tleHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX1NUQVJUX1BBUkFNXSA9ICd0JztcbiAgICAgICAgICAgIHVybFBhcmFtc1tleHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xuICAgICAgICAgICAgaWYgKF90aGlzLnNjcmlwdFRhZ0hvbGRlci51bmlxdWVDYWxsYmFja0lkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW2V4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU1dID0gX3RoaXMuc2NyaXB0VGFnSG9sZGVyLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllcjtcbiAgICAgICAgICAgIHVybFBhcmFtc1tDb25zdGFudHNfMS5WRVJTSU9OX1BBUkFNXSA9IENvbnN0YW50c18xLlBST1RPQ09MX1ZFUlNJT047XG4gICAgICAgICAgICBpZiAoX3RoaXMudHJhbnNwb3J0U2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0NvbnN0YW50c18xLlRSQU5TUE9SVF9TRVNTSU9OX1BBUkFNXSA9IF90aGlzLnRyYW5zcG9ydFNlc3Npb25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5sYXN0U2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0NvbnN0YW50c18xLkxBU1RfU0VTU0lPTl9QQVJBTV0gPSBfdGhpcy5sYXN0U2Vzc2lvbklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1dGlsXzMuaXNOb2RlU2RrKCkgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgbG9jYXRpb24uaHJlZiAmJlxuICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYuaW5kZXhPZihDb25zdGFudHNfMS5GT1JHRV9ET01BSU4pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tDb25zdGFudHNfMS5SRUZFUkVSX1BBUkFNXSA9IENvbnN0YW50c18xLkZPUkdFX1JFRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb25uZWN0VVJMID0gX3RoaXMudXJsRm4odXJsUGFyYW1zKTtcbiAgICAgICAgICAgIF90aGlzLmxvZ18oJ0Nvbm5lY3RpbmcgdmlhIGxvbmctcG9sbCB0byAnICsgY29ubmVjdFVSTCk7XG4gICAgICAgICAgICBfdGhpcy5zY3JpcHRUYWdIb2xkZXIuYWRkVGFnKGNvbm5lY3RVUkwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvKiBkbyBub3RoaW5nICovXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsIHRoaXMgd2hlbiBhIGhhbmRzaGFrZSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBhbmQgd2Ugd2FudCB0byBjb25zaWRlciB0aGUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZFxuICAgICAqL1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLnN0YXJ0TG9uZ1BvbGwodGhpcy5pZCwgdGhpcy5wYXNzd29yZCk7XG4gICAgICAgIHRoaXMuYWRkRGlzY29ubmVjdFBpbmdGcmFtZSh0aGlzLmlkLCB0aGlzLnBhc3N3b3JkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvcmNlcyBsb25nIHBvbGxpbmcgdG8gYmUgY29uc2lkZXJlZCBhcyBhIHBvdGVudGlhbCB0cmFuc3BvcnRcbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlQWxsb3dfID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvcmNlcyBsb25ncG9sbGluZyB0byBub3QgYmUgY29uc2lkZXJlZCBhcyBhIHBvdGVudGlhbCB0cmFuc3BvcnRcbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3dfID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIFN0YXRpYyBtZXRob2QsIHVzZSBzdHJpbmcgbGl0ZXJhbCBzbyBpdCBjYW4gYmUgYWNjZXNzZWQgaW4gYSBnZW5lcmljIHdheVxuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTk9URTogSW4gUmVhY3QtTmF0aXZlIHRoZXJlJ3Mgbm9ybWFsbHkgbm8gJ2RvY3VtZW50JywgYnV0IGlmIHlvdSBkZWJ1ZyBhIFJlYWN0LU5hdGl2ZSBhcHAgaW5cbiAgICAgICAgLy8gdGhlIENocm9tZSBkZWJ1Z2dlciwgJ2RvY3VtZW50JyBpcyBkZWZpbmVkLCBidXQgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyBudWxsICgyMDE1LzA2LzA4KS5cbiAgICAgICAgcmV0dXJuIChCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvd18gfHxcbiAgICAgICAgICAgICghQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3dfICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICF1dGlsXzEuaXNDaHJvbWVFeHRlbnNpb25Db250ZW50U2NyaXB0KCkgJiZcbiAgICAgICAgICAgICAgICAhdXRpbF8xLmlzV2luZG93c1N0b3JlQXBwKCkgJiZcbiAgICAgICAgICAgICAgICAhdXRpbF8zLmlzTm9kZVNkaygpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOby1vcCBmb3IgcG9sbGluZ1xuICAgICAqL1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5wcm90b3R5cGUubWFya0Nvbm5lY3Rpb25IZWFsdGh5ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIFN0b3BzIHBvbGxpbmcgYW5kIGNsZWFucyB1cCB0aGUgaWZyYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24ucHJvdG90eXBlLnNodXRkb3duXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zY3JpcHRUYWdIb2xkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZW1vdmUgdGhlIGRpc2Nvbm5lY3QgZnJhbWUsIHdoaWNoIHdpbGwgdHJpZ2dlciBhbiBYSFIgY2FsbCB0byB0aGUgc2VydmVyIHRvIHRlbGwgaXQgd2UncmUgbGVhdmluZy5cbiAgICAgICAgaWYgKHRoaXMubXlEaXNjb25uRnJhbWUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5teURpc2Nvbm5GcmFtZSk7XG4gICAgICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoaXMgdHJhbnNwb3J0IGlzIGNsb3NlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnTG9uZ3BvbGwgaXMgY2xvc2luZyBpdHNlbGYnKTtcbiAgICAgICAgICAgIHRoaXMuc2h1dGRvd25fKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vbkRpc2Nvbm5lY3RfKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKHRoaXMuZXZlckNvbm5lY3RlZF8pO1xuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dGVybmFsLWZhY2luZyBjbG9zZSBoYW5kbGVyLiBSZWFsVGltZSBoYXMgcmVxdWVzdGVkIHdlIHNodXQgZG93bi4gS2lsbCBvdXIgY29ubmVjdGlvbiBhbmQgdGVsbCB0aGUgc2VydmVyXG4gICAgICogdGhhdCB3ZSd2ZSBsZWZ0LlxuICAgICAqL1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnTG9uZ3BvbGwgaXMgYmVpbmcgY2xvc2VkLicpO1xuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgSlNPTiBvYmplY3QgZG93biB0byB0aGUgc2VydmVyLiBJdCB3aWxsIG5lZWQgdG8gYmUgc3RyaW5naWZpZWQsIGJhc2U2NCBlbmNvZGVkLCBhbmQgdGhlblxuICAgICAqIGJyb2tlbiBpbnRvIGNodW5rcyAoc2luY2UgVVJMcyBoYXZlIGEgc21hbGwgbWF4aW11bSBsZW5ndGgpLlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZGF0YSBUaGUgSlNPTiBkYXRhIHRvIHRyYW5zbWl0LlxuICAgICAqL1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBkYXRhU3RyID0gdXRpbF8yLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgdGhpcy5ieXRlc1NlbnQgKz0gZGF0YVN0ci5sZW5ndGg7XG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3NlbnQnLCBkYXRhU3RyLmxlbmd0aCk7XG4gICAgICAgIC8vZmlyc3QsIGxldHMgZ2V0IHRoZSBiYXNlNjQtZW5jb2RlZCBkYXRhXG4gICAgICAgIHZhciBiYXNlNjRkYXRhID0gdXRpbF8yLmJhc2U2NEVuY29kZShkYXRhU3RyKTtcbiAgICAgICAgLy9XZSBjYW4gb25seSBmaXQgYSBjZXJ0YWluIGFtb3VudCBpbiBlYWNoIFVSTCwgc28gd2UgbmVlZCB0byBzcGxpdCB0aGlzIHJlcXVlc3RcbiAgICAgICAgLy91cCBpbnRvIG11bHRpcGxlIHBpZWNlcyBpZiBpdCBkb2Vzbid0IGZpdCBpbiBvbmUgcmVxdWVzdC5cbiAgICAgICAgdmFyIGRhdGFTZWdzID0gdXRpbF8xLnNwbGl0U3RyaW5nQnlTaXplKGJhc2U2NGRhdGEsIE1BWF9QQVlMT0FEX1NJWkUpO1xuICAgICAgICAvL0VucXVldWUgZWFjaCBzZWdtZW50IGZvciB0cmFuc21pc3Npb24uIFdlIGFzc2lnbiBlYWNoIGNodW5rIGEgc2VxdWVudGlhbCBJRCBhbmQgYSB0b3RhbCBudW1iZXJcbiAgICAgICAgLy9vZiBzZWdtZW50cyBzbyB0aGF0IHdlIGNhbiByZWFzc2VtYmxlIHRoZSBwYWNrZXQgb24gdGhlIHNlcnZlci5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhU2Vncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuZW5xdWV1ZVNlZ21lbnQodGhpcy5jdXJTZWdtZW50TnVtLCBkYXRhU2Vncy5sZW5ndGgsIGRhdGFTZWdzW2ldKTtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VnbWVudE51bSsrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGhvdyB3ZSBub3RpZnkgdGhlIHNlcnZlciB0aGF0IHdlJ3JlIGxlYXZpbmcuXG4gICAgICogV2UgYXJlbid0IGFibGUgdG8gc2VuZCByZXF1ZXN0cyB3aXRoIERIVE1MIG9uIGEgd2luZG93IGNsb3NlIGV2ZW50LCBidXQgd2UgY2FuXG4gICAgICogdHJpZ2dlciBYSFIgcmVxdWVzdHMgaW4gc29tZSBicm93c2VycyAoZXZlcnl0aGluZyBidXQgT3BlcmEgYmFzaWNhbGx5KS5cbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBwd1xuICAgICAqL1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkRGlzY29ubmVjdFBpbmdGcmFtZSA9IGZ1bmN0aW9uIChpZCwgcHcpIHtcbiAgICAgICAgaWYgKHV0aWxfMy5pc05vZGVTZGsoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5teURpc2Nvbm5GcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICB2YXIgdXJsUGFyYW1zID0ge307XG4gICAgICAgIHVybFBhcmFtc1tleHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUkVRVUVTVF9QQVJBTV0gPSAndCc7XG4gICAgICAgIHVybFBhcmFtc1tleHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IGlkO1xuICAgICAgICB1cmxQYXJhbXNbZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSBwdztcbiAgICAgICAgdGhpcy5teURpc2Nvbm5GcmFtZS5zcmMgPSB0aGlzLnVybEZuKHVybFBhcmFtcyk7XG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLm15RGlzY29ubkZyYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gdHJhY2sgdGhlIGJ5dGVzIHJlY2VpdmVkIGJ5IHRoaXMgY2xpZW50XG4gICAgICogQHBhcmFtIHsqfSBhcmdzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24ucHJvdG90eXBlLmluY3JlbWVudEluY29taW5nQnl0ZXNfID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhbiBhbm5veWluZyBwZXJmIGhpdCBqdXN0IHRvIHRyYWNrIHRoZSBudW1iZXIgb2YgaW5jb21pbmcgYnl0ZXMuICBNYXliZSBpdCBzaG91bGQgYmUgb3B0LWluLlxuICAgICAgICB2YXIgYnl0ZXNSZWNlaXZlZCA9IHV0aWxfMi5zdHJpbmdpZnkoYXJncykubGVuZ3RoO1xuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gYnl0ZXNSZWNlaXZlZDtcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfcmVjZWl2ZWQnLCBieXRlc1JlY2VpdmVkKTtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VyUG9sbENvbm5lY3Rpb247XG59KCkpO1xuZXhwb3J0cy5Ccm93c2VyUG9sbENvbm5lY3Rpb24gPSBCcm93c2VyUG9sbENvbm5lY3Rpb247XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIGFuIGlmcmFtZSB0aGF0IGlzIHVzZWQgYXMgYSBsb25nLXBvbGxpbmcgc2NyaXB0IGhvbGRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29tbWFuZENCIC0gVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIGNvbnRyb2wgY29tbWFuZHMgYXJlIHJlY2V2aWVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlQ0IgLSBUaGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gcmVzcG9uc2VzIGFycml2ZSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIG9uRGlzY29ubmVjdCAtIFRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGlzIHRhZyBob2xkZXIgaXMgY2xvc2VkXG4gICAgICogQHBhcmFtIHVybEZuIC0gQSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIHRoZSBVUkwgb2YgdGhlIGVuZHBvaW50IHRvIHNlbmQgZGF0YSB0by5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlcihjb21tYW5kQ0IsIG9uTWVzc2FnZUNCLCBvbkRpc2Nvbm5lY3QsIHVybEZuKSB7XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0O1xuICAgICAgICB0aGlzLnVybEZuID0gdXJsRm47XG4gICAgICAgIC8vV2UgbWFpbnRhaW4gYSBjb3VudCBvZiBhbGwgb2YgdGhlIG91dHN0YW5kaW5nIHJlcXVlc3RzLCBiZWNhdXNlIGlmIHdlIGhhdmUgdG9vIG1hbnkgYWN0aXZlIGF0IG9uY2UgaXQgY2FuIGNhdXNlXG4gICAgICAgIC8vcHJvYmxlbXMgaW4gc29tZSBicm93c2Vycy5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtDb3VudGVkU2V0LjxudW1iZXIsIG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMgPSBuZXcgQ291bnRlZFNldF8xLkNvdW50ZWRTZXQoKTtcbiAgICAgICAgLy9BIHF1ZXVlIG9mIHRoZSBwZW5kaW5nIHNlZ21lbnRzIHdhaXRpbmcgZm9yIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxuICAgICAgICB0aGlzLnBlbmRpbmdTZWdzID0gW107XG4gICAgICAgIC8vQSBzZXJpYWwgbnVtYmVyLiBXZSB1c2UgdGhpcyBmb3IgdHdvIHRoaW5nczpcbiAgICAgICAgLy8gMSkgQSB3YXkgdG8gZW5zdXJlIHRoZSBicm93c2VyIGRvZXNuJ3QgY2FjaGUgcmVzcG9uc2VzIHRvIHBvbGxzXG4gICAgICAgIC8vIDIpIEEgd2F5IHRvIG1ha2UgdGhlIHNlcnZlciBhd2FyZSB3aGVuIGxvbmctcG9sbHMgYXJyaXZlIGluIGEgZGlmZmVyZW50IG9yZGVyIHRoYW4gd2Ugc3RhcnRlZCB0aGVtLiBUaGVcbiAgICAgICAgLy8gICAgc2VydmVyIG5lZWRzIHRvIHJlbGVhc2UgYm90aCBwb2xscyBpbiB0aGlzIGNhc2Ugb3IgaXQgd2lsbCBjYXVzZSBwcm9ibGVtcyBpbiBPcGVyYSBzaW5jZSBPcGVyYSBjYW4gb25seSBleGVjdXRlXG4gICAgICAgIC8vICAgIEpTT05QIGNvZGUgaW4gdGhlIG9yZGVyIGl0IHdhcyBhZGRlZCB0byB0aGUgaWZyYW1lLlxuICAgICAgICB0aGlzLmN1cnJlbnRTZXJpYWwgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xuICAgICAgICAvLyBUaGlzIGdldHMgc2V0IHRvIGZhbHNlIHdoZW4gd2UncmUgXCJjbG9zaW5nIGRvd25cIiB0aGUgY29ubmVjdGlvbiAoZS5nLiB3ZSdyZSBzd2l0Y2hpbmcgdHJhbnNwb3J0cyBidXQgdGhlcmUncyBzdGlsbFxuICAgICAgICAvLyBpbmNvbWluZyBkYXRhIGZyb20gdGhlIHNlcnZlciB0aGF0IHdlJ3JlIHdhaXRpbmcgZm9yKS5cbiAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgPSB0cnVlO1xuICAgICAgICBpZiAoIXV0aWxfMy5pc05vZGVTZGsoKSkge1xuICAgICAgICAgICAgLy9FYWNoIHNjcmlwdCBob2xkZXIgcmVnaXN0ZXJzIGEgY291cGxlIG9mIHVuaXF1ZWx5IG5hbWVkIGNhbGxiYWNrcyB3aXRoIHRoZSB3aW5kb3cuIFRoZXNlIGFyZSBjYWxsZWQgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vaWZyYW1lcyB3aGVyZSB3ZSBwdXQgdGhlIGxvbmctcG9sbGluZyBzY3JpcHQgdGFncy4gV2UgaGF2ZSB0d28gY2FsbGJhY2tzOlxuICAgICAgICAgICAgLy8gICAxKSBDb21tYW5kIENhbGxiYWNrIC0gVHJpZ2dlcmVkIGZvciBjb250cm9sIGlzc3VlcywgbGlrZSBzdGFydGluZyBhIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAvLyAgIDIpIE1lc3NhZ2UgQ2FsbGJhY2sgLSBUcmlnZ2VyZWQgd2hlbiBuZXcgZGF0YSBhcnJpdmVzLlxuICAgICAgICAgICAgdGhpcy51bmlxdWVDYWxsYmFja0lkZW50aWZpZXIgPSB1dGlsXzEuTFVJREdlbmVyYXRvcigpO1xuICAgICAgICAgICAgd2luZG93W2V4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfQ09NTUFORF9DQl9OQU1FICsgdGhpcy51bmlxdWVDYWxsYmFja0lkZW50aWZpZXJdID0gY29tbWFuZENCO1xuICAgICAgICAgICAgd2luZG93W2V4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfREFUQV9DQl9OQU1FICsgdGhpcy51bmlxdWVDYWxsYmFja0lkZW50aWZpZXJdID0gb25NZXNzYWdlQ0I7XG4gICAgICAgICAgICAvL0NyZWF0ZSBhbiBpZnJhbWUgZm9yIHVzIHRvIGFkZCBzY3JpcHQgdGFncyB0by5cbiAgICAgICAgICAgIHRoaXMubXlJRnJhbWUgPSBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5jcmVhdGVJRnJhbWVfKCk7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGlmcmFtZSdzIGNvbnRlbnRzLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9ICcnO1xuICAgICAgICAgICAgLy8gaWYgd2Ugc2V0IGEgamF2YXNjcmlwdCB1cmwsIGl0J3MgSUUgYW5kIHdlIG5lZWQgdG8gc2V0IHRoZSBkb2N1bWVudCBkb21haW4uIFRoZSBqYXZhc2NyaXB0IHVybCBpcyBzdWZmaWNpZW50XG4gICAgICAgICAgICAvLyBmb3IgaWU5LCBidXQgaWU4IG5lZWRzIHRvIGRvIGl0IGFnYWluIGluIHRoZSBkb2N1bWVudCBpdHNlbGYuXG4gICAgICAgICAgICBpZiAodGhpcy5teUlGcmFtZS5zcmMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lLnNyYy5zdWJzdHIoMCwgJ2phdmFzY3JpcHQ6Jy5sZW5ndGgpID09PSAnamF2YXNjcmlwdDonKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnREb21haW4gPSBkb2N1bWVudC5kb21haW47XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gJzxzY3JpcHQ+ZG9jdW1lbnQuZG9tYWluPVwiJyArIGN1cnJlbnREb21haW4gKyAnXCI7PC9zY3JpcHQ+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpZnJhbWVDb250ZW50cyA9ICc8aHRtbD48Ym9keT4nICsgc2NyaXB0ICsgJzwvYm9keT48L2h0bWw+JztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2Mub3BlbigpO1xuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLndyaXRlKGlmcmFtZUNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lLmRvYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEubG9nKCdmcmFtZSB3cml0aW5nIGV4Y2VwdGlvbicpO1xuICAgICAgICAgICAgICAgIGlmIChlLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5sb2coZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHV0aWxfMS5sb2coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRDQiA9IGNvbW1hbmRDQjtcbiAgICAgICAgICAgIHRoaXMub25NZXNzYWdlQ0IgPSBvbk1lc3NhZ2VDQjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYWNoIGJyb3dzZXIgaGFzIGl0cyBvd24gZnVubnkgd2F5IHRvIGhhbmRsZSBpZnJhbWVzLiBIZXJlIHdlIG11c2ggdGhlbSBhbGwgdG9nZXRoZXIgaW50byBvbmUgb2JqZWN0IHRoYXQgSSBjYW5cbiAgICAgKiBhY3R1YWxseSB1c2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgICAqL1xuICAgIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyLmNyZWF0ZUlGcmFtZV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGluIG9yZGVyIHRvIGluaXRpYWxpemUgdGhlIGRvY3VtZW50IGluc2lkZSB0aGUgaWZyYW1lXG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIElmIGRvY3VtZW50LmRvbWFpbiBoYXMgYmVlbiBtb2RpZmllZCBpbiBJRSwgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLCBhbmQgd2UgbmVlZCB0byBzZXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gZG9tYWluIG9mIHRoZSBpZnJhbWUncyBkb2N1bWVudCBtYW51YWxseS4gV2UgY2FuIGRvIHRoaXMgdmlhIGEgamF2YXNjcmlwdDogdXJsIGFzIHRoZSBzcmMgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgd2UgbXVzdCBkbyB0aGlzICphZnRlciogdGhlIGlmcmFtZSBoYXMgYmVlbiBhcHBlbmRlZCB0byB0aGUgcGFnZS4gT3RoZXJ3aXNlIGl0IGRvZXNuJ3Qgd29yay5cbiAgICAgICAgICAgICAgICB2YXIgYSA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgICAgICAgICAgICAgIGlmICghYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcG9sb2dpZXMgZm9yIHRoZSBsb2ctc3BhbSwgSSBuZWVkIHRvIGRvIHNvbWV0aGluZyB0byBrZWVwIGNsb3N1cmUgZnJvbSBvcHRpbWl6aW5nIG91dCB0aGUgYXNzaWdubWVudCBhYm92ZS5cbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmxvZygnTm8gSUUgZG9tYWluIHNldHRpbmcgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBkb2N1bWVudC5kb21haW47XG4gICAgICAgICAgICAgICAgaWZyYW1lLnNyYyA9XG4gICAgICAgICAgICAgICAgICAgIFwiamF2YXNjcmlwdDp2b2lkKChmdW5jdGlvbigpe2RvY3VtZW50Lm9wZW4oKTtkb2N1bWVudC5kb21haW49J1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIic7ZG9jdW1lbnQuY2xvc2UoKTt9KSgpKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTG9uZ1BvbGxDb25uZWN0aW9uIGF0dGVtcHRzIHRvIGRlbGF5IGluaXRpYWxpemF0aW9uIHVudGlsIHRoZSBkb2N1bWVudCBpcyByZWFkeSwgc28gaG9wZWZ1bGx5IHRoaXNcbiAgICAgICAgICAgIC8vIG5ldmVyIGdldHMgaGl0LlxuICAgICAgICAgICAgdGhyb3cgJ0RvY3VtZW50IGJvZHkgaGFzIG5vdCBpbml0aWFsaXplZC4gV2FpdCB0byBpbml0aWFsaXplIEZpcmViYXNlIHVudGlsIGFmdGVyIHRoZSBkb2N1bWVudCBpcyByZWFkeS4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgZG9jdW1lbnQgb2YgdGhlIGlmcmFtZSBpbiBhIGJyb3dzZXItc3BlY2lmaWMgd2F5LlxuICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnREb2N1bWVudCkge1xuICAgICAgICAgICAgaWZyYW1lLmRvYyA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQ7IC8vIEZpcmVmb3gsIE9wZXJhLCBTYWZhcmlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgaWZyYW1lLmRvYyA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50OyAvLyBJbnRlcm5ldCBFeHBsb3JlclxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlmcmFtZS5kb2N1bWVudCkge1xuICAgICAgICAgICAgaWZyYW1lLmRvYyA9IGlmcmFtZS5kb2N1bWVudDsgLy9vdGhlcnM/XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlmcmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbmNlbCBhbGwgb3V0c3RhbmRpbmcgcXVlcmllcyBhbmQgcmVtb3ZlIHRoZSBmcmFtZS5cbiAgICAgKi9cbiAgICBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vTWFyayB0aGlzIGlmcmFtZSBhcyBkZWFkLCBzbyBubyBuZXcgcmVxdWVzdHMgYXJlIHNlbnQuXG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMubXlJRnJhbWUpIHtcbiAgICAgICAgICAgIC8vV2UgaGF2ZSB0byBhY3R1YWxseSByZW1vdmUgYWxsIG9mIHRoZSBodG1sIGluc2lkZSB0aGlzIGlmcmFtZSBiZWZvcmUgcmVtb3ZpbmcgaXQgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vd2luZG93LCBvciBJRSB3aWxsIGNvbnRpbnVlIGxvYWRpbmcgYW5kIGV4ZWN1dGluZyB0aGUgc2NyaXB0IHRhZ3Mgd2UndmUgYWxyZWFkeSBhZGRlZCwgd2hpY2hcbiAgICAgICAgICAgIC8vY2FuIGxlYWQgdG8gc29tZSBlcnJvcnMgYmVpbmcgdGhyb3duLiBTZXR0aW5nIGlubmVySFRNTCBzZWVtcyB0byBiZSB0aGUgZWFzaWVzdCB3YXkgdG8gZG8gdGhpcy5cbiAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLmJvZHkuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubXlJRnJhbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChfdGhpcy5teUlGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm15SUZyYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbF8zLmlzTm9kZVNkaygpICYmIHRoaXMubXlJRCkge1xuICAgICAgICAgICAgdmFyIHVybFBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgdXJsUGFyYW1zW2V4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfRElTQ09OTl9GUkFNRV9QQVJBTV0gPSAndCc7XG4gICAgICAgICAgICB1cmxQYXJhbXNbZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9JRF9QQVJBTV0gPSB0aGlzLm15SUQ7XG4gICAgICAgICAgICB1cmxQYXJhbXNbZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSB0aGlzLm15UFc7XG4gICAgICAgICAgICB2YXIgdGhlVVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xuICAgICAgICAgICAgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIubm9kZVJlc3RSZXF1ZXN0KHRoZVVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvdGVjdCBmcm9tIGJlaW5nIGNhbGxlZCByZWN1cnNpdmVseS5cbiAgICAgICAgdmFyIG9uRGlzY29ubmVjdCA9IHRoaXMub25EaXNjb25uZWN0O1xuICAgICAgICBpZiAob25EaXNjb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG51bGw7XG4gICAgICAgICAgICBvbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWN0dWFsbHkgc3RhcnQgdGhlIGxvbmctcG9sbGluZyBzZXNzaW9uIGJ5IGFkZGluZyB0aGUgZmlyc3Qgc2NyaXB0IHRhZyhzKSB0byB0aGUgaWZyYW1lLlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gaWQgLSBUaGUgSUQgb2YgdGhpcyBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBwdyAtIFRoZSBwYXNzd29yZCBmb3IgdGhpcyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIucHJvdG90eXBlLnN0YXJ0TG9uZ1BvbGwgPSBmdW5jdGlvbiAoaWQsIHB3KSB7XG4gICAgICAgIHRoaXMubXlJRCA9IGlkO1xuICAgICAgICB0aGlzLm15UFcgPSBwdztcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIC8vc2VuZCB0aGUgaW5pdGlhbCByZXF1ZXN0LiBJZiB0aGVyZSBhcmUgcmVxdWVzdHMgcXVldWVkLCBtYWtlIHN1cmUgdGhhdCB3ZSB0cmFuc21pdCBhcyBtYW55IGFzIHdlIGFyZSBjdXJyZW50bHkgYWJsZSB0by5cbiAgICAgICAgd2hpbGUgKHRoaXMubmV3UmVxdWVzdF8oKSkgeyB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBhbnkgdGltZSBzb21lb25lIG1pZ2h0IHdhbnQgYSBzY3JpcHQgdGFnIHRvIGJlIGFkZGVkLiBJdCBhZGRzIGEgc2NyaXB0IHRhZyB3aGVuIHRoZXJlIGFyZW4ndFxuICAgICAqIHRvbyBtYW55IG91dHN0YW5kaW5nIHJlcXVlc3RzIGFuZCB3ZSBhcmUgc3RpbGwgYWxpdmUuXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBhcmUgb3V0c3RhbmRpbmcgcGFja2V0IHNlZ21lbnRzIHRvIHNlbmQsIGl0IHNlbmRzIG9uZS4gSWYgdGhlcmUgYXJlbid0LCBpdCBzZW5kcyBhIGxvbmctcG9sbCBhbnl3YXlzIGlmXG4gICAgICogbmVlZGVkLlxuICAgICAqL1xuICAgIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyLnByb3RvdHlwZS5uZXdSZXF1ZXN0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gV2Uga2VlcCBvbmUgb3V0c3RhbmRpbmcgcmVxdWVzdCBvcGVuIGFsbCB0aGUgdGltZSB0byByZWNlaXZlIGRhdGEsIGJ1dCBpZiB3ZSBuZWVkIHRvIHNlbmQgZGF0YVxuICAgICAgICAvLyAocGVuZGluZ1NlZ3MubGVuZ3RoID4gMCkgdGhlbiB3ZSBjcmVhdGUgYSBuZXcgcmVxdWVzdCB0byBzZW5kIHRoZSBkYXRhLiAgVGhlIHNlcnZlciB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgLy8gY2xvc2UgdGhlIG9sZCByZXF1ZXN0LlxuICAgICAgICBpZiAodGhpcy5hbGl2ZSAmJlxuICAgICAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgJiZcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5jb3VudCgpIDwgKHRoaXMucGVuZGluZ1NlZ3MubGVuZ3RoID4gMCA/IDIgOiAxKSkge1xuICAgICAgICAgICAgLy9jb25zdHJ1Y3Qgb3VyIHVybFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VyaWFsKys7XG4gICAgICAgICAgICB2YXIgdXJsUGFyYW1zID0ge307XG4gICAgICAgICAgICB1cmxQYXJhbXNbZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9JRF9QQVJBTV0gPSB0aGlzLm15SUQ7XG4gICAgICAgICAgICB1cmxQYXJhbXNbZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSB0aGlzLm15UFc7XG4gICAgICAgICAgICB1cmxQYXJhbXNbZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU1dID0gdGhpcy5jdXJyZW50U2VyaWFsO1xuICAgICAgICAgICAgdmFyIHRoZVVSTCA9IHRoaXMudXJsRm4odXJsUGFyYW1zKTtcbiAgICAgICAgICAgIC8vTm93IGFkZCBhcyBtdWNoIGRhdGEgYXMgd2UgY2FuLlxuICAgICAgICAgICAgdmFyIGN1ckRhdGFTdHJpbmcgPSAnJztcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdTZWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvL2ZpcnN0LCBsZXRzIHNlZSBpZiB0aGUgbmV4dCBzZWdtZW50IHdpbGwgZml0LlxuICAgICAgICAgICAgICAgIHZhciBuZXh0U2VnID0gdGhpcy5wZW5kaW5nU2Vnc1swXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlZy5kLmxlbmd0aCArIFNFR19IRUFERVJfU0laRSArIGN1ckRhdGFTdHJpbmcubGVuZ3RoIDw9XG4gICAgICAgICAgICAgICAgICAgIE1BWF9VUkxfREFUQV9TSVpFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZ3JlYXQsIHRoZSBzZWdtZW50IHdpbGwgZml0LiBMZXRzIGFwcGVuZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZVNlZyA9IHRoaXMucGVuZGluZ1NlZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VyRGF0YVN0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVF9OVU1fUEFSQU0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlU2VnLnNlZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRTX0lOX1BBQ0tFVCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVTZWcudHMgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy5kO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGVVUkwgPSB0aGVVUkwgKyBjdXJEYXRhU3RyaW5nO1xuICAgICAgICAgICAgdGhpcy5hZGRMb25nUG9sbFRhZ18odGhlVVJMLCB0aGlzLmN1cnJlbnRTZXJpYWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFF1ZXVlIGEgcGFja2V0IGZvciB0cmFuc21pc3Npb24gdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gc2VnbnVtIC0gQSBzZXF1ZW50aWFsIGlkIGZvciB0aGlzIHBhY2tldCBzZWdtZW50IHVzZWQgZm9yIHJlYXNzZW1ibHlcbiAgICAgKiBAcGFyYW0gdG90YWxzZWdzIC0gVGhlIHRvdGFsIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGlzIHBhY2tldFxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgZm9yIHRoaXMgc2VnbWVudC5cbiAgICAgKi9cbiAgICBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5wcm90b3R5cGUuZW5xdWV1ZVNlZ21lbnQgPSBmdW5jdGlvbiAoc2VnbnVtLCB0b3RhbHNlZ3MsIGRhdGEpIHtcbiAgICAgICAgLy9hZGQgdGhpcyB0byB0aGUgcXVldWUgb2Ygc2VnbWVudHMgdG8gc2VuZC5cbiAgICAgICAgdGhpcy5wZW5kaW5nU2Vncy5wdXNoKHsgc2VnOiBzZWdudW0sIHRzOiB0b3RhbHNlZ3MsIGQ6IGRhdGEgfSk7XG4gICAgICAgIC8vc2VuZCB0aGUgZGF0YSBpbW1lZGlhdGVseSBpZiB0aGVyZSBpc24ndCBhbHJlYWR5IGRhdGEgYmVpbmcgdHJhbnNtaXR0ZWQsIHVubGVzc1xuICAgICAgICAvL3N0YXJ0TG9uZ1BvbGwgaGFzbid0IGJlZW4gY2FsbGVkIHlldC5cbiAgICAgICAgaWYgKHRoaXMuYWxpdmUpIHtcbiAgICAgICAgICAgIHRoaXMubmV3UmVxdWVzdF8oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgc2NyaXB0IHRhZyBmb3IgYSByZWd1bGFyIGxvbmctcG9sbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gdXJsIC0gVGhlIFVSTCBvZiB0aGUgc2NyaXB0IHRhZy5cbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IHNlcmlhbCAtIFRoZSBzZXJpYWwgbnVtYmVyIG9mIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIucHJvdG90eXBlLmFkZExvbmdQb2xsVGFnXyA9IGZ1bmN0aW9uICh1cmwsIHNlcmlhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvL3JlbWVtYmVyIHRoYXQgd2Ugc2VudCB0aGlzIHJlcXVlc3QuXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5hZGQoc2VyaWFsLCAxKTtcbiAgICAgICAgdmFyIGRvTmV3UmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMucmVtb3ZlKHNlcmlhbCk7XG4gICAgICAgICAgICBfdGhpcy5uZXdSZXF1ZXN0XygpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiB0aGlzIHJlcXVlc3QgZG9lc24ndCByZXR1cm4gb24gaXRzIG93biBhY2NvcmQgKGJ5IHRoZSBzZXJ2ZXIgc2VuZGluZyB1cyBzb21lIGRhdGEpLCB3ZSdsbFxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgb25lIGFmdGVyIHRoZSBLRUVQQUxJVkUgaW50ZXJ2YWwgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBrZWVwIGEgZnJlc2ggcmVxdWVzdCBvcGVuLlxuICAgICAgICB2YXIga2VlcGFsaXZlVGltZW91dCA9IHNldFRpbWVvdXQoZG9OZXdSZXF1ZXN0LCBNYXRoLmZsb29yKEtFRVBBTElWRV9SRVFVRVNUX0lOVEVSVkFMKSk7XG4gICAgICAgIHZhciByZWFkeVN0YXRlQ0IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IGNvbXBsZXRlZC4gIENhbmNlbCB0aGUga2VlcGFsaXZlLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGtlZXBhbGl2ZVRpbWVvdXQpO1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBhIG5ldyByZXF1ZXN0IHNvIHdlIGNhbiBjb250aW51ZSByZWNlaXZpbmcgZGF0YS5cbiAgICAgICAgICAgIGRvTmV3UmVxdWVzdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZFRhZyh1cmwsIHJlYWR5U3RhdGVDQik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYXJiaXRyYXJ5IHNjcmlwdCB0YWcgdG8gdGhlIGlmcmFtZS5cbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHVybCAtIFRoZSBVUkwgZm9yIHRoZSBzY3JpcHQgdGFnIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBsb2FkQ0IgLSBBIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCBvbmNlIHRoZSBzY3JpcHQgaGFzIGxvYWRlZC5cbiAgICAgKi9cbiAgICBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5wcm90b3R5cGUuYWRkVGFnID0gZnVuY3Rpb24gKHVybCwgbG9hZENCKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh1dGlsXzMuaXNOb2RlU2RrKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZG9Ob2RlTG9uZ1BvbGwodXJsLCBsb2FkQ0IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgYWxyZWFkeSBjbG9zZWQsIGRvbid0IGFkZCB0aGlzIHBvbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5zZW5kTmV3UG9sbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTY3JpcHRfMSA9IF90aGlzLm15SUZyYW1lLmRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0XzEudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHRfMS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdF8xLnNyYyA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0XzEub25sb2FkID0gbmV3U2NyaXB0XzEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJzdGF0ZSA9IG5ld1NjcmlwdF8xLnJlYWR5U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJzdGF0ZSB8fCByc3RhdGUgPT09ICdsb2FkZWQnIHx8IHJzdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdF8xLm9ubG9hZCA9IG5ld1NjcmlwdF8xLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1NjcmlwdF8xLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0XzEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuZXdTY3JpcHRfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDQigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHRfMS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmxvZygnTG9uZy1wb2xsIHNjcmlwdCBmYWlsZWQgdG8gbG9hZDogJyArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZW5kTmV3UG9sbHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm15SUZyYW1lLmRvYy5ib2R5LmFwcGVuZENoaWxkKG5ld1NjcmlwdF8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIG1ha2UgdGhpcyBlcnJvciB2aXNpYmxlIHNvbWVob3dcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKDEpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyO1xufSgpKTtcbmV4cG9ydHMuRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIgPSBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlclBvbGxDb25uZWN0aW9uLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdXRpbFwiKTtcbnZhciBzdG9yYWdlXzEgPSByZXF1aXJlKFwiLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VcIik7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG52YXIgVHJhbnNwb3J0TWFuYWdlcl8xID0gcmVxdWlyZShcIi4vVHJhbnNwb3J0TWFuYWdlclwiKTtcbi8vIEFib3J0IHVwZ3JhZGUgYXR0ZW1wdCBpZiBpdCB0YWtlcyBsb25nZXIgdGhhbiA2MHMuXG52YXIgVVBHUkFERV9USU1FT1VUID0gNjAwMDA7XG4vLyBGb3Igc29tZSB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBcInZhbGlkYXRlXCIgdGhlIHRyYW5zcG9ydCBieSBleGNoYW5naW5nIGEgZmV3IHJlcXVlc3RzIGFuZCByZXNwb25zZXMuXG4vLyBJZiB3ZSBoYXZlbid0IHNlbnQgZW5vdWdoIHJlcXVlc3RzIHdpdGhpbiA1cywgd2UnbGwgc3RhcnQgc2VuZGluZyBub29wIHBpbmcgcmVxdWVzdHMuXG52YXIgREVMQVlfQkVGT1JFX1NFTkRJTkdfRVhUUkFfUkVRVUVTVFMgPSA1MDAwO1xuLy8gSWYgdGhlIGluaXRpYWwgZGF0YSBzZW50IHRyaWdnZXJzIGEgbG90IG9mIGJhbmR3aWR0aCAoaS5lLiBpdCdzIGEgbGFyZ2UgcHV0IG9yIGEgbGlzdGVuIGZvciBhIGxhcmdlIGFtb3VudCBvZiBkYXRhKVxuLy8gdGhlbiB3ZSBtYXkgbm90IGJlIGFibGUgdG8gZXhjaGFuZ2Ugb3VyIHBpbmcvcG9uZyByZXF1ZXN0cyB3aXRoaW4gdGhlIGhlYWx0aHkgdGltZW91dC4gIFNvIGlmIHdlIHJlYWNoIHRoZSB0aW1lb3V0XG4vLyBidXQgd2UndmUgc2VudC9yZWNlaXZlZCBlbm91Z2ggYnl0ZXMsIHdlIGRvbid0IGNhbmNlbCB0aGUgY29ubmVjdGlvbi5cbnZhciBCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUgPSAxMCAqIDEwMjQ7XG52YXIgQllURVNfUkVDRUlWRURfSEVBTFRIWV9PVkVSUklERSA9IDEwMCAqIDEwMjQ7XG52YXIgTUVTU0FHRV9UWVBFID0gJ3QnO1xudmFyIE1FU1NBR0VfREFUQSA9ICdkJztcbnZhciBDT05UUk9MX1NIVVRET1dOID0gJ3MnO1xudmFyIENPTlRST0xfUkVTRVQgPSAncic7XG52YXIgQ09OVFJPTF9FUlJPUiA9ICdlJztcbnZhciBDT05UUk9MX1BPTkcgPSAnbyc7XG52YXIgU1dJVENIX0FDSyA9ICdhJztcbnZhciBFTkRfVFJBTlNNSVNTSU9OID0gJ24nO1xudmFyIFBJTkcgPSAncCc7XG52YXIgU0VSVkVSX0hFTExPID0gJ2gnO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWwtdGltZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgdXNpbmcgd2hpY2hldmVyIG1ldGhvZCB3b3Jrc1xuICogYmVzdCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29ubmVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGlkIC0gYW4gaWQgZm9yIHRoaXMgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mb18gLSB0aGUgaW5mbyBmb3IgdGhlIGVuZHBvaW50IHRvIGNvbm5lY3QgdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCl9IG9uTWVzc2FnZV8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gYSBzZXJ2ZXItcHVzaCBtZXNzYWdlIGFycml2ZXNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgc3RyaW5nKX0gb25SZWFkeV8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBjb25uZWN0aW9uIGlzIHJlYWR5IHRvIHNlbmQgbWVzc2FnZXMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBvbkRpc2Nvbm5lY3RfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgY29ubmVjdGlvbiB3YXMgbG9zdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nKX0gb25LaWxsXyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGlzIGNvbm5lY3Rpb24gaGFzIHBlcm1hbmVudGx5IHNodXQgZG93bi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGxhc3RTZXNzaW9uSWQgLSBsYXN0IHNlc3Npb24gaWQgaW4gcGVyc2lzdGVudCBjb25uZWN0aW9uLiBpcyB1c2VkIHRvIGNsZWFuIHVwIG9sZCBzZXNzaW9uIGluIHJlYWwtdGltZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uKGlkLCByZXBvSW5mb18sIG9uTWVzc2FnZV8sIG9uUmVhZHlfLCBvbkRpc2Nvbm5lY3RfLCBvbktpbGxfLCBsYXN0U2Vzc2lvbklkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XG4gICAgICAgIHRoaXMub25NZXNzYWdlXyA9IG9uTWVzc2FnZV87XG4gICAgICAgIHRoaXMub25SZWFkeV8gPSBvblJlYWR5XztcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gb25EaXNjb25uZWN0XztcbiAgICAgICAgdGhpcy5vbktpbGxfID0gb25LaWxsXztcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gbGFzdFNlc3Npb25JZDtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZV8gPSAwIC8qIENPTk5FQ1RJTkcgKi87XG4gICAgICAgIHRoaXMubG9nXyA9IHV0aWxfMS5sb2dXcmFwcGVyKCdjOicgKyB0aGlzLmlkICsgJzonKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyXyA9IG5ldyBUcmFuc3BvcnRNYW5hZ2VyXzEuVHJhbnNwb3J0TWFuYWdlcihyZXBvSW5mb18pO1xuICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gY3JlYXRlZCcpO1xuICAgICAgICB0aGlzLnN0YXJ0XygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBjb25uZWN0aW9uIGF0dGVtcHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbm4gPSB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfLmluaXRpYWxUcmFuc3BvcnQoKTtcbiAgICAgICAgdGhpcy5jb25uXyA9IG5ldyBjb25uKHRoaXMubmV4dFRyYW5zcG9ydElkXygpLCB0aGlzLnJlcG9JbmZvXywgdW5kZWZpbmVkLCB0aGlzLmxhc3RTZXNzaW9uSWQpO1xuICAgICAgICAvLyBGb3IgY2VydGFpbiB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBzZW5kIGFuZCByZWNlaXZlIHNldmVyYWwgbWVzc2FnZXMgYmFjayBhbmQgZm9ydGggYmVmb3JlIHdlXG4gICAgICAgIC8vIGNhbiBjb25zaWRlciB0aGUgdHJhbnNwb3J0IGhlYWx0aHkuXG4gICAgICAgIHRoaXMucHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXyA9IGNvbm5bJ3Jlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHknXSB8fCAwO1xuICAgICAgICB2YXIgb25NZXNzYWdlUmVjZWl2ZWQgPSB0aGlzLmNvbm5SZWNlaXZlcl8odGhpcy5jb25uXyk7XG4gICAgICAgIHZhciBvbkNvbm5lY3Rpb25Mb3N0ID0gdGhpcy5kaXNjb25uUmVjZWl2ZXJfKHRoaXMuY29ubl8pO1xuICAgICAgICB0aGlzLnR4XyA9IHRoaXMuY29ubl87XG4gICAgICAgIHRoaXMucnhfID0gdGhpcy5jb25uXztcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IGZhbHNlO1xuICAgICAgICAvKlxuICAgICAgICAgKiBGaXJlZm94IGRvZXNuJ3QgbGlrZSB3aGVuIGNvZGUgZnJvbSBvbmUgaWZyYW1lIHRyaWVzIHRvIGNyZWF0ZSBhbm90aGVyIGlmcmFtZSBieSB3YXkgb2YgdGhlIHBhcmVudCBmcmFtZS5cbiAgICAgICAgICogVGhpcyBjYW4gb2NjdXIgaW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdCwgaS5lLiB3ZSBndWVzc2VkIHdyb25nIG9uIHdoYXQgc2VydmVyIHRvIGNvbm5lY3QgdG8gYW5kIHJlY2VpdmVkIGEgcmVzZXQuXG4gICAgICAgICAqIFNvbWVob3csIHNldFRpbWVvdXQgc2VlbXMgdG8gbWFrZSB0aGlzIG9rLiBUaGF0IGRvZXNuJ3QgbWFrZSBzZW5zZSBmcm9tIGEgc2VjdXJpdHkgcGVyc3BlY3RpdmUsIHNpbmNlIHlvdSBzaG91bGRcbiAgICAgICAgICogc3RpbGwgaGF2ZSB0aGUgY29udGV4dCBvZiB5b3VyIG9yaWdpbmF0aW5nIGZyYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB0aGlzLmNvbm5fIGdldHMgc2V0IHRvIG51bGwgaW4gc29tZSBvZiB0aGUgdGVzdHMuIENoZWNrIHRvIG1ha2Ugc3VyZSBpdCBzdGlsbCBleGlzdHMgYmVmb3JlIHVzaW5nIGl0XG4gICAgICAgICAgICBfdGhpcy5jb25uXyAmJiBfdGhpcy5jb25uXy5vcGVuKG9uTWVzc2FnZVJlY2VpdmVkLCBvbkNvbm5lY3Rpb25Mb3N0KTtcbiAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XG4gICAgICAgIHZhciBoZWFsdGh5VGltZW91dF9tcyA9IGNvbm5bJ2hlYWx0aHlUaW1lb3V0J10gfHwgMDtcbiAgICAgICAgaWYgKGhlYWx0aHlUaW1lb3V0X21zID4gMCkge1xuICAgICAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSB1dGlsXzEuc2V0VGltZW91dE5vbkJsb2NraW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oZWFsdGh5VGltZW91dF8gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaXNIZWFsdGh5Xykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29ubl8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5fLmJ5dGVzUmVjZWl2ZWQgPiBCWVRFU19SRUNFSVZFRF9IRUFMVEhZX09WRVJSSURFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dfKCdDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHJlY2VpdmVkICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5fLmJ5dGVzUmVjZWl2ZWQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMuICBNYXJraW5nIGNvbm5lY3Rpb24gaGVhbHRoeS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlzSGVhbHRoeV8gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubl8ubWFya0Nvbm5lY3Rpb25IZWFsdGh5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuY29ubl8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5fLmJ5dGVzU2VudCA+IEJZVEVTX1NFTlRfSEVBTFRIWV9PVkVSUklERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nXygnQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyBzZW50ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5fLmJ5dGVzU2VudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBieXRlcy4gIExlYXZpbmcgY29ubmVjdGlvbiBhbGl2ZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIGRvbid0IHdhbnQgdG8gbWFyayBpdCBoZWFsdGh5LCBzaW5jZSB3ZSBoYXZlIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBieXRlcyBoYXZlIG1hZGUgaXQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dfKCdDbG9zaW5nIHVuaGVhbHRoeSBjb25uZWN0aW9uIGFmdGVyIHRpbWVvdXQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcihoZWFsdGh5VGltZW91dF9tcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshc3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUubmV4dFRyYW5zcG9ydElkXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdjOicgKyB0aGlzLmlkICsgJzonICsgdGhpcy5jb25uZWN0aW9uQ291bnQrKztcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmRpc2Nvbm5SZWNlaXZlcl8gPSBmdW5jdGlvbiAoY29ubikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZXJDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChjb25uID09PSBfdGhpcy5jb25uXykge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uQ29ubmVjdGlvbkxvc3RfKGV2ZXJDb25uZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gX3RoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dfKCdTZWNvbmRhcnkgY29ubmVjdGlvbiBsb3N0LicpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uU2Vjb25kYXJ5Q29ubmVjdGlvbkxvc3RfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dfKCdjbG9zaW5nIGFuIG9sZCBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5jb25uUmVjZWl2ZXJfID0gZnVuY3Rpb24gKGNvbm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGVfICE9IDIgLyogRElTQ09OTkVDVEVEICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm4gPT09IF90aGlzLnJ4Xykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblByaW1hcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25uID09PSBfdGhpcy5zZWNvbmRhcnlDb25uXykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblNlY29uZGFyeU1lc3NhZ2VSZWNlaXZlZF8obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dfKCdtZXNzYWdlIG9uIG9sZCBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YU1zZyBBbiBhcmJpdHJhcnkgZGF0YSBtZXNzYWdlIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gKGRhdGFNc2cpIHtcbiAgICAgICAgLy8gd3JhcCBpbiBhIGRhdGEgbWVzc2FnZSBlbnZlbG9wZSBhbmQgc2VuZCBpdCBvblxuICAgICAgICB2YXIgbXNnID0geyB0OiAnZCcsIGQ6IGRhdGFNc2cgfTtcbiAgICAgICAgdGhpcy5zZW5kRGF0YV8obXNnKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnRyeUNsZWFudXBDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50eF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8gJiYgdGhpcy5yeF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnY2xlYW5pbmcgdXAgYW5kIHByb21vdGluZyBhIGNvbm5lY3Rpb246ICcgKyB0aGlzLnNlY29uZGFyeUNvbm5fLmNvbm5JZCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5fID0gdGhpcy5zZWNvbmRhcnlDb25uXztcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xuICAgICAgICAgICAgLy8gdGhlIHNlcnZlciB3aWxsIHNodXRkb3duIHRoZSBvbGQgY29ubmVjdGlvblxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5vblNlY29uZGFyeUNvbnRyb2xfID0gZnVuY3Rpb24gKGNvbnRyb2xEYXRhKSB7XG4gICAgICAgIGlmIChNRVNTQUdFX1RZUEUgaW4gY29udHJvbERhdGEpIHtcbiAgICAgICAgICAgIHZhciBjbWQgPSBjb250cm9sRGF0YVtNRVNTQUdFX1RZUEVdO1xuICAgICAgICAgICAgaWYgKGNtZCA9PT0gU1dJVENIX0FDSykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9SRVNFVCkge1xuICAgICAgICAgICAgICAgIC8vIE1vc3QgbGlrZWx5IHRoZSBzZXNzaW9uIHdhc24ndCB2YWxpZC4gQWJhbmRvbiB0aGUgc3dpdGNoIGF0dGVtcHRcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0dvdCBhIHJlc2V0IG9uIHNlY29uZGFyeSwgY2xvc2luZyBpdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGFscmVhZHkgdXNpbmcgdGhpcyBjb25uZWN0aW9uIGZvciBzb21ldGhpbmcsIHRoYW4gd2UgbmVlZCB0byBmdWxseSBjbG9zZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR4XyA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ4XyA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ2dvdCBwb25nIG9uIHNlY29uZGFyeS4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXy0tO1xuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25TZWNvbmRhcnlNZXNzYWdlUmVjZWl2ZWRfID0gZnVuY3Rpb24gKHBhcnNlZERhdGEpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdXRpbF8xLnJlcXVpcmVLZXkoJ3QnLCBwYXJzZWREYXRhKTtcbiAgICAgICAgdmFyIGRhdGEgPSB1dGlsXzEucmVxdWlyZUtleSgnZCcsIHBhcnNlZERhdGEpO1xuICAgICAgICBpZiAobGF5ZXIgPT0gJ2MnKSB7XG4gICAgICAgICAgICB0aGlzLm9uU2Vjb25kYXJ5Q29udHJvbF8oZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGF5ZXIgPT0gJ2QnKSB7XG4gICAgICAgICAgICAvLyBnb3QgYSBkYXRhIG1lc3NhZ2UsIGJ1dCB3ZSdyZSBzdGlsbCBzZWNvbmQgY29ubmVjdGlvbi4gTmVlZCB0byBidWZmZXIgaXQgdXBcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcy5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb3RvY29sIGxheWVyOiAnICsgbGF5ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS51cGdyYWRlSWZTZWNvbmRhcnlIZWFsdGh5XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5UmVzcG9uc2VzUmVxdWlyZWRfIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnU2Vjb25kYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcbiAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLm1hcmtDb25uZWN0aW9uSGVhbHRoeSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZWVkV2l0aFVwZ3JhZGVfKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTZW5kIGEgcGluZyB0byBtYWtlIHN1cmUgdGhlIGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cbiAgICAgICAgICAgIHRoaXMubG9nXygnc2VuZGluZyBwaW5nIG9uIHNlY29uZGFyeS4nKTtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uc2VuZCh7IHQ6ICdjJywgZDogeyB0OiBQSU5HLCBkOiB7fSB9IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5wcm9jZWVkV2l0aFVwZ3JhZGVfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0ZWxsIHRoaXMgY29ubmVjdGlvbiB0byBjb25zaWRlciBpdHNlbGYgb3BlblxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnN0YXJ0KCk7XG4gICAgICAgIC8vIHNlbmQgYWNrXG4gICAgICAgIHRoaXMubG9nXygnc2VuZGluZyBjbGllbnQgYWNrIG9uIHNlY29uZGFyeScpO1xuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogU1dJVENIX0FDSywgZDoge30gfSB9KTtcbiAgICAgICAgLy8gc2VuZCBlbmQgcGFja2V0IG9uIHByaW1hcnkgdHJhbnNwb3J0LCBzd2l0Y2ggdG8gc2VuZGluZyBvbiB0aGlzIG9uZVxuICAgICAgICAvLyBjYW4gcmVjZWl2ZSBvbiB0aGlzIG9uZSwgYnVmZmVyIHJlc3BvbnNlcyB1bnRpbCBlbmQgcmVjZWl2ZWQgb24gcHJpbWFyeSB0cmFuc3BvcnRcbiAgICAgICAgdGhpcy5sb2dfKCdFbmRpbmcgdHJhbnNtaXNzaW9uIG9uIHByaW1hcnknKTtcbiAgICAgICAgdGhpcy5jb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IEVORF9UUkFOU01JU1NJT04sIGQ6IHt9IH0gfSk7XG4gICAgICAgIHRoaXMudHhfID0gdGhpcy5zZWNvbmRhcnlDb25uXztcbiAgICAgICAgdGhpcy50cnlDbGVhbnVwQ29ubmVjdGlvbigpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25QcmltYXJ5TWVzc2FnZVJlY2VpdmVkXyA9IGZ1bmN0aW9uIChwYXJzZWREYXRhKSB7XG4gICAgICAgIC8vIE11c3QgcmVmZXIgdG8gcGFyc2VkRGF0YSBwcm9wZXJ0aWVzIGluIHF1b3Rlcywgc28gY2xvc3VyZSBkb2Vzbid0IHRvdWNoIHRoZW0uXG4gICAgICAgIHZhciBsYXllciA9IHV0aWxfMS5yZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XG4gICAgICAgIHZhciBkYXRhID0gdXRpbF8xLnJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcbiAgICAgICAgaWYgKGxheWVyID09ICdjJykge1xuICAgICAgICAgICAgdGhpcy5vbkNvbnRyb2xfKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09ICdkJykge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyhkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25EYXRhTWVzc2FnZV8gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm9uUHJpbWFyeVJlc3BvbnNlXygpO1xuICAgICAgICAvLyBXZSBkb24ndCBkbyBhbnl0aGluZyB3aXRoIGRhdGEgbWVzc2FnZXMsIGp1c3Qga2ljayB0aGVtIHVwIGEgbGV2ZWxcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VfKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25QcmltYXJ5UmVzcG9uc2VfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5Xykge1xuICAgICAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfLS07XG4gICAgICAgICAgICBpZiAodGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ1ByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25Db250cm9sXyA9IGZ1bmN0aW9uIChjb250cm9sRGF0YSkge1xuICAgICAgICB2YXIgY21kID0gdXRpbF8xLnJlcXVpcmVLZXkoTUVTU0FHRV9UWVBFLCBjb250cm9sRGF0YSk7XG4gICAgICAgIGlmIChNRVNTQUdFX0RBVEEgaW4gY29udHJvbERhdGEpIHtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gY29udHJvbERhdGFbTUVTU0FHRV9EQVRBXTtcbiAgICAgICAgICAgIGlmIChjbWQgPT09IFNFUlZFUl9IRUxMTykge1xuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kc2hha2VfKHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBFTkRfVFJBTlNNSVNTSU9OKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdyZWN2ZCBlbmQgdHJhbnNtaXNzaW9uIG9uIHByaW1hcnknKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ4XyA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyh0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUNsZWFudXBDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfU0hVVERPV04pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdhcyBwcmV2aW91c2x5IHRoZSAnb25LaWxsJyBjYWxsYmFjayBwYXNzZWQgdG8gdGhlIGxvd2VyLWxldmVsIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGluIHRoaXMgY2FzZSBpcyB0aGUgcmVhc29uIGZvciB0aGUgc2h1dGRvd24uIEdlbmVyYWxseSBhIGh1bWFuLXJlYWRhYmxlIGVycm9yXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25TaHV0ZG93bl8ocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUkVTRVQpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGluIHRoaXMgY2FzZSBpcyB0aGUgaG9zdCB3ZSBzaG91bGQgY29udGFjdFxuICAgICAgICAgICAgICAgIHRoaXMub25SZXNldF8ocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfRVJST1IpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEuZXJyb3IoJ1NlcnZlciBFcnJvcjogJyArIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ2dvdCBwb25nIG9uIHByaW1hcnkuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vblByaW1hcnlSZXNwb25zZV8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEuZXJyb3IoJ1Vua25vd24gY29udHJvbCBwYWNrZXQgY29tbWFuZDogJyArIGNtZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBUaGUgaGFuZHNoYWtlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5vbkhhbmRzaGFrZV8gPSBmdW5jdGlvbiAoaGFuZHNoYWtlKSB7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBoYW5kc2hha2UudHM7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gaGFuZHNoYWtlLnY7XG4gICAgICAgIHZhciBob3N0ID0gaGFuZHNoYWtlLmg7XG4gICAgICAgIHRoaXMuc2Vzc2lvbklkID0gaGFuZHNoYWtlLnM7XG4gICAgICAgIHRoaXMucmVwb0luZm9fLnVwZGF0ZUhvc3QoaG9zdCk7XG4gICAgICAgIC8vIGlmIHdlJ3ZlIGFscmVhZHkgY2xvc2VkIHRoZSBjb25uZWN0aW9uLCB0aGVuIGRvbid0IGJvdGhlciB0cnlpbmcgdG8gcHJvZ3Jlc3MgZnVydGhlclxuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gPT0gMCAvKiBDT05ORUNUSU5HICovKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5fLnN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvbkVzdGFibGlzaGVkXyh0aGlzLmNvbm5fLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgaWYgKENvbnN0YW50c18xLlBST1RPQ09MX1ZFUlNJT04gIT09IHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEud2FybignUHJvdG9jb2wgdmVyc2lvbiBtaXNtYXRjaCBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogZG8gd2Ugd2FudCB0byB1cGdyYWRlPyB3aGVuPyBtYXliZSBhIGRlbGF5P1xuICAgICAgICAgICAgdGhpcy50cnlTdGFydFVwZ3JhZGVfKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnRyeVN0YXJ0VXBncmFkZV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uID0gdGhpcy50cmFuc3BvcnRNYW5hZ2VyXy51cGdyYWRlVHJhbnNwb3J0KCk7XG4gICAgICAgIGlmIChjb25uKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VXBncmFkZV8oY29ubik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0VXBncmFkZV8gPSBmdW5jdGlvbiAoY29ubikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbmV3IGNvbm4odGhpcy5uZXh0VHJhbnNwb3J0SWRfKCksIHRoaXMucmVwb0luZm9fLCB0aGlzLnNlc3Npb25JZCk7XG4gICAgICAgIC8vIEZvciBjZXJ0YWluIHRyYW5zcG9ydHMgKFdlYlNvY2tldHMpLCB3ZSBuZWVkIHRvIHNlbmQgYW5kIHJlY2VpdmUgc2V2ZXJhbCBtZXNzYWdlcyBiYWNrIGFuZCBmb3J0aCBiZWZvcmUgd2VcbiAgICAgICAgLy8gY2FuIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgaGVhbHRoeS5cbiAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8gPVxuICAgICAgICAgICAgY29ublsncmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeSddIHx8IDA7XG4gICAgICAgIHZhciBvbk1lc3NhZ2UgPSB0aGlzLmNvbm5SZWNlaXZlcl8odGhpcy5zZWNvbmRhcnlDb25uXyk7XG4gICAgICAgIHZhciBvbkRpc2Nvbm5lY3QgPSB0aGlzLmRpc2Nvbm5SZWNlaXZlcl8odGhpcy5zZWNvbmRhcnlDb25uXyk7XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8ub3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3Qgc3VjY2Vzc2Z1bGx5IHVwZ3JhZGVkIGFmdGVyIFVQR1JBREVfVElNRU9VVCwgZ2l2ZSB1cCBhbmQga2lsbCB0aGUgc2Vjb25kYXJ5LlxuICAgICAgICB1dGlsXzEuc2V0VGltZW91dE5vbkJsb2NraW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zZWNvbmRhcnlDb25uXykge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ18oJ1RpbWVkIG91dCB0cnlpbmcgdG8gdXBncmFkZS4nKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWNvbmRhcnlDb25uXy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBNYXRoLmZsb29yKFVQR1JBREVfVElNRU9VVCkpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25SZXNldF8gPSBmdW5jdGlvbiAoaG9zdCkge1xuICAgICAgICB0aGlzLmxvZ18oJ1Jlc2V0IHBhY2tldCByZWNlaXZlZC4gIE5ldyBob3N0OiAnICsgaG9zdCk7XG4gICAgICAgIHRoaXMucmVwb0luZm9fLnVwZGF0ZUhvc3QoaG9zdCk7XG4gICAgICAgIC8vIFRPRE86IGlmIHdlJ3JlIGFscmVhZHkgXCJjb25uZWN0ZWRcIiwgd2UgbmVlZCB0byB0cmlnZ2VyIGEgZGlzY29ubmVjdCBhdCB0aGUgbmV4dCBsYXllciB1cC5cbiAgICAgICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgcmVzZXRzIGFmdGVyIHRoZSBjb25uZWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gZXN0YWJsaXNoZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfID09PSAxIC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2xvc2Ugd2hhdGV2ZXIgY29ubmVjdGlvbnMgd2UgaGF2ZSBvcGVuIGFuZCBzdGFydCBhZ2Fpbi5cbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRfKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uQ29ubmVjdGlvbkVzdGFibGlzaGVkXyA9IGZ1bmN0aW9uIChjb25uLCB0aW1lc3RhbXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkLicpO1xuICAgICAgICB0aGlzLmNvbm5fID0gY29ubjtcbiAgICAgICAgdGhpcy5zdGF0ZV8gPSAxIC8qIENPTk5FQ1RFRCAqLztcbiAgICAgICAgaWYgKHRoaXMub25SZWFkeV8pIHtcbiAgICAgICAgICAgIHRoaXMub25SZWFkeV8odGltZXN0YW1wLCB0aGlzLnNlc3Npb25JZCk7XG4gICAgICAgICAgICB0aGlzLm9uUmVhZHlfID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhZnRlciA1IHNlY29uZHMgd2UgaGF2ZW4ndCBzZW50IGVub3VnaCByZXF1ZXN0cyB0byB0aGUgc2VydmVyIHRvIGdldCB0aGUgY29ubmVjdGlvbiBoZWFsdGh5LFxuICAgICAgICAvLyBzZW5kIHNvbWUgcGluZ3MuXG4gICAgICAgIGlmICh0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnUHJpbWFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuJyk7XG4gICAgICAgICAgICB0aGlzLmlzSGVhbHRoeV8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbF8xLnNldFRpbWVvdXROb25CbG9ja2luZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8oKTtcbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoREVMQVlfQkVGT1JFX1NFTkRJTkdfRVhUUkFfUkVRVUVTVFMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uIGlzbid0IGNvbnNpZGVyZWQgaGVhbHRoeSB5ZXQsIHdlJ2xsIHNlbmQgYSBub29wIHBpbmcgcGFja2V0IHJlcXVlc3QuXG4gICAgICAgIGlmICghdGhpcy5pc0hlYWx0aHlfICYmIHRoaXMuc3RhdGVfID09PSAxIC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gcHJpbWFyeS4nKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZERhdGFfKHsgdDogJ2MnLCBkOiB7IHQ6IFBJTkcsIGQ6IHt9IH0gfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uU2Vjb25kYXJ5Q29ubmVjdGlvbkxvc3RfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubiA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy50eF8gPT09IGNvbm4gfHwgdGhpcy5yeF8gPT09IGNvbm4pIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSByZWx5aW5nIG9uIHRoaXMgY29ubmVjdGlvbiBhbHJlYWR5IGluIHNvbWUgY2FwYWNpdHkuIFRoZXJlZm9yZSwgYSBmYWlsdXJlIGlzIHJlYWxcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV2ZXJDb25uZWN0ZWQgV2hldGhlciBvciBub3QgdGhlIGNvbm5lY3Rpb24gZXZlciByZWFjaGVkIGEgc2VydmVyLiBVc2VkIHRvIGRldGVybWluZSBpZlxuICAgICAqIHdlIHNob3VsZCBmbHVzaCB0aGUgaG9zdCBjYWNoZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25Db25uZWN0aW9uTG9zdF8gPSBmdW5jdGlvbiAoZXZlckNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmNvbm5fID0gbnVsbDtcbiAgICAgICAgLy8gTk9URTogSUYgeW91J3JlIHNlZWluZyBhIEZpcmVmb3ggZXJyb3IgZm9yIHRoaXMgbGluZSwgSSB0aGluayBpdCBtaWdodCBiZSBiZWNhdXNlIGl0J3MgZ2V0dGluZ1xuICAgICAgICAvLyBjYWxsZWQgb24gd2luZG93IGNsb3NlIGFuZCBSZWFsdGltZVN0YXRlLkNPTk5FQ1RJTkcgaXMgbm8gbG9uZ2VyIGRlZmluZWQuICBKdXN0IGEgZ3Vlc3MuXG4gICAgICAgIGlmICghZXZlckNvbm5lY3RlZCAmJiB0aGlzLnN0YXRlXyA9PT0gMCAvKiBDT05ORUNUSU5HICovKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1JlYWx0aW1lIGNvbm5lY3Rpb24gZmFpbGVkLicpO1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UgZmFpbGVkIHRvIGNvbm5lY3QgYXQgYWxsLCBjbGVhciBhbnkgY2FjaGVkIGVudHJ5IGZvciB0aGlzIG5hbWVzcGFjZSBpbiBjYXNlIHRoZSBtYWNoaW5lIHdlbnQgYXdheVxuICAgICAgICAgICAgaWYgKHRoaXMucmVwb0luZm9fLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZV8xLlBlcnNpc3RlbnRTdG9yYWdlLnJlbW92ZSgnaG9zdDonICsgdGhpcy5yZXBvSW5mb18uaG9zdCk7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGludGVybmFsIGhvc3QgdG8gd2hhdCB3ZSB3b3VsZCBzaG93IHRoZSB1c2VyLCBpLmUuIDxucz4uZmlyZWJhc2Vpby5jb21cbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9JbmZvXy5pbnRlcm5hbEhvc3QgPSB0aGlzLnJlcG9JbmZvXy5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGVfID09PSAxIC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGxvc3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5vbkNvbm5lY3Rpb25TaHV0ZG93bl8gPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHRoaXMubG9nXygnQ29ubmVjdGlvbiBzaHV0ZG93biBjb21tYW5kIHJlY2VpdmVkLiBTaHV0dGluZyBkb3duLi4uJyk7XG4gICAgICAgIGlmICh0aGlzLm9uS2lsbF8pIHtcbiAgICAgICAgICAgIHRoaXMub25LaWxsXyhyZWFzb24pO1xuICAgICAgICAgICAgdGhpcy5vbktpbGxfID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHdhbnQgdG8gZmlyZSBvbkRpc2Nvbm5lY3QgKGtpbGwgaXMgYSBkaWZmZXJlbnQgY2FzZSksXG4gICAgICAgIC8vIHNvIGNsZWFyIHRoZSBjYWxsYmFjay5cbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZERhdGFfID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSAxIC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgICAgICAgdGhyb3cgJ0Nvbm5lY3Rpb24gaXMgbm90IGNvbm5lY3RlZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR4Xy5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgdGhpcyBjb25uZWN0aW9uLCBjYWxsaW5nIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3NcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSAyIC8qIERJU0NPTk5FQ1RFRCAqLykge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdDbG9zaW5nIHJlYWx0aW1lIGNvbm5lY3Rpb24uJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlXyA9IDIgLyogRElTQ09OTkVDVEVEICovO1xuICAgICAgICAgICAgdGhpcy5jbG9zZUNvbm5lY3Rpb25zXygpO1xuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0Xykge1xuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0XygpO1xuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZUNvbm5lY3Rpb25zXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dfKCdTaHV0dGluZyBkb3duIGFsbCBjb25uZWN0aW9ucycpO1xuICAgICAgICBpZiAodGhpcy5jb25uXykge1xuICAgICAgICAgICAgdGhpcy5jb25uXy5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jb25uXyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlYWx0aHlUaW1lb3V0Xykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhbHRoeVRpbWVvdXRfKTtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoeVRpbWVvdXRfID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbm5lY3Rpb247XG59KCkpO1xuZXhwb3J0cy5Db25uZWN0aW9uID0gQ29ubmVjdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29ubmVjdGlvbi5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUFJPVE9DT0xfVkVSU0lPTiA9ICc1JztcbmV4cG9ydHMuVkVSU0lPTl9QQVJBTSA9ICd2JztcbmV4cG9ydHMuVFJBTlNQT1JUX1NFU1NJT05fUEFSQU0gPSAncyc7XG5leHBvcnRzLlJFRkVSRVJfUEFSQU0gPSAncic7XG5leHBvcnRzLkZPUkdFX1JFRiA9ICdmJztcbmV4cG9ydHMuRk9SR0VfRE9NQUlOID0gJ2ZpcmViYXNlaW8uY29tJztcbmV4cG9ydHMuTEFTVF9TRVNTSU9OX1BBUkFNID0gJ2xzJztcbmV4cG9ydHMuV0VCU09DS0VUID0gJ3dlYnNvY2tldCc7XG5leHBvcnRzLkxPTkdfUE9MTElORyA9ICdsb25nX3BvbGxpbmcnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25zdGFudHMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnJvd3NlclBvbGxDb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9Ccm93c2VyUG9sbENvbm5lY3Rpb25cIik7XG52YXIgV2ViU29ja2V0Q29ubmVjdGlvbl8xID0gcmVxdWlyZShcIi4vV2ViU29ja2V0Q29ubmVjdGlvblwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL3V0aWxcIik7XG4vKipcbiAqIEN1cnJlbnRseSBzaW1wbGlzdGljLCB0aGlzIGNsYXNzIG1hbmFnZXMgd2hhdCB0cmFuc3BvcnQgYSBDb25uZWN0aW9uIHNob3VsZCB1c2UgYXQgdmFyaW91cyBzdGFnZXMgb2YgaXRzXG4gKiBsaWZlY3ljbGUuXG4gKlxuICogSXQgc3RhcnRzIHdpdGggbG9uZ3BvbGxpbmcgaW4gYSBicm93c2VyLCBhbmQgaHR0cHBvbGxpbmcgb24gbm9kZS4gSXQgdGhlbiB1cGdyYWRlcyB0byB3ZWJzb2NrZXRzIGlmXG4gKiB0aGV5IGFyZSBhdmFpbGFibGUuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFRyYW5zcG9ydE1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUmVwb0luZm99IHJlcG9JbmZvIE1ldGFkYXRhIGFyb3VuZCB0aGUgbmFtZXNwYWNlIHdlJ3JlIGNvbm5lY3RpbmcgdG9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFuc3BvcnRNYW5hZ2VyKHJlcG9JbmZvKSB7XG4gICAgICAgIHRoaXMuaW5pdFRyYW5zcG9ydHNfKHJlcG9JbmZvKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zcG9ydE1hbmFnZXIsIFwiQUxMX1RSQU5TUE9SVFNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPGZ1bmN0aW9uKG5ldzpUcmFuc3BvcnQsIHN0cmluZywgUmVwb0luZm8sIHN0cmluZz0pPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtCcm93c2VyUG9sbENvbm5lY3Rpb25fMS5Ccm93c2VyUG9sbENvbm5lY3Rpb24sIFdlYlNvY2tldENvbm5lY3Rpb25fMS5XZWJTb2NrZXRDb25uZWN0aW9uXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUmVwb0luZm99IHJlcG9JbmZvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUcmFuc3BvcnRNYW5hZ2VyLnByb3RvdHlwZS5pbml0VHJhbnNwb3J0c18gPSBmdW5jdGlvbiAocmVwb0luZm8pIHtcbiAgICAgICAgdmFyIGlzV2ViU29ja2V0c0F2YWlsYWJsZSA9IFdlYlNvY2tldENvbm5lY3Rpb25fMS5XZWJTb2NrZXRDb25uZWN0aW9uICYmIFdlYlNvY2tldENvbm5lY3Rpb25fMS5XZWJTb2NrZXRDb25uZWN0aW9uWydpc0F2YWlsYWJsZSddKCk7XG4gICAgICAgIHZhciBpc1NraXBQb2xsQ29ubmVjdGlvbiA9IGlzV2ViU29ja2V0c0F2YWlsYWJsZSAmJiAhV2ViU29ja2V0Q29ubmVjdGlvbl8xLldlYlNvY2tldENvbm5lY3Rpb24ucHJldmlvdXNseUZhaWxlZCgpO1xuICAgICAgICBpZiAocmVwb0luZm8ud2ViU29ja2V0T25seSkge1xuICAgICAgICAgICAgaWYgKCFpc1dlYlNvY2tldHNBdmFpbGFibGUpXG4gICAgICAgICAgICAgICAgdXRpbF8xLndhcm4oXCJ3c3M6Ly8gVVJMIHVzZWQsIGJ1dCBicm93c2VyIGlzbid0IGtub3duIHRvIHN1cHBvcnQgd2Vic29ja2V0cy4gIFRyeWluZyBhbnl3YXkuXCIpO1xuICAgICAgICAgICAgaXNTa2lwUG9sbENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NraXBQb2xsQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRzXyA9IFtXZWJTb2NrZXRDb25uZWN0aW9uXzEuV2ViU29ja2V0Q29ubmVjdGlvbl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNwb3J0c18xID0gKHRoaXMudHJhbnNwb3J0c18gPSBbXSk7XG4gICAgICAgICAgICB1dGlsXzEuZWFjaChUcmFuc3BvcnRNYW5hZ2VyLkFMTF9UUkFOU1BPUlRTLCBmdW5jdGlvbiAoaSwgdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCAmJiB0cmFuc3BvcnRbJ2lzQXZhaWxhYmxlJ10oKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRzXzEucHVzaCh0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6VHJhbnNwb3J0LCAhc3RyaW5nLCAhUmVwb0luZm8sIHN0cmluZz0sIHN0cmluZz0pfSBUaGUgY29uc3RydWN0b3IgZm9yIHRoZVxuICAgICAqIGluaXRpYWwgdHJhbnNwb3J0IHRvIHVzZVxuICAgICAqL1xuICAgIFRyYW5zcG9ydE1hbmFnZXIucHJvdG90eXBlLmluaXRpYWxUcmFuc3BvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydHNfLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydHNfWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb24obmV3OlRyYW5zcG9ydCwgZnVuY3Rpb24oKSxmdW5jdGlvbigpLCBzdHJpbmc9KX0gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgbmV4dFxuICAgICAqIHRyYW5zcG9ydCwgb3IgbnVsbFxuICAgICAqL1xuICAgIFRyYW5zcG9ydE1hbmFnZXIucHJvdG90eXBlLnVwZ3JhZGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydHNfLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydHNfWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUcmFuc3BvcnRNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuVHJhbnNwb3J0TWFuYWdlciA9IFRyYW5zcG9ydE1hbmFnZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zcG9ydE1hbmFnZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXBwXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL2FwcFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC91dGlsXCIpO1xudmFyIFN0YXRzTWFuYWdlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvc3RhdHMvU3RhdHNNYW5hZ2VyXCIpO1xudmFyIENvbnN0YW50c18xID0gcmVxdWlyZShcIi4vQ29uc3RhbnRzXCIpO1xudmFyIHV0aWxfMyA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBzdG9yYWdlXzEgPSByZXF1aXJlKFwiLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VcIik7XG52YXIgdXRpbF80ID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfNSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBXRUJTT0NLRVRfTUFYX0ZSQU1FX1NJWkUgPSAxNjM4NDtcbnZhciBXRUJTT0NLRVRfS0VFUEFMSVZFX0lOVEVSVkFMID0gNDUwMDA7XG52YXIgV2ViU29ja2V0SW1wbCA9IG51bGw7XG5pZiAodHlwZW9mIE1veldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBXZWJTb2NrZXRJbXBsID0gTW96V2ViU29ja2V0O1xufVxuZWxzZSBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBXZWJTb2NrZXRJbXBsID0gV2ViU29ja2V0O1xufVxuZnVuY3Rpb24gc2V0V2ViU29ja2V0SW1wbChpbXBsKSB7XG4gICAgV2ViU29ja2V0SW1wbCA9IGltcGw7XG59XG5leHBvcnRzLnNldFdlYlNvY2tldEltcGwgPSBzZXRXZWJTb2NrZXRJbXBsO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgd2Vic29ja2V0IGNvbm5lY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gY2FsbGJhY2tzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7VHJhbnNwb3J0fVxuICovXG52YXIgV2ViU29ja2V0Q29ubmVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29ubklkIGlkZW50aWZpZXIgZm9yIHRoaXMgdHJhbnNwb3J0XG4gICAgICogQHBhcmFtIHtSZXBvSW5mb30gcmVwb0luZm8gVGhlIGluZm8gZm9yIHRoZSB3ZWJzb2NrZXQgZW5kcG9pbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSB0cmFuc3BvcnRTZXNzaW9uSWQgT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZyB0byBhbiBleGlzdGluZyB0cmFuc3BvcnRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gbGFzdFNlc3Npb25JZCBPcHRpb25hbCBsYXN0U2Vzc2lvbklkIGlmIHRoZXJlIHdhcyBhIHByZXZpb3VzIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXZWJTb2NrZXRDb25uZWN0aW9uKGNvbm5JZCwgcmVwb0luZm8sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCkge1xuICAgICAgICB0aGlzLmNvbm5JZCA9IGNvbm5JZDtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhbWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IDA7XG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ID0gMDtcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy5sb2dfID0gdXRpbF8yLmxvZ1dyYXBwZXIodGhpcy5jb25uSWQpO1xuICAgICAgICB0aGlzLnN0YXRzXyA9IFN0YXRzTWFuYWdlcl8xLlN0YXRzTWFuYWdlci5nZXRDb2xsZWN0aW9uKHJlcG9JbmZvKTtcbiAgICAgICAgdGhpcy5jb25uVVJMID0gV2ViU29ja2V0Q29ubmVjdGlvbi5jb25uZWN0aW9uVVJMXyhyZXBvSW5mbywgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZXBvSW5mb30gcmVwb0luZm8gVGhlIGluZm8gZm9yIHRoZSB3ZWJzb2NrZXQgZW5kcG9pbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSB0cmFuc3BvcnRTZXNzaW9uSWQgT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZyB0byBhbiBleGlzdGluZyB0cmFuc3BvcnRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gbGFzdFNlc3Npb25JZCBPcHRpb25hbCBsYXN0U2Vzc2lvbklkIGlmIHRoZXJlIHdhcyBhIHByZXZpb3VzIGNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGNvbm5lY3Rpb24gdXJsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLmNvbm5lY3Rpb25VUkxfID0gZnVuY3Rpb24gKHJlcG9JbmZvLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQpIHtcbiAgICAgICAgdmFyIHVybFBhcmFtcyA9IHt9O1xuICAgICAgICB1cmxQYXJhbXNbQ29uc3RhbnRzXzEuVkVSU0lPTl9QQVJBTV0gPSBDb25zdGFudHNfMS5QUk9UT0NPTF9WRVJTSU9OO1xuICAgICAgICBpZiAoIXV0aWxfNS5pc05vZGVTZGsoKSAmJlxuICAgICAgICAgICAgdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgbG9jYXRpb24uaHJlZiAmJlxuICAgICAgICAgICAgbG9jYXRpb24uaHJlZi5pbmRleE9mKENvbnN0YW50c18xLkZPUkdFX0RPTUFJTikgIT09IC0xKSB7XG4gICAgICAgICAgICB1cmxQYXJhbXNbQ29uc3RhbnRzXzEuUkVGRVJFUl9QQVJBTV0gPSBDb25zdGFudHNfMS5GT1JHRV9SRUY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zcG9ydFNlc3Npb25JZCkge1xuICAgICAgICAgICAgdXJsUGFyYW1zW0NvbnN0YW50c18xLlRSQU5TUE9SVF9TRVNTSU9OX1BBUkFNXSA9IHRyYW5zcG9ydFNlc3Npb25JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFNlc3Npb25JZCkge1xuICAgICAgICAgICAgdXJsUGFyYW1zW0NvbnN0YW50c18xLkxBU1RfU0VTU0lPTl9QQVJBTV0gPSBsYXN0U2Vzc2lvbklkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBvSW5mby5jb25uZWN0aW9uVVJMKENvbnN0YW50c18xLldFQlNPQ0tFVCwgdXJsUGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG9uTWVzc2FnZSBDYWxsYmFjayB3aGVuIG1lc3NhZ2VzIGFycml2ZVxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgQ2FsbGJhY2sgd2l0aCBjb25uZWN0aW9uIGxvc3QuXG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG9uRGlzY29ubmVjdDtcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2UgPSBvbk1lc3NhZ2U7XG4gICAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3RpbmcgdG8gJyArIHRoaXMuY29ublVSTCk7XG4gICAgICAgIHRoaXMuZXZlckNvbm5lY3RlZF8gPSBmYWxzZTtcbiAgICAgICAgLy8gQXNzdW1lIGZhaWx1cmUgdW50aWwgcHJvdmVuIG90aGVyd2lzZS5cbiAgICAgICAgc3RvcmFnZV8xLlBlcnNpc3RlbnRTdG9yYWdlLnNldCgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnLCB0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh1dGlsXzUuaXNOb2RlU2RrKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGV2aWNlID0gdXRpbF8zLkNPTlNUQU5UUy5OT0RFX0FETUlOID8gJ0FkbWluTm9kZScgOiAnTm9kZSc7XG4gICAgICAgICAgICAgICAgLy8gVUEgRm9ybWF0OiBGaXJlYmFzZS88d2lyZV9wcm90b2NvbD4vPHNka192ZXJzaW9uPi88cGxhdGZvcm0+LzxkZXZpY2U+XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdVc2VyLUFnZW50JzogXCJGaXJlYmFzZS9cIiArIENvbnN0YW50c18xLlBST1RPQ09MX1ZFUlNJT04gKyBcIi9cIiArIGFwcF8xLmRlZmF1bHQuU0RLX1ZFUlNJT04gKyBcIi9cIiArIHByb2Nlc3MucGxhdGZvcm0gKyBcIi9cIiArIGRldmljZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBQbHVtYiBhcHByb3ByaWF0ZSBodHRwX3Byb3h5IGVudmlyb25tZW50IHZhcmlhYmxlIGludG8gZmF5ZS13ZWJzb2NrZXQgaWYgaXQgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHZhciBlbnYgPSBwcm9jZXNzWydlbnYnXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLmNvbm5VUkwuaW5kZXhPZignd3NzOi8vJykgPT0gMFxuICAgICAgICAgICAgICAgICAgICA/IGVudlsnSFRUUFNfUFJPWFknXSB8fCBlbnZbJ2h0dHBzX3Byb3h5J11cbiAgICAgICAgICAgICAgICAgICAgOiBlbnZbJ0hUVFBfUFJPWFknXSB8fCBlbnZbJ2h0dHBfcHJveHknXTtcbiAgICAgICAgICAgICAgICBpZiAocHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1sncHJveHknXSA9IHsgb3JpZ2luOiBwcm94eSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm15U29jayA9IG5ldyBXZWJTb2NrZXRJbXBsKHRoaXMuY29ublVSTCwgW10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5teVNvY2sgPSBuZXcgV2ViU29ja2V0SW1wbCh0aGlzLmNvbm5VUkwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Vycm9yIGluc3RhbnRpYXRpbmcgV2ViU29ja2V0LicpO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gZS5tZXNzYWdlIHx8IGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nXyhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXlTb2NrLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ18oJ1dlYnNvY2tldCBjb25uZWN0ZWQuJyk7XG4gICAgICAgICAgICBfdGhpcy5ldmVyQ29ubmVjdGVkXyA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubXlTb2NrLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dfKCdXZWJzb2NrZXQgY29ubmVjdGlvbiB3YXMgZGlzY29ubmVjdGVkLicpO1xuICAgICAgICAgICAgX3RoaXMubXlTb2NrID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm15U29jay5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlSW5jb21pbmdGcmFtZShtKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5teVNvY2sub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dfKCdXZWJTb2NrZXQgZXJyb3IuICBDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBlLm1lc3NhZ2UgfHwgZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nXyhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5vbkNsb3NlZF8oKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5vLW9wIGZvciB3ZWJzb2NrZXRzLCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIG9uY2UgdGhlIGNvbm5lY3Rpb24gaXMgY29uZmlybWVkIGFzIG9wZW5cbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFdlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18gPSB0cnVlO1xuICAgIH07XG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlzT2xkQW5kcm9pZCA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCkge1xuICAgICAgICAgICAgdmFyIG9sZEFuZHJvaWRSZWdleCA9IC9BbmRyb2lkIChbMC05XXswLH1cXC5bMC05XXswLH0pLztcbiAgICAgICAgICAgIHZhciBvbGRBbmRyb2lkTWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKG9sZEFuZHJvaWRSZWdleCk7XG4gICAgICAgICAgICBpZiAob2xkQW5kcm9pZE1hdGNoICYmIG9sZEFuZHJvaWRNYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQob2xkQW5kcm9pZE1hdGNoWzFdKSA8IDQuNCkge1xuICAgICAgICAgICAgICAgICAgICBpc09sZEFuZHJvaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCFpc09sZEFuZHJvaWQgJiZcbiAgICAgICAgICAgIFdlYlNvY2tldEltcGwgIT09IG51bGwgJiZcbiAgICAgICAgICAgICFXZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3dfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB3ZSBwcmV2aW91c2x5IGZhaWxlZCB0byBjb25uZWN0IHdpdGggdGhpcyB0cmFuc3BvcnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByZXZpb3VzbHlGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIG91ciBwZXJzaXN0ZW50IHN0b3JhZ2UgaXMgYWN0dWFsbHkgb25seSBpbi1tZW1vcnkgc3RvcmFnZSxcbiAgICAgICAgLy8gd2UgZGVmYXVsdCB0byBhc3N1bWluZyB0aGF0IGl0IHByZXZpb3VzbHkgZmFpbGVkIHRvIGJlIHNhZmUuXG4gICAgICAgIHJldHVybiAoc3RvcmFnZV8xLlBlcnNpc3RlbnRTdG9yYWdlLmlzSW5NZW1vcnlTdG9yYWdlIHx8XG4gICAgICAgICAgICBzdG9yYWdlXzEuUGVyc2lzdGVudFN0b3JhZ2UuZ2V0KCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScpID09PSB0cnVlKTtcbiAgICB9O1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLm1hcmtDb25uZWN0aW9uSGVhbHRoeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RvcmFnZV8xLlBlcnNpc3RlbnRTdG9yYWdlLnJlbW92ZSgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnKTtcbiAgICB9O1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmFwcGVuZEZyYW1lXyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZnJhbWVzLnB1c2goZGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lcy5sZW5ndGggPT0gdGhpcy50b3RhbEZyYW1lcykge1xuICAgICAgICAgICAgdmFyIGZ1bGxNZXNzID0gdGhpcy5mcmFtZXMuam9pbignJyk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lcyA9IG51bGw7XG4gICAgICAgICAgICB2YXIganNvbk1lc3MgPSB1dGlsXzQuanNvbkV2YWwoZnVsbE1lc3MpO1xuICAgICAgICAgICAgLy9oYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRoaXMub25NZXNzYWdlKGpzb25NZXNzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyYW1lQ291bnQgVGhlIG51bWJlciBvZiBmcmFtZXMgd2UgYXJlIGV4cGVjdGluZyBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZU5ld0ZyYW1lQ291bnRfID0gZnVuY3Rpb24gKGZyYW1lQ291bnQpIHtcbiAgICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IGZyYW1lQ291bnQ7XG4gICAgICAgIHRoaXMuZnJhbWVzID0gW107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBwYXJzZSBhIGZyYW1lIGNvdW50IG91dCBvZiBzb21lIHRleHQuIElmIGl0IGNhbid0LCBhc3N1bWVzIGEgdmFsdWUgb2YgMVxuICAgICAqIEBwYXJhbSB7IVN0cmluZ30gZGF0YVxuICAgICAqIEByZXR1cm4gez9TdHJpbmd9IEFueSByZW1haW5pbmcgZGF0YSB0byBiZSBwcm9jZXNzLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmV4dHJhY3RGcmFtZUNvdW50XyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodGhpcy5mcmFtZXMgPT09IG51bGwsICdXZSBhbHJlYWR5IGhhdmUgYSBmcmFtZSBidWZmZXInKTtcbiAgICAgICAgLy8gVE9ETzogVGhlIHNlcnZlciBpcyBvbmx5IHN1cHBvc2VkIHRvIHNlbmQgdXAgdG8gOTk5OSBmcmFtZXMgKGkuZS4gbGVuZ3RoIDw9IDQpLCBidXQgdGhhdCBpc24ndCBiZWluZyBlbmZvcmNlZFxuICAgICAgICAvLyBjdXJyZW50bHkuICBTbyBhbGxvd2luZyBsYXJnZXIgZnJhbWUgY291bnRzIChsZW5ndGggPD0gNikuICBTZWUgaHR0cHM6Ly9hcHAuYXNhbmEuY29tLzAvc2VhcmNoLzg2ODg1OTg5OTgzODAvODIzNzYwODA0MjUwOFxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPD0gNikge1xuICAgICAgICAgICAgdmFyIGZyYW1lQ291bnQgPSBOdW1iZXIoZGF0YSk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGZyYW1lQ291bnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVOZXdGcmFtZUNvdW50XyhmcmFtZUNvdW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZU5ld0ZyYW1lQ291bnRfKDEpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYSB3ZWJzb2NrZXQgZnJhbWUgdGhhdCBoYXMgYXJyaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIG1lc3MgVGhlIGZyYW1lIGRhdGFcbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVJbmNvbWluZ0ZyYW1lID0gZnVuY3Rpb24gKG1lc3MpIHtcbiAgICAgICAgaWYgKHRoaXMubXlTb2NrID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBDaHJvbWUgYXBwYXJlbnRseSBkZWxpdmVycyBpbmNvbWluZyBwYWNrZXRzIGV2ZW4gYWZ0ZXIgd2UgLmNsb3NlKCkgdGhlIGNvbm5lY3Rpb24gc29tZXRpbWVzLlxuICAgICAgICB2YXIgZGF0YSA9IG1lc3NbJ2RhdGEnXTtcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKCdieXRlc19yZWNlaXZlZCcsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5yZXNldEtlZXBBbGl2ZSgpO1xuICAgICAgICBpZiAodGhpcy5mcmFtZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIGJ1ZmZlcmluZ1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRGcmFtZV8oZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0cnkgdG8gcGFyc2Ugb3V0IGEgZnJhbWUgY291bnQsIG90aGVyd2lzZSwgYXNzdW1lIDEgYW5kIHByb2Nlc3MgaXRcbiAgICAgICAgICAgIHZhciByZW1haW5pbmdEYXRhID0gdGhpcy5leHRyYWN0RnJhbWVDb3VudF8oZGF0YSk7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kRnJhbWVfKHJlbWFpbmluZ0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgc2VydmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIEpTT04gb2JqZWN0IHRvIHRyYW5zbWl0XG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMucmVzZXRLZWVwQWxpdmUoKTtcbiAgICAgICAgdmFyIGRhdGFTdHIgPSB1dGlsXzQuc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICB0aGlzLmJ5dGVzU2VudCArPSBkYXRhU3RyLmxlbmd0aDtcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfc2VudCcsIGRhdGFTdHIubGVuZ3RoKTtcbiAgICAgICAgLy9XZSBjYW4gb25seSBmaXQgYSBjZXJ0YWluIGFtb3VudCBpbiBlYWNoIHdlYnNvY2tldCBmcmFtZSwgc28gd2UgbmVlZCB0byBzcGxpdCB0aGlzIHJlcXVlc3RcbiAgICAgICAgLy91cCBpbnRvIG11bHRpcGxlIHBpZWNlcyBpZiBpdCBkb2Vzbid0IGZpdCBpbiBvbmUgcmVxdWVzdC5cbiAgICAgICAgdmFyIGRhdGFTZWdzID0gdXRpbF8yLnNwbGl0U3RyaW5nQnlTaXplKGRhdGFTdHIsIFdFQlNPQ0tFVF9NQVhfRlJBTUVfU0laRSk7XG4gICAgICAgIC8vU2VuZCB0aGUgbGVuZ3RoIGhlYWRlclxuICAgICAgICBpZiAoZGF0YVNlZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5zZW5kU3RyaW5nXyhTdHJpbmcoZGF0YVNlZ3MubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9TZW5kIHRoZSBhY3R1YWwgZGF0YSBpbiBzZWdtZW50cy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhU2Vncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZW5kU3RyaW5nXyhkYXRhU2Vnc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNodXRkb3duXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5rZWVwYWxpdmVUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm15U29jaykge1xuICAgICAgICAgICAgdGhpcy5teVNvY2suY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMubXlTb2NrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUub25DbG9zZWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dlYlNvY2tldCBpcyBjbG9zaW5nIGl0c2VsZicpO1xuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoaXMgaXMgYW4gaW50ZXJuYWwgY2xvc2UsIHRyaWdnZXIgdGhlIGNsb3NlIGxpc3RlbmVyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCh0aGlzLmV2ZXJDb25uZWN0ZWRfKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dGVybmFsLWZhY2luZyBjbG9zZSBoYW5kbGVyLlxuICAgICAqIENsb3NlIHRoZSB3ZWJzb2NrZXQgYW5kIGtpbGwgdGhlIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGlzIGJlaW5nIGNsb3NlZCcpO1xuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogS2lsbCB0aGUgY3VycmVudCBrZWVwYWxpdmUgdGltZXIgYW5kIHN0YXJ0IGEgbmV3IG9uZSwgdG8gZW5zdXJlIHRoYXQgaXQgYWx3YXlzIGZpcmVzIE4gc2Vjb25kcyBhZnRlclxuICAgICAqIHRoZSBsYXN0IGFjdGl2aXR5LlxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnJlc2V0S2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMua2VlcGFsaXZlVGltZXIpO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy9JZiB0aGVyZSBoYXMgYmVlbiBubyB3ZWJzb2NrZXQgYWN0aXZpdHkgZm9yIGEgd2hpbGUsIHNlbmQgYSBuby1vcFxuICAgICAgICAgICAgaWYgKF90aGlzLm15U29jaykge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlbmRTdHJpbmdfKCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZXNldEtlZXBBbGl2ZSgpO1xuICAgICAgICB9LCBNYXRoLmZsb29yKFdFQlNPQ0tFVF9LRUVQQUxJVkVfSU5URVJWQUwpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSBzdHJpbmcgb3ZlciB0aGUgd2Vic29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VuZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRTdHJpbmdfID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAvLyBGaXJlZm94IHNlZW1zIHRvIHNvbWV0aW1lcyB0aHJvdyBleGNlcHRpb25zIChOU19FUlJPUl9VTkVYUEVDVEVEKSBmcm9tIHdlYnNvY2tldCAuc2VuZCgpXG4gICAgICAgIC8vIGNhbGxzIGZvciBzb21lIHVua25vd24gcmVhc29uLiAgV2UgdHJlYXQgdGhlc2UgYXMgYW4gZXJyb3IgYW5kIGRpc2Nvbm5lY3QuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2FwcC5hc2FuYS5jb20vMC81ODkyNjExMTQwMjI5Mi82ODAyMTM0MDI1MDQxMFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5teVNvY2suc2VuZChzdHIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0V4Y2VwdGlvbiB0aHJvd24gZnJvbSBXZWJTb2NrZXQuc2VuZCgpOicsIGUubWVzc2FnZSB8fCBlLmRhdGEsICdDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMub25DbG9zZWRfLmJpbmQodGhpcyksIDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgcmVzcG9uc2UgYmVmb3JlIHdlIGNvbnNpZGVyIHRoZSBjb25uZWN0aW9uIFwiaGVhbHRoeS5cIlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5ID0gMjtcbiAgICAvKipcbiAgICAgKiBUaW1lIHRvIHdhaXQgZm9yIHRoZSBjb25uZWN0aW9uIHRlIGJlY29tZSBoZWFsdGh5IGJlZm9yZSBnaXZpbmcgdXAuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLmhlYWx0aHlUaW1lb3V0ID0gMzAwMDA7XG4gICAgcmV0dXJuIFdlYlNvY2tldENvbm5lY3Rpb247XG59KCkpO1xuZXhwb3J0cy5XZWJTb2NrZXRDb25uZWN0aW9uID0gV2ViU29ja2V0Q29ubmVjdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViU29ja2V0Q29ubmVjdGlvbi5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZS91dGlsL3V0aWxcIik7XG4vKipcbiAqIFRoaXMgY2xhc3MgZW5zdXJlcyB0aGUgcGFja2V0cyBmcm9tIHRoZSBzZXJ2ZXIgYXJyaXZlIGluIG9yZGVyXG4gKiBUaGlzIGNsYXNzIHRha2VzIGRhdGEgZnJvbSB0aGUgc2VydmVyIGFuZCBlbnN1cmVzIGl0IGdldHMgcGFzc2VkIGludG8gdGhlIGNhbGxiYWNrcyBpbiBvcmRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUGFja2V0UmVjZWl2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uTWVzc2FnZV9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYWNrZXRSZWNlaXZlcihvbk1lc3NhZ2VfKSB7XG4gICAgICAgIHRoaXMub25NZXNzYWdlXyA9IG9uTWVzc2FnZV87XG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZU51bSA9IDA7XG4gICAgICAgIHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlID0gLTE7XG4gICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XG4gICAgfVxuICAgIFBhY2tldFJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZUFmdGVyID0gZnVuY3Rpb24gKHJlc3BvbnNlTnVtLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA9IHJlc3BvbnNlTnVtO1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlIDwgdGhpcy5jdXJyZW50UmVzcG9uc2VOdW0pIHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRWFjaCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlciBjb21lcyB3aXRoIGEgcmVzcG9uc2UgbnVtYmVyLCBhbmQgYW4gYXJyYXkgb2YgZGF0YS4gVGhlIHJlc3BvbnNlTnVtYmVyXG4gICAgICogYWxsb3dzIHVzIHRvIGVuc3VyZSB0aGF0IHdlIHByb2Nlc3MgdGhlbSBpbiB0aGUgcmlnaHQgb3JkZXIsIHNpbmNlIHdlIGNhbid0IGJlIGd1YXJhbnRlZWQgdGhhdCBhbGxcbiAgICAgKiBicm93c2VycyB3aWxsIHJlc3BvbmQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHJlcXVlc3RzIHdlIHNlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVxdWVzdE51bVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICAgKi9cbiAgICBQYWNrZXRSZWNlaXZlci5wcm90b3R5cGUuaGFuZGxlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVxdWVzdE51bSwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXNbcmVxdWVzdE51bV0gPSBkYXRhO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b1Byb2Nlc3MgPSB0aGlzXzEucGVuZGluZ1Jlc3BvbnNlc1t0aGlzXzEuY3VycmVudFJlc3BvbnNlTnVtXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzXzEucGVuZGluZ1Jlc3BvbnNlc1t0aGlzXzEuY3VycmVudFJlc3BvbnNlTnVtXTtcbiAgICAgICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9Qcm9jZXNzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5leGNlcHRpb25HdWFyZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbk1lc3NhZ2VfKHRvUHJvY2Vzc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUHJvY2Vzcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIF9sb29wXzIoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc18xLmN1cnJlbnRSZXNwb25zZU51bSA9PT0gdGhpc18xLmNsb3NlQWZ0ZXJSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzXzEub25DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEub25DbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEub25DbG9zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzXzEuY3VycmVudFJlc3BvbnNlTnVtKys7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nUmVzcG9uc2VzW3RoaXMuY3VycmVudFJlc3BvbnNlTnVtXSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8xKCk7XG4gICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGFja2V0UmVjZWl2ZXI7XG59KCkpO1xuZXhwb3J0cy5QYWNrZXRSZWNlaXZlciA9IFBhY2tldFJlY2VpdmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYWNrZXRSZWNlaXZlci5qcy5tYXBcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd2luZG93X2NvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL3NyYy9jb250cm9sbGVycy93aW5kb3ctY29udHJvbGxlclwiKTtcbnZhciBzd19jb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9zcmMvY29udHJvbGxlcnMvc3ctY29udHJvbGxlclwiKTtcbnZhciBhcHBfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvYXBwXCIpO1xuZnVuY3Rpb24gcmVnaXN0ZXJNZXNzYWdpbmcoaW5zdGFuY2UpIHtcbiAgICB2YXIgbWVzc2FnaW5nTmFtZSA9ICdtZXNzYWdpbmcnO1xuICAgIHZhciBmYWN0b3J5TWV0aG9kID0gZnVuY3Rpb24gKGFwcCkge1xuICAgICAgICBpZiAoc2VsZiAmJiAnU2VydmljZVdvcmtlckdsb2JhbFNjb3BlJyBpbiBzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN3X2NvbnRyb2xsZXJfMS5kZWZhdWx0KGFwcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzdW1lIHdlIGFyZSBpbiB0aGUgd2luZG93IGNvbnRleHQuXG4gICAgICAgIHJldHVybiBuZXcgd2luZG93X2NvbnRyb2xsZXJfMS5kZWZhdWx0KGFwcCk7XG4gICAgfTtcbiAgICB2YXIgbmFtZXNwYWNlRXhwb3J0cyA9IHtcbiAgICAgICAgLy8gbm8taW5saW5lXG4gICAgICAgIE1lc3NhZ2luZzogd2luZG93X2NvbnRyb2xsZXJfMS5kZWZhdWx0XG4gICAgfTtcbiAgICBpbnN0YW5jZS5JTlRFUk5BTC5yZWdpc3RlclNlcnZpY2UobWVzc2FnaW5nTmFtZSwgZmFjdG9yeU1ldGhvZCwgbmFtZXNwYWNlRXhwb3J0cyk7XG59XG5leHBvcnRzLnJlZ2lzdGVyTWVzc2FnaW5nID0gcmVnaXN0ZXJNZXNzYWdpbmc7XG5yZWdpc3Rlck1lc3NhZ2luZyhhcHBfMS5kZWZhdWx0KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbHMvZXJyb3JzXCIpO1xudmFyIHRva2VuX21hbmFnZXJfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbHMvdG9rZW4tbWFuYWdlclwiKTtcbnZhciBub3RpZmljYXRpb25fcGVybWlzc2lvbl8xID0gcmVxdWlyZShcIi4uL21vZGVscy9ub3RpZmljYXRpb24tcGVybWlzc2lvblwiKTtcbnZhciBTRU5ERVJfSURfT1BUSU9OX05BTUUgPSAnbWVzc2FnaW5nU2VuZGVySWQnO1xudmFyIENvbnRyb2xsZXJJbnRlcmZhY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJmYWNlIG9mIHRoZSBNZXNzYWdpbmcgU2VydmljZSBBUElcbiAgICAgKiBAcGFyYW0geyFmaXJlYmFzZS5hcHAuQXBwfSBhcHBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb250cm9sbGVySW50ZXJmYWNlKGFwcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmVycm9yRmFjdG9yeV8gPSBuZXcgdXRpbF8xLkVycm9yRmFjdG9yeSgnbWVzc2FnaW5nJywgJ01lc3NhZ2luZycsIGVycm9yc18xLmRlZmF1bHQubWFwKTtcbiAgICAgICAgaWYgKCFhcHAub3B0aW9uc1tTRU5ERVJfSURfT1BUSU9OX05BTUVdIHx8XG4gICAgICAgICAgICB0eXBlb2YgYXBwLm9wdGlvbnNbU0VOREVSX0lEX09QVElPTl9OQU1FXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5CQURfU0VOREVSX0lEKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2luZ1NlbmRlcklkXyA9IGFwcC5vcHRpb25zW1NFTkRFUl9JRF9PUFRJT05fTkFNRV07XG4gICAgICAgIHRoaXMudG9rZW5NYW5hZ2VyXyA9IG5ldyB0b2tlbl9tYW5hZ2VyXzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5JTlRFUk5BTCA9IHt9O1xuICAgICAgICB0aGlzLklOVEVSTkFMLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRlbGV0ZTsgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGV4cG9ydFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPiB8IFByb21pc2U8bnVsbD59IFJldHVybnMgYSBwcm9taXNlIHRoYXRcbiAgICAgKiByZXNvbHZlcyB0byBhbiBGQ00gdG9rZW4uXG4gICAgICovXG4gICAgQ29udHJvbGxlckludGVyZmFjZS5wcm90b3R5cGUuZ2V0VG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIENoZWNrIHdpdGggcGVybWlzc2lvbnNcbiAgICAgICAgdmFyIGN1cnJlbnRQZXJtaXNzaW9uID0gdGhpcy5nZXROb3RpZmljYXRpb25QZXJtaXNzaW9uXygpO1xuICAgICAgICBpZiAoY3VycmVudFBlcm1pc3Npb24gIT09IG5vdGlmaWNhdGlvbl9wZXJtaXNzaW9uXzEuZGVmYXVsdC5ncmFudGVkKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBlcm1pc3Npb24gPT09IG5vdGlmaWNhdGlvbl9wZXJtaXNzaW9uXzEuZGVmYXVsdC5kZW5pZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShlcnJvcnNfMS5kZWZhdWx0LmNvZGVzLk5PVElGSUNBVElPTlNfQkxPQ0tFRCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgbXVzdCB3YWl0IGZvciBwZXJtaXNzaW9uIHRvIGJlIGdyYW50ZWRcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U1dSZWdpc3RyYXRpb25fKCkudGhlbihmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudG9rZW5NYW5hZ2VyX1xuICAgICAgICAgICAgICAgIC5nZXRTYXZlZFRva2VuKF90aGlzLm1lc3NhZ2luZ1NlbmRlcklkXywgcmVnaXN0cmF0aW9uKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2tlbk1hbmFnZXJfLmNyZWF0ZVRva2VuKF90aGlzLm1lc3NhZ2luZ1NlbmRlcklkXywgcmVnaXN0cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGRlbGV0ZXMgdG9rZW5zIHRoYXQgdGhlIHRva2VuIG1hbmFnZXIgbG9va3MgYWZ0ZXIgYW5kIHRoZW5cbiAgICAgKiB1bnJlZ2lzdGVycyB0aGUgcHVzaCBzdWJzY3JpcHRpb24gaWYgaXQgZXhpc3RzLlxuICAgICAqIEBleHBvcnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIENvbnRyb2xsZXJJbnRlcmZhY2UucHJvdG90eXBlLmRlbGV0ZVRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuTWFuYWdlcl8uZGVsZXRlVG9rZW4odG9rZW4pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFNXUmVnaXN0cmF0aW9uXygpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvbi5wdXNoTWFuYWdlci5nZXRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250cm9sbGVySW50ZXJmYWNlLnByb3RvdHlwZS5nZXRTV1JlZ2lzdHJhdGlvbl8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IHRoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5TSE9VTERfQkVfSU5IRVJJVEVEKTtcbiAgICB9O1xuICAgIC8vXG4gICAgLy8gVGhlIGZvbGxvd2luZyBtZXRob2RzIHNob3VsZCBvbmx5IGJlIGF2YWlsYWJsZSBpbiB0aGUgd2luZG93LlxuICAgIC8vXG4gICAgQ29udHJvbGxlckludGVyZmFjZS5wcm90b3R5cGUucmVxdWVzdFBlcm1pc3Npb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IHRoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5BVkFJTEFCTEVfSU5fV0lORE9XKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBleHBvcnRcbiAgICAgKiBAcGFyYW0geyFTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9ufSByZWdpc3RyYXRpb25cbiAgICAgKi9cbiAgICBDb250cm9sbGVySW50ZXJmYWNlLnByb3RvdHlwZS51c2VTZXJ2aWNlV29ya2VyID0gZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICB0aHJvdyB0aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuQVZBSUxBQkxFX0lOX1dJTkRPVyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZXhwb3J0XG4gICAgICogQHBhcmFtIHshZmlyZWJhc2UuT2JzZXJ2ZXJ8ZnVuY3Rpb24oKil9IG5leHRPck9ic2VydmVyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighRXJyb3IpPX0gb3B0RXJyb3JcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRDb21wbGV0ZWRcbiAgICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgICAgKi9cbiAgICBDb250cm9sbGVySW50ZXJmYWNlLnByb3RvdHlwZS5vbk1lc3NhZ2UgPSBmdW5jdGlvbiAobmV4dE9yT2JzZXJ2ZXIsIG9wdEVycm9yLCBvcHRDb21wbGV0ZWQpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShlcnJvcnNfMS5kZWZhdWx0LmNvZGVzLkFWQUlMQUJMRV9JTl9XSU5ET1cpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cG9ydFxuICAgICAqIEBwYXJhbSB7IWZpcmViYXNlLk9ic2VydmVyfGZ1bmN0aW9uKCl9IG5leHRPck9ic2VydmVyIEFuIG9ic2VydmVyIG9iamVjdFxuICAgICAqIG9yIGEgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIHRva2VuIHJlZnJlc2guXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighRXJyb3IpPX0gb3B0RXJyb3IgT3B0aW9uYWwgQSBmdW5jdGlvblxuICAgICAqIHRyaWdnZXJlZCBvbiB0b2tlbiByZWZyZXNoIGVycm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdENvbXBsZXRlZCBPcHRpb25hbCBmdW5jdGlvbiB0cmlnZ2VyZWQgd2hlbiB0aGVcbiAgICAgKiBvYnNlcnZlciBpcyByZW1vdmVkLlxuICAgICAqIEByZXR1cm4geyFmdW5jdGlvbigpfSBUaGUgdW5zdWJzY3JpYmUgZnVuY3Rpb24gZm9yIHRoZSBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBDb250cm9sbGVySW50ZXJmYWNlLnByb3RvdHlwZS5vblRva2VuUmVmcmVzaCA9IGZ1bmN0aW9uIChuZXh0T3JPYnNlcnZlciwgb3B0RXJyb3IsIG9wdENvbXBsZXRlZCkge1xuICAgICAgICB0aHJvdyB0aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuQVZBSUxBQkxFX0lOX1dJTkRPVyk7XG4gICAgfTtcbiAgICAvL1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCBieSB0aGUgc2VydmljZSB3b3JrZXIgb25seS5cbiAgICAvL1xuICAgIC8qKlxuICAgICAqIEBleHBvcnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCl9IGNhbGxiYWNrXG4gICAgICovXG4gICAgQ29udHJvbGxlckludGVyZmFjZS5wcm90b3R5cGUuc2V0QmFja2dyb3VuZE1lc3NhZ2VIYW5kbGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IHRoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5BVkFJTEFCTEVfSU5fU1cpO1xuICAgIH07XG4gICAgLy9cbiAgICAvLyBUaGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgYnkgdGhlIHNlcnZpY2UgdGhlbXNlbHZlcyBhbmQgbm90IGV4cG9zZWRcbiAgICAvLyBwdWJsaWNseSBvciBub3QgZXhwZWN0ZWQgdG8gYmUgdXNlZCBieSBkZXZlbG9wZXJzLlxuICAgIC8vXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgcmVxdWlyZWQgdG8gYWRoZXJlIHRvIHRoZSBGaXJlYmFzZSBpbnRlcmZhY2UuXG4gICAgICogSXQgY2xvc2VzIGFueSBjdXJyZW50bHkgb3BlbiBpbmRleGRiIGRhdGFiYXNlIGNvbm5lY3Rpb25zLlxuICAgICAqL1xuICAgIENvbnRyb2xsZXJJbnRlcmZhY2UucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5NYW5hZ2VyXy5jbG9zZURhdGFiYXNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IE5vdGlmaWNhdGlvbiBQZXJtaXNzaW9uIHN0YXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY3VycmVuY3QgcGVybWlzc2lvbiBzdGF0ZS5cbiAgICAgKi9cbiAgICBDb250cm9sbGVySW50ZXJmYWNlLnByb3RvdHlwZS5nZXROb3RpZmljYXRpb25QZXJtaXNzaW9uXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtUb2tlbk1hbmFnZXJ9XG4gICAgICovXG4gICAgQ29udHJvbGxlckludGVyZmFjZS5wcm90b3R5cGUuZ2V0VG9rZW5NYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbk1hbmFnZXJfO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRyb2xsZXJJbnRlcmZhY2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29udHJvbGxlckludGVyZmFjZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJvbGxlci1pbnRlcmZhY2UuanMubWFwXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udHJvbGxlcl9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2NvbnRyb2xsZXItaW50ZXJmYWNlXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL21vZGVscy9lcnJvcnNcIik7XG52YXIgd29ya2VyX3BhZ2VfbWVzc2FnZV8xID0gcmVxdWlyZShcIi4uL21vZGVscy93b3JrZXItcGFnZS1tZXNzYWdlXCIpO1xudmFyIGZjbV9kZXRhaWxzXzEgPSByZXF1aXJlKFwiLi4vbW9kZWxzL2ZjbS1kZXRhaWxzXCIpO1xudmFyIEZDTV9NU0cgPSAnRkNNX01TRyc7XG52YXIgU1dDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTV0NvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU1dDb250cm9sbGVyKGFwcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBhcHApIHx8IHRoaXM7XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigncHVzaCcsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5vblB1c2hfKGUpOyB9LCBmYWxzZSk7XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigncHVzaHN1YnNjcmlwdGlvbmNoYW5nZScsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5vblN1YkNoYW5nZV8oZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdub3RpZmljYXRpb25jbGljaycsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5vbk5vdGlmaWNhdGlvbkNsaWNrXyhlKTsgfSwgZmFsc2UpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKE9iamVjdCl8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmJnTWVzc2FnZUhhbmRsZXJfID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEEgaGFuZGxlciBmb3IgcHVzaCBldmVudHMgdGhhdCBzaG93cyBub3RpZmljYXRpb25zIGJhc2VkIG9uIHRoZSBjb250ZW50IG9mXG4gICAgKiB0aGUgcGF5bG9hZC5cbiAgICAqXG4gICAgKiBUaGUgcGF5bG9hZCBtdXN0IGJlIGEgSlNPTi1lbmNvZGVkIE9iamVjdCB3aXRoIGEgYG5vdGlmaWNhdGlvbmAga2V5LiBUaGVcbiAgICAqIHZhbHVlIG9mIHRoZSBgbm90aWZpY2F0aW9uYCBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQgYXMgdGhlIE5vdGlmaWNhdGlvbk9wdGlvbnNcbiAgICAqIG9iamVjdCBwYXNzZWQgdG8gc2hvd05vdGlmaWNhdGlvbi4gQWRkaXRpb25hbGx5LCB0aGUgYHRpdGxlYCBwcm9wZXJ0eSBvZiB0aGVcbiAgICAqIG5vdGlmaWNhdGlvbiBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIHRoZSB0aXRsZS5cbiAgICAqXG4gICAgKiBJZiB0aGVyZSBpcyBubyBub3RpZmljYXRpb24gZGF0YSBpbiB0aGUgcGF5bG9hZCB0aGVuIG5vIG5vdGlmaWNhdGlvbiB3aWxsIGJlXG4gICAgKiBzaG93bi5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBTV0NvbnRyb2xsZXIucHJvdG90eXBlLm9uUHVzaF8gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1zZ1BheWxvYWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtc2dQYXlsb2FkID0gZXZlbnQuZGF0YS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gTm90IEpTT04gc28gbm90IGFuIEZDTSBtZXNzYWdlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhbmRsZU1zZ1Byb21pc2UgPSB0aGlzLmhhc1Zpc2libGVDbGllbnRzXygpLnRoZW4oZnVuY3Rpb24gKGhhc1Zpc2libGVDbGllbnRzKSB7XG4gICAgICAgICAgICBpZiAoaGFzVmlzaWJsZUNsaWVudHMpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgbmVlZCB0byBzaG93IGEgbm90aWZpY2F0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChtc2dQYXlsb2FkLm5vdGlmaWNhdGlvbiB8fCBfdGhpcy5iZ01lc3NhZ2VIYW5kbGVyXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIHRvIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmRNZXNzYWdlVG9XaW5kb3dDbGllbnRzXyhtc2dQYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vdGlmaWNhdGlvbkRldGFpbHMgPSBfdGhpcy5nZXROb3RpZmljYXRpb25EYXRhXyhtc2dQYXlsb2FkKTtcbiAgICAgICAgICAgIGlmIChub3RpZmljYXRpb25EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdGlmaWNhdGlvblRpdGxlID0gbm90aWZpY2F0aW9uRGV0YWlscy50aXRsZSB8fCAnJztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yZWdpc3RyYXRpb24uc2hvd05vdGlmaWNhdGlvbihub3RpZmljYXRpb25UaXRsZSwgbm90aWZpY2F0aW9uRGV0YWlscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5iZ01lc3NhZ2VIYW5kbGVyXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5iZ01lc3NhZ2VIYW5kbGVyXyhtc2dQYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50LndhaXRVbnRpbChoYW5kbGVNc2dQcm9taXNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIFNXQ29udHJvbGxlci5wcm90b3R5cGUub25TdWJDaGFuZ2VfID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9taXNlQ2hhaW4gPSB0aGlzLmdldFRva2VuKCkudGhlbihmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCByZXN1YnNjcmliZSBpZiB3ZSBkb24ndCBoYXZlIGFuIEZDTSB0b2tlbiBmb3IgdGhpcyBzY29wZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShlcnJvcnNfMS5kZWZhdWx0LmNvZGVzLk5PX0ZDTV9UT0tFTl9GT1JfUkVTVUJTQ1JJQkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdG9rZW5NYW5hZ2VyID0gX3RoaXMuZ2V0VG9rZW5NYW5hZ2VyKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5NYW5hZ2VyXG4gICAgICAgICAgICAgICAgLmdldFRva2VuRGV0YWlsc0Zyb21Ub2tlbih0b2tlbilcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGV0YWlscykge1xuICAgICAgICAgICAgICAgIHRva2VuRGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5JTlZBTElEX1NBVkVEX1RPS0VOKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBnZXQgYSBuZXcgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucmVnaXN0cmF0aW9uLnB1c2hNYW5hZ2VyLnN1YnNjcmliZShmY21fZGV0YWlsc18xLmRlZmF1bHQuU1VCU0NSSVBUSU9OX09QVElPTlMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobmV3U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCBuZXcgc3Vic2NyaXB0aW9uIHRvIEZDTS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5NYW5hZ2VyLnN1YnNjcmliZVRvRkNNKHRva2VuRGV0YWlscy5mY21TZW5kZXJJZCwgbmV3U3Vic2NyaXB0aW9uLCB0b2tlbkRldGFpbHMuZmNtUHVzaFNldCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGJlc3QgdGhpbmcgd2UgY2FuIGRvIGlzIGxvZyB0aGlzIHRvIHRoZSB0ZXJtaW5hbCBzb1xuICAgICAgICAgICAgICAgIC8vIGRldmVsb3BlcnMgbWlnaHQgbm90aWNlIHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5NYW5hZ2VyLmRlbGV0ZVRva2VuKHRva2VuRGV0YWlscy5mY21Ub2tlbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuVU5BQkxFX1RPX1JFU1VCU0NSSUJFLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50LndhaXRVbnRpbChwcm9taXNlQ2hhaW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgU1dDb250cm9sbGVyLnByb3RvdHlwZS5vbk5vdGlmaWNhdGlvbkNsaWNrXyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIShldmVudC5ub3RpZmljYXRpb24gJiZcbiAgICAgICAgICAgIGV2ZW50Lm5vdGlmaWNhdGlvbi5kYXRhICYmXG4gICAgICAgICAgICBldmVudC5ub3RpZmljYXRpb24uZGF0YVtGQ01fTVNHXSkpIHtcbiAgICAgICAgICAgIC8vIE5vdCBhbiBGQ00gbm90aWZpY2F0aW9uLCBkbyBub3RoaW5nLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgb3RoZXIgbGlzdGVuZXJzIGZyb20gcmVjZWl2aW5nIHRoZSBldmVudFxuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQubm90aWZpY2F0aW9uLmNsb3NlKCk7XG4gICAgICAgIHZhciBtc2dQYXlsb2FkID0gZXZlbnQubm90aWZpY2F0aW9uLmRhdGFbRkNNX01TR107XG4gICAgICAgIHZhciBjbGlja0FjdGlvbiA9IG1zZ1BheWxvYWRbJ25vdGlmaWNhdGlvbiddWydjbGlja19hY3Rpb24nXTtcbiAgICAgICAgaWYgKCFjbGlja0FjdGlvbikge1xuICAgICAgICAgICAgLy8gTm90aGluZyB0byBkby5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZUNoYWluID0gdGhpcy5nZXRXaW5kb3dDbGllbnRfKGNsaWNrQWN0aW9uKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHdpbmRvd0NsaWVudCkge1xuICAgICAgICAgICAgaWYgKCF3aW5kb3dDbGllbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBVbmFibGUgdG8gZmluZCB3aW5kb3cgY2xpZW50IHNvIG5lZWQgdG8gb3BlbiBvbmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2xpZW50cy5vcGVuV2luZG93KGNsaWNrQWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aW5kb3dDbGllbnQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAod2luZG93Q2xpZW50KSB7XG4gICAgICAgICAgICBpZiAoIXdpbmRvd0NsaWVudCkge1xuICAgICAgICAgICAgICAgIC8vIFdpbmRvdyBDbGllbnQgd2lsbCBub3QgYmUgcmV0dXJuZWQgaWYgaXQncyBmb3IgYSB0aGlyZCBwYXJ0eSBvcmlnaW4uXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVsZXRlIG5vdGlmaWNhdGlvbiBkYXRhIGZyb20gcGF5bG9hZCBiZWZvcmUgc2VuZGluZyB0byB0aGUgcGFnZS5cbiAgICAgICAgICAgIHZhciBub3RpZmljYXRpb25EYXRhID0gbXNnUGF5bG9hZFsnbm90aWZpY2F0aW9uJ107XG4gICAgICAgICAgICBkZWxldGUgbXNnUGF5bG9hZFsnbm90aWZpY2F0aW9uJ107XG4gICAgICAgICAgICB2YXIgaW50ZXJuYWxNc2cgPSB3b3JrZXJfcGFnZV9tZXNzYWdlXzEuZGVmYXVsdC5jcmVhdGVOZXdNc2cod29ya2VyX3BhZ2VfbWVzc2FnZV8xLmRlZmF1bHQuVFlQRVNfT0ZfTVNHLk5PVElGSUNBVElPTl9DTElDS0VELCBtc2dQYXlsb2FkKTtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gc2VuZCBhIG1lc3NhZ2UgdG8gdGhlIGNsaWVudCB0byBoYW5kbGUgdGhlIGRhdGFcbiAgICAgICAgICAgIC8vIElzIGFmZmVjdGVkIGJ5OiBodHRwczovL2dpdGh1Yi5jb20vc2xpZ2h0bHlvZmYvU2VydmljZVdvcmtlci9pc3N1ZXMvNzI4XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXR0ZW1wdFRvTWVzc2FnZUNsaWVudF8od2luZG93Q2xpZW50LCBpbnRlcm5hbE1zZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC53YWl0VW50aWwocHJvbWlzZUNoYWluKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BheWxvYWRcbiAgICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb25PcHRpb25zfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBTV0NvbnRyb2xsZXIucHJvdG90eXBlLmdldE5vdGlmaWNhdGlvbkRhdGFfID0gZnVuY3Rpb24gKG1zZ1BheWxvYWQpIHtcbiAgICAgICAgaWYgKCFtc2dQYXlsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtc2dQYXlsb2FkLm5vdGlmaWNhdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm90aWZpY2F0aW9uSW5mb3JtYXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBtc2dQYXlsb2FkLm5vdGlmaWNhdGlvbik7XG4gICAgICAgIC8vIFB1dCB0aGUgbWVzc2FnZSBwYXlsb2FkIHVuZGVyIEZDTV9NU0cgbmFtZSBzbyB3ZSBjYW4gaWRlbnRpZnkgdGhlXG4gICAgICAgIC8vIG5vdGlmaWNhdGlvbiBhcyBiZWluZyBhbiBGQ00gbm90aWZpY2F0aW9uIHZzIGEgbm90aWZpY2F0aW9uIGZyb21cbiAgICAgICAgLy8gc29tZXdoZXJlIGVsc2UgKGkuZS4gbm9ybWFsIHdlYiBwdXNoIG9yIGRldmVsb3BlciBnZW5lcmF0ZWRcbiAgICAgICAgLy8gbm90aWZpY2F0aW9uKS5cbiAgICAgICAgbm90aWZpY2F0aW9uSW5mb3JtYXRpb25bJ2RhdGEnXSA9IChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbRkNNX01TR10gPSBtc2dQYXlsb2FkLFxuICAgICAgICAgICAgX2EpO1xuICAgICAgICByZXR1cm4gbm90aWZpY2F0aW9uSW5mb3JtYXRpb247XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxpbmcgc2V0QmFja2dyb3VuZE1lc3NhZ2VIYW5kbGVyIHdpbGwgb3B0IGluIHRvIHNvbWUgc3BlY2lmaWNcbiAgICAgKiBiZWhhdmlvdXJzLlxuICAgICAqIDEuKSBJZiBhIG5vdGlmaWNhdGlvbiBkb2Vzbid0IG5lZWQgdG8gYmUgc2hvd24gZHVlIHRvIGEgd2luZG93IGFscmVhZHlcbiAgICAgKiBiZWluZyB2aXNpYmxlLCB0aGVuIHB1c2ggbWVzc2FnZXMgd2lsbCBiZSBzZW50IHRvIHRoZSBwYWdlLlxuICAgICAqIDIuKSBJZiBhIG5vdGlmaWNhdGlvbiBuZWVkcyB0byBiZSBzaG93biwgYW5kIHRoZSBtZXNzYWdlIGNvbnRhaW5zIG5vXG4gICAgICogbm90aWZpY2F0aW9uIGRhdGEgdGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBhbmQgdGhlIHByb21pc2UgaXQgcmV0dXJucyB3aWxsIGJlIHBhc3NlZCB0byBldmVudC53YWl0VW50aWwuXG4gICAgICogSWYgeW91IGRvIG5vdCBzZXQgdGhpcyBjYWxsYmFjayB0aGVuIGFsbCBwdXNoIG1lc3NhZ2VzIHdpbGwgbGV0IGFuZCB0aGVcbiAgICAgKiBkZXZlbG9wZXIgY2FuIGhhbmRsZSB0aGVtIGluIGEgdGhlaXIgb3duICdwdXNoJyBldmVudCBjYWxsYmFja1xuICAgICAqIEBleHBvcnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCl9IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBhIHB1c2hcbiAgICAgKiBtZXNzYWdlIGlzIHJlY2VpdmVkIGFuZCBhIG5vdGlmaWNhdGlvbiBtdXN0IGJlIHNob3duLiBUaGUgY2FsbGJhY2sgd2lsbFxuICAgICAqIGJlIGdpdmVuIHRoZSBkYXRhIGZyb20gdGhlIHB1c2ggbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTV0NvbnRyb2xsZXIucHJvdG90eXBlLnNldEJhY2tncm91bmRNZXNzYWdlSGFuZGxlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuQkdfSEFORExFUl9GVU5DVElPTl9FWFBFQ1RFRCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZ01lc3NhZ2VIYW5kbGVyXyA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gbG9vayBmb3Igd2hlbiBmb2N1c2luZyBhIGNsaWVudC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gZXhpc3Rpbmcgd2luZG93IGNsaWVudCBvciBhIG5ld2x5IG9wZW5lZFxuICAgICAqIFdpbmRvd0NsaWVudC5cbiAgICAgKi9cbiAgICBTV0NvbnRyb2xsZXIucHJvdG90eXBlLmdldFdpbmRvd0NsaWVudF8gPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIC8vIFVzZSBVUkwgdG8gbm9ybWFsaXplIHRoZSBVUkwgd2hlbiBjb21wYXJpbmcgdG8gd2luZG93Q2xpZW50cy5cbiAgICAgICAgLy8gVGhpcyBhdCBsZWFzdCBoYW5kbGVzIHdoZXRoZXIgdG8gaW5jbHVkZSB0cmFpbGluZyBzbGFzaGVzIG9yIG5vdFxuICAgICAgICB2YXIgcGFyc2VkVVJMID0gbmV3IFVSTCh1cmwpLmhyZWY7XG4gICAgICAgIHJldHVybiBzZWxmLmNsaWVudHNcbiAgICAgICAgICAgIC5tYXRjaEFsbCh7XG4gICAgICAgICAgICB0eXBlOiAnd2luZG93JyxcbiAgICAgICAgICAgIGluY2x1ZGVVbmNvbnRyb2xsZWQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjbGllbnRMaXN0KSB7XG4gICAgICAgICAgICB2YXIgc3VpdGFibGVDbGllbnQgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGllbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZENsaWVudFVybCA9IG5ldyBVUkwoY2xpZW50TGlzdFtpXS51cmwpLmhyZWY7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZENsaWVudFVybCA9PT0gcGFyc2VkVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1aXRhYmxlQ2xpZW50ID0gY2xpZW50TGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1aXRhYmxlQ2xpZW50KSB7XG4gICAgICAgICAgICAgICAgc3VpdGFibGVDbGllbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VpdGFibGVDbGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXNzYWdlIHdpbGwgYXR0ZW1wdCB0byBzZW5kIHRoZSBtZXNzYWdlIHRvIGEgd2luZG93IGNsaWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjbGllbnQgVGhlIFdpbmRvd0NsaWVudCB0byBzZW5kIHRoZSBtZXNzYWdlIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHNlbmQgdG8gdGhlIGNsaWVudC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBzZW5kaW5nIHRoZVxuICAgICAqIG1lc3NhZ2UuIFRoaXMgZG9lcyBub3QgZ3VhcmFudGVlIHRoYXQgdGhlIG1lc3NhZ2Ugd2FzIHN1Y2Nlc3NmdWxseVxuICAgICAqIHJlY2VpdmVkLlxuICAgICAqL1xuICAgIFNXQ29udHJvbGxlci5wcm90b3R5cGUuYXR0ZW1wdFRvTWVzc2FnZUNsaWVudF8gPSBmdW5jdGlvbiAoY2xpZW50LCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5OT19XSU5ET1dfQ0xJRU5UX1RPX01TRykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IElmIHRoZXJlIGlzIGN1cnJlbnRseSBhIHZpc2libGUgV2luZG93Q2xpZW50LFxuICAgICAqIHRoaXMgbWV0aG9kIHdpbGwgcmVzb2x2ZSB0byB0cnVlLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgU1dDb250cm9sbGVyLnByb3RvdHlwZS5oYXNWaXNpYmxlQ2xpZW50c18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNsaWVudHNcbiAgICAgICAgICAgIC5tYXRjaEFsbCh7XG4gICAgICAgICAgICB0eXBlOiAnd2luZG93JyxcbiAgICAgICAgICAgIGluY2x1ZGVVbmNvbnRyb2xsZWQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjbGllbnRMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50TGlzdC5zb21lKGZ1bmN0aW9uIChjbGllbnQpIHsgcmV0dXJuIGNsaWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJzsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGF5bG9hZCBUaGUgZGF0YSBmcm9tIHRoZSBwdXNoIGV2ZW50IHRoYXQgc2hvdWxkIGJlIHNlbnRcbiAgICAgKiB0byBhbGwgYXZhaWxhYmxlIHBhZ2VzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIG1lc3NhZ2VcbiAgICAgKiBoYXMgYmVlbiBzZW50IHRvIGFsbCBXaW5kb3dDbGllbnRzLlxuICAgICAqL1xuICAgIFNXQ29udHJvbGxlci5wcm90b3R5cGUuc2VuZE1lc3NhZ2VUb1dpbmRvd0NsaWVudHNfID0gZnVuY3Rpb24gKG1zZ1BheWxvYWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbGYuY2xpZW50c1xuICAgICAgICAgICAgLm1hdGNoQWxsKHtcbiAgICAgICAgICAgIHR5cGU6ICd3aW5kb3cnLFxuICAgICAgICAgICAgaW5jbHVkZVVuY29udHJvbGxlZDogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNsaWVudExpc3QpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcm5hbE1zZyA9IHdvcmtlcl9wYWdlX21lc3NhZ2VfMS5kZWZhdWx0LmNyZWF0ZU5ld01zZyh3b3JrZXJfcGFnZV9tZXNzYWdlXzEuZGVmYXVsdC5UWVBFU19PRl9NU0cuUFVTSF9NU0dfUkVDRUlWRUQsIG1zZ1BheWxvYWQpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNsaWVudExpc3QubWFwKGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYXR0ZW1wdFRvTWVzc2FnZUNsaWVudF8oY2xpZW50LCBpbnRlcm5hbE1zZyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsIHJlZ2lzdGVyIHRoZSBkZWZhdWx0IHNlcnZpY2Ugd29ya2VyIGFuZCByZXR1cm4gdGhlIHJlZ2lzdHJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8IVNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb24+fSBUaGUgc2VydmljZSB3b3JrZXJcbiAgICAgKiByZWdpc3RyYXRpb24gdG8gYmUgdXNlZCBmb3IgdGhlIHB1c2ggc2VydmljZS5cbiAgICAgKi9cbiAgICBTV0NvbnRyb2xsZXIucHJvdG90eXBlLmdldFNXUmVnaXN0cmF0aW9uXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLnJlZ2lzdHJhdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gU1dDb250cm9sbGVyO1xufShjb250cm9sbGVyX2ludGVyZmFjZV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNXQ29udHJvbGxlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ctY29udHJvbGxlci5qcy5tYXBcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250cm9sbGVyX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vY29udHJvbGxlci1pbnRlcmZhY2VcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vbW9kZWxzL2Vycm9yc1wiKTtcbnZhciB3b3JrZXJfcGFnZV9tZXNzYWdlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWxzL3dvcmtlci1wYWdlLW1lc3NhZ2VcIik7XG52YXIgZGVmYXVsdF9zd18xID0gcmVxdWlyZShcIi4uL21vZGVscy9kZWZhdWx0LXN3XCIpO1xudmFyIG5vdGlmaWNhdGlvbl9wZXJtaXNzaW9uXzEgPSByZXF1aXJlKFwiLi4vbW9kZWxzL25vdGlmaWNhdGlvbi1wZXJtaXNzaW9uXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBXaW5kb3dDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEEgc2VydmljZSB0aGF0IHByb3ZpZGVzIGEgTWVzc2FnaW5nU2VydmljZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0geyFmaXJlYmFzZS5hcHAuQXBwfSBhcHBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXaW5kb3dDb250cm9sbGVyKGFwcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBhcHApIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7U2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnJlZ2lzdHJhdGlvblRvVXNlXztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtQcm9taXNlfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubWFuaWZlc3RDaGVja1Byb21pc2VfO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2ZpcmViYXNlLk9ic2VydmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubWVzc2FnZU9ic2VydmVyXyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZSB7IWZpcmViYXNlLlN1YnNjcmliZX0gVGhlIHN1YnNjcmliZSBmdW5jdGlvbiB0byB0aGUgb25NZXNzYWdlXG4gICAgICAgICAqIG9ic2VydmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub25NZXNzYWdlXyA9IHV0aWxfMS5jcmVhdGVTdWJzY3JpYmUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5tZXNzYWdlT2JzZXJ2ZXJfID0gb2JzZXJ2ZXI7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2ZpcmViYXNlLk9ic2VydmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudG9rZW5SZWZyZXNoT2JzZXJ2ZXJfID0gbnVsbDtcbiAgICAgICAgX3RoaXMub25Ub2tlblJlZnJlc2hfID0gdXRpbF8xLmNyZWF0ZVN1YnNjcmliZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLnRva2VuUmVmcmVzaE9ic2VydmVyXyA9IG9ic2VydmVyO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuc2V0dXBTV01lc3NhZ2VMaXN0ZW5lcl8oKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIEZDTSB0b2tlbiBpZiBpdCBjYW4gYmUgZ2VuZXJhdGVkLlxuICAgICAqIFRoZSByZXR1cm4gcHJvbWlzZSB3aWxsIHJlamVjdCBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnRcbiAgICAgKiBGQ00sIGlmIHBlcm1pc3Npb24gaXMgZGVuaWVkIGZvciBub3RpZmljYXRpb25zIG9yIGl0J3Mgbm90XG4gICAgICogcG9zc2libGUgdG8gZ2VuZXJhdGUgYSB0b2tlbi5cbiAgICAgKiBAZXhwb3J0XG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+IHwgUHJvbWlzZTxudWxsPn0gUmV0dXJucyBhIHByb21pc2UgdGhlXG4gICAgICogcmVzb2x2ZXMgdG8gYW4gRkNNIHRva2VuIG9yIG51bGwgaWYgcGVybWlzc2lvbiBpc24ndCBncmFudGVkLlxuICAgICAqL1xuICAgIFdpbmRvd0NvbnRyb2xsZXIucHJvdG90eXBlLmdldFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSByZXF1aXJlZCBBUEkncyBhcmUgYXZhaWxhYmxlXG4gICAgICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZF8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5VTlNVUFBPUlRFRF9CUk9XU0VSKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFuaWZlc3RDaGVja18oKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmdldFRva2VuLmNhbGwoX3RoaXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgY2hlY2tzIHRoYXQgYSBtYW5pZmVzdCBpcyBkZWZpbmVkIGFuZCBoYXMgdGhlIGNvcnJlY3QgR0NNXG4gICAgICogc2VuZGVyIElELlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBpZiB0aGUgbWFuaWZlc3QgbWF0Y2hlc1xuICAgICAqIG91ciByZXF1aXJlZCBzZW5kZXIgSURcbiAgICAgKi9cbiAgICBXaW5kb3dDb250cm9sbGVyLnByb3RvdHlwZS5tYW5pZmVzdENoZWNrXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMubWFuaWZlc3RDaGVja1Byb21pc2VfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYW5pZmVzdENoZWNrUHJvbWlzZV87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hbmlmZXN0VGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGlua1tyZWw9XCJtYW5pZmVzdFwiXScpO1xuICAgICAgICBpZiAoIW1hbmlmZXN0VGFnKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmlmZXN0Q2hlY2tQcm9taXNlXyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYW5pZmVzdENoZWNrUHJvbWlzZV8gPSBmZXRjaChtYW5pZmVzdFRhZy5ocmVmKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRvd25sb2FkIG9yIHBhcnNpbmcgZmFpbHMgYWxsb3cgY2hlY2suXG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIGVycm9yIGlmIHdlIEtOT1cgdGhhdCB0aGUgZ2NtX3NlbmRlcl9pZCBpcyBpbmNvcnJlY3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobWFuaWZlc3RDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYW5pZmVzdENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW1hbmlmZXN0Q29udGVudFsnZ2NtX3NlbmRlcl9pZCddKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hbmlmZXN0Q29udGVudFsnZ2NtX3NlbmRlcl9pZCddICE9PSAnMTAzOTUzODAwNTA3Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShlcnJvcnNfMS5kZWZhdWx0LmNvZGVzLklOQ09SUkVDVF9HQ01fU0VOREVSX0lEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYW5pZmVzdENoZWNrUHJvbWlzZV87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHBlcm1pc3Npb24gaWYgaXQgaXMgbm90IGN1cnJlbnRseSBncmFudGVkXG4gICAgICogQGV4cG9ydFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXNvbHZlcyBpZiB0aGUgcGVybWlzc2lvbiB3YXMgZ3JhbnRlZCwgb3RoZXJ3aXNlXG4gICAgICogcmVqZWN0c1xuICAgICAqL1xuICAgIFdpbmRvd0NvbnRyb2xsZXIucHJvdG90eXBlLnJlcXVlc3RQZXJtaXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoTm90aWZpY2F0aW9uLnBlcm1pc3Npb24gPT09IG5vdGlmaWNhdGlvbl9wZXJtaXNzaW9uXzEuZGVmYXVsdC5ncmFudGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBtYW5hZ2VQZXJtaXNzaW9uUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG5vdGlmaWNhdGlvbl9wZXJtaXNzaW9uXzEuZGVmYXVsdC5ncmFudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdCA9PT0gbm90aWZpY2F0aW9uX3Blcm1pc3Npb25fMS5kZWZhdWx0LmRlbmllZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuUEVSTUlTU0lPTl9CTE9DS0VEKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuUEVSTUlTU0lPTl9ERUZBVUxUKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFRoZSBOb3RpZmljYXRpb24ucmVxdWVzdFBlcm1pc3Npb24gQVBJIHdhcyBjaGFuZ2VkIHRvXG4gICAgICAgICAgICAvLyByZXR1cm4gYSBwcm9taXNlIHNvIG5vdyBoYXZlIHRvIGhhbmRsZSBib3RoIGluIGNhc2VcbiAgICAgICAgICAgIC8vIGJyb3dzZXJzIHN0b3Agc3VwcG9ydCBjYWxsYmFja3MgZm9yIHByb21pc2VkIHZlcnNpb25cbiAgICAgICAgICAgIHZhciBwZXJtaXNzaW9uUHJvbWlzZSA9IE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcm1pc3Npb25Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExldCB0aGUgcHJvbWlzZSBtYW5hZ2UgdGhpc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hbmFnZVBlcm1pc3Npb25SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHBlcm1pc3Npb25Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBwcm9taXNlIHZlcnNpb24gYXMgaXQncyB0aGUgZnV0dXJlIEFQSS5cbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uUHJvbWlzZS50aGVuKG1hbmFnZVBlcm1pc3Npb25SZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyBhIGRldmVsb3BlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBzZXJ2aWNlIHdvcmtlciBhbmRcbiAgICAgKiBpbnN0ZWFkIHVzZSBhIGN1c3RvbSBzZXJ2aWNlIHdvcmtlci5cbiAgICAgKiBAZXhwb3J0XG4gICAgICogQHBhcmFtIHshU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbn0gcmVnaXN0cmF0aW9uIFRoZSBzZXJ2aWNlIHdvcmtlclxuICAgICAqIHJlZ2lzdHJhdGlvbiB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlY2VpdmUgdGhlIHB1c2ggbWVzc2FnZXMuXG4gICAgICovXG4gICAgV2luZG93Q29udHJvbGxlci5wcm90b3R5cGUudXNlU2VydmljZVdvcmtlciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgaWYgKCEocmVnaXN0cmF0aW9uIGluc3RhbmNlb2YgU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5TV19SRUdJU1RSQVRJT05fRVhQRUNURUQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5yZWdpc3RyYXRpb25Ub1VzZV8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuVVNFX1NXX0JFRk9SRV9HRVRfVE9LRU4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0cmF0aW9uVG9Vc2VfID0gcmVnaXN0cmF0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cG9ydFxuICAgICAqIEBwYXJhbSB7IWZpcmViYXNlLk9ic2VydmVyfGZ1bmN0aW9uKCopfSBuZXh0T3JPYnNlcnZlciBBbiBvYnNlcnZlciBvYmplY3RcbiAgICAgKiBvciBhIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUVycm9yKT19IG9wdEVycm9yIE9wdGlvbmFsIEEgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uXG4gICAgICogbWVzc2FnZSBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRDb21wbGV0ZWQgT3B0aW9uYWwgZnVuY3Rpb24gdHJpZ2dlcmVkIHdoZW4gdGhlXG4gICAgICogb2JzZXJ2ZXIgaXMgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX0gVGhlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIGZvciB0aGUgb2JzZXJ2ZXIuXG4gICAgICovXG4gICAgV2luZG93Q29udHJvbGxlci5wcm90b3R5cGUub25NZXNzYWdlID0gZnVuY3Rpb24gKG5leHRPck9ic2VydmVyLCBvcHRFcnJvciwgb3B0Q29tcGxldGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uTWVzc2FnZV8obmV4dE9yT2JzZXJ2ZXIsIG9wdEVycm9yLCBvcHRDb21wbGV0ZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cG9ydFxuICAgICAqIEBwYXJhbSB7IWZpcmViYXNlLk9ic2VydmVyfGZ1bmN0aW9uKCl9IG5leHRPck9ic2VydmVyIEFuIG9ic2VydmVyIG9iamVjdFxuICAgICAqIG9yIGEgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIHRva2VuIHJlZnJlc2guXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighRXJyb3IpPX0gb3B0RXJyb3IgT3B0aW9uYWwgQSBmdW5jdGlvblxuICAgICAqIHRyaWdnZXJlZCBvbiB0b2tlbiByZWZyZXNoIGVycm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdENvbXBsZXRlZCBPcHRpb25hbCBmdW5jdGlvbiB0cmlnZ2VyZWQgd2hlbiB0aGVcbiAgICAgKiBvYnNlcnZlciBpcyByZW1vdmVkLlxuICAgICAqIEByZXR1cm4geyFmdW5jdGlvbigpfSBUaGUgdW5zdWJzY3JpYmUgZnVuY3Rpb24gZm9yIHRoZSBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBXaW5kb3dDb250cm9sbGVyLnByb3RvdHlwZS5vblRva2VuUmVmcmVzaCA9IGZ1bmN0aW9uIChuZXh0T3JPYnNlcnZlciwgb3B0RXJyb3IsIG9wdENvbXBsZXRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vblRva2VuUmVmcmVzaF8obmV4dE9yT2JzZXJ2ZXIsIG9wdEVycm9yLCBvcHRDb21wbGV0ZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSByZWdpc3RyYXRpb24sIHdhaXQgZm9yIHRoZSBzZXJ2aWNlIHdvcmtlciBpdCByZWxhdGVzIHRvXG4gICAgICogYmVjb21lIGFjdGl2ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge1NlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb259IHJlZ2lzdHJhdGlvbiBSZWdpc3RyYXRpb24gdG8gd2FpdFxuICAgICAqIGZvciBzZXJ2aWNlIHdvcmtlciB0byBiZWNvbWUgYWN0aXZlXG4gICAgICogQHJldHVybiB7UHJvbWlzZTwhU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbj59IFdhaXQgZm9yIHNlcnZpY2Ugd29ya2VyXG4gICAgICogcmVnaXN0cmF0aW9uIHRvIGJlY29tZSBhY3RpdmVcbiAgICAgKi9cbiAgICBXaW5kb3dDb250cm9sbGVyLnByb3RvdHlwZS53YWl0Rm9yUmVnaXN0cmF0aW9uVG9BY3RpdmF0ZV8gPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZXJ2aWNlV29ya2VyID0gcmVnaXN0cmF0aW9uLmluc3RhbGxpbmcgfHwgcmVnaXN0cmF0aW9uLndhaXRpbmcgfHwgcmVnaXN0cmF0aW9uLmFjdGl2ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICghc2VydmljZVdvcmtlcikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByYXJlIHNjZW5hcmlvIGJ1dCBoYXMgb2NjdXJlZCBpbiBmaXJlZm94XG4gICAgICAgICAgICAgICAgcmVqZWN0KF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuTk9fU1dfSU5fUkVHKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgUHJvbWlzZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gbmV4dCB0aWNrIHRoZXJlIGlzIGFcbiAgICAgICAgICAgIC8vIHNtYWxsIGNoYW5jZSB0aGF0IHRoZSB3b3JrZXIgYmVjYW1lIGFjdGl2ZSBvciByZWR1bmRhbnQgYWxyZWFkeS5cbiAgICAgICAgICAgIGlmIChzZXJ2aWNlV29ya2VyLnN0YXRlID09PSAnYWN0aXZhdGVkJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVnaXN0cmF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VydmljZVdvcmtlci5zdGF0ZSA9PT0gJ3JlZHVuZGFudCcpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5TV19SRUdfUkVEVU5EQU5UKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXRlQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VXb3JrZXIuc3RhdGUgPT09ICdhY3RpdmF0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVnaXN0cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VydmljZVdvcmtlci5zdGF0ZSA9PT0gJ3JlZHVuZGFudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuU1dfUkVHX1JFRFVOREFOVCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGFuZCB3YWl0IHRvIG5leHQgc3RhdGUgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VydmljZVdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIHN0YXRlQ2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlcnZpY2VXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCBzdGF0ZUNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgcmVnaWF0ZXIgdGhlIGRlZmF1bHQgc2VydmljZSB3b3JrZXIgYW5kIHJldHVybiB0aGUgcmVnaXN0cmF0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPCFTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uPn0gVGhlIHNlcnZpY2Ugd29ya2VyXG4gICAgICogcmVnaXN0cmF0aW9uIHRvIGJlIHVzZWQgZm9yIHRoZSBwdXNoIHNlcnZpY2UuXG4gICAgICovXG4gICAgV2luZG93Q29udHJvbGxlci5wcm90b3R5cGUuZ2V0U1dSZWdpc3RyYXRpb25fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25Ub1VzZV8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JSZWdpc3RyYXRpb25Ub0FjdGl2YXRlXyh0aGlzLnJlZ2lzdHJhdGlvblRvVXNlXyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSB0aGUgcmVnaXN0cmF0aW9uIG51bGwgc28gd2Uga25vdyB1c2VTZXJ2aWNlV29ya2VyIHdpbGwgbm90XG4gICAgICAgIC8vIHVzZSBhIG5ldyBzZXJ2aWNlIHdvcmtlciBhcyByZWdpc3RyYXRpb25Ub1VzZV8gaXMgbm8gbG9uZ2VyIHVuZGVmaW5lZFxuICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvblRvVXNlXyA9IG51bGw7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgICAgICAgLnJlZ2lzdGVyKGRlZmF1bHRfc3dfMS5kZWZhdWx0LnBhdGgsIHtcbiAgICAgICAgICAgIHNjb3BlOiBkZWZhdWx0X3N3XzEuZGVmYXVsdC5zY29wZVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuRkFJTEVEX0RFRkFVTFRfUkVHSVNUUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgYnJvd3NlckVycm9yTWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLndhaXRGb3JSZWdpc3RyYXRpb25Ub0FjdGl2YXRlXyhyZWdpc3RyYXRpb24pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdHJhdGlvblRvVXNlXyA9IHJlZ2lzdHJhdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBXZSB1cGRhdGUgYWZ0ZXIgYWN0aXZhdGlvbiBkdWUgdG8gYW4gaXNzdWUgd2l0aCBGaXJlZm94IHY0OSB3aGVyZVxuICAgICAgICAgICAgICAgIC8vIGEgcmFjZSBjb25kaXRpb24gb2NjYXNzaW9uYWxseSBjYXVzZXMgdGhlIHNlcnZpY2Ugd29yayB0byBub3RcbiAgICAgICAgICAgICAgICAvLyBpbnN0YWxsXG4gICAgICAgICAgICAgICAgcmVnaXN0cmF0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdpc3RyYXRpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNldCB1cCBhIG1lc3NhZ2UgbGlzdGVuZXIgdG8gaGFuZGxlXG4gICAgICogZXZlbnRzIGZyb20gdGhlIHNlcnZpY2Ugd29ya2VyIHRoYXQgc2hvdWxkIHRyaWdnZXJcbiAgICAgKiBldmVudHMgaW4gdGhlIHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFdpbmRvd0NvbnRyb2xsZXIucHJvdG90eXBlLnNldHVwU1dNZXNzYWdlTGlzdGVuZXJfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoISgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghZXZlbnQuZGF0YSB8fCAhZXZlbnQuZGF0YVt3b3JrZXJfcGFnZV9tZXNzYWdlXzEuZGVmYXVsdC5QQVJBTVMuVFlQRV9PRl9NU0ddKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IGEgbWVzc2FnZSBmcm9tIEZDTVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3b3JrZXJQYWdlTWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBzd2l0Y2ggKHdvcmtlclBhZ2VNZXNzYWdlW3dvcmtlcl9wYWdlX21lc3NhZ2VfMS5kZWZhdWx0LlBBUkFNUy5UWVBFX09GX01TR10pIHtcbiAgICAgICAgICAgICAgICBjYXNlIHdvcmtlcl9wYWdlX21lc3NhZ2VfMS5kZWZhdWx0LlRZUEVTX09GX01TRy5QVVNIX01TR19SRUNFSVZFRDpcbiAgICAgICAgICAgICAgICBjYXNlIHdvcmtlcl9wYWdlX21lc3NhZ2VfMS5kZWZhdWx0LlRZUEVTX09GX01TRy5OT1RJRklDQVRJT05fQ0xJQ0tFRDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHB1c2hNZXNzYWdlID0gd29ya2VyUGFnZU1lc3NhZ2Vbd29ya2VyX3BhZ2VfbWVzc2FnZV8xLmRlZmF1bHQuUEFSQU1TLkRBVEFdO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tZXNzYWdlT2JzZXJ2ZXJfLm5leHQocHVzaE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBOb29wLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgcmVxdWlyZWQgQVBJJ3MgYXJlIHZhbGlkIG9yIG5vdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZGVzaXJlZCBBUElzIGFyZSBhdmFpbGFibGUuXG4gICAgICovXG4gICAgV2luZG93Q29udHJvbGxlci5wcm90b3R5cGUuaXNTdXBwb3J0ZWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCdzZXJ2aWNlV29ya2VyJyBpbiBuYXZpZ2F0b3IgJiZcbiAgICAgICAgICAgICdQdXNoTWFuYWdlcicgaW4gd2luZG93ICYmXG4gICAgICAgICAgICAnTm90aWZpY2F0aW9uJyBpbiB3aW5kb3cgJiZcbiAgICAgICAgICAgICdmZXRjaCcgaW4gd2luZG93ICYmXG4gICAgICAgICAgICBTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnc2hvd05vdGlmaWNhdGlvbicpICYmXG4gICAgICAgICAgICBQdXNoU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnZ2V0S2V5JykpO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd0NvbnRyb2xsZXI7XG59KGNvbnRyb2xsZXJfaW50ZXJmYWNlXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gV2luZG93Q29udHJvbGxlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93LWNvbnRyb2xsZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiB0b0Jhc2U2NChhcnJheUJ1ZmZlcikge1xuICAgIHZhciB1aW50OFZlcnNpb24gPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgcmV0dXJuIHdpbmRvdy5idG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdWludDhWZXJzaW9uKSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgYmFzZTY0U3RyaW5nID0gdG9CYXNlNjQoYXJyYXlCdWZmZXIpO1xuICAgIHJldHVybiBiYXNlNjRTdHJpbmdcbiAgICAgICAgLnJlcGxhY2UoLz0vZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxuICAgICAgICAucmVwbGFjZSgvXFwvL2csICdfJyk7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS1idWZmZXItdG8tYmFzZTY0LmpzLm1hcFxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBwYXRoOiAnL2ZpcmViYXNlLW1lc3NhZ2luZy1zdy5qcycsXG4gICAgc2NvcGU6ICcvZmlyZWJhc2UtY2xvdWQtbWVzc2FnaW5nLXB1c2gtc2NvcGUnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LXN3LmpzLm1hcFxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDT0RFUyA9IHtcbiAgICBBVkFJTEFCTEVfSU5fV0lORE9XOiAnb25seS1hdmFpbGFibGUtaW4td2luZG93JyxcbiAgICBBVkFJTEFCTEVfSU5fU1c6ICdvbmx5LWF2YWlsYWJsZS1pbi1zdycsXG4gICAgU0hPVUxEX0JFX0lOSEVSSVRFRDogJ3Nob3VsZC1iZS1vdmVycmlkZW4nLFxuICAgIEJBRF9TRU5ERVJfSUQ6ICdiYWQtc2VuZGVyLWlkJyxcbiAgICBJTkNPUlJFQ1RfR0NNX1NFTkRFUl9JRDogJ2luY29ycmVjdC1nY20tc2VuZGVyLWlkJyxcbiAgICBQRVJNSVNTSU9OX0RFRkFVTFQ6ICdwZXJtaXNzaW9uLWRlZmF1bHQnLFxuICAgIFBFUk1JU1NJT05fQkxPQ0tFRDogJ3Blcm1pc3Npb24tYmxvY2tlZCcsXG4gICAgVU5TVVBQT1JURURfQlJPV1NFUjogJ3Vuc3VwcG9ydGVkLWJyb3dzZXInLFxuICAgIE5PVElGSUNBVElPTlNfQkxPQ0tFRDogJ25vdGlmaWNhdGlvbnMtYmxvY2tlZCcsXG4gICAgRkFJTEVEX0RFRkFVTFRfUkVHSVNUUkFUSU9OOiAnZmFpbGVkLXNlcnZpY2V3b3JrZXItcmVnaXN0cmF0aW9uJyxcbiAgICBTV19SRUdJU1RSQVRJT05fRVhQRUNURUQ6ICdzdy1yZWdpc3RyYXRpb24tZXhwZWN0ZWQnLFxuICAgIEdFVF9TVUJTQ1JJUFRJT05fRkFJTEVEOiAnZ2V0LXN1YnNjcmlwdGlvbi1mYWlsZWQnLFxuICAgIElOVkFMSURfU0FWRURfVE9LRU46ICdpbnZhbGlkLXNhdmVkLXRva2VuJyxcbiAgICBTV19SRUdfUkVEVU5EQU5UOiAnc3ctcmVnLXJlZHVuZGFudCcsXG4gICAgVE9LRU5fU1VCU0NSSUJFX0ZBSUxFRDogJ3Rva2VuLXN1YnNjcmliZS1mYWlsZWQnLFxuICAgIFRPS0VOX1NVQlNDUklCRV9OT19UT0tFTjogJ3Rva2VuLXN1YnNjcmliZS1uby10b2tlbicsXG4gICAgVE9LRU5fU1VCU0NSSUJFX05PX1BVU0hfU0VUOiAndG9rZW4tc3Vic2NyaWJlLW5vLXB1c2gtc2V0JyxcbiAgICBVU0VfU1dfQkVGT1JFX0dFVF9UT0tFTjogJ3VzZS1zdy1iZWZvcmUtZ2V0LXRva2VuJyxcbiAgICBJTlZBTElEX0RFTEVURV9UT0tFTjogJ2ludmFsaWQtZGVsZXRlLXRva2VuJyxcbiAgICBERUxFVEVfVE9LRU5fTk9UX0ZPVU5EOiAnZGVsZXRlLXRva2VuLW5vdC1mb3VuZCcsXG4gICAgREVMRVRFX1NDT1BFX05PVF9GT1VORDogJ2RlbGV0ZS1zY29wZS1ub3QtZm91bmQnLFxuICAgIEJHX0hBTkRMRVJfRlVOQ1RJT05fRVhQRUNURUQ6ICdiZy1oYW5kbGVyLWZ1bmN0aW9uLWV4cGVjdGVkJyxcbiAgICBOT19XSU5ET1dfQ0xJRU5UX1RPX01TRzogJ25vLXdpbmRvdy1jbGllbnQtdG8tbXNnJyxcbiAgICBVTkFCTEVfVE9fUkVTVUJTQ1JJQkU6ICd1bmFibGUtdG8tcmVzdWJzY3JpYmUnLFxuICAgIE5PX0ZDTV9UT0tFTl9GT1JfUkVTVUJTQ1JJQkU6ICduby1mY20tdG9rZW4tZm9yLXJlc3Vic2NyaWJlJyxcbiAgICBGQUlMRURfVE9fREVMRVRFX1RPS0VOOiAnZmFpbGVkLXRvLWRlbGV0ZS10b2tlbicsXG4gICAgTk9fU1dfSU5fUkVHOiAnbm8tc3ctaW4tcmVnJyxcbiAgICBCQURfU0NPUEU6ICdiYWQtc2NvcGUnLFxuICAgIEJBRF9WQVBJRF9LRVk6ICdiYWQtdmFwaWQta2V5JyxcbiAgICBCQURfU1VCU0NSSVBUSU9OOiAnYmFkLXN1YnNjcmlwdGlvbicsXG4gICAgQkFEX1RPS0VOOiAnYmFkLXRva2VuJyxcbiAgICBCQURfUFVTSF9TRVQ6ICdiYWQtcHVzaC1zZXQnLFxuICAgIEZBSUxFRF9ERUxFVEVfVkFQSURfS0VZOiAnZmFpbGVkLWRlbGV0ZS12YXBpZC1rZXknXG59O1xudmFyIEVSUk9SX01BUCA9IChfYSA9IHt9LFxuICAgIF9hW0NPREVTLkFWQUlMQUJMRV9JTl9XSU5ET1ddID0gJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBpbiBhIFdpbmRvdyBjb250ZXh0LicsXG4gICAgX2FbQ09ERVMuQVZBSUxBQkxFX0lOX1NXXSA9ICdUaGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgaW4gYSBzZXJ2aWNlIHdvcmtlciAnICsgJ2NvbnRleHQuJyxcbiAgICBfYVtDT0RFUy5TSE9VTERfQkVfSU5IRVJJVEVEXSA9ICdUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGVuIGJ5ICcgKyAnZXh0ZW5kZWQgY2xhc3Nlcy4nLFxuICAgIF9hW0NPREVTLkJBRF9TRU5ERVJfSURdID0gXCJQbGVhc2UgZW5zdXJlIHRoYXQgJ21lc3NhZ2luZ1NlbmRlcklkJyBpcyBzZXQgXCIgK1xuICAgICAgICAnY29ycmVjdGx5IGluIHRoZSBvcHRpb25zIHBhc3NlZCBpbnRvIGZpcmViYXNlLmluaXRpYWxpemVBcHAoKS4nLFxuICAgIF9hW0NPREVTLlBFUk1JU1NJT05fREVGQVVMVF0gPSAnVGhlIHJlcXVpcmVkIHBlcm1pc3Npb25zIHdlcmUgbm90IGdyYW50ZWQgYW5kICcgKyAnZGlzbWlzc2VkIGluc3RlYWQuJyxcbiAgICBfYVtDT0RFUy5QRVJNSVNTSU9OX0JMT0NLRURdID0gJ1RoZSByZXF1aXJlZCBwZXJtaXNzaW9ucyB3ZXJlIG5vdCBncmFudGVkIGFuZCAnICsgJ2Jsb2NrZWQgaW5zdGVhZC4nLFxuICAgIF9hW0NPREVTLlVOU1VQUE9SVEVEX0JST1dTRVJdID0gXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBBUEkncyBcIiArXG4gICAgICAgICdyZXF1aXJlZCB0byB1c2UgdGhlIGZpcmViYXNlIFNESy4nLFxuICAgIF9hW0NPREVTLk5PVElGSUNBVElPTlNfQkxPQ0tFRF0gPSAnTm90aWZpY2F0aW9ucyBoYXZlIGJlZW4gYmxvY2tlZC4nLFxuICAgIF9hW0NPREVTLkZBSUxFRF9ERUZBVUxUX1JFR0lTVFJBVElPTl0gPSAnV2UgYXJlIHVuYWJsZSB0byByZWdpc3RlciB0aGUgJyArXG4gICAgICAgICdkZWZhdWx0IHNlcnZpY2Ugd29ya2VyLiB7JGJyb3dzZXJFcnJvck1lc3NhZ2V9JyxcbiAgICBfYVtDT0RFUy5TV19SRUdJU1RSQVRJT05fRVhQRUNURURdID0gJ0Egc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHdhcyB0aGUgJyArICdleHBlY3RlZCBpbnB1dC4nLFxuICAgIF9hW0NPREVTLkdFVF9TVUJTQ1JJUFRJT05fRkFJTEVEXSA9ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hlbiB0cnlpbmcgdG8gZ2V0ICcgK1xuICAgICAgICAnYW55IGV4aXN0aW5nIFB1c2ggU3Vic2NyaXB0aW9ucy4nLFxuICAgIF9hW0NPREVTLklOVkFMSURfU0FWRURfVE9LRU5dID0gJ1VuYWJsZSB0byBhY2Nlc3MgZGV0YWlscyBvZiB0aGUgc2F2ZWQgdG9rZW4uJyxcbiAgICBfYVtDT0RFUy5TV19SRUdfUkVEVU5EQU5UXSA9ICdUaGUgc2VydmljZSB3b3JrZXIgYmVpbmcgdXNlZCBmb3IgcHVzaCB3YXMgbWFkZSAnICsgJ3JlZHVuZGFudC4nLFxuICAgIF9hW0NPREVTLlRPS0VOX1NVQlNDUklCRV9GQUlMRURdID0gJ0EgcHJvYmxlbSBvY2N1cmVkIHdoaWxlIHN1YnNjcmliaW5nIHRoZSAnICsgJ3VzZXIgdG8gRkNNOiB7JG1lc3NhZ2V9JyxcbiAgICBfYVtDT0RFUy5UT0tFTl9TVUJTQ1JJQkVfTk9fVE9LRU5dID0gJ0ZDTSByZXR1cm5lZCBubyB0b2tlbiB3aGVuIHN1YnNjcmliaW5nICcgKyAndGhlIHVzZXIgdG8gcHVzaC4nLFxuICAgIF9hW0NPREVTLlRPS0VOX1NVQlNDUklCRV9OT19QVVNIX1NFVF0gPSAnRkNNIHJldHVybmVkIGFuIGludmFsaWQgcmVzcG9uc2UgJyArICd3aGVuIGdldHRpbmcgYW4gRkNNIHRva2VuLicsXG4gICAgX2FbQ09ERVMuVVNFX1NXX0JFRk9SRV9HRVRfVE9LRU5dID0gJ1lvdSBtdXN0IGNhbGwgdXNlU2VydmljZVdvcmtlcigpIGJlZm9yZSAnICtcbiAgICAgICAgJ2NhbGxpbmcgZ2V0VG9rZW4oKSB0byBlbnN1cmUgeW91ciBzZXJ2aWNlIHdvcmtlciBpcyB1c2VkLicsXG4gICAgX2FbQ09ERVMuSU5WQUxJRF9ERUxFVEVfVE9LRU5dID0gJ1lvdSBtdXN0IHBhc3MgYSB2YWxpZCB0b2tlbiBpbnRvICcgK1xuICAgICAgICAnZGVsZXRlVG9rZW4oKSwgaS5lLiB0aGUgdG9rZW4gZnJvbSBnZXRUb2tlbigpLicsXG4gICAgX2FbQ09ERVMuREVMRVRFX1RPS0VOX05PVF9GT1VORF0gPSAnVGhlIGRlbGV0aW9uIGF0dGVtcHQgZm9yIHRva2VuIGNvdWxkIG5vdCAnICtcbiAgICAgICAgJ2JlIHBlcmZvcm1lZCBhcyB0aGUgdG9rZW4gd2FzIG5vdCBmb3VuZC4nLFxuICAgIF9hW0NPREVTLkRFTEVURV9TQ09QRV9OT1RfRk9VTkRdID0gJ1RoZSBkZWxldGlvbiBhdHRlbXB0IGZvciBzZXJ2aWNlIHdvcmtlciAnICtcbiAgICAgICAgJ3Njb3BlIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgYXMgdGhlIHNjb3BlIHdhcyBub3QgZm91bmQuJyxcbiAgICBfYVtDT0RFUy5CR19IQU5ETEVSX0ZVTkNUSU9OX0VYUEVDVEVEXSA9ICdUaGUgaW5wdXQgdG8gJyArICdzZXRCYWNrZ3JvdW5kTWVzc2FnZUhhbmRsZXIoKSBtdXN0IGJlIGEgZnVuY3Rpb24uJyxcbiAgICBfYVtDT0RFUy5OT19XSU5ET1dfQ0xJRU5UX1RPX01TR10gPSAnQW4gYXR0ZW1wdCB3YXMgbWFkZSB0byBtZXNzYWdlIGEgJyArICdub24tZXhpc3RhbnQgd2luZG93IGNsaWVudC4nLFxuICAgIF9hW0NPREVTLlVOQUJMRV9UT19SRVNVQlNDUklCRV0gPSAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHJlLXN1YnNjcmliaW5nICcgK1xuICAgICAgICAndGhlIEZDTSB0b2tlbiBmb3IgcHVzaCBtZXNzYWdpbmcuIFdpbGwgaGF2ZSB0byByZXN1YnNjcmliZSB0aGUgJyArXG4gICAgICAgICd1c2VyIG9uIG5leHQgdmlzaXQuIHskbWVzc2FnZX0nLFxuICAgIF9hW0NPREVTLk5PX0ZDTV9UT0tFTl9GT1JfUkVTVUJTQ1JJQkVdID0gJ0NvdWxkIG5vdCBmaW5kIGFuIEZDTSB0b2tlbiAnICtcbiAgICAgICAgJ2FuZCBhcyBhIHJlc3VsdCwgdW5hYmxlIHRvIHJlc3Vic2NyaWJlLiBXaWxsIGhhdmUgdG8gcmVzdWJzY3JpYmUgdGhlICcgK1xuICAgICAgICAndXNlciBvbiBuZXh0IHZpc2l0LicsXG4gICAgX2FbQ09ERVMuRkFJTEVEX1RPX0RFTEVURV9UT0tFTl0gPSAnVW5hYmxlIHRvIGRlbGV0ZSB0aGUgY3VycmVudGx5IHNhdmVkIHRva2VuLicsXG4gICAgX2FbQ09ERVMuTk9fU1dfSU5fUkVHXSA9ICdFdmVuIHRob3VnaCB0aGUgc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHdhcyAnICtcbiAgICAgICAgJ3N1Y2Nlc3NmdWwsIHRoZXJlIHdhcyBhIHByb2JsZW0gYWNjZXNzaW5nIHRoZSBzZXJ2aWNlIHdvcmtlciBpdHNlbGYuJyxcbiAgICBfYVtDT0RFUy5JTkNPUlJFQ1RfR0NNX1NFTkRFUl9JRF0gPSBcIlBsZWFzZSBjaGFuZ2UgeW91ciB3ZWIgYXBwIG1hbmlmZXN0J3MgXCIgK1xuICAgICAgICBcIidnY21fc2VuZGVyX2lkJyB2YWx1ZSB0byAnMTAzOTUzODAwNTA3JyB0byB1c2UgRmlyZWJhc2UgbWVzc2FnaW5nLlwiLFxuICAgIF9hW0NPREVTLkJBRF9TQ09QRV0gPSAnVGhlIHNlcnZpY2Ugd29ya2VyIHNjb3BlIG11c3QgYmUgYSBzdHJpbmcgd2l0aCBhdCAnICtcbiAgICAgICAgJ2xlYXN0IG9uZSBjaGFyYWN0ZXIuJyxcbiAgICBfYVtDT0RFUy5CQURfVkFQSURfS0VZXSA9ICdUaGUgcHVibGljIFZBUElEIGtleSBtdXN0IGJlIGEgc3RyaW5nIHdpdGggYXQgJyArICdsZWFzdCBvbmUgY2hhcmFjdGVyLicsXG4gICAgX2FbQ09ERVMuQkFEX1NVQlNDUklQVElPTl0gPSAnVGhlIHN1YnNjcmlwdGlvbiBtdXN0IGJlIGEgdmFsaWQgJyArICdQdXNoU3Vic2NyaXB0aW9uLicsXG4gICAgX2FbQ09ERVMuQkFEX1RPS0VOXSA9ICdUaGUgRkNNIFRva2VuIHVzZWQgZm9yIHN0b3JhZ2UgLyBsb29rdXAgd2FzIG5vdCAnICtcbiAgICAgICAgJ2EgdmFsaWQgdG9rZW4gc3RyaW5nLicsXG4gICAgX2FbQ09ERVMuQkFEX1BVU0hfU0VUXSA9ICdUaGUgRkNNIHB1c2ggc2V0IHVzZWQgZm9yIHN0b3JhZ2UgLyBsb29rdXAgd2FzIG5vdCAnICtcbiAgICAgICAgJ25vdCBhIHZhbGlkIHB1c2ggc2V0IHN0cmluZy4nLFxuICAgIF9hW0NPREVTLkZBSUxFRF9ERUxFVEVfVkFQSURfS0VZXSA9ICdUaGUgVkFQSUQga2V5IGNvdWxkIG5vdCBiZSBkZWxldGVkLicsXG4gICAgX2EpO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIGNvZGVzOiBDT0RFUyxcbiAgICBtYXA6IEVSUk9SX01BUFxufTtcbnZhciBfYTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcFxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBGQ01fQVBQTElDQVRJT05fU0VSVkVSX0tFWSA9IFtcbiAgICAweDA0LFxuICAgIDB4MzMsXG4gICAgMHg5NCxcbiAgICAweGY3LFxuICAgIDB4ZGYsXG4gICAgMHhhMSxcbiAgICAweGViLFxuICAgIDB4YjEsXG4gICAgMHhkYyxcbiAgICAweDAzLFxuICAgIDB4YTIsXG4gICAgMHg1ZSxcbiAgICAweDE1LFxuICAgIDB4NzEsXG4gICAgMHhkYixcbiAgICAweDQ4LFxuICAgIDB4ZDMsXG4gICAgMHgyZSxcbiAgICAweGVkLFxuICAgIDB4ZWQsXG4gICAgMHhiMixcbiAgICAweDM0LFxuICAgIDB4ZGIsXG4gICAgMHhiNyxcbiAgICAweDQ3LFxuICAgIDB4M2EsXG4gICAgMHgwYyxcbiAgICAweDhmLFxuICAgIDB4YzQsXG4gICAgMHhjYyxcbiAgICAweGUxLFxuICAgIDB4NmYsXG4gICAgMHgzYyxcbiAgICAweDhjLFxuICAgIDB4ODQsXG4gICAgMHhkZixcbiAgICAweGFiLFxuICAgIDB4YjYsXG4gICAgMHg2NixcbiAgICAweDNlLFxuICAgIDB4ZjIsXG4gICAgMHgwYyxcbiAgICAweGQ0LFxuICAgIDB4OGIsXG4gICAgMHhmZSxcbiAgICAweGUzLFxuICAgIDB4ZjksXG4gICAgMHg3NixcbiAgICAweDJmLFxuICAgIDB4MTQsXG4gICAgMHgxYyxcbiAgICAweDYzLFxuICAgIDB4MDgsXG4gICAgMHg2YSxcbiAgICAweDZmLFxuICAgIDB4MmQsXG4gICAgMHhiMSxcbiAgICAweDFhLFxuICAgIDB4OTUsXG4gICAgMHhiMCxcbiAgICAweGNlLFxuICAgIDB4MzcsXG4gICAgMHhjMCxcbiAgICAweDljLFxuICAgIDB4NmVcbl07XG52YXIgU1VCU0NSSVBUSU9OX0RFVEFJTFMgPSB7XG4gICAgdXNlclZpc2libGVPbmx5OiB0cnVlLFxuICAgIGFwcGxpY2F0aW9uU2VydmVyS2V5OiBuZXcgVWludDhBcnJheShGQ01fQVBQTElDQVRJT05fU0VSVkVSX0tFWSlcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgRU5EUE9JTlQ6ICdodHRwczovL2ZjbS5nb29nbGVhcGlzLmNvbScsXG4gICAgQVBQTElDQVRJT05fU0VSVkVSX0tFWTogRkNNX0FQUExJQ0FUSU9OX1NFUlZFUl9LRVksXG4gICAgU1VCU0NSSVBUSU9OX09QVElPTlM6IFNVQlNDUklQVElPTl9ERVRBSUxTXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mY20tZGV0YWlscy5qcy5tYXBcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgZ3JhbnRlZDogJ2dyYW50ZWQnLFxuICAgIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgICBkZW5pZWQ6ICdkZW5pZWQnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3RpZmljYXRpb24tcGVybWlzc2lvbi5qcy5tYXBcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIGFycmF5X2J1ZmZlcl90b19iYXNlNjRfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2FycmF5LWJ1ZmZlci10by1iYXNlNjRcIik7XG52YXIgZmNtX2RldGFpbHNfMSA9IHJlcXVpcmUoXCIuL2ZjbS1kZXRhaWxzXCIpO1xudmFyIEZDTV9UT0tFTl9PQkpfU1RPUkUgPSAnZmNtX3Rva2VuX29iamVjdF9TdG9yZSc7XG52YXIgRkNNX1RPS0VOX0RFVEFJTFNfREJfVkVSU0lPTiA9IDE7XG52YXIgVG9rZW5NYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRva2VuTWFuYWdlcigpIHtcbiAgICAgICAgdGhpcy5lcnJvckZhY3RvcnlfID0gbmV3IHV0aWxfMS5FcnJvckZhY3RvcnkoJ21lc3NhZ2luZycsICdNZXNzYWdpbmcnLCBlcnJvcnNfMS5kZWZhdWx0Lm1hcCk7XG4gICAgICAgIHRoaXMub3BlbkRiUHJvbWlzZV8gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGluZGV4ZWREQiBhcyBhIHByb21zaWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPElEQkRhdGFiYXNlPn0gVGhlIEluZGV4ZWREQiBkYXRhYmFzZVxuICAgICAqL1xuICAgIFRva2VuTWFuYWdlci5wcm90b3R5cGUub3BlbkRhdGFiYXNlXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3BlbkRiUHJvbWlzZV8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW5EYlByb21pc2VfO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlbkRiUHJvbWlzZV8gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKFRva2VuTWFuYWdlci5EQl9OQU1FLCBGQ01fVE9LRU5fREVUQUlMU19EQl9WRVJTSU9OKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRkNNX1RPS0VOX09CSl9TVE9SRSwge1xuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiAnc3dTY29wZSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHNlbmRlciBJRCBjYW4gYmUgc2VhcmNoZWRcbiAgICAgICAgICAgICAgICBvYmplY3RTdG9yZS5jcmVhdGVJbmRleCgnZmNtU2VuZGVySWQnLCAnZmNtU2VuZGVySWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvYmplY3RTdG9yZS5jcmVhdGVJbmRleCgnZmNtVG9rZW4nLCAnZmNtVG9rZW4nLCB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW5EYlByb21pc2VfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGN1cnJlbnRseSBvcGVuIGRhdGFiYXNlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Pz59IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJvbWlzZSBjaGFpbi5cbiAgICAgKi9cbiAgICBUb2tlbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlRGF0YWJhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLm9wZW5EYlByb21pc2VfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuRGJQcm9taXNlXy50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMub3BlbkRiUHJvbWlzZV8gPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSB0b2tlbiwgdGhpcyBtZXRob2Qgd2lsbCBsb29rIHVwIHRoZSBkZXRhaWxzIGluIGluZGV4ZWREQi5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZjbVRva2VuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgZGV0YWlscyBhc3NvY2lhdGVkIHdpdGggdGhhdCB0b2tlbi5cbiAgICAgKi9cbiAgICBUb2tlbk1hbmFnZXIucHJvdG90eXBlLmdldFRva2VuRGV0YWlsc0Zyb21Ub2tlbiA9IGZ1bmN0aW9uIChmY21Ub2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuRGF0YWJhc2VfKCkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZDTV9UT0tFTl9PQkpfU1RPUkVdKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGQ01fVE9LRU5fT0JKX1NUT1JFKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBvYmplY3RTdG9yZS5pbmRleCgnZmNtVG9rZW4nKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGluZGV4LmdldChmY21Ub2tlbik7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVG9rZW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRUb2tlbkRldGFpbHNGcm9tU1dTY29wZV8gPSBmdW5jdGlvbiAoc3dTY29wZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuRGF0YWJhc2VfKCkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZDTV9UT0tFTl9PQkpfU1RPUkVdKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGQ01fVE9LRU5fT0JKX1NUT1JFKTtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGVSZXF1ZXN0ID0gb2JqZWN0U3RvcmUuZ2V0KHN3U2NvcGUpO1xuICAgICAgICAgICAgICAgIHNjb3BlUmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NvcGVSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUb2tlbk1hbmFnZXIucHJvdG90eXBlLmdldEFsbFRva2VuRGV0YWlsc0ZvclNlbmRlcklkXyA9IGZ1bmN0aW9uIChzZW5kZXJJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuRGF0YWJhc2VfKCkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZDTV9UT0tFTl9PQkpfU1RPUkVdKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGQ01fVE9LRU5fT0JKX1NUT1JFKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VuZGVySWRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yUmVxdWVzdCA9IG9iamVjdFN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci52YWx1ZVsnZmNtU2VuZGVySWQnXSA9PT0gc2VuZGVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXJJZFRva2Vucy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VuZGVySWRUb2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgUHVzaFN1YnNjcmlwdGlvbiBhbmQgbWVzc2FnaW5nU2VuZGVySWQsIGdldCBhbiBGQ00gdG9rZW4uXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gc2VuZGVySWQgVGhlICdtZXNzYWdpbmdTZW5kZXJJZCcgdG8gdGllIHRoZSB0b2tlbiB0by5cbiAgICAgKiBAcGFyYW0gIHtQdXNoU3Vic2NyaXB0aW9ufSBzdWJzY3JpcHRpb24gVGhlIFB1c2hTdXNiY3JpcHRpb24gdG8gXCJmZWRlcmF0ZVwiLlxuICAgICAqIEBwYXJhbSAge3N0cmluZz19IHB1c2hTZXQgSWYgZGVmaW5lZCB0aGlzIHdpbGwgc3dhcCB0aGUgc3Vic2NyaXB0aW9uIGZvclxuICAgICAqIG1hdGNoaW5nIEZDTSB0b2tlbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPCFPYmplY3Q+fSBSZXR1cm5zIHRoZSBGQ00gdG9rZW4gdG8gYmUgdXNlZCBpbiBwbGFjZVxuICAgICAqIG9mIHRoZSBQdXNoU3Vic2NyaXB0aW9uLlxuICAgICAqL1xuICAgIFRva2VuTWFuYWdlci5wcm90b3R5cGUuc3Vic2NyaWJlVG9GQ00gPSBmdW5jdGlvbiAoc2VuZGVySWQsIHN1YnNjcmlwdGlvbiwgcHVzaFNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcDI1NmRoID0gYXJyYXlfYnVmZmVyX3RvX2Jhc2U2NF8xLmRlZmF1bHQoc3Vic2NyaXB0aW9uWydnZXRLZXknXSgncDI1NmRoJykpO1xuICAgICAgICB2YXIgYXV0aCA9IGFycmF5X2J1ZmZlcl90b19iYXNlNjRfMS5kZWZhdWx0KHN1YnNjcmlwdGlvblsnZ2V0S2V5J10oJ2F1dGgnKSk7XG4gICAgICAgIHZhciBmY21TdWJzY3JpYmVCb2R5ID0gXCJhdXRob3JpemVkX2VudGl0eT1cIiArIHNlbmRlcklkICsgXCImXCIgK1xuICAgICAgICAgICAgKFwiZW5kcG9pbnQ9XCIgKyBzdWJzY3JpcHRpb24uZW5kcG9pbnQgKyBcIiZcIikgK1xuICAgICAgICAgICAgKFwiZW5jcnlwdGlvbl9rZXk9XCIgKyBwMjU2ZGggKyBcIiZcIikgK1xuICAgICAgICAgICAgKFwiZW5jcnlwdGlvbl9hdXRoPVwiICsgYXV0aCk7XG4gICAgICAgIGlmIChwdXNoU2V0KSB7XG4gICAgICAgICAgICBmY21TdWJzY3JpYmVCb2R5ICs9IFwiJnB1c2hTZXQ9XCIgKyBwdXNoU2V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICAgICAgdmFyIHN1YnNjcmliZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBmY21TdWJzY3JpYmVCb2R5XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmZXRjaChmY21fZGV0YWlsc18xLmRlZmF1bHQuRU5EUE9JTlQgKyAnL2ZjbS9jb25uZWN0L3N1YnNjcmliZScsIHN1YnNjcmliZU9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGZjbVRva2VuUmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChmY21Ub2tlblJlc3BvbnNlWydlcnJvciddKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBmY21Ub2tlblJlc3BvbnNlWydlcnJvciddWydtZXNzYWdlJ107XG4gICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5UT0tFTl9TVUJTQ1JJQkVfRkFJTEVELCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZmNtVG9rZW5SZXNwb25zZVsndG9rZW4nXSkge1xuICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuVE9LRU5fU1VCU0NSSUJFX05PX1RPS0VOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZmNtVG9rZW5SZXNwb25zZVsncHVzaFNldCddKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5UT0tFTl9TVUJTQ1JJQkVfTk9fUFVTSF9TRVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b2tlbjogZmNtVG9rZW5SZXNwb25zZVsndG9rZW4nXSxcbiAgICAgICAgICAgICAgICBwdXNoU2V0OiBmY21Ub2tlblJlc3BvbnNlWydwdXNoU2V0J11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSB0aGF0IGZpZWxkcyBpbiB0aGUgUHVzaFN1YnNjcmlwdGlvbiBhcmUgZXF1aXZhbGVudCB0byB0aGVcbiAgICAgKiBkZXRhaWxzIHN0b3JlcyBpbiB0aGUgbWFzdGVyVG9rZW5EZXRhaWxzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7UHVzaFN1YnNjcmlwdGlvbn0gc3Vic2NyaXB0aW9uIFRoZSBwdXNoIHN1YnNjcmlwdGlvbiB3ZSBleHBlY3RcbiAgICAgKiB0aGUgbWFzdGVyIHRva2VuIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gIG1hc3RlclRva2VuRGV0YWlscyBUaGUgc2F2ZWQgZGV0YWlscyB3ZSB3aXNoIHRvIGNvbXBhcmVcbiAgICAgKiB3aXRoIHRoZSBQdXNoU3Vic2NyaXB0aW9uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3Vic2NyaXB0aW9uIGFuZCB0b2tlbiBkZXRhaWxzIGFyZVxuICAgICAqIGVxdWl2YWxlbnQuXG4gICAgICovXG4gICAgVG9rZW5NYW5hZ2VyLnByb3RvdHlwZS5pc1NhbWVTdWJzY3JpcHRpb25fID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbiwgbWFzdGVyVG9rZW5EZXRhaWxzKSB7XG4gICAgICAgIC8vIGdldEtleSgpIGlzbid0IGRlZmluZWQgaW4gdGhlIFB1c2hTdWJzY3JpcHRpb24gZXh0ZXJucyBmaWxlLCBoZW5jZVxuICAgICAgICAvLyBzdWJzY3JpcHRpb25bJ2dldEtleSddKCc8a2V5IG5hbWU+JykuXG4gICAgICAgIHJldHVybiAoc3Vic2NyaXB0aW9uLmVuZHBvaW50ID09PSBtYXN0ZXJUb2tlbkRldGFpbHNbJ2VuZHBvaW50J10gJiZcbiAgICAgICAgICAgIGFycmF5X2J1ZmZlcl90b19iYXNlNjRfMS5kZWZhdWx0KHN1YnNjcmlwdGlvblsnZ2V0S2V5J10oJ2F1dGgnKSkgPT09XG4gICAgICAgICAgICAgICAgbWFzdGVyVG9rZW5EZXRhaWxzWydhdXRoJ10gJiZcbiAgICAgICAgICAgIGFycmF5X2J1ZmZlcl90b19iYXNlNjRfMS5kZWZhdWx0KHN1YnNjcmlwdGlvblsnZ2V0S2V5J10oJ3AyNTZkaCcpKSA9PT1cbiAgICAgICAgICAgICAgICBtYXN0ZXJUb2tlbkRldGFpbHNbJ3AyNTZkaCddKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIGRldGFpbHMgZm9yIHRoZSBmY20gdG9rZW4gZm9yIHJlLXVzZSBhdCBhIGxhdGVyIGRhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHNlbmRlcklkIFRoZSAnbWVzc2FnaW5nU2VuZGVySWQnIHVzZWQgZm9yIHRoaXMgcHJvamVjdFxuICAgICAqIEBwYXJhbSAge1NlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb259IHN3UmVnaXN0cmF0aW9uIFRoZSBzZXJ2aWNlIHdvcmtlclxuICAgICAqIHVzZWQgdG8gc3Vic2NyaWJlIHRoZSB1c2VyIGZvciB3ZWIgcHVzaFxuICAgICAqIEBwYXJhbSAge1B1c2hTdWJzY3JpcHRpb259IHN1YnNjcmlwdGlvbiBUaGUgcHVzaCBzdWJzY3JpcHRpb24gcGFzc2VkIHRvXG4gICAgICogRkNNIGZvciB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZjbVRva2VuIFRoZSBGQ00gdG9rZW4gY3VycmVudGx5IHVzZWQgb24gdGhpc1xuICAgICAqIGRldmljZS5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZjbVB1c2hTZXQgVGhlIEZDTSBwdXNoIHRpZWQgdG8gdGhlIGZjbSB0b2tlbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIFRva2VuTWFuYWdlci5wcm90b3R5cGUuc2F2ZVRva2VuRGV0YWlsc18gPSBmdW5jdGlvbiAoc2VuZGVySWQsIHN3UmVnaXN0cmF0aW9uLCBzdWJzY3JpcHRpb24sIGZjbVRva2VuLCBmY21QdXNoU2V0KSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0ge1xuICAgICAgICAgICAgc3dTY29wZTogc3dSZWdpc3RyYXRpb24uc2NvcGUsXG4gICAgICAgICAgICBlbmRwb2ludDogc3Vic2NyaXB0aW9uLmVuZHBvaW50LFxuICAgICAgICAgICAgYXV0aDogYXJyYXlfYnVmZmVyX3RvX2Jhc2U2NF8xLmRlZmF1bHQoc3Vic2NyaXB0aW9uWydnZXRLZXknXSgnYXV0aCcpKSxcbiAgICAgICAgICAgIHAyNTZkaDogYXJyYXlfYnVmZmVyX3RvX2Jhc2U2NF8xLmRlZmF1bHQoc3Vic2NyaXB0aW9uWydnZXRLZXknXSgncDI1NmRoJykpLFxuICAgICAgICAgICAgZmNtVG9rZW46IGZjbVRva2VuLFxuICAgICAgICAgICAgZmNtUHVzaFNldDogZmNtUHVzaFNldCxcbiAgICAgICAgICAgIGZjbVNlbmRlcklkOiBzZW5kZXJJZFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuRGF0YWJhc2VfKCkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZDTV9UT0tFTl9PQkpfU1RPUkVdLCAncmVhZHdyaXRlJyk7XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoRkNNX1RPS0VOX09CSl9TVE9SRSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBvYmplY3RTdG9yZS5wdXQoZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzYXZlZCBGQ00gVG9rZW4gaWYgb25lIGlzIGF2YWlsYWJsZSBhbmQgc3RpbGwgdmFsaWQsXG4gICAgICogb3RoZXJ3aXNlIGBudWxsYCBpcyByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VuZGVySWQgVGhpcyBzaG91bGQgYmUgdGhlIHNlbmRlciBJRCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogRkNNIFRva2VuIGJlaW5nIHJldHJpZXZlZC5cbiAgICAgKiBAcGFyYW0ge1NlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb259IHN3UmVnaXN0cmF0aW9uIFJlZ2lzdHJhdGlvbiB0byBiZSB1c2VkXG4gICAgICogdG8gc3Vic2NyaWJlIHRoZSB1c2VyIHRvIHB1c2guXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+IHwgUHJvbWlzZX0gUmV0dXJucyB0aGUgc2F2ZWQgRkNNIFRva2VuIGlmXG4gICAgICogYXZpbGFibGUgYW5kIHZhbGlkLlxuICAgICAqIEBleHBvcnRcbiAgICAgKi9cbiAgICBUb2tlbk1hbmFnZXIucHJvdG90eXBlLmdldFNhdmVkVG9rZW4gPSBmdW5jdGlvbiAoc2VuZGVySWQsIHN3UmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghKHN3UmVnaXN0cmF0aW9uIGluc3RhbmNlb2YgU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuU1dfUkVHSVNUUkFUSU9OX0VYUEVDVEVEKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZW5kZXJJZCAhPT0gJ3N0cmluZycgfHwgc2VuZGVySWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShlcnJvcnNfMS5kZWZhdWx0LmNvZGVzLkJBRF9TRU5ERVJfSUQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxUb2tlbkRldGFpbHNGb3JTZW5kZXJJZF8oc2VuZGVySWQpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWxsVG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAoYWxsVG9rZW5EZXRhaWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGFsbFRva2VuRGV0YWlscy5maW5kSW5kZXgoZnVuY3Rpb24gKHRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc3dSZWdpc3RyYXRpb24uc2NvcGUgPT09IHRva2VuRGV0YWlsc1snc3dTY29wZSddICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbmRlcklkID09PSB0b2tlbkRldGFpbHNbJ2ZjbVNlbmRlcklkJ10pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFsbFRva2VuRGV0YWlsc1tpbmRleF07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAoIXRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzd1JlZ2lzdHJhdGlvbi5wdXNoTWFuYWdlclxuICAgICAgICAgICAgICAgIC5nZXRTdWJzY3JpcHRpb24oKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5HRVRfU1VCU0NSSVBUSU9OX0ZBSUxFRCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzU2FtZVN1YnNjcmlwdGlvbl8oc3Vic2NyaXB0aW9uLCB0b2tlbkRldGFpbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkRldGFpbHNbJ2ZjbVRva2VuJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGQ00gdG9rZW4uXG4gICAgICovXG4gICAgVG9rZW5NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVUb2tlbiA9IGZ1bmN0aW9uIChzZW5kZXJJZCwgc3dSZWdpc3RyYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBzZW5kZXJJZCAhPT0gJ3N0cmluZycgfHwgc2VuZGVySWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShlcnJvcnNfMS5kZWZhdWx0LmNvZGVzLkJBRF9TRU5ERVJfSUQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzd1JlZ2lzdHJhdGlvbiBpbnN0YW5jZW9mIFNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShlcnJvcnNfMS5kZWZhdWx0LmNvZGVzLlNXX1JFR0lTVFJBVElPTl9FWFBFQ1RFRCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBleGlzdGluZyBzdWJzY3JpcHRpb24gZmlyc3RcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdmFyIGZjbVRva2VuRGV0YWlscztcbiAgICAgICAgcmV0dXJuIHN3UmVnaXN0cmF0aW9uLnB1c2hNYW5hZ2VyXG4gICAgICAgICAgICAuZ2V0U3Vic2NyaXB0aW9uKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN3UmVnaXN0cmF0aW9uLnB1c2hNYW5hZ2VyLnN1YnNjcmliZShmY21fZGV0YWlsc18xLmRlZmF1bHQuU1VCU0NSSVBUSU9OX09QVElPTlMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gc3ViO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN1YnNjcmliZVRvRkNNKHNlbmRlcklkLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgZmNtVG9rZW5EZXRhaWxzID0gdG9rZW5EZXRhaWxzO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNhdmVUb2tlbkRldGFpbHNfKHNlbmRlcklkLCBzd1JlZ2lzdHJhdGlvbiwgc3Vic2NyaXB0aW9uLCBmY21Ub2tlbkRldGFpbHNbJ3Rva2VuJ10sIGZjbVRva2VuRGV0YWlsc1sncHVzaFNldCddKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZjbVRva2VuRGV0YWlsc1sndG9rZW4nXTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBkZWxldGVzIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgRkNNIHRva2VuLlxuICAgICAqIEl0J3MgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiBjYXNlIHdlIG5lZWQgdG8gbW92ZSB0byBhbiBhc3luY1xuICAgICAqIG1ldGhvZCBmb3IgZGVsZXRpbmcgYXQgYSBsYXRlciBkYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUb2tlbiB0byBiZSBkZWxldGVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSBSZXNvbHZlcyBvbmNlIHRoZSBGQ00gdG9rZW4gZGV0YWlscyBoYXZlIGJlZW5cbiAgICAgKiBkZWxldGVkIGFuZCByZXR1cm5zIHRoZSBkZWxldGVkIGRldGFpbHMuXG4gICAgICovXG4gICAgVG9rZW5NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJyB8fCB0b2tlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuSU5WQUxJRF9ERUxFVEVfVE9LRU4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbkRldGFpbHNGcm9tVG9rZW4odG9rZW4pLnRoZW4oZnVuY3Rpb24gKGRldGFpbHMpIHtcbiAgICAgICAgICAgIGlmICghZGV0YWlscykge1xuICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKGVycm9yc18xLmRlZmF1bHQuY29kZXMuREVMRVRFX1RPS0VOX05PVF9GT1VORCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMub3BlbkRhdGFiYXNlXygpLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZDTV9UT0tFTl9PQkpfU1RPUkVdLCAncmVhZHdyaXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEZDTV9UT0tFTl9PQkpfU1RPUkUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG9iamVjdFN0b3JlLmRlbGV0ZShkZXRhaWxzWydzd1Njb3BlJ10pO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5yZXN1bHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoZXJyb3JzXzEuZGVmYXVsdC5jb2Rlcy5GQUlMRURfVE9fREVMRVRFX1RPS0VOKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUb2tlbk1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5NYW5hZ2VyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbi1tYW5hZ2VyLmpzLm1hcFxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIFRoZXNlIGZpZWxkcyBhcmUgc3RyaW5ncyB0byBwcmV2ZW50IGNsb3N1cmUgZnJvbSB0aGlua2luZyBnb29nLmdldE1zZ1xuLy8gc2hvdWxkIGJlIHVzZWQgdG8gaW5pdGlhbGlzZSB0aGUgdmFsdWVzXG52YXIgUEFSQU1TID0ge1xuICAgIFRZUEVfT0ZfTVNHOiAnZmlyZWJhc2UtbWVzc2FnaW5nLW1zZy10eXBlJyxcbiAgICBEQVRBOiAnZmlyZWJhc2UtbWVzc2FnaW5nLW1zZy1kYXRhJ1xufTtcbi8vIFRoaXMgdmFsdWUgaXNuJ3QgdXNpbmcgdGhlIFRZUEVfT0ZfTVNHIHNob3J0IGhhbmQgYXMgY2xvc3VyZVxuLy8gZXhwZWN0cyB0aGUgdmFyaWFibGUgdG8gYmUgZGVmaW5lZCB2aWEgZ29vZy5nZXRNc2dcbnZhciBtc2dUeXBlID0ge1xuICAgIFBVU0hfTVNHX1JFQ0VJVkVEOiAncHVzaC1tc2ctcmVjZWl2ZWQnLFxuICAgIE5PVElGSUNBVElPTl9DTElDS0VEOiAnbm90aWZpY2F0aW9uLWNsaWNrZWQnXG59O1xudmFyIGNyZWF0ZU5ld01zZyA9IGZ1bmN0aW9uIChtc2dUeXBlLCBtc2dEYXRhKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAoX2EgPSB7fSxcbiAgICAgICAgX2FbUEFSQU1TLlRZUEVfT0ZfTVNHXSA9IG1zZ1R5cGUsXG4gICAgICAgIF9hW1BBUkFNUy5EQVRBXSA9IG1zZ0RhdGEsXG4gICAgICAgIF9hKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB2YXIgX2E7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIFBBUkFNUzogUEFSQU1TLFxuICAgIFRZUEVTX09GX01TRzogbXNnVHlwZSxcbiAgICBjcmVhdGVOZXdNc2c6IGNyZWF0ZU5ld01zZ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyLXBhZ2UtbWVzc2FnZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnJlcXVpcmUoXCIuL3NyYy9wb2x5ZmlsbHMvcHJvbWlzZVwiKTtcbnJlcXVpcmUoXCIuL3NyYy9zaGltcy9maW5kXCIpO1xucmVxdWlyZShcIi4vc3JjL3NoaW1zL2ZpbmRJbmRleFwiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZ2xvYmFsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59KSgpO1xuLy8gUG9seWZpbGwgUHJvbWlzZVxuaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEhBQ0s6IFRTIHRocm93cyBhbiBlcnJvciBpZiBJIGF0dGVtcHQgdG8gdXNlICdkb3Qtbm90YXRpb24nXG4gICAgX19nbG9iYWxbJ1Byb21pc2UnXSA9IFByb21pc2UgPSByZXF1aXJlKCdwcm9taXNlLXBvbHlmaWxsJyk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2UuanMubWFwXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBBcnJheS5wcm90b3R5cGUuZmluZCBwb2x5ZmlsbCBmcm9tIE1ETlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZFxuICogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAqL1xuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdmaW5kJywge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgLy8gMS4gTGV0IE8gYmUgPyBUb09iamVjdCh0aGlzIHZhbHVlKS5cbiAgICAgICAgICAgIGlmICh0aGlzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbyA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIC8vIDIuIExldCBsZW4gYmUgPyBUb0xlbmd0aCg/IEdldChPLCBcImxlbmd0aFwiKSkuXG4gICAgICAgICAgICB2YXIgbGVuID0gby5sZW5ndGggPj4+IDA7XG4gICAgICAgICAgICAvLyAzLiBJZiBJc0NhbGxhYmxlKHByZWRpY2F0ZSkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNC4gSWYgdGhpc0FyZyB3YXMgc3VwcGxpZWQsIGxldCBUIGJlIHRoaXNBcmc7IGVsc2UgbGV0IFQgYmUgdW5kZWZpbmVkLlxuICAgICAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAvLyA1LiBMZXQgayBiZSAwLlxuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgLy8gNi4gUmVwZWF0LCB3aGlsZSBrIDwgbGVuXG4gICAgICAgICAgICB3aGlsZSAoayA8IGxlbikge1xuICAgICAgICAgICAgICAgIC8vIGEuIExldCBQayBiZSAhIFRvU3RyaW5nKGspLlxuICAgICAgICAgICAgICAgIC8vIGIuIExldCBrVmFsdWUgYmUgPyBHZXQoTywgUGspLlxuICAgICAgICAgICAgICAgIC8vIGMuIExldCB0ZXN0UmVzdWx0IGJlIFRvQm9vbGVhbig/IENhbGwocHJlZGljYXRlLCBULCDCqyBrVmFsdWUsIGssIE8gwrspKS5cbiAgICAgICAgICAgICAgICAvLyBkLiBJZiB0ZXN0UmVzdWx0IGlzIHRydWUsIHJldHVybiBrVmFsdWUuXG4gICAgICAgICAgICAgICAgdmFyIGtWYWx1ZSA9IG9ba107XG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIGtWYWx1ZSwgaywgbykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZS4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDcuIFJldHVybiB1bmRlZmluZWQuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmQuanMubWFwXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4IHBvbHlmaWxsIGZyb20gTUROXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maW5kSW5kZXhcbiAqIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAqL1xuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbmRJbmRleCcsIHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIC8vIDEuIExldCBPIGJlID8gVG9PYmplY3QodGhpcyB2YWx1ZSkuXG4gICAgICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ0aGlzXCIgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG8gPSBPYmplY3QodGhpcyk7XG4gICAgICAgICAgICAvLyAyLiBMZXQgbGVuIGJlID8gVG9MZW5ndGgoPyBHZXQoTywgXCJsZW5ndGhcIikpLlxuICAgICAgICAgICAgdmFyIGxlbiA9IG8ubGVuZ3RoID4+PiAwO1xuICAgICAgICAgICAgLy8gMy4gSWYgSXNDYWxsYWJsZShwcmVkaWNhdGUpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDQuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgLy8gNS4gTGV0IGsgYmUgMC5cbiAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgIC8vIDYuIFJlcGVhdCwgd2hpbGUgayA8IGxlblxuICAgICAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBhLiBMZXQgUGsgYmUgISBUb1N0cmluZyhrKS5cbiAgICAgICAgICAgICAgICAvLyBiLiBMZXQga1ZhbHVlIGJlID8gR2V0KE8sIFBrKS5cbiAgICAgICAgICAgICAgICAvLyBjLiBMZXQgdGVzdFJlc3VsdCBiZSBUb0Jvb2xlYW4oPyBDYWxsKHByZWRpY2F0ZSwgVCwgwqsga1ZhbHVlLCBrLCBPIMK7KSkuXG4gICAgICAgICAgICAgICAgLy8gZC4gSWYgdGVzdFJlc3VsdCBpcyB0cnVlLCByZXR1cm4gay5cbiAgICAgICAgICAgICAgICB2YXIga1ZhbHVlID0gb1trXTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywga1ZhbHVlLCBrLCBvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZS4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDcuIFJldHVybiAtMS5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5kSW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXBwXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL2FwcFwiKTtcbnZhciBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3NyYy9pbXBsZW1lbnRhdGlvbi9zdHJpbmdcIik7XG52YXIgdGFza2VudW1zXzEgPSByZXF1aXJlKFwiLi9zcmMvaW1wbGVtZW50YXRpb24vdGFza2VudW1zXCIpO1xudmFyIHRhc2tlbnVtc18yID0gcmVxdWlyZShcIi4vc3JjL2ltcGxlbWVudGF0aW9uL3Rhc2tlbnVtc1wiKTtcbnZhciB4aHJpb3Bvb2xfMSA9IHJlcXVpcmUoXCIuL3NyYy9pbXBsZW1lbnRhdGlvbi94aHJpb3Bvb2xcIik7XG52YXIgcmVmZXJlbmNlXzEgPSByZXF1aXJlKFwiLi9zcmMvcmVmZXJlbmNlXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NyYy9zZXJ2aWNlXCIpO1xuLyoqXG4gKiBUeXBlIGNvbnN0YW50IGZvciBGaXJlYmFzZSBTdG9yYWdlLlxuICovXG52YXIgU1RPUkFHRV9UWVBFID0gJ3N0b3JhZ2UnO1xuZnVuY3Rpb24gZmFjdG9yeShhcHAsIHVudXNlZCwgb3B0X3VybCkge1xuICAgIHJldHVybiBuZXcgc2VydmljZV8xLlNlcnZpY2UoYXBwLCBuZXcgeGhyaW9wb29sXzEuWGhySW9Qb29sKCksIG9wdF91cmwpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJTdG9yYWdlKGluc3RhbmNlKSB7XG4gICAgdmFyIG5hbWVzcGFjZUV4cG9ydHMgPSB7XG4gICAgICAgIC8vIG5vLWlubGluZVxuICAgICAgICBUYXNrU3RhdGU6IHRhc2tlbnVtc18yLlRhc2tTdGF0ZSxcbiAgICAgICAgVGFza0V2ZW50OiB0YXNrZW51bXNfMS5UYXNrRXZlbnQsXG4gICAgICAgIFN0cmluZ0Zvcm1hdDogc3RyaW5nXzEuU3RyaW5nRm9ybWF0LFxuICAgICAgICBTdG9yYWdlOiBzZXJ2aWNlXzEuU2VydmljZSxcbiAgICAgICAgUmVmZXJlbmNlOiByZWZlcmVuY2VfMS5SZWZlcmVuY2VcbiAgICB9O1xuICAgIGluc3RhbmNlLklOVEVSTkFMLnJlZ2lzdGVyU2VydmljZShTVE9SQUdFX1RZUEUsIGZhY3RvcnksIG5hbWVzcGFjZUV4cG9ydHMsIHVuZGVmaW5lZCwgXG4gICAgLy8gQWxsb3cgbXVsdGlwbGUgc3RvcmFnZSBpbnN0YW5jZXMgcGVyIGFwcC5cbiAgICB0cnVlKTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJTdG9yYWdlID0gcmVnaXN0ZXJTdG9yYWdlO1xucmVnaXN0ZXJTdG9yYWdlKGFwcF8xLmRlZmF1bHQpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBlcnJvcnNFeHBvcnRzID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG52YXIgTWV0YWRhdGFVdGlscyA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xudmFyIHR5cGUgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xuLyoqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSBzcGVjcyBBcmd1bWVudCBzcGVjcy5cbiAqIEBwYXJhbSBwYXNzZWQgVGhlIGFjdHVhbCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cbiAqIEB0aHJvd3Mge2Zicy5FcnJvcn0gSWYgdGhlIGFyZ3VtZW50cyBhcmUgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUobmFtZSwgc3BlY3MsIHBhc3NlZCkge1xuICAgIHZhciBtaW5BcmdzID0gc3BlY3MubGVuZ3RoO1xuICAgIHZhciBtYXhBcmdzID0gc3BlY3MubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNwZWNzW2ldLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBtaW5BcmdzID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB2YWxpZExlbmd0aCA9IG1pbkFyZ3MgPD0gcGFzc2VkLmxlbmd0aCAmJiBwYXNzZWQubGVuZ3RoIDw9IG1heEFyZ3M7XG4gICAgaWYgKCF2YWxpZExlbmd0aCkge1xuICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmludmFsaWRBcmd1bWVudENvdW50KG1pbkFyZ3MsIG1heEFyZ3MsIG5hbWUsIHBhc3NlZC5sZW5ndGgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhc3NlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3BlY3NbaV0udmFsaWRhdG9yKHBhc3NlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmludmFsaWRBcmd1bWVudChpLCBuYW1lLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzRXhwb3J0cy5pbnZhbGlkQXJndW1lbnQoaSwgbmFtZSwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vKipcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIEFyZ1NwZWMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJnU3BlYyh2YWxpZGF0b3IsIG9wdF9vcHRpb25hbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbmFsICYmICF0eXBlLmlzSnVzdERlZihwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRvcihwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9ICEhb3B0X29wdGlvbmFsO1xuICAgIH1cbiAgICByZXR1cm4gQXJnU3BlYztcbn0oKSk7XG5leHBvcnRzLkFyZ1NwZWMgPSBBcmdTcGVjO1xuZnVuY3Rpb24gYW5kXyh2MSwgdjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdjEocCk7XG4gICAgICAgIHYyKHApO1xuICAgIH07XG59XG5leHBvcnRzLmFuZF8gPSBhbmRfO1xuZnVuY3Rpb24gc3RyaW5nU3BlYyhvcHRfdmFsaWRhdG9yLCBvcHRfb3B0aW9uYWwpIHtcbiAgICBmdW5jdGlvbiBzdHJpbmdWYWxpZGF0b3IocCkge1xuICAgICAgICBpZiAoIXR5cGUuaXNTdHJpbmcocCkpIHtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBzdHJpbmcuJztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgdmFsaWRhdG9yO1xuICAgIGlmIChvcHRfdmFsaWRhdG9yKSB7XG4gICAgICAgIHZhbGlkYXRvciA9IGFuZF8oc3RyaW5nVmFsaWRhdG9yLCBvcHRfdmFsaWRhdG9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbGlkYXRvciA9IHN0cmluZ1ZhbGlkYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcmdTcGVjKHZhbGlkYXRvciwgb3B0X29wdGlvbmFsKTtcbn1cbmV4cG9ydHMuc3RyaW5nU3BlYyA9IHN0cmluZ1NwZWM7XG5mdW5jdGlvbiB1cGxvYWREYXRhU3BlYygpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0b3IocCkge1xuICAgICAgICB2YXIgdmFsaWQgPSBwIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAgICAgcCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICAodHlwZS5pc05hdGl2ZUJsb2JEZWZpbmVkKCkgJiYgcCBpbnN0YW5jZW9mIEJsb2IpO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgQmxvYiBvciBGaWxlLic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcmdTcGVjKHZhbGlkYXRvcik7XG59XG5leHBvcnRzLnVwbG9hZERhdGFTcGVjID0gdXBsb2FkRGF0YVNwZWM7XG5mdW5jdGlvbiBtZXRhZGF0YVNwZWMob3B0X29wdGlvbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBBcmdTcGVjKE1ldGFkYXRhVXRpbHMubWV0YWRhdGFWYWxpZGF0b3IsIG9wdF9vcHRpb25hbCk7XG59XG5leHBvcnRzLm1ldGFkYXRhU3BlYyA9IG1ldGFkYXRhU3BlYztcbmZ1bmN0aW9uIG5vbk5lZ2F0aXZlTnVtYmVyU3BlYygpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0b3IocCkge1xuICAgICAgICB2YXIgdmFsaWQgPSB0eXBlLmlzTnVtYmVyKHApICYmIHAgPj0gMDtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGEgbnVtYmVyIDAgb3IgZ3JlYXRlci4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJnU3BlYyh2YWxpZGF0b3IpO1xufVxuZXhwb3J0cy5ub25OZWdhdGl2ZU51bWJlclNwZWMgPSBub25OZWdhdGl2ZU51bWJlclNwZWM7XG5mdW5jdGlvbiBsb29zZU9iamVjdFNwZWMob3B0X3ZhbGlkYXRvciwgb3B0X29wdGlvbmFsKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdG9yKHApIHtcbiAgICAgICAgdmFyIGlzTG9vc2VPYmplY3QgPSBwID09PSBudWxsIHx8ICh0eXBlLmlzRGVmKHApICYmIHAgaW5zdGFuY2VvZiBPYmplY3QpO1xuICAgICAgICBpZiAoIWlzTG9vc2VPYmplY3QpIHtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBhbiBPYmplY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0X3ZhbGlkYXRvciAhPT0gdW5kZWZpbmVkICYmIG9wdF92YWxpZGF0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdF92YWxpZGF0b3IocCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcmdTcGVjKHZhbGlkYXRvciwgb3B0X29wdGlvbmFsKTtcbn1cbmV4cG9ydHMubG9vc2VPYmplY3RTcGVjID0gbG9vc2VPYmplY3RTcGVjO1xuZnVuY3Rpb24gbnVsbEZ1bmN0aW9uU3BlYyhvcHRfb3B0aW9uYWwpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0b3IocCkge1xuICAgICAgICB2YXIgdmFsaWQgPSBwID09PSBudWxsIHx8IHR5cGUuaXNGdW5jdGlvbihwKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGEgRnVuY3Rpb24uJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFyZ1NwZWModmFsaWRhdG9yLCBvcHRfb3B0aW9uYWwpO1xufVxuZXhwb3J0cy5udWxsRnVuY3Rpb25TcGVjID0gbnVsbEZ1bmN0aW9uU3BlYztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJncy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgY29udGFpbmVkIGluIHRoZSBhcnJheSAoY29tcGFyZWQgd2l0aCA9PT0pLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIGVsZW0pIHtcbiAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG59XG5leHBvcnRzLmNvbnRhaW5zID0gY29udGFpbnM7XG4vKipcbiAqIFJldHVybnMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5IG9yIGFycmF5LWxpa2Ugb2JqZWN0IChlLmcuIGFyZ3VtZW50cykuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5mdW5jdGlvbiBjbG9uZShhcnJheWxpa2UpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlsaWtlKTtcbn1cbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2l2ZW4gZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBhcnJheSwgaWYgaXQgaXMgY29udGFpbmVkLlxuICogRGlyZWN0bHkgbW9kaWZpZXMgdGhlIHBhc3NlZC1pbiBhcnJheS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZShhcnJheSwgZWxlbSkge1xuICAgIHZhciBpID0gYXJyYXkuaW5kZXhPZihlbGVtKTtcbiAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xuICAgIH1cbn1cbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBNZXRob2QgZm9yIGludm9raW5nIGEgY2FsbGJhY2sgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBwcm9taXNlaW1wbCA9IHJlcXVpcmUoXCIuL3Byb21pc2VfZXh0ZXJuYWxcIik7XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgZiB3aXRoIGl0cyBhcmd1bWVudHMgYXN5bmNocm9ub3VzbHkgYXMgYVxuICogbWljcm90YXNrLCBpLmUuIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgc2NyaXB0IHJldHVybnMgYmFja1xuICogaW50byBicm93c2VyIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGFzeW5jKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJnc1RvRm9yd2FyZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1RvRm9yd2FyZFtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHByb21pc2VpbXBsLnJlc29sdmUodHJ1ZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmLmFwcGx5KG51bGwsIGFyZ3NUb0ZvcndhcmQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5hc3luYyA9IGFzeW5jO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBlcnJvcnNFeHBvcnRzID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG52YXIgZmFpbHJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuL2ZhaWxyZXF1ZXN0XCIpO1xudmFyIGxvY2F0aW9uXzEgPSByZXF1aXJlKFwiLi9sb2NhdGlvblwiKTtcbnZhciBwcm9taXNlaW1wbCA9IHJlcXVpcmUoXCIuL3Byb21pc2VfZXh0ZXJuYWxcIik7XG52YXIgcmVxdWVzdG1hcF8xID0gcmVxdWlyZShcIi4vcmVxdWVzdG1hcFwiKTtcbnZhciB0eXBlID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbi8qKlxuICogQHBhcmFtIGFwcCBJZiBudWxsLCBnZXRBdXRoVG9rZW4gYWx3YXlzIHJlc29sdmVzIHdpdGggbnVsbC5cbiAqIEBwYXJhbSBzZXJ2aWNlIFRoZSBzdG9yYWdlIHNlcnZpY2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYXV0aCB3cmFwcGVyLlxuICogICAgIFVudHlwZWQgdG8gYXZvaWQgY2lyY3VsYXIgdHlwZSBkZXBlbmRlbmNpZXMuXG4gKiBAc3RydWN0XG4gKi9cbnZhciBBdXRoV3JhcHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRoV3JhcHBlcihhcHAsIG1ha2VyLCByZXF1ZXN0TWFrZXIsIHNlcnZpY2UsIHBvb2wpIHtcbiAgICAgICAgdGhpcy5idWNrZXRfID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWxldGVkXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFwcF8gPSBhcHA7XG4gICAgICAgIGlmICh0aGlzLmFwcF8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5hcHBfLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAodHlwZS5pc0RlZihvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVja2V0XyA9IEF1dGhXcmFwcGVyLmV4dHJhY3RCdWNrZXRfKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmFnZVJlZk1ha2VyXyA9IG1ha2VyO1xuICAgICAgICB0aGlzLnJlcXVlc3RNYWtlcl8gPSByZXF1ZXN0TWFrZXI7XG4gICAgICAgIHRoaXMucG9vbF8gPSBwb29sO1xuICAgICAgICB0aGlzLnNlcnZpY2VfID0gc2VydmljZTtcbiAgICAgICAgdGhpcy5tYXhPcGVyYXRpb25SZXRyeVRpbWVfID0gY29uc3RhbnRzLmRlZmF1bHRNYXhPcGVyYXRpb25SZXRyeVRpbWU7XG4gICAgICAgIHRoaXMubWF4VXBsb2FkUmV0cnlUaW1lXyA9IGNvbnN0YW50cy5kZWZhdWx0TWF4VXBsb2FkUmV0cnlUaW1lO1xuICAgICAgICB0aGlzLnJlcXVlc3RNYXBfID0gbmV3IHJlcXVlc3RtYXBfMS5SZXF1ZXN0TWFwKCk7XG4gICAgfVxuICAgIEF1dGhXcmFwcGVyLmV4dHJhY3RCdWNrZXRfID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgYnVja2V0U3RyaW5nID0gY29uZmlnW2NvbnN0YW50cy5jb25maWdPcHRpb25dIHx8IG51bGw7XG4gICAgICAgIGlmIChidWNrZXRTdHJpbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvYyA9IGxvY2F0aW9uXzEuTG9jYXRpb24ubWFrZUZyb21CdWNrZXRTcGVjKGJ1Y2tldFN0cmluZyk7XG4gICAgICAgIHJldHVybiBsb2MuYnVja2V0O1xuICAgIH07XG4gICAgQXV0aFdyYXBwZXIucHJvdG90eXBlLmdldEF1dGhUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IHJlbW92ZSBpZkRlZiBjaGVja3MgYWZ0ZXIgZmlyZWJhc2UtYXBwIGltcGxlbWVudHMgc3R1YnNcbiAgICAgICAgLy8gKGIvMjg2NzM4MTgpLlxuICAgICAgICBpZiAodGhpcy5hcHBfICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlLmlzRGVmKHRoaXMuYXBwXy5JTlRFUk5BTCkgJiZcbiAgICAgICAgICAgIHR5cGUuaXNEZWYodGhpcy5hcHBfLklOVEVSTkFMLmdldFRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwXy5JTlRFUk5BTC5nZXRUb2tlbigpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VpbXBsLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dGhXcmFwcGVyLnByb3RvdHlwZS5idWNrZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGV0ZWRfKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmFwcERlbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldF87XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2aWNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGF1dGggd3JhcHBlci4gVW50eXBlZCB0byBhdm9pZCBjaXJjdWxhclxuICAgICAqIHR5cGUgZGVwZW5kZW5jaWVzLlxuICAgICAqL1xuICAgIEF1dGhXcmFwcGVyLnByb3RvdHlwZS5zZXJ2aWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgZmlyZWJhc2VTdG9yYWdlLlJlZmVyZW5jZSBvYmplY3QgcmVmZXJlbmNpbmcgdGhpcyBBdXRoV3JhcHBlclxuICAgICAqIGF0IHRoZSBnaXZlbiBMb2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gbG9jIFRoZSBMb2NhdGlvbi5cbiAgICAgKiBAcmV0dXJuIEFjdHVhbGx5IGEgZmlyZWJhc2VTdG9yYWdlLlJlZmVyZW5jZSwgdHlwaW5nIG5vdCBhbGxvd2VkXG4gICAgICogICAgIGJlY2F1c2Ugb2YgY2lyY3VsYXIgZGVwZW5kZW5jeSBwcm9ibGVtcy5cbiAgICAgKi9cbiAgICBBdXRoV3JhcHBlci5wcm90b3R5cGUubWFrZVN0b3JhZ2VSZWZlcmVuY2UgPSBmdW5jdGlvbiAobG9jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VSZWZNYWtlcl8odGhpcywgbG9jKTtcbiAgICB9O1xuICAgIEF1dGhXcmFwcGVyLnByb3RvdHlwZS5tYWtlUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0SW5mbywgYXV0aFRva2VuKSB7XG4gICAgICAgIGlmICghdGhpcy5kZWxldGVkXykge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RNYWtlcl8ocmVxdWVzdEluZm8sIGF1dGhUb2tlbiwgdGhpcy5wb29sXyk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNYXBfLmFkZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZmFpbHJlcXVlc3RfMS5GYWlsUmVxdWVzdChlcnJvcnNFeHBvcnRzLmFwcERlbGV0ZWQoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgcnVubmluZyByZXF1ZXN0cyBhbmQgcHJldmVudCBtb3JlIGZyb20gYmVpbmcgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBBdXRoV3JhcHBlci5wcm90b3R5cGUuZGVsZXRlQXBwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlbGV0ZWRfID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHBfID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWFwXy5jbGVhcigpO1xuICAgIH07XG4gICAgQXV0aFdyYXBwZXIucHJvdG90eXBlLm1heFVwbG9hZFJldHJ5VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4VXBsb2FkUmV0cnlUaW1lXztcbiAgICB9O1xuICAgIEF1dGhXcmFwcGVyLnByb3RvdHlwZS5zZXRNYXhVcGxvYWRSZXRyeVRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICB0aGlzLm1heFVwbG9hZFJldHJ5VGltZV8gPSB0aW1lO1xuICAgIH07XG4gICAgQXV0aFdyYXBwZXIucHJvdG90eXBlLm1heE9wZXJhdGlvblJldHJ5VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4T3BlcmF0aW9uUmV0cnlUaW1lXztcbiAgICB9O1xuICAgIEF1dGhXcmFwcGVyLnByb3RvdHlwZS5zZXRNYXhPcGVyYXRpb25SZXRyeVRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICB0aGlzLm1heE9wZXJhdGlvblJldHJ5VGltZV8gPSB0aW1lO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dGhXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuQXV0aFdyYXBwZXIgPSBBdXRoV3JhcHBlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aHdyYXBwZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBwYXJhbSBmIE1heSBiZSBpbnZva2VkXG4gKiAgICAgYmVmb3JlIHRoZSBmdW5jdGlvbiByZXR1cm5zLlxuICogQHBhcmFtIGNhbGxiYWNrIEdldCBhbGwgdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uXG4gKiAgICAgcGFzc2VkIHRvIGYsIGluY2x1ZGluZyB0aGUgaW5pdGlhbCBib29sZWFuLlxuICovXG5mdW5jdGlvbiBzdGFydChmLCBjYWxsYmFjaywgdGltZW91dCkge1xuICAgIC8vIFRPRE8oYW5keXNvdG8pOiBtYWtlIHRoaXMgY29kZSBjbGVhbmVyIChwcm9iYWJseSByZWZhY3RvciBpbnRvIGFuIGFjdHVhbFxuICAgIC8vIHR5cGUgaW5zdGVhZCBvZiBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyB3aXRoIHN0YXRlIHNoYXJlZCBpbiB0aGUgY2xvc3VyZSlcbiAgICB2YXIgd2FpdFNlY29uZHMgPSAxO1xuICAgIC8vIFdvdWxkIHR5cGUgdGhpcyBhcyBcIm51bWJlclwiIGJ1dCB0aGF0IGRvZXNuJ3Qgd29yayBmb3IgTm9kZSBzbyDCr1xcXyjjg4QpXy/Cr1xuICAgIHZhciB0aW1lb3V0SWQgPSBudWxsO1xuICAgIHZhciBoaXRUaW1lb3V0ID0gZmFsc2U7XG4gICAgdmFyIGNhbmNlbFN0YXRlID0gMDtcbiAgICBmdW5jdGlvbiBjYW5jZWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIGNhbmNlbFN0YXRlID09PSAyO1xuICAgIH1cbiAgICB2YXIgdHJpZ2dlcmVkQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiB0cmlnZ2VyQ2FsbGJhY2soKSB7XG4gICAgICAgIGlmICghdHJpZ2dlcmVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRyaWdnZXJlZENhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbFdpdGhEZWxheShtaWxsaXMpIHtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgZihoYW5kbGVyLCBjYW5jZWxlZCgpKTtcbiAgICAgICAgfSwgbWlsbGlzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlcihzdWNjZXNzKSB7XG4gICAgICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyX2FyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaWdnZXJlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRyaWdnZXJDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtdXN0U3RvcCA9IGNhbmNlbGVkKCkgfHwgaGl0VGltZW91dDtcbiAgICAgICAgaWYgKG11c3RTdG9wKSB7XG4gICAgICAgICAgICB0cmlnZ2VyQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2FpdFNlY29uZHMgPCA2NCkge1xuICAgICAgICAgICAgLyogVE9ETyhhbmR5c290byk6IGRvbid0IGJhY2sgb2ZmIHNvIHF1aWNrbHkgaWYgd2Uga25vdyB3ZSdyZSBvZmZsaW5lLiAqL1xuICAgICAgICAgICAgd2FpdFNlY29uZHMgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2FpdE1pbGxpcztcbiAgICAgICAgaWYgKGNhbmNlbFN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICBjYW5jZWxTdGF0ZSA9IDI7XG4gICAgICAgICAgICB3YWl0TWlsbGlzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhaXRNaWxsaXMgPSAod2FpdFNlY29uZHMgKyBNYXRoLnJhbmRvbSgpKSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFdpdGhEZWxheSh3YWl0TWlsbGlzKTtcbiAgICB9XG4gICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBzdG9wKHdhc1RpbWVvdXQpIHtcbiAgICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRyaWdnZXJlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCF3YXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsU3RhdGUgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBjYWxsV2l0aERlbGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF3YXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsU3RhdGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxXaXRoRGVsYXkoMCk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhpdFRpbWVvdXQgPSB0cnVlO1xuICAgICAgICBzdG9wKHRydWUpO1xuICAgIH0sIHRpbWVvdXQpO1xuICAgIHJldHVybiBzdG9wO1xufVxuZXhwb3J0cy5zdGFydCA9IHN0YXJ0O1xuLyoqXG4gKiBTdG9wcyB0aGUgcmV0cnkgbG9vcCBmcm9tIHJlcGVhdGluZy5cbiAqIElmIHRoZSBmdW5jdGlvbiBpcyBjdXJyZW50bHkgXCJpbiBiZXR3ZWVuXCIgcmV0cmllcywgaXQgaXMgaW52b2tlZCBpbW1lZGlhdGVseVxuICogd2l0aCB0aGUgc2Vjb25kIHBhcmFtZXRlciBhcyBcInRydWVcIi4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGludm9rZWQgb25jZSBtb3JlXG4gKiBhZnRlciB0aGUgY3VycmVudCBpbnZvY2F0aW9uIGZpbmlzaGVzIGlmZiB0aGUgY3VycmVudCBpbnZvY2F0aW9uIHdvdWxkIGhhdmVcbiAqIHRyaWdnZXJlZCBhbm90aGVyIHJldHJ5LlxuICovXG5mdW5jdGlvbiBzdG9wKGlkKSB7XG4gICAgaWQoZmFsc2UpO1xufVxuZXhwb3J0cy5zdG9wID0gc3RvcDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja29mZi5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGUgUHJvdmlkZXMgYSBCbG9iLWxpa2Ugd3JhcHBlciBmb3IgdmFyaW91cyBiaW5hcnkgdHlwZXMgKGluY2x1ZGluZyB0aGVcbiAqIG5hdGl2ZSBCbG9iIHR5cGUpLiBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlIHRvIHVwbG9hZCB0eXBlcyBsaWtlIEFycmF5QnVmZmVycyxcbiAqIG1ha2luZyB1cGxvYWRzIHBvc3NpYmxlIGluIGVudmlyb25tZW50cyB3aXRob3V0IHRoZSBuYXRpdmUgQmxvYiB0eXBlLlxuICovXG52YXIgZnMgPSByZXF1aXJlKFwiLi9mc1wiKTtcbnZhciBzdHJpbmcgPSByZXF1aXJlKFwiLi9zdHJpbmdcIik7XG52YXIgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdcIik7XG52YXIgdHlwZSA9IHJlcXVpcmUoXCIuL3R5cGVcIik7XG4vKipcbiAqIEBwYXJhbSBvcHRfZWxpZGVDb3B5IElmIHRydWUsIGRvZXNuJ3QgY29weSBtdXRhYmxlIGlucHV0IGRhdGFcbiAqICAgICAoZS5nLiBVaW50OEFycmF5cykuIFBhc3MgdHJ1ZSBvbmx5IGlmIHlvdSBrbm93IHRoZSBvYmplY3RzIHdpbGwgbm90IGJlXG4gKiAgICAgbW9kaWZpZWQgYWZ0ZXIgdGhpcyBibG9iJ3MgY29uc3RydWN0aW9uLlxuICovXG52YXIgRmJzQmxvYiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGYnNCbG9iKGRhdGEsIG9wdF9lbGlkZUNvcHkpIHtcbiAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICB2YXIgYmxvYlR5cGUgPSAnJztcbiAgICAgICAgaWYgKHR5cGUuaXNOYXRpdmVCbG9iKGRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgICAgICBibG9iVHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChvcHRfZWxpZGVDb3B5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXy5zZXQobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuZGF0YV8ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBpZiAob3B0X2VsaWRlQ29weSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFfLnNldChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemVfID0gc2l6ZTtcbiAgICAgICAgdGhpcy50eXBlXyA9IGJsb2JUeXBlO1xuICAgIH1cbiAgICBGYnNCbG9iLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgICB9O1xuICAgIEZic0Jsb2IucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVfO1xuICAgIH07XG4gICAgRmJzQmxvYi5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnRCeXRlLCBlbmRCeXRlKSB7XG4gICAgICAgIGlmICh0eXBlLmlzTmF0aXZlQmxvYih0aGlzLmRhdGFfKSkge1xuICAgICAgICAgICAgdmFyIHJlYWxCbG9iID0gdGhpcy5kYXRhXztcbiAgICAgICAgICAgIHZhciBzbGljZWQgPSBmcy5zbGljZUJsb2IocmVhbEJsb2IsIHN0YXJ0Qnl0ZSwgZW5kQnl0ZSk7XG4gICAgICAgICAgICBpZiAoc2xpY2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2Ioc2xpY2VkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzbGljZSA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YV8uYnVmZmVyLCBzdGFydEJ5dGUsIGVuZEJ5dGUgLSBzdGFydEJ5dGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYnNCbG9iKHNsaWNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmJzQmxvYi5nZXRCbG9iID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFyX2FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhcl9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUuaXNOYXRpdmVCbG9iRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB2YXIgYmxvYmJ5ID0gdmFyX2FyZ3MubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRmJzQmxvYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmRhdGFfO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmJzQmxvYihmcy5nZXRCbG9iLmFwcGx5KG51bGwsIGJsb2JieSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVpbnQ4QXJyYXlzID0gdmFyX2FyZ3MubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5pc1N0cmluZyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuZGF0YUZyb21TdHJpbmcoc3RyaW5nXzEuU3RyaW5nRm9ybWF0LlJBVywgdmFsKS5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmxvYnMgZG9uJ3QgZXhpc3QsIHNvIHRoaXMgaGFzIHRvIGJlIGEgVWludDhBcnJheS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5kYXRhXztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBmaW5hbExlbmd0aF8xID0gMDtcbiAgICAgICAgICAgIHVpbnQ4QXJyYXlzLmZvckVhY2goZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgZmluYWxMZW5ndGhfMSArPSBhcnJheS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkXzEgPSBuZXcgVWludDhBcnJheShmaW5hbExlbmd0aF8xKTtcbiAgICAgICAgICAgIHZhciBpbmRleF8xID0gMDtcbiAgICAgICAgICAgIHVpbnQ4QXJyYXlzLmZvckVhY2goZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRfMVtpbmRleF8xKytdID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2IobWVyZ2VkXzEsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGYnNCbG9iLnByb3RvdHlwZS51cGxvYWREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhXztcbiAgICB9O1xuICAgIHJldHVybiBGYnNCbG9iO1xufSgpKTtcbmV4cG9ydHMuRmJzQmxvYiA9IEZic0Jsb2I7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2IuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29uc3RhbnRzIHVzZWQgaW4gdGhlIEZpcmViYXNlIFN0b3JhZ2UgbGlicmFyeS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBEb21haW4gYW5kIHNjaGVtZSBmb3IgQVBJIGNhbGxzLlxuICovXG5leHBvcnRzLmRvbWFpbkJhc2UgPSAnaHR0cHM6Ly9maXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20nO1xuLyoqXG4gKiBEb21haW4gYW5kIHNjaGVtZSBmb3Igb2JqZWN0IGRvd25sb2Fkcy5cbiAqL1xuZXhwb3J0cy5kb3dubG9hZEJhc2UgPSAnaHR0cHM6Ly9maXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20nO1xuLyoqXG4gKiBCYXNlIFVSTCBmb3Igbm9uLXVwbG9hZCBjYWxscyB0byB0aGUgQVBJLlxuICovXG5leHBvcnRzLmFwaUJhc2VVcmwgPSAnL3YwJztcbi8qKlxuICogQmFzZSBVUkwgZm9yIHVwbG9hZCBjYWxscyB0byB0aGUgQVBJLlxuICovXG5leHBvcnRzLmFwaVVwbG9hZEJhc2VVcmwgPSAnL3YwJztcbmZ1bmN0aW9uIHNldERvbWFpbkJhc2UoZG9tYWluQmFzZSkge1xuICAgIGRvbWFpbkJhc2UgPSBkb21haW5CYXNlO1xufVxuZXhwb3J0cy5zZXREb21haW5CYXNlID0gc2V0RG9tYWluQmFzZTtcbmV4cG9ydHMuY29uZmlnT3B0aW9uID0gJ3N0b3JhZ2VCdWNrZXQnO1xuLyoqXG4gKiAxIG1pbnV0ZVxuICovXG5leHBvcnRzLnNob3J0TWF4T3BlcmF0aW9uUmV0cnlUaW1lID0gMSAqIDYwICogMTAwMDtcbi8qKlxuICogMiBtaW51dGVzXG4gKi9cbmV4cG9ydHMuZGVmYXVsdE1heE9wZXJhdGlvblJldHJ5VGltZSA9IDIgKiA2MCAqIDEwMDA7XG4vKipcbiAqIDEwIG1pbnV0ZXNcbiAqL1xuZXhwb3J0cy5kZWZhdWx0TWF4VXBsb2FkUmV0cnlUaW1lID0gMTAgKiA2MCAqIDEwMDtcbi8qKlxuICogVGhpcyBpcyB0aGUgdmFsdWUgb2YgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsIHdoaWNoIGlzIG5vdCB3ZWxsIHN1cHBvcnRlZFxuICogZW5vdWdoIGZvciB1cyB0byB1c2UgaXQgZGlyZWN0bHkuXG4gKi9cbmV4cG9ydHMubWluU2FmZUludGVnZXIgPSAtOTAwNzE5OTI1NDc0MDk5MTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIEZpcmViYXNlU3RvcmFnZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpcmViYXNlU3RvcmFnZUVycm9yKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5jb2RlXyA9IHByZXBlbmRDb2RlKGNvZGUpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VfID0gJ0ZpcmViYXNlIFN0b3JhZ2U6ICcgKyBtZXNzYWdlO1xuICAgICAgICB0aGlzLnNlcnZlclJlc3BvbnNlXyA9IG51bGw7XG4gICAgICAgIHRoaXMubmFtZV8gPSAnRmlyZWJhc2VFcnJvcic7XG4gICAgfVxuICAgIEZpcmViYXNlU3RvcmFnZUVycm9yLnByb3RvdHlwZS5jb2RlUHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZTtcbiAgICB9O1xuICAgIEZpcmViYXNlU3RvcmFnZUVycm9yLnByb3RvdHlwZS5jb2RlRXF1YWxzID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHByZXBlbmRDb2RlKGNvZGUpID09PSB0aGlzLmNvZGVQcm9wKCk7XG4gICAgfTtcbiAgICBGaXJlYmFzZVN0b3JhZ2VFcnJvci5wcm90b3R5cGUuc2VydmVyUmVzcG9uc2VQcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJSZXNwb25zZV87XG4gICAgfTtcbiAgICBGaXJlYmFzZVN0b3JhZ2VFcnJvci5wcm90b3R5cGUuc2V0U2VydmVyUmVzcG9uc2VQcm9wID0gZnVuY3Rpb24gKHNlcnZlclJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuc2VydmVyUmVzcG9uc2VfID0gc2VydmVyUmVzcG9uc2U7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmlyZWJhc2VTdG9yYWdlRXJyb3IucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmlyZWJhc2VTdG9yYWdlRXJyb3IucHJvdG90eXBlLCBcImNvZGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGVfO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmlyZWJhc2VTdG9yYWdlRXJyb3IucHJvdG90eXBlLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VfO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmlyZWJhc2VTdG9yYWdlRXJyb3IucHJvdG90eXBlLCBcInNlcnZlclJlc3BvbnNlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJSZXNwb25zZV87XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBGaXJlYmFzZVN0b3JhZ2VFcnJvcjtcbn0oKSk7XG5leHBvcnRzLkZpcmViYXNlU3RvcmFnZUVycm9yID0gRmlyZWJhc2VTdG9yYWdlRXJyb3I7XG5leHBvcnRzLmVycm9ycyA9IHt9O1xuZXhwb3J0cy5Db2RlID0ge1xuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIGFsbCBwbGF0Zm9ybXNcbiAgICBVTktOT1dOOiAndW5rbm93bicsXG4gICAgT0JKRUNUX05PVF9GT1VORDogJ29iamVjdC1ub3QtZm91bmQnLFxuICAgIEJVQ0tFVF9OT1RfRk9VTkQ6ICdidWNrZXQtbm90LWZvdW5kJyxcbiAgICBQUk9KRUNUX05PVF9GT1VORDogJ3Byb2plY3Qtbm90LWZvdW5kJyxcbiAgICBRVU9UQV9FWENFRURFRDogJ3F1b3RhLWV4Y2VlZGVkJyxcbiAgICBVTkFVVEhFTlRJQ0FURUQ6ICd1bmF1dGhlbnRpY2F0ZWQnLFxuICAgIFVOQVVUSE9SSVpFRDogJ3VuYXV0aG9yaXplZCcsXG4gICAgUkVUUllfTElNSVRfRVhDRUVERUQ6ICdyZXRyeS1saW1pdC1leGNlZWRlZCcsXG4gICAgSU5WQUxJRF9DSEVDS1NVTTogJ2ludmFsaWQtY2hlY2tzdW0nLFxuICAgIENBTkNFTEVEOiAnY2FuY2VsZWQnLFxuICAgIC8vIEpTIHNwZWNpZmljXG4gICAgSU5WQUxJRF9FVkVOVF9OQU1FOiAnaW52YWxpZC1ldmVudC1uYW1lJyxcbiAgICBJTlZBTElEX1VSTDogJ2ludmFsaWQtdXJsJyxcbiAgICBJTlZBTElEX0RFRkFVTFRfQlVDS0VUOiAnaW52YWxpZC1kZWZhdWx0LWJ1Y2tldCcsXG4gICAgTk9fREVGQVVMVF9CVUNLRVQ6ICduby1kZWZhdWx0LWJ1Y2tldCcsXG4gICAgQ0FOTk9UX1NMSUNFX0JMT0I6ICdjYW5ub3Qtc2xpY2UtYmxvYicsXG4gICAgU0VSVkVSX0ZJTEVfV1JPTkdfU0laRTogJ3NlcnZlci1maWxlLXdyb25nLXNpemUnLFxuICAgIE5PX0RPV05MT0FEX1VSTDogJ25vLWRvd25sb2FkLXVybCcsXG4gICAgSU5WQUxJRF9BUkdVTUVOVDogJ2ludmFsaWQtYXJndW1lbnQnLFxuICAgIElOVkFMSURfQVJHVU1FTlRfQ09VTlQ6ICdpbnZhbGlkLWFyZ3VtZW50LWNvdW50JyxcbiAgICBBUFBfREVMRVRFRDogJ2FwcC1kZWxldGVkJyxcbiAgICBJTlZBTElEX1JPT1RfT1BFUkFUSU9OOiAnaW52YWxpZC1yb290LW9wZXJhdGlvbicsXG4gICAgSU5WQUxJRF9GT1JNQVQ6ICdpbnZhbGlkLWZvcm1hdCcsXG4gICAgSU5URVJOQUxfRVJST1I6ICdpbnRlcm5hbC1lcnJvcidcbn07XG5mdW5jdGlvbiBwcmVwZW5kQ29kZShjb2RlKSB7XG4gICAgcmV0dXJuICdzdG9yYWdlLycgKyBjb2RlO1xufVxuZXhwb3J0cy5wcmVwZW5kQ29kZSA9IHByZXBlbmRDb2RlO1xuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkLCBwbGVhc2UgY2hlY2sgdGhlIGVycm9yIHBheWxvYWQgZm9yICcgK1xuICAgICAgICAnc2VydmVyIHJlc3BvbnNlLic7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihleHBvcnRzLkNvZGUuVU5LTk9XTiwgbWVzc2FnZSk7XG59XG5leHBvcnRzLnVua25vd24gPSB1bmtub3duO1xuZnVuY3Rpb24gb2JqZWN0Tm90Rm91bmQocGF0aCkge1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoZXhwb3J0cy5Db2RlLk9CSkVDVF9OT1RfRk9VTkQsIFwiT2JqZWN0ICdcIiArIHBhdGggKyBcIicgZG9lcyBub3QgZXhpc3QuXCIpO1xufVxuZXhwb3J0cy5vYmplY3ROb3RGb3VuZCA9IG9iamVjdE5vdEZvdW5kO1xuZnVuY3Rpb24gYnVja2V0Tm90Rm91bmQoYnVja2V0KSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihleHBvcnRzLkNvZGUuQlVDS0VUX05PVF9GT1VORCwgXCJCdWNrZXQgJ1wiICsgYnVja2V0ICsgXCInIGRvZXMgbm90IGV4aXN0LlwiKTtcbn1cbmV4cG9ydHMuYnVja2V0Tm90Rm91bmQgPSBidWNrZXROb3RGb3VuZDtcbmZ1bmN0aW9uIHByb2plY3ROb3RGb3VuZChwcm9qZWN0KSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihleHBvcnRzLkNvZGUuUFJPSkVDVF9OT1RfRk9VTkQsIFwiUHJvamVjdCAnXCIgKyBwcm9qZWN0ICsgXCInIGRvZXMgbm90IGV4aXN0LlwiKTtcbn1cbmV4cG9ydHMucHJvamVjdE5vdEZvdW5kID0gcHJvamVjdE5vdEZvdW5kO1xuZnVuY3Rpb24gcXVvdGFFeGNlZWRlZChidWNrZXQpIHtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKGV4cG9ydHMuQ29kZS5RVU9UQV9FWENFRURFRCwgXCJRdW90YSBmb3IgYnVja2V0ICdcIiArXG4gICAgICAgIGJ1Y2tldCArXG4gICAgICAgIFwiJyBleGNlZWRlZCwgcGxlYXNlIHZpZXcgcXVvdGEgb24gXCIgK1xuICAgICAgICAnaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL3ByaWNpbmcvLicpO1xufVxuZXhwb3J0cy5xdW90YUV4Y2VlZGVkID0gcXVvdGFFeGNlZWRlZDtcbmZ1bmN0aW9uIHVuYXV0aGVudGljYXRlZCgpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdVc2VyIGlzIG5vdCBhdXRoZW50aWNhdGVkLCBwbGVhc2UgYXV0aGVudGljYXRlIHVzaW5nIEZpcmViYXNlICcgK1xuICAgICAgICAnQXV0aGVudGljYXRpb24gYW5kIHRyeSBhZ2Fpbi4nO1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoZXhwb3J0cy5Db2RlLlVOQVVUSEVOVElDQVRFRCwgbWVzc2FnZSk7XG59XG5leHBvcnRzLnVuYXV0aGVudGljYXRlZCA9IHVuYXV0aGVudGljYXRlZDtcbmZ1bmN0aW9uIHVuYXV0aG9yaXplZChwYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihleHBvcnRzLkNvZGUuVU5BVVRIT1JJWkVELCBcIlVzZXIgZG9lcyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyAnXCIgKyBwYXRoICsgXCInLlwiKTtcbn1cbmV4cG9ydHMudW5hdXRob3JpemVkID0gdW5hdXRob3JpemVkO1xuZnVuY3Rpb24gcmV0cnlMaW1pdEV4Y2VlZGVkKCkge1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoZXhwb3J0cy5Db2RlLlJFVFJZX0xJTUlUX0VYQ0VFREVELCAnTWF4IHJldHJ5IHRpbWUgZm9yIG9wZXJhdGlvbiBleGNlZWRlZCwgcGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbn1cbmV4cG9ydHMucmV0cnlMaW1pdEV4Y2VlZGVkID0gcmV0cnlMaW1pdEV4Y2VlZGVkO1xuZnVuY3Rpb24gaW52YWxpZENoZWNrc3VtKHBhdGgsIGNoZWNrc3VtLCBjYWxjdWxhdGVkKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihleHBvcnRzLkNvZGUuSU5WQUxJRF9DSEVDS1NVTSwgXCJVcGxvYWRlZC9kb3dubG9hZGVkIG9iamVjdCAnXCIgK1xuICAgICAgICBwYXRoICtcbiAgICAgICAgXCInIGhhcyBjaGVja3N1bSAnXCIgK1xuICAgICAgICBjaGVja3N1bSArXG4gICAgICAgIFwiJyB3aGljaCBkb2VzIG5vdCBtYXRjaCAnXCIgK1xuICAgICAgICBjYWxjdWxhdGVkICtcbiAgICAgICAgXCInLiBQbGVhc2UgcmV0cnkgdGhlIHVwbG9hZC9kb3dubG9hZC5cIik7XG59XG5leHBvcnRzLmludmFsaWRDaGVja3N1bSA9IGludmFsaWRDaGVja3N1bTtcbmZ1bmN0aW9uIGNhbmNlbGVkKCkge1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoZXhwb3J0cy5Db2RlLkNBTkNFTEVELCAnVXNlciBjYW5jZWxlZCB0aGUgdXBsb2FkL2Rvd25sb2FkLicpO1xufVxuZXhwb3J0cy5jYW5jZWxlZCA9IGNhbmNlbGVkO1xuZnVuY3Rpb24gaW52YWxpZEV2ZW50TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihleHBvcnRzLkNvZGUuSU5WQUxJRF9FVkVOVF9OQU1FLCBcIkludmFsaWQgZXZlbnQgbmFtZSAnXCIgKyBuYW1lICsgXCInLlwiKTtcbn1cbmV4cG9ydHMuaW52YWxpZEV2ZW50TmFtZSA9IGludmFsaWRFdmVudE5hbWU7XG5mdW5jdGlvbiBpbnZhbGlkVXJsKHVybCkge1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoZXhwb3J0cy5Db2RlLklOVkFMSURfVVJMLCBcIkludmFsaWQgVVJMICdcIiArIHVybCArIFwiJy5cIik7XG59XG5leHBvcnRzLmludmFsaWRVcmwgPSBpbnZhbGlkVXJsO1xuZnVuY3Rpb24gaW52YWxpZERlZmF1bHRCdWNrZXQoYnVja2V0KSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihleHBvcnRzLkNvZGUuSU5WQUxJRF9ERUZBVUxUX0JVQ0tFVCwgXCJJbnZhbGlkIGRlZmF1bHQgYnVja2V0ICdcIiArIGJ1Y2tldCArIFwiJy5cIik7XG59XG5leHBvcnRzLmludmFsaWREZWZhdWx0QnVja2V0ID0gaW52YWxpZERlZmF1bHRCdWNrZXQ7XG5mdW5jdGlvbiBub0RlZmF1bHRCdWNrZXQoKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihleHBvcnRzLkNvZGUuTk9fREVGQVVMVF9CVUNLRVQsICdObyBkZWZhdWx0IGJ1Y2tldCAnICtcbiAgICAgICAgXCJmb3VuZC4gRGlkIHlvdSBzZXQgdGhlICdcIiArXG4gICAgICAgIGNvbnN0YW50c18xLmNvbmZpZ09wdGlvbiArXG4gICAgICAgIFwiJyBwcm9wZXJ0eSB3aGVuIGluaXRpYWxpemluZyB0aGUgYXBwP1wiKTtcbn1cbmV4cG9ydHMubm9EZWZhdWx0QnVja2V0ID0gbm9EZWZhdWx0QnVja2V0O1xuZnVuY3Rpb24gY2Fubm90U2xpY2VCbG9iKCkge1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoZXhwb3J0cy5Db2RlLkNBTk5PVF9TTElDRV9CTE9CLCAnQ2Fubm90IHNsaWNlIGJsb2IgZm9yIHVwbG9hZC4gUGxlYXNlIHJldHJ5IHRoZSB1cGxvYWQuJyk7XG59XG5leHBvcnRzLmNhbm5vdFNsaWNlQmxvYiA9IGNhbm5vdFNsaWNlQmxvYjtcbmZ1bmN0aW9uIHNlcnZlckZpbGVXcm9uZ1NpemUoKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihleHBvcnRzLkNvZGUuU0VSVkVSX0ZJTEVfV1JPTkdfU0laRSwgJ1NlcnZlciByZWNvcmRlZCBpbmNvcnJlY3QgdXBsb2FkIGZpbGUgc2l6ZSwgcGxlYXNlIHJldHJ5IHRoZSB1cGxvYWQuJyk7XG59XG5leHBvcnRzLnNlcnZlckZpbGVXcm9uZ1NpemUgPSBzZXJ2ZXJGaWxlV3JvbmdTaXplO1xuZnVuY3Rpb24gbm9Eb3dubG9hZFVSTCgpIHtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKGV4cG9ydHMuQ29kZS5OT19ET1dOTE9BRF9VUkwsICdUaGUgZ2l2ZW4gZmlsZSBkb2VzIG5vdCBoYXZlIGFueSBkb3dubG9hZCBVUkxzLicpO1xufVxuZXhwb3J0cy5ub0Rvd25sb2FkVVJMID0gbm9Eb3dubG9hZFVSTDtcbmZ1bmN0aW9uIGludmFsaWRBcmd1bWVudChpbmRleCwgZm5OYW1lLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihleHBvcnRzLkNvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgYXJndW1lbnQgaW4gYCcgKyBmbk5hbWUgKyAnYCBhdCBpbmRleCAnICsgaW5kZXggKyAnOiAnICsgbWVzc2FnZSk7XG59XG5leHBvcnRzLmludmFsaWRBcmd1bWVudCA9IGludmFsaWRBcmd1bWVudDtcbmZ1bmN0aW9uIGludmFsaWRBcmd1bWVudENvdW50KGFyZ01pbiwgYXJnTWF4LCBmbk5hbWUsIHJlYWwpIHtcbiAgICB2YXIgY291bnRQYXJ0O1xuICAgIHZhciBwbHVyYWw7XG4gICAgaWYgKGFyZ01pbiA9PT0gYXJnTWF4KSB7XG4gICAgICAgIGNvdW50UGFydCA9IGFyZ01pbjtcbiAgICAgICAgcGx1cmFsID0gYXJnTWluID09PSAxID8gJ2FyZ3VtZW50JyA6ICdhcmd1bWVudHMnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY291bnRQYXJ0ID0gJ2JldHdlZW4gJyArIGFyZ01pbiArICcgYW5kICcgKyBhcmdNYXg7XG4gICAgICAgIHBsdXJhbCA9ICdhcmd1bWVudHMnO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKGV4cG9ydHMuQ29kZS5JTlZBTElEX0FSR1VNRU5UX0NPVU5ULCAnSW52YWxpZCBhcmd1bWVudCBjb3VudCBpbiBgJyArXG4gICAgICAgIGZuTmFtZSArXG4gICAgICAgICdgOiBFeHBlY3RlZCAnICtcbiAgICAgICAgY291bnRQYXJ0ICtcbiAgICAgICAgJyAnICtcbiAgICAgICAgcGx1cmFsICtcbiAgICAgICAgJywgcmVjZWl2ZWQgJyArXG4gICAgICAgIHJlYWwgK1xuICAgICAgICAnLicpO1xufVxuZXhwb3J0cy5pbnZhbGlkQXJndW1lbnRDb3VudCA9IGludmFsaWRBcmd1bWVudENvdW50O1xuZnVuY3Rpb24gYXBwRGVsZXRlZCgpIHtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKGV4cG9ydHMuQ29kZS5BUFBfREVMRVRFRCwgJ1RoZSBGaXJlYmFzZSBhcHAgd2FzIGRlbGV0ZWQuJyk7XG59XG5leHBvcnRzLmFwcERlbGV0ZWQgPSBhcHBEZWxldGVkO1xuLyoqXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0aW9uIHRoYXQgd2FzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRSb290T3BlcmF0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKGV4cG9ydHMuQ29kZS5JTlZBTElEX1JPT1RfT1BFUkFUSU9OLCBcIlRoZSBvcGVyYXRpb24gJ1wiICtcbiAgICAgICAgbmFtZSArXG4gICAgICAgIFwiJyBjYW5ub3QgYmUgcGVyZm9ybWVkIG9uIGEgcm9vdCByZWZlcmVuY2UsIGNyZWF0ZSBhIG5vbi1yb290IFwiICtcbiAgICAgICAgXCJyZWZlcmVuY2UgdXNpbmcgY2hpbGQsIHN1Y2ggYXMgLmNoaWxkKCdmaWxlLnBuZycpLlwiKTtcbn1cbmV4cG9ydHMuaW52YWxpZFJvb3RPcGVyYXRpb24gPSBpbnZhbGlkUm9vdE9wZXJhdGlvbjtcbi8qKlxuICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IHRoYXQgd2FzIG5vdCB2YWxpZC5cbiAqIEBwYXJhbSBtZXNzYWdlIEEgbWVzc2FnZSBkZXNjcmliaW5nIHRoZSBmb3JtYXQgdmlvbGF0aW9uLlxuICovXG5mdW5jdGlvbiBpbnZhbGlkRm9ybWF0KGZvcm1hdCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoZXhwb3J0cy5Db2RlLklOVkFMSURfRk9STUFULCBcIlN0cmluZyBkb2VzIG5vdCBtYXRjaCBmb3JtYXQgJ1wiICsgZm9ybWF0ICsgXCInOiBcIiArIG1lc3NhZ2UpO1xufVxuZXhwb3J0cy5pbnZhbGlkRm9ybWF0ID0gaW52YWxpZEZvcm1hdDtcbi8qKlxuICogQHBhcmFtIG1lc3NhZ2UgQSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGludGVybmFsIGVycm9yLlxuICovXG5mdW5jdGlvbiBpbnRlcm5hbEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoZXhwb3J0cy5Db2RlLklOVEVSTkFMX0VSUk9SLCAnSW50ZXJuYWwgZXJyb3I6ICcgKyBtZXNzYWdlKTtcbn1cbmV4cG9ydHMuaW50ZXJuYWxFcnJvciA9IGludGVybmFsRXJyb3I7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJvbWlzZWltcGwgPSByZXF1aXJlKFwiLi9wcm9taXNlX2V4dGVybmFsXCIpO1xuLyoqXG4gKiBBIHJlcXVlc3Qgd2hvc2UgcHJvbWlzZSBhbHdheXMgZmFpbHMuXG4gKiBAc3RydWN0XG4gKiBAdGVtcGxhdGUgVFxuICovXG52YXIgRmFpbFJlcXVlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmFpbFJlcXVlc3QoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlXyA9IHByb21pc2VpbXBsLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIEZhaWxSZXF1ZXN0LnByb3RvdHlwZS5nZXRQcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlXztcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIEZhaWxSZXF1ZXN0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYXBwRGVsZXRlKSB7XG4gICAgICAgIGlmIChhcHBEZWxldGUgPT09IHZvaWQgMCkgeyBhcHBEZWxldGUgPSBmYWxzZTsgfVxuICAgIH07XG4gICAgcmV0dXJuIEZhaWxSZXF1ZXN0O1xufSgpKTtcbmV4cG9ydHMuRmFpbFJlcXVlc3QgPSBGYWlsUmVxdWVzdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFpbHJlcXVlc3QuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0eXBlID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbmZ1bmN0aW9uIGdldEJsb2JCdWlsZGVyKCkge1xuICAgIGlmICh0eXBlb2YgQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBCbG9iQnVpbGRlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIFdlYktpdEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gV2ViS2l0QmxvYkJ1aWxkZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogQ29uY2F0ZW5hdGVzIG9uZSBvciBtb3JlIHZhbHVlcyB0b2dldGhlciBhbmQgY29udmVydHMgdGhlbSB0byBhIEJsb2IuXG4gKlxuICogQHBhcmFtIHZhcl9hcmdzIFRoZSB2YWx1ZXMgdGhhdCB3aWxsIG1ha2UgdXAgdGhlIHJlc3VsdGluZyBibG9iLlxuICogQHJldHVybiBUaGUgYmxvYi5cbiAqL1xuZnVuY3Rpb24gZ2V0QmxvYigpIHtcbiAgICB2YXIgdmFyX2FyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXJfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgQmxvYkJ1aWxkZXIgPSBnZXRCbG9iQnVpbGRlcigpO1xuICAgIGlmIChCbG9iQnVpbGRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcl9hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBiYi5hcHBlbmQodmFyX2FyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYi5nZXRCbG9iKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZS5pc05hdGl2ZUJsb2JEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYih2YXJfYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHNlZW0gdG8gc3VwcG9ydCBjcmVhdGluZyBCbG9ic1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZ2V0QmxvYiA9IGdldEJsb2I7XG4vKipcbiAqIFNsaWNlcyB0aGUgYmxvYi4gVGhlIHJldHVybmVkIGJsb2IgY29udGFpbnMgZGF0YSBmcm9tIHRoZSBzdGFydCBieXRlXG4gKiAoaW5jbHVzaXZlKSB0aWxsIHRoZSBlbmQgYnl0ZSAoZXhjbHVzaXZlKS4gTmVnYXRpdmUgaW5kaWNlcyBjYW5ub3QgYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gYmxvYiBUaGUgYmxvYiB0byBiZSBzbGljZWQuXG4gKiBAcGFyYW0gc3RhcnQgSW5kZXggb2YgdGhlIHN0YXJ0aW5nIGJ5dGUuXG4gKiBAcGFyYW0gZW5kIEluZGV4IG9mIHRoZSBlbmRpbmcgYnl0ZS5cbiAqIEByZXR1cm4gVGhlIGJsb2Igc2xpY2Ugb3IgbnVsbCBpZiBub3Qgc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBzbGljZUJsb2IoYmxvYiwgc3RhcnQsIGVuZCkge1xuICAgIGlmIChibG9iLndlYmtpdFNsaWNlKSB7XG4gICAgICAgIHJldHVybiBibG9iLndlYmtpdFNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChibG9iLm1velNsaWNlKSB7XG4gICAgICAgIHJldHVybiBibG9iLm1velNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChibG9iLnNsaWNlKSB7XG4gICAgICAgIHJldHVybiBibG9iLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuc2xpY2VCbG9iID0gc2xpY2VCbG9iO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciB0eXBlID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbi8qKlxuICogUmV0dXJucyB0aGUgT2JqZWN0IHJlc3VsdGluZyBmcm9tIHBhcnNpbmcgdGhlIGdpdmVuIEpTT04sIG9yIG51bGwgaWYgdGhlXG4gKiBnaXZlbiBzdHJpbmcgZG9lcyBub3QgcmVwcmVzZW50IGEgSlNPTiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGpzb25PYmplY3RPck51bGwocykge1xuICAgIHZhciBvYmo7XG4gICAgdHJ5IHtcbiAgICAgICAgb2JqID0gSlNPTi5wYXJzZShzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlLmlzTm9uQXJyYXlPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5qc29uT2JqZWN0T3JOdWxsID0ganNvbk9iamVjdE9yTnVsbDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBGdW5jdGlvbmFsaXR5IHJlbGF0ZWQgdG8gdGhlIHBhcnNpbmcvY29tcG9zaXRpb24gb2YgYnVja2V0L1xuICogb2JqZWN0IGxvY2F0aW9uLlxuICovXG52YXIgZXJyb3JzRXhwb3J0cyA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuLyoqXG4gKiBAc3RydWN0XG4gKi9cbnZhciBMb2NhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2NhdGlvbihidWNrZXQsIHBhdGgpIHtcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIHRoaXMucGF0aF8gPSBwYXRoO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9jYXRpb24ucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGhfO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuZnVsbFNlcnZlclVybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuICcvYi8nICsgZW5jb2RlKHRoaXMuYnVja2V0KSArICcvby8nICsgZW5jb2RlKHRoaXMucGF0aCk7XG4gICAgfTtcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuYnVja2V0T25seVNlcnZlclVybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuICcvYi8nICsgZW5jb2RlKHRoaXMuYnVja2V0KSArICcvbyc7XG4gICAgfTtcbiAgICBMb2NhdGlvbi5tYWtlRnJvbUJ1Y2tldFNwZWMgPSBmdW5jdGlvbiAoYnVja2V0U3RyaW5nKSB7XG4gICAgICAgIHZhciBidWNrZXRMb2NhdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJ1Y2tldExvY2F0aW9uID0gTG9jYXRpb24ubWFrZUZyb21VcmwoYnVja2V0U3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTm90IHZhbGlkIFVSTCwgdXNlIGFzLWlzLiBUaGlzIGxldHMgeW91IHB1dCBiYXJlIGJ1Y2tldCBuYW1lcyBpblxuICAgICAgICAgICAgLy8gY29uZmlnLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2NhdGlvbihidWNrZXRTdHJpbmcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVja2V0TG9jYXRpb24ucGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBidWNrZXRMb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuaW52YWxpZERlZmF1bHRCdWNrZXQoYnVja2V0U3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9jYXRpb24ubWFrZUZyb21VcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciBidWNrZXREb21haW4gPSAnKFtBLVphLXowLTkuXFxcXC1dKyknO1xuICAgICAgICBmdW5jdGlvbiBnc01vZGlmeShsb2MpIHtcbiAgICAgICAgICAgIGlmIChsb2MucGF0aC5jaGFyQXQobG9jLnBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xuICAgICAgICAgICAgICAgIGxvYy5wYXRoXyA9IGxvYy5wYXRoXy5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdzUGF0aCA9ICcoLyguKikpPyQnO1xuICAgICAgICB2YXIgcGF0aCA9ICcoLyhbXj8jXSopLiopPyQnO1xuICAgICAgICB2YXIgZ3NSZWdleCA9IG5ldyBSZWdFeHAoJ15nczovLycgKyBidWNrZXREb21haW4gKyBnc1BhdGgsICdpJyk7XG4gICAgICAgIHZhciBnc0luZGljZXMgPSB7IGJ1Y2tldDogMSwgcGF0aDogMyB9O1xuICAgICAgICBmdW5jdGlvbiBodHRwTW9kaWZ5KGxvYykge1xuICAgICAgICAgICAgbG9jLnBhdGhfID0gZGVjb2RlVVJJQ29tcG9uZW50KGxvYy5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVyc2lvbiA9ICd2W0EtWmEtejAtOV9dKyc7XG4gICAgICAgIHZhciBodHRwUmVnZXggPSBuZXcgUmVnRXhwKCdeaHR0cHM/Oi8vZmlyZWJhc2VzdG9yYWdlXFxcXC5nb29nbGVhcGlzXFxcXC5jb20vJyArXG4gICAgICAgICAgICB2ZXJzaW9uICtcbiAgICAgICAgICAgICcvYi8nICtcbiAgICAgICAgICAgIGJ1Y2tldERvbWFpbiArXG4gICAgICAgICAgICAnL28nICtcbiAgICAgICAgICAgIHBhdGgsICdpJyk7XG4gICAgICAgIHZhciBodHRwSW5kaWNlcyA9IHsgYnVja2V0OiAxLCBwYXRoOiAzIH07XG4gICAgICAgIHZhciBncm91cHMgPSBbXG4gICAgICAgICAgICB7IHJlZ2V4OiBnc1JlZ2V4LCBpbmRpY2VzOiBnc0luZGljZXMsIHBvc3RNb2RpZnk6IGdzTW9kaWZ5IH0sXG4gICAgICAgICAgICB7IHJlZ2V4OiBodHRwUmVnZXgsIGluZGljZXM6IGh0dHBJbmRpY2VzLCBwb3N0TW9kaWZ5OiBodHRwTW9kaWZ5IH1cbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICAgIHZhciBjYXB0dXJlcyA9IGdyb3VwLnJlZ2V4LmV4ZWModXJsKTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgICAgIHZhciBidWNrZXRWYWx1ZSA9IGNhcHR1cmVzW2dyb3VwLmluZGljZXMuYnVja2V0XTtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aFZhbHVlID0gY2FwdHVyZXNbZ3JvdXAuaW5kaWNlcy5wYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoVmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBuZXcgTG9jYXRpb24oYnVja2V0VmFsdWUsIHBhdGhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZ3JvdXAucG9zdE1vZGlmeShsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuaW52YWxpZFVybCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhdGlvbjtcbn0oKSk7XG5leHBvcnRzLkxvY2F0aW9uID0gTG9jYXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2F0aW9uLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGpzb24gPSByZXF1aXJlKFwiLi9qc29uXCIpO1xudmFyIGxvY2F0aW9uXzEgPSByZXF1aXJlKFwiLi9sb2NhdGlvblwiKTtcbnZhciBwYXRoID0gcmVxdWlyZShcIi4vcGF0aFwiKTtcbnZhciB0eXBlID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbnZhciBVcmxVdGlscyA9IHJlcXVpcmUoXCIuL3VybFwiKTtcbmZ1bmN0aW9uIG5vWGZvcm1fKG1ldGFkYXRhLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMubm9YZm9ybV8gPSBub1hmb3JtXztcbi8qKlxuICogQHN0cnVjdFxuICovXG52YXIgTWFwcGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBwaW5nKHNlcnZlciwgb3B0X2xvY2FsLCBvcHRfd3JpdGFibGUsIG9wdF94Zm9ybSkge1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5sb2NhbCA9IG9wdF9sb2NhbCB8fCBzZXJ2ZXI7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSAhIW9wdF93cml0YWJsZTtcbiAgICAgICAgdGhpcy54Zm9ybSA9IG9wdF94Zm9ybSB8fCBub1hmb3JtXztcbiAgICB9XG4gICAgcmV0dXJuIE1hcHBpbmc7XG59KCkpO1xuZXhwb3J0cy5NYXBwaW5nID0gTWFwcGluZztcbnZhciBtYXBwaW5nc18gPSBudWxsO1xuZnVuY3Rpb24geGZvcm1QYXRoKGZ1bGxQYXRoKSB7XG4gICAgdmFyIHZhbGlkID0gdHlwZS5pc1N0cmluZyhmdWxsUGF0aCk7XG4gICAgaWYgKCF2YWxpZCB8fCBmdWxsUGF0aC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBmdWxsUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZ1bGxQYXRoID0gZnVsbFBhdGg7XG4gICAgICAgIHJldHVybiBwYXRoLmxhc3RDb21wb25lbnQoZnVsbFBhdGgpO1xuICAgIH1cbn1cbmV4cG9ydHMueGZvcm1QYXRoID0geGZvcm1QYXRoO1xuZnVuY3Rpb24gZ2V0TWFwcGluZ3MoKSB7XG4gICAgaWYgKG1hcHBpbmdzXykge1xuICAgICAgICByZXR1cm4gbWFwcGluZ3NfO1xuICAgIH1cbiAgICB2YXIgbWFwcGluZ3MgPSBbXTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdidWNrZXQnKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnZ2VuZXJhdGlvbicpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdtZXRhZ2VuZXJhdGlvbicpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCduYW1lJywgJ2Z1bGxQYXRoJywgdHJ1ZSkpO1xuICAgIGZ1bmN0aW9uIG1hcHBpbmdzWGZvcm1QYXRoKG1ldGFkYXRhLCBmdWxsUGF0aCkge1xuICAgICAgICByZXR1cm4geGZvcm1QYXRoKGZ1bGxQYXRoKTtcbiAgICB9XG4gICAgdmFyIG5hbWVNYXBwaW5nID0gbmV3IE1hcHBpbmcoJ25hbWUnKTtcbiAgICBuYW1lTWFwcGluZy54Zm9ybSA9IG1hcHBpbmdzWGZvcm1QYXRoO1xuICAgIG1hcHBpbmdzLnB1c2gobmFtZU1hcHBpbmcpO1xuICAgIC8qKlxuICAgICAqIENvZXJjZXMgdGhlIHNlY29uZCBwYXJhbSB0byBhIG51bWJlciwgaWYgaXQgaXMgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB4Zm9ybVNpemUobWV0YWRhdGEsIHNpemUpIHtcbiAgICAgICAgaWYgKHR5cGUuaXNEZWYoc2l6ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiArc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzaXplTWFwcGluZyA9IG5ldyBNYXBwaW5nKCdzaXplJyk7XG4gICAgc2l6ZU1hcHBpbmcueGZvcm0gPSB4Zm9ybVNpemU7XG4gICAgbWFwcGluZ3MucHVzaChzaXplTWFwcGluZyk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygndGltZUNyZWF0ZWQnKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygndXBkYXRlZCcpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdtZDVIYXNoJywgbnVsbCwgdHJ1ZSkpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2NhY2hlQ29udHJvbCcsIG51bGwsIHRydWUpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjb250ZW50RGlzcG9zaXRpb24nLCBudWxsLCB0cnVlKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY29udGVudEVuY29kaW5nJywgbnVsbCwgdHJ1ZSkpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2NvbnRlbnRMYW5ndWFnZScsIG51bGwsIHRydWUpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjb250ZW50VHlwZScsIG51bGwsIHRydWUpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdtZXRhZGF0YScsICdjdXN0b21NZXRhZGF0YScsIHRydWUpKTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgY29tbWEtc2VwYXJhdGVkIHN0cmluZyBvZiB0b2tlbnMgaW50byBhIGxpc3Qgb2YgZG93bmxvYWRcbiAgICAgKiBVUkxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhmb3JtVG9rZW5zKG1ldGFkYXRhLCB0b2tlbnMpIHtcbiAgICAgICAgdmFyIHZhbGlkID0gdHlwZS5pc1N0cmluZyh0b2tlbnMpICYmIHRva2Vucy5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgb2JqZWN0cyBhcmUgdXBsb2FkZWQgdGhyb3VnaCBHQ1MgYW5kIHJldHJpZXZlZFxuICAgICAgICAgICAgLy8gdGhyb3VnaCBsaXN0LCBzbyB3ZSBkb24ndCB3YW50IHRvIHRocm93IGFuIEVycm9yLlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG4gICAgICAgIHZhciB0b2tlbnNMaXN0ID0gdG9rZW5zLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciB1cmxzID0gdG9rZW5zTGlzdC5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICB2YXIgYnVja2V0ID0gbWV0YWRhdGFbJ2J1Y2tldCddO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBtZXRhZGF0YVsnZnVsbFBhdGgnXTtcbiAgICAgICAgICAgIHZhciB1cmxQYXJ0ID0gJy9iLycgKyBlbmNvZGUoYnVja2V0KSArICcvby8nICsgZW5jb2RlKHBhdGgpO1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBVcmxVdGlscy5tYWtlRG93bmxvYWRVcmwodXJsUGFydCk7XG4gICAgICAgICAgICB2YXIgcXVlcnlTdHJpbmcgPSBVcmxVdGlscy5tYWtlUXVlcnlTdHJpbmcoe1xuICAgICAgICAgICAgICAgIGFsdDogJ21lZGlhJyxcbiAgICAgICAgICAgICAgICB0b2tlbjogdG9rZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2UgKyBxdWVyeVN0cmluZztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cmxzO1xuICAgIH1cbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdkb3dubG9hZFRva2VucycsICdkb3dubG9hZFVSTHMnLCBmYWxzZSwgeGZvcm1Ub2tlbnMpKTtcbiAgICBtYXBwaW5nc18gPSBtYXBwaW5ncztcbiAgICByZXR1cm4gbWFwcGluZ3NfO1xufVxuZXhwb3J0cy5nZXRNYXBwaW5ncyA9IGdldE1hcHBpbmdzO1xuZnVuY3Rpb24gYWRkUmVmKG1ldGFkYXRhLCBhdXRoV3JhcHBlcikge1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlUmVmKCkge1xuICAgICAgICB2YXIgYnVja2V0ID0gbWV0YWRhdGFbJ2J1Y2tldCddO1xuICAgICAgICB2YXIgcGF0aCA9IG1ldGFkYXRhWydmdWxsUGF0aCddO1xuICAgICAgICB2YXIgbG9jID0gbmV3IGxvY2F0aW9uXzEuTG9jYXRpb24oYnVja2V0LCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIGF1dGhXcmFwcGVyLm1ha2VTdG9yYWdlUmVmZXJlbmNlKGxvYyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRhZGF0YSwgJ3JlZicsIHsgZ2V0OiBnZW5lcmF0ZVJlZiB9KTtcbn1cbmV4cG9ydHMuYWRkUmVmID0gYWRkUmVmO1xuZnVuY3Rpb24gZnJvbVJlc291cmNlKGF1dGhXcmFwcGVyLCByZXNvdXJjZSwgbWFwcGluZ3MpIHtcbiAgICB2YXIgbWV0YWRhdGEgPSB7fTtcbiAgICBtZXRhZGF0YVsndHlwZSddID0gJ2ZpbGUnO1xuICAgIHZhciBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgICBtZXRhZGF0YVttYXBwaW5nLmxvY2FsXSA9IG1hcHBpbmcueGZvcm0obWV0YWRhdGEsIHJlc291cmNlW21hcHBpbmcuc2VydmVyXSk7XG4gICAgfVxuICAgIGFkZFJlZihtZXRhZGF0YSwgYXV0aFdyYXBwZXIpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbn1cbmV4cG9ydHMuZnJvbVJlc291cmNlID0gZnJvbVJlc291cmNlO1xuZnVuY3Rpb24gZnJvbVJlc291cmNlU3RyaW5nKGF1dGhXcmFwcGVyLCByZXNvdXJjZVN0cmluZywgbWFwcGluZ3MpIHtcbiAgICB2YXIgb2JqID0ganNvbi5qc29uT2JqZWN0T3JOdWxsKHJlc291cmNlU3RyaW5nKTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcmVzb3VyY2UgPSBvYmo7XG4gICAgcmV0dXJuIGZyb21SZXNvdXJjZShhdXRoV3JhcHBlciwgcmVzb3VyY2UsIG1hcHBpbmdzKTtcbn1cbmV4cG9ydHMuZnJvbVJlc291cmNlU3RyaW5nID0gZnJvbVJlc291cmNlU3RyaW5nO1xuZnVuY3Rpb24gdG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgbWFwcGluZ3MpIHtcbiAgICB2YXIgcmVzb3VyY2UgPSB7fTtcbiAgICB2YXIgbGVuID0gbWFwcGluZ3MubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgICAgaWYgKG1hcHBpbmcud3JpdGFibGUpIHtcbiAgICAgICAgICAgIHJlc291cmNlW21hcHBpbmcuc2VydmVyXSA9IG1ldGFkYXRhW21hcHBpbmcubG9jYWxdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXNvdXJjZSk7XG59XG5leHBvcnRzLnRvUmVzb3VyY2VTdHJpbmcgPSB0b1Jlc291cmNlU3RyaW5nO1xuZnVuY3Rpb24gbWV0YWRhdGFWYWxpZGF0b3IocCkge1xuICAgIHZhciB2YWxpZFR5cGUgPSBwICYmIHR5cGUuaXNPYmplY3QocCk7XG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIE1ldGFkYXRhIG9iamVjdC4nO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gcCkge1xuICAgICAgICB2YXIgdmFsID0gcFtrZXldO1xuICAgICAgICBpZiAoa2V5ID09PSAnY3VzdG9tTWV0YWRhdGEnKSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUuaXNPYmplY3QodmFsKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBvYmplY3QgZm9yIFxcJ2N1c3RvbU1ldGFkYXRhXFwnIG1hcHBpbmcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlLmlzTm9uTnVsbE9iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJNYXBwaW5nIGZvciAnXCIgKyBrZXkgKyBcIicgY2Fubm90IGJlIGFuIG9iamVjdC5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMubWV0YWRhdGFWYWxpZGF0b3IgPSBtZXRhZGF0YVZhbGlkYXRvcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29udGFpbnMgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zKG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbmV4cG9ydHMuY29udGFpbnMgPSBjb250YWlucztcbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoY29udGFpbnMob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBmKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5mb3JFYWNoID0gZm9yRWFjaDtcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHZhciBjID0ge307XG4gICAgZm9yRWFjaChvYmosIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICBjW2tleV0gPSB2YWw7XG4gICAgfSk7XG4gICAgcmV0dXJuIGM7XG59XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciB0eXBlID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbi8qKlxuICogQHN0cnVjdFxuICovXG52YXIgT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZXIobmV4dE9yT2JzZXJ2ZXIsIG9wdF9lcnJvciwgb3B0X2NvbXBsZXRlKSB7XG4gICAgICAgIHZhciBhc0Z1bmN0aW9ucyA9IHR5cGUuaXNGdW5jdGlvbihuZXh0T3JPYnNlcnZlcikgfHxcbiAgICAgICAgICAgIHR5cGUuaXNEZWYob3B0X2Vycm9yKSB8fFxuICAgICAgICAgICAgdHlwZS5pc0RlZihvcHRfY29tcGxldGUpO1xuICAgICAgICBpZiAoYXNGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG5leHRPck9ic2VydmVyO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG9wdF9lcnJvciB8fCBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSA9IG9wdF9jb21wbGV0ZSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9ic2VydmVyID0gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBvYnNlcnZlci5uZXh0IHx8IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gb2JzZXJ2ZXIuZXJyb3IgfHwgbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBvYnNlcnZlci5jb21wbGV0ZSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYnNlcnZlcjtcbn0oKSk7XG5leHBvcnRzLk9ic2VydmVyID0gT2JzZXJ2ZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnRhaW5zIGhlbHBlciBtZXRob2RzIGZvciBtYW5pcHVsYXRpbmcgcGF0aHMuXG4gKi9cbi8qKlxuICogQHJldHVybiBOdWxsIGlmIHRoZSBwYXRoIGlzIGFscmVhZHkgYXQgdGhlIHJvb3QuXG4gKi9cbmZ1bmN0aW9uIHBhcmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIG5ld1BhdGggPSBwYXRoLnNsaWNlKDAsIGluZGV4KTtcbiAgICByZXR1cm4gbmV3UGF0aDtcbn1cbmV4cG9ydHMucGFyZW50ID0gcGFyZW50O1xuZnVuY3Rpb24gY2hpbGQocGF0aCwgY2hpbGRQYXRoKSB7XG4gICAgdmFyIGNhbm9uaWNhbENoaWxkUGF0aCA9IGNoaWxkUGF0aFxuICAgICAgICAuc3BsaXQoJy8nKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5sZW5ndGggPiAwO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcvJyk7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjYW5vbmljYWxDaGlsZFBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aCArICcvJyArIGNhbm9uaWNhbENoaWxkUGF0aDtcbiAgICB9XG59XG5leHBvcnRzLmNoaWxkID0gY2hpbGQ7XG4vKipcbiAqIFJldHVybnMgdGhlIGxhc3QgY29tcG9uZW50IG9mIGEgcGF0aC5cbiAqICcvZm9vL2JhcicgLT4gJ2JhcidcbiAqICcvZm9vL2Jhci9iYXovJyAtPiAnYmF6LydcbiAqICcvYScgLT4gJ2EnXG4gKi9cbmZ1bmN0aW9uIGxhc3RDb21wb25lbnQocGF0aCkge1xuICAgIHZhciBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nLCBwYXRoLmxlbmd0aCAtIDIpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShpbmRleCArIDEpO1xuICAgIH1cbn1cbmV4cG9ydHMubGFzdENvbXBvbmVudCA9IGxhc3RDb21wb25lbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSW1wbGVtZW50cyB0aGUgcHJvbWlzZSBhYnN0cmFjdGlvbiBpbnRlcmZhY2UgZm9yIGV4dGVybmFsXG4gKiAocHVibGljIFNESykgcGFja2FnaW5nLCB3aGljaCBqdXN0IHBhc3NlcyB0aHJvdWdoIHRvIHRoZSBmaXJlYmFzZS1hcHAgaW1wbC5cbiAqL1xuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbigoZnVuY3Rpb24oVCk6IHZvaWQpLFxuICogICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oIUVycm9yKTogdm9pZCkpfSByZXNvbHZlclxuICovXG5mdW5jdGlvbiBtYWtlKHJlc29sdmVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmVyKTtcbn1cbmV4cG9ydHMubWFrZSA9IG1ha2U7XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbn1cbmV4cG9ydHMucmVzb2x2ZSA9IHJlc29sdmU7XG5mdW5jdGlvbiByZWplY3QoZXJyb3IpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xufVxuZXhwb3J0cy5yZWplY3QgPSByZWplY3Q7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2VfZXh0ZXJuYWwuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyBtZXRob2RzIHVzZWQgdG8gYWN0dWFsbHkgc2VuZCBIVFRQIHJlcXVlc3RzIGZyb21cbiAqIGFic3RyYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAqL1xudmFyIGFwcF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS9hcHBcIik7XG52YXIgYXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbnZhciBiYWNrb2ZmID0gcmVxdWlyZShcIi4vYmFja29mZlwiKTtcbnZhciBlcnJvcnNFeHBvcnRzID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG52YXIgb2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xudmFyIHByb21pc2VpbXBsID0gcmVxdWlyZShcIi4vcHJvbWlzZV9leHRlcm5hbFwiKTtcbnZhciB0eXBlID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbnZhciBVcmxVdGlscyA9IHJlcXVpcmUoXCIuL3VybFwiKTtcbnZhciBYaHJJb0V4cG9ydHMgPSByZXF1aXJlKFwiLi94aHJpb1wiKTtcbi8qKlxuICogQHN0cnVjdFxuICogQHRlbXBsYXRlIFRcbiAqL1xudmFyIE5ldHdvcmtSZXF1ZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtSZXF1ZXN0KHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5LCBzdWNjZXNzQ29kZXMsIGFkZGl0aW9uYWxSZXRyeUNvZGVzLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaywgdGltZW91dCwgcHJvZ3Jlc3NDYWxsYmFjaywgcG9vbCkge1xuICAgICAgICB0aGlzLnBlbmRpbmdYaHJfID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYWNrb2ZmSWRfID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNvbHZlXyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVqZWN0XyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FuY2VsZWRfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXBwRGVsZXRlXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVybF8gPSB1cmw7XG4gICAgICAgIHRoaXMubWV0aG9kXyA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5oZWFkZXJzXyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMuYm9keV8gPSBib2R5O1xuICAgICAgICB0aGlzLnN1Y2Nlc3NDb2Rlc18gPSBzdWNjZXNzQ29kZXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsUmV0cnlDb2Rlc18gPSBhZGRpdGlvbmFsUmV0cnlDb2Rlcy5zbGljZSgpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmVycm9yQ2FsbGJhY2tfID0gZXJyb3JDYWxsYmFjaztcbiAgICAgICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrXyA9IHByb2dyZXNzQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMudGltZW91dF8gPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLnBvb2xfID0gcG9vbDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnByb21pc2VfID0gcHJvbWlzZWltcGwubWFrZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmVfID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHNlbGYucmVqZWN0XyA9IHJlamVjdDtcbiAgICAgICAgICAgIHNlbGYuc3RhcnRfKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3R1YWxseSBzdGFydHMgdGhlIHJldHJ5IGxvb3AuXG4gICAgICovXG4gICAgTmV0d29ya1JlcXVlc3QucHJvdG90eXBlLnN0YXJ0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBkb1RoZVJlcXVlc3QoYmFja29mZkNhbGxiYWNrLCBjYW5jZWxlZCkge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgYmFja29mZkNhbGxiYWNrKGZhbHNlLCBuZXcgUmVxdWVzdEVuZFN0YXR1cyhmYWxzZSwgbnVsbCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB4aHIgPSBzZWxmLnBvb2xfLmNyZWF0ZVhocklvKCk7XG4gICAgICAgICAgICBzZWxmLnBlbmRpbmdYaHJfID0geGhyO1xuICAgICAgICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3NMaXN0ZW5lcihwcm9ncmVzc0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlZCA9IHByb2dyZXNzRXZlbnQubG9hZGVkO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IHByb2dyZXNzRXZlbnQubGVuZ3RoQ29tcHV0YWJsZSA/IHByb2dyZXNzRXZlbnQudG90YWwgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5wcm9ncmVzc0NhbGxiYWNrXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnByb2dyZXNzQ2FsbGJhY2tfKGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnByb2dyZXNzQ2FsbGJhY2tfICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeGhyLmFkZFVwbG9hZFByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3NMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4aHJcbiAgICAgICAgICAgICAgICAuc2VuZChzZWxmLnVybF8sIHNlbGYubWV0aG9kXywgc2VsZi5ib2R5Xywgc2VsZi5oZWFkZXJzXylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoeGhyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucHJvZ3Jlc3NDYWxsYmFja18gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnJlbW92ZVVwbG9hZFByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3NMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYucGVuZGluZ1hocl8gPSBudWxsO1xuICAgICAgICAgICAgICAgIHhociA9IHhocjtcbiAgICAgICAgICAgICAgICB2YXIgaGl0U2VydmVyID0geGhyLmdldEVycm9yQ29kZSgpID09PSBYaHJJb0V4cG9ydHMuRXJyb3JDb2RlLk5PX0VSUk9SO1xuICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSB4aHIuZ2V0U3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFoaXRTZXJ2ZXIgfHwgc2VsZi5pc1JldHJ5U3RhdHVzQ29kZV8oc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2FzQ2FuY2VsZWQgPSB4aHIuZ2V0RXJyb3JDb2RlKCkgPT09IFhocklvRXhwb3J0cy5FcnJvckNvZGUuQUJPUlQ7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tvZmZDYWxsYmFjayhmYWxzZSwgbmV3IFJlcXVlc3RFbmRTdGF0dXMoZmFsc2UsIG51bGwsIHdhc0NhbmNlbGVkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDb2RlID0gYXJyYXkuY29udGFpbnMoc2VsZi5zdWNjZXNzQ29kZXNfLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgIGJhY2tvZmZDYWxsYmFjayh0cnVlLCBuZXcgUmVxdWVzdEVuZFN0YXR1cyhzdWNjZXNzQ29kZSwgeGhyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHJlcXVlc3RXZW50VGhyb3VnaCBUcnVlIGlmIHRoZSByZXF1ZXN0IGV2ZW50dWFsbHkgd2VudFxuICAgICAgICAgKiAgICAgdGhyb3VnaCwgZmFsc2UgaWYgaXQgaGl0IHRoZSByZXRyeSBsaW1pdCBvciB3YXMgY2FuY2VsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBiYWNrb2ZmRG9uZShyZXF1ZXN0V2VudFRocm91Z2gsIHN0YXR1cykge1xuICAgICAgICAgICAgdmFyIHJlc29sdmUgPSBzZWxmLnJlc29sdmVfO1xuICAgICAgICAgICAgdmFyIHJlamVjdCA9IHNlbGYucmVqZWN0XztcbiAgICAgICAgICAgIHZhciB4aHIgPSBzdGF0dXMueGhyO1xuICAgICAgICAgICAgaWYgKHN0YXR1cy53YXNTdWNjZXNzQ29kZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBzZWxmLmNhbGxiYWNrXyh4aHIsIHhoci5nZXRSZXNwb25zZVRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLmlzSnVzdERlZihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh4aHIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGVycm9yc0V4cG9ydHMudW5rbm93bigpO1xuICAgICAgICAgICAgICAgICAgICBlcnIuc2V0U2VydmVyUmVzcG9uc2VQcm9wKHhoci5nZXRSZXNwb25zZVRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmVycm9yQ2FsbGJhY2tfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoc2VsZi5lcnJvckNhbGxiYWNrXyh4aHIsIGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBzZWxmLmFwcERlbGV0ZV9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVycm9yc0V4cG9ydHMuYXBwRGVsZXRlZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBlcnJvcnNFeHBvcnRzLmNhbmNlbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBlcnJvcnNFeHBvcnRzLnJldHJ5TGltaXRFeGNlZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsZWRfKSB7XG4gICAgICAgICAgICBiYWNrb2ZmRG9uZShmYWxzZSwgbmV3IFJlcXVlc3RFbmRTdGF0dXMoZmFsc2UsIG51bGwsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZklkXyA9IGJhY2tvZmYuc3RhcnQoZG9UaGVSZXF1ZXN0LCBiYWNrb2ZmRG9uZSwgdGhpcy50aW1lb3V0Xyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIE5ldHdvcmtSZXF1ZXN0LnByb3RvdHlwZS5nZXRQcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlXztcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIE5ldHdvcmtSZXF1ZXN0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYXBwRGVsZXRlKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsZWRfID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHBEZWxldGVfID0gYXBwRGVsZXRlIHx8IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5iYWNrb2ZmSWRfICE9PSBudWxsKSB7XG4gICAgICAgICAgICBiYWNrb2ZmLnN0b3AodGhpcy5iYWNrb2ZmSWRfKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nWGhyXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nWGhyXy5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOZXR3b3JrUmVxdWVzdC5wcm90b3R5cGUuaXNSZXRyeVN0YXR1c0NvZGVfID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICAvLyBUaGUgY29kZXMgZm9yIHdoaWNoIHRvIHJldHJ5IGNhbWUgZnJvbSB0aGlzIHBhZ2U6XG4gICAgICAgIC8vIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9zdG9yYWdlL2RvY3MvZXhwb25lbnRpYWwtYmFja29mZlxuICAgICAgICB2YXIgaXNGaXZlSHVuZHJlZENvZGUgPSBzdGF0dXMgPj0gNTAwICYmIHN0YXR1cyA8IDYwMDtcbiAgICAgICAgdmFyIGV4dHJhUmV0cnlDb2RlcyA9IFtcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgVGltZW91dDogd2ViIHNlcnZlciBkaWRuJ3QgcmVjZWl2ZSBmdWxsIHJlcXVlc3QgaW4gdGltZS5cbiAgICAgICAgICAgIDQwOCxcbiAgICAgICAgICAgIC8vIFRvbyBNYW55IFJlcXVlc3RzOiB5b3UncmUgZ2V0dGluZyByYXRlLWxpbWl0ZWQsIGJhc2ljYWxseS5cbiAgICAgICAgICAgIDQyOVxuICAgICAgICBdO1xuICAgICAgICB2YXIgaXNFeHRyYVJldHJ5Q29kZSA9IGFycmF5LmNvbnRhaW5zKGV4dHJhUmV0cnlDb2Rlcywgc3RhdHVzKTtcbiAgICAgICAgdmFyIGlzUmVxdWVzdFNwZWNpZmljUmV0cnlDb2RlID0gYXJyYXkuY29udGFpbnModGhpcy5hZGRpdGlvbmFsUmV0cnlDb2Rlc18sIHN0YXR1cyk7XG4gICAgICAgIHJldHVybiBpc0ZpdmVIdW5kcmVkQ29kZSB8fCBpc0V4dHJhUmV0cnlDb2RlIHx8IGlzUmVxdWVzdFNwZWNpZmljUmV0cnlDb2RlO1xuICAgIH07XG4gICAgcmV0dXJuIE5ldHdvcmtSZXF1ZXN0O1xufSgpKTtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXN1bHQgb2YgYSBuZXR3b3JrIHJlcXVlc3QuXG4gKiBAcGFyYW0gb3B0X2NhbmNlbGVkIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHN0cnVjdFxuICovXG52YXIgUmVxdWVzdEVuZFN0YXR1cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXF1ZXN0RW5kU3RhdHVzKHdhc1N1Y2Nlc3NDb2RlLCB4aHIsIG9wdF9jYW5jZWxlZCkge1xuICAgICAgICB0aGlzLndhc1N1Y2Nlc3NDb2RlID0gd2FzU3VjY2Vzc0NvZGU7XG4gICAgICAgIHRoaXMueGhyID0geGhyO1xuICAgICAgICB0aGlzLmNhbmNlbGVkID0gISFvcHRfY2FuY2VsZWQ7XG4gICAgfVxuICAgIHJldHVybiBSZXF1ZXN0RW5kU3RhdHVzO1xufSgpKTtcbmV4cG9ydHMuUmVxdWVzdEVuZFN0YXR1cyA9IFJlcXVlc3RFbmRTdGF0dXM7XG5mdW5jdGlvbiBhZGRBdXRoSGVhZGVyXyhoZWFkZXJzLCBhdXRoVG9rZW4pIHtcbiAgICBpZiAoYXV0aFRva2VuICE9PSBudWxsICYmIGF1dGhUb2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9ICdGaXJlYmFzZSAnICsgYXV0aFRva2VuO1xuICAgIH1cbn1cbmV4cG9ydHMuYWRkQXV0aEhlYWRlcl8gPSBhZGRBdXRoSGVhZGVyXztcbmZ1bmN0aW9uIGFkZFZlcnNpb25IZWFkZXJfKGhlYWRlcnMpIHtcbiAgICB2YXIgbnVtYmVyID0gdHlwZW9mIGFwcF8xLmRlZmF1bHQgIT09ICd1bmRlZmluZWQnID8gYXBwXzEuZGVmYXVsdC5TREtfVkVSU0lPTiA6ICdBcHBNYW5hZ2VyJztcbiAgICBoZWFkZXJzWydYLUZpcmViYXNlLVN0b3JhZ2UtVmVyc2lvbiddID0gJ3dlYmpzLycgKyBudW1iZXI7XG59XG5leHBvcnRzLmFkZFZlcnNpb25IZWFkZXJfID0gYWRkVmVyc2lvbkhlYWRlcl87XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBhdXRoVG9rZW4sIHBvb2wpIHtcbiAgICB2YXIgcXVlcnlQYXJ0ID0gVXJsVXRpbHMubWFrZVF1ZXJ5U3RyaW5nKHJlcXVlc3RJbmZvLnVybFBhcmFtcyk7XG4gICAgdmFyIHVybCA9IHJlcXVlc3RJbmZvLnVybCArIHF1ZXJ5UGFydDtcbiAgICB2YXIgaGVhZGVycyA9IG9iamVjdC5jbG9uZShyZXF1ZXN0SW5mby5oZWFkZXJzKTtcbiAgICBhZGRBdXRoSGVhZGVyXyhoZWFkZXJzLCBhdXRoVG9rZW4pO1xuICAgIGFkZFZlcnNpb25IZWFkZXJfKGhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgTmV0d29ya1JlcXVlc3QodXJsLCByZXF1ZXN0SW5mby5tZXRob2QsIGhlYWRlcnMsIHJlcXVlc3RJbmZvLmJvZHksIHJlcXVlc3RJbmZvLnN1Y2Nlc3NDb2RlcywgcmVxdWVzdEluZm8uYWRkaXRpb25hbFJldHJ5Q29kZXMsIHJlcXVlc3RJbmZvLmhhbmRsZXIsIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciwgcmVxdWVzdEluZm8udGltZW91dCwgcmVxdWVzdEluZm8ucHJvZ3Jlc3NDYWxsYmFjaywgcG9vbCk7XG59XG5leHBvcnRzLm1ha2VSZXF1ZXN0ID0gbWFrZVJlcXVlc3Q7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZXF1ZXN0SW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgXG4gICAgICAgIC8qKlxuICAgICAgICAgICAqIFJldHVybnMgdGhlIHZhbHVlIHdpdGggd2hpY2ggdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdCdzIHByb21pc2UuIE9ubHkgY2FsbGVkXG4gICAgICAgICAgICogaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC4gVGhyb3cgZnJvbSB0aGlzIGZ1bmN0aW9uIHRvIHJlamVjdCB0aGVcbiAgICAgICAgICAgKiByZXR1cm5lZCBSZXF1ZXN0J3MgcHJvbWlzZSB3aXRoIHRoZSB0aHJvd24gZXJyb3IuXG4gICAgICAgICAgICogTm90ZTogVGhlIFhocklvIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIG1heSBiZSByZXVzZWQgYWZ0ZXIgdGhpcyBjYWxsYmFja1xuICAgICAgICAgICAqIHJldHVybnMuIERvIG5vdCBrZWVwIGEgcmVmZXJlbmNlIHRvIGl0IGluIGFueSB3YXkuXG4gICAgICAgICAgICovXG4gICAgICAgIGhhbmRsZXIsIHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLnVybFBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGJ5dGVzIHVwbG9hZGVkIGFuZCB0b3RhbCBzaXplICgtMSBpZiBub3RcbiAgICAgICAgICogY29tcHV0YWJsZSkgb2YgdGhlIHJlcXVlc3QgYm9keSAoaS5lLiB1c2VkIHRvIHJlcG9ydCB1cGxvYWQgcHJvZ3Jlc3MpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWNjZXNzQ29kZXMgPSBbMjAwXTtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsUmV0cnlDb2RlcyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gUmVxdWVzdEluZm87XG59KCkpO1xuZXhwb3J0cy5SZXF1ZXN0SW5mbyA9IFJlcXVlc3RJbmZvO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0aW5mby5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBvYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBAc3RydWN0XG4gKi9cbnZhciBSZXF1ZXN0TWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcXVlc3RNYXAoKSB7XG4gICAgICAgIHRoaXMubWFwXyA9IHt9O1xuICAgICAgICB0aGlzLmlkXyA9IGNvbnN0YW50cy5taW5TYWZlSW50ZWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBnaXZlbiByZXF1ZXN0IHdpdGggdGhpcyBtYXAuXG4gICAgICogVGhlIHJlcXVlc3QgaXMgdW5yZWdpc3RlcmVkIHdoZW4gaXQgY29tcGxldGVzLlxuICAgICAqIEBwYXJhbSByIFRoZSByZXF1ZXN0IHRvIHJlZ2lzdGVyLlxuICAgICAqL1xuICAgIFJlcXVlc3RNYXAucHJvdG90eXBlLmFkZFJlcXVlc3QgPSBmdW5jdGlvbiAocikge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkXztcbiAgICAgICAgdGhpcy5pZF8rKztcbiAgICAgICAgdGhpcy5tYXBfW2lkXSA9IHI7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gdW5tYXAoKSB7XG4gICAgICAgICAgICBkZWxldGUgc2VsZi5tYXBfW2lkXTtcbiAgICAgICAgfVxuICAgICAgICByLmdldFByb21pc2UoKS50aGVuKHVubWFwLCB1bm1hcCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGFsbCByZWdpc3RlcmVkIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIFJlcXVlc3RNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvYmplY3QuZm9yRWFjaCh0aGlzLm1hcF8sIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhbC5jYW5jZWwodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcF8gPSB7fTtcbiAgICB9O1xuICAgIHJldHVybiBSZXF1ZXN0TWFwO1xufSgpKTtcbmV4cG9ydHMuUmVxdWVzdE1hcCA9IFJlcXVlc3RNYXA7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3RtYXAuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbnZhciBibG9iXzEgPSByZXF1aXJlKFwiLi9ibG9iXCIpO1xudmFyIGVycm9yc0V4cG9ydHMgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbnZhciBNZXRhZGF0YVV0aWxzID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG52YXIgb2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xudmFyIHJlcXVlc3RpbmZvXzEgPSByZXF1aXJlKFwiLi9yZXF1ZXN0aW5mb1wiKTtcbnZhciB0eXBlID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbnZhciBVcmxVdGlscyA9IHJlcXVpcmUoXCIuL3VybFwiKTtcbi8qKlxuICogVGhyb3dzIHRoZSBVTktOT1dOIEZpcmViYXNlU3RvcmFnZUVycm9yIGlmIGNuZG4gaXMgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZXJDaGVjayhjbmRuKSB7XG4gICAgaWYgKCFjbmRuKSB7XG4gICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMudW5rbm93bigpO1xuICAgIH1cbn1cbmV4cG9ydHMuaGFuZGxlckNoZWNrID0gaGFuZGxlckNoZWNrO1xuZnVuY3Rpb24gbWV0YWRhdGFIYW5kbGVyKGF1dGhXcmFwcGVyLCBtYXBwaW5ncykge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoeGhyLCB0ZXh0KSB7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IE1ldGFkYXRhVXRpbHMuZnJvbVJlc291cmNlU3RyaW5nKGF1dGhXcmFwcGVyLCB0ZXh0LCBtYXBwaW5ncyk7XG4gICAgICAgIGhhbmRsZXJDaGVjayhtZXRhZGF0YSAhPT0gbnVsbCk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXI7XG59XG5leHBvcnRzLm1ldGFkYXRhSGFuZGxlciA9IG1ldGFkYXRhSGFuZGxlcjtcbmZ1bmN0aW9uIHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbikge1xuICAgIGZ1bmN0aW9uIGVycm9ySGFuZGxlcih4aHIsIGVycikge1xuICAgICAgICB2YXIgbmV3RXJyO1xuICAgICAgICBpZiAoeGhyLmdldFN0YXR1cygpID09PSA0MDEpIHtcbiAgICAgICAgICAgIG5ld0VyciA9IGVycm9yc0V4cG9ydHMudW5hdXRoZW50aWNhdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoeGhyLmdldFN0YXR1cygpID09PSA0MDIpIHtcbiAgICAgICAgICAgICAgICBuZXdFcnIgPSBlcnJvcnNFeHBvcnRzLnF1b3RhRXhjZWVkZWQobG9jYXRpb24uYnVja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh4aHIuZ2V0U3RhdHVzKCkgPT09IDQwMykge1xuICAgICAgICAgICAgICAgICAgICBuZXdFcnIgPSBlcnJvcnNFeHBvcnRzLnVuYXV0aG9yaXplZChsb2NhdGlvbi5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VyciA9IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3RXJyLnNldFNlcnZlclJlc3BvbnNlUHJvcChlcnIuc2VydmVyUmVzcG9uc2VQcm9wKCkpO1xuICAgICAgICByZXR1cm4gbmV3RXJyO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JIYW5kbGVyO1xufVxuZXhwb3J0cy5zaGFyZWRFcnJvckhhbmRsZXIgPSBzaGFyZWRFcnJvckhhbmRsZXI7XG5mdW5jdGlvbiBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pIHtcbiAgICB2YXIgc2hhcmVkID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICBmdW5jdGlvbiBlcnJvckhhbmRsZXIoeGhyLCBlcnIpIHtcbiAgICAgICAgdmFyIG5ld0VyciA9IHNoYXJlZCh4aHIsIGVycik7XG4gICAgICAgIGlmICh4aHIuZ2V0U3RhdHVzKCkgPT09IDQwNCkge1xuICAgICAgICAgICAgbmV3RXJyID0gZXJyb3JzRXhwb3J0cy5vYmplY3ROb3RGb3VuZChsb2NhdGlvbi5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdFcnIuc2V0U2VydmVyUmVzcG9uc2VQcm9wKGVyci5zZXJ2ZXJSZXNwb25zZVByb3AoKSk7XG4gICAgICAgIHJldHVybiBuZXdFcnI7XG4gICAgfVxuICAgIHJldHVybiBlcnJvckhhbmRsZXI7XG59XG5leHBvcnRzLm9iamVjdEVycm9ySGFuZGxlciA9IG9iamVjdEVycm9ySGFuZGxlcjtcbmZ1bmN0aW9uIGdldE1ldGFkYXRhKGF1dGhXcmFwcGVyLCBsb2NhdGlvbiwgbWFwcGluZ3MpIHtcbiAgICB2YXIgdXJsUGFydCA9IGxvY2F0aW9uLmZ1bGxTZXJ2ZXJVcmwoKTtcbiAgICB2YXIgdXJsID0gVXJsVXRpbHMubWFrZU5vcm1hbFVybCh1cmxQYXJ0KTtcbiAgICB2YXIgbWV0aG9kID0gJ0dFVCc7XG4gICAgdmFyIHRpbWVvdXQgPSBhdXRoV3JhcHBlci5tYXhPcGVyYXRpb25SZXRyeVRpbWUoKTtcbiAgICB2YXIgcmVxdWVzdEluZm8gPSBuZXcgcmVxdWVzdGluZm9fMS5SZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgbWV0YWRhdGFIYW5kbGVyKGF1dGhXcmFwcGVyLCBtYXBwaW5ncyksIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IG9iamVjdEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuZXhwb3J0cy5nZXRNZXRhZGF0YSA9IGdldE1ldGFkYXRhO1xuZnVuY3Rpb24gdXBkYXRlTWV0YWRhdGEoYXV0aFdyYXBwZXIsIGxvY2F0aW9uLCBtZXRhZGF0YSwgbWFwcGluZ3MpIHtcbiAgICB2YXIgdXJsUGFydCA9IGxvY2F0aW9uLmZ1bGxTZXJ2ZXJVcmwoKTtcbiAgICB2YXIgdXJsID0gVXJsVXRpbHMubWFrZU5vcm1hbFVybCh1cmxQYXJ0KTtcbiAgICB2YXIgbWV0aG9kID0gJ1BBVENIJztcbiAgICB2YXIgYm9keSA9IE1ldGFkYXRhVXRpbHMudG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgbWFwcGluZ3MpO1xuICAgIHZhciBoZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnIH07XG4gICAgdmFyIHRpbWVvdXQgPSBhdXRoV3JhcHBlci5tYXhPcGVyYXRpb25SZXRyeVRpbWUoKTtcbiAgICB2YXIgcmVxdWVzdEluZm8gPSBuZXcgcmVxdWVzdGluZm9fMS5SZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgbWV0YWRhdGFIYW5kbGVyKGF1dGhXcmFwcGVyLCBtYXBwaW5ncyksIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5O1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IG9iamVjdEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuZXhwb3J0cy51cGRhdGVNZXRhZGF0YSA9IHVwZGF0ZU1ldGFkYXRhO1xuZnVuY3Rpb24gZGVsZXRlT2JqZWN0KGF1dGhXcmFwcGVyLCBsb2NhdGlvbikge1xuICAgIHZhciB1cmxQYXJ0ID0gbG9jYXRpb24uZnVsbFNlcnZlclVybCgpO1xuICAgIHZhciB1cmwgPSBVcmxVdGlscy5tYWtlTm9ybWFsVXJsKHVybFBhcnQpO1xuICAgIHZhciBtZXRob2QgPSAnREVMRVRFJztcbiAgICB2YXIgdGltZW91dCA9IGF1dGhXcmFwcGVyLm1heE9wZXJhdGlvblJldHJ5VGltZSgpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoeGhyLCB0ZXh0KSB7IH1cbiAgICB2YXIgcmVxdWVzdEluZm8gPSBuZXcgcmVxdWVzdGluZm9fMS5SZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8uc3VjY2Vzc0NvZGVzID0gWzIwMCwgMjA0XTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmV4cG9ydHMuZGVsZXRlT2JqZWN0ID0gZGVsZXRlT2JqZWN0O1xuZnVuY3Rpb24gZGV0ZXJtaW5lQ29udGVudFR5cGVfKG1ldGFkYXRhLCBibG9iKSB7XG4gICAgcmV0dXJuICgobWV0YWRhdGEgJiYgbWV0YWRhdGFbJ2NvbnRlbnRUeXBlJ10pIHx8XG4gICAgICAgIChibG9iICYmIGJsb2IudHlwZSgpKSB8fFxuICAgICAgICAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG59XG5leHBvcnRzLmRldGVybWluZUNvbnRlbnRUeXBlXyA9IGRldGVybWluZUNvbnRlbnRUeXBlXztcbmZ1bmN0aW9uIG1ldGFkYXRhRm9yVXBsb2FkXyhsb2NhdGlvbiwgYmxvYiwgb3B0X21ldGFkYXRhKSB7XG4gICAgdmFyIG1ldGFkYXRhID0gb2JqZWN0LmNsb25lKG9wdF9tZXRhZGF0YSk7XG4gICAgbWV0YWRhdGFbJ2Z1bGxQYXRoJ10gPSBsb2NhdGlvbi5wYXRoO1xuICAgIG1ldGFkYXRhWydzaXplJ10gPSBibG9iLnNpemUoKTtcbiAgICBpZiAoIW1ldGFkYXRhWydjb250ZW50VHlwZSddKSB7XG4gICAgICAgIG1ldGFkYXRhWydjb250ZW50VHlwZSddID0gZGV0ZXJtaW5lQ29udGVudFR5cGVfKG51bGwsIGJsb2IpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGE7XG59XG5leHBvcnRzLm1ldGFkYXRhRm9yVXBsb2FkXyA9IG1ldGFkYXRhRm9yVXBsb2FkXztcbmZ1bmN0aW9uIG11bHRpcGFydFVwbG9hZChhdXRoV3JhcHBlciwgbG9jYXRpb24sIG1hcHBpbmdzLCBibG9iLCBvcHRfbWV0YWRhdGEpIHtcbiAgICB2YXIgdXJsUGFydCA9IGxvY2F0aW9uLmJ1Y2tldE9ubHlTZXJ2ZXJVcmwoKTtcbiAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtUHJvdG9jb2wnOiAnbXVsdGlwYXJ0J1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ2VuQm91bmRhcnkoKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHN0ciA9XG4gICAgICAgICAgICAgICAgc3RyICtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yYW5kb20oKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICB2YXIgYm91bmRhcnkgPSBnZW5Cb3VuZGFyeSgpO1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ211bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT0nICsgYm91bmRhcnk7XG4gICAgdmFyIG1ldGFkYXRhID0gbWV0YWRhdGFGb3JVcGxvYWRfKGxvY2F0aW9uLCBibG9iLCBvcHRfbWV0YWRhdGEpO1xuICAgIHZhciBtZXRhZGF0YVN0cmluZyA9IE1ldGFkYXRhVXRpbHMudG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgbWFwcGluZ3MpO1xuICAgIHZhciBwcmVCbG9iUGFydCA9ICctLScgK1xuICAgICAgICBib3VuZGFyeSArXG4gICAgICAgICdcXHJcXG4nICtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFxcclxcblxcclxcbicgK1xuICAgICAgICBtZXRhZGF0YVN0cmluZyArXG4gICAgICAgICdcXHJcXG4tLScgK1xuICAgICAgICBib3VuZGFyeSArXG4gICAgICAgICdcXHJcXG4nICtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZTogJyArXG4gICAgICAgIG1ldGFkYXRhWydjb250ZW50VHlwZSddICtcbiAgICAgICAgJ1xcclxcblxcclxcbic7XG4gICAgdmFyIHBvc3RCbG9iUGFydCA9ICdcXHJcXG4tLScgKyBib3VuZGFyeSArICctLSc7XG4gICAgdmFyIGJvZHkgPSBibG9iXzEuRmJzQmxvYi5nZXRCbG9iKHByZUJsb2JQYXJ0LCBibG9iLCBwb3N0QmxvYlBhcnQpO1xuICAgIGlmIChib2R5ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuY2Fubm90U2xpY2VCbG9iKCk7XG4gICAgfVxuICAgIHZhciB1cmxQYXJhbXMgPSB7IG5hbWU6IG1ldGFkYXRhWydmdWxsUGF0aCddIH07XG4gICAgdmFyIHVybCA9IFVybFV0aWxzLm1ha2VVcGxvYWRVcmwodXJsUGFydCk7XG4gICAgdmFyIG1ldGhvZCA9ICdQT1NUJztcbiAgICB2YXIgdGltZW91dCA9IGF1dGhXcmFwcGVyLm1heFVwbG9hZFJldHJ5VGltZSgpO1xuICAgIHZhciByZXF1ZXN0SW5mbyA9IG5ldyByZXF1ZXN0aW5mb18xLlJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBtZXRhZGF0YUhhbmRsZXIoYXV0aFdyYXBwZXIsIG1hcHBpbmdzKSwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8udXJsUGFyYW1zID0gdXJsUGFyYW1zO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5LnVwbG9hZERhdGEoKTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmV4cG9ydHMubXVsdGlwYXJ0VXBsb2FkID0gbXVsdGlwYXJ0VXBsb2FkO1xuLyoqXG4gKiBAcGFyYW0gY3VycmVudCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaGF2ZSBiZWVuIHVwbG9hZGVkIHNvIGZhci5cbiAqIEBwYXJhbSB0b3RhbCBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSB1cGxvYWQuXG4gKiBAcGFyYW0gb3B0X2ZpbmFsaXplZCBUcnVlIGlmIHRoZSBzZXJ2ZXIgaGFzIGZpbmlzaGVkIHRoZSB1cGxvYWQuXG4gKiBAcGFyYW0gb3B0X21ldGFkYXRhIFRoZSB1cGxvYWQgbWV0YWRhdGEsIHNob3VsZFxuICogICAgIG9ubHkgYmUgcGFzc2VkIGlmIG9wdF9maW5hbGl6ZWQgaXMgdHJ1ZS5cbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIFJlc3VtYWJsZVVwbG9hZFN0YXR1cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXN1bWFibGVVcGxvYWRTdGF0dXMoY3VycmVudCwgdG90YWwsIGZpbmFsaXplZCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9ICEhZmluYWxpemVkO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFJlc3VtYWJsZVVwbG9hZFN0YXR1cztcbn0oKSk7XG5leHBvcnRzLlJlc3VtYWJsZVVwbG9hZFN0YXR1cyA9IFJlc3VtYWJsZVVwbG9hZFN0YXR1cztcbmZ1bmN0aW9uIGNoZWNrUmVzdW1lSGVhZGVyXyh4aHIsIG9wdF9hbGxvd2VkKSB7XG4gICAgdmFyIHN0YXR1cztcbiAgICB0cnkge1xuICAgICAgICBzdGF0dXMgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtR29vZy1VcGxvYWQtU3RhdHVzJyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XG4gICAgfVxuICAgIHZhciBhbGxvd2VkID0gb3B0X2FsbG93ZWQgfHwgWydhY3RpdmUnXTtcbiAgICBoYW5kbGVyQ2hlY2soYXJyYXkuY29udGFpbnMoYWxsb3dlZCwgc3RhdHVzKSk7XG4gICAgcmV0dXJuIHN0YXR1cztcbn1cbmV4cG9ydHMuY2hlY2tSZXN1bWVIZWFkZXJfID0gY2hlY2tSZXN1bWVIZWFkZXJfO1xuZnVuY3Rpb24gY3JlYXRlUmVzdW1hYmxlVXBsb2FkKGF1dGhXcmFwcGVyLCBsb2NhdGlvbiwgbWFwcGluZ3MsIGJsb2IsIG9wdF9tZXRhZGF0YSkge1xuICAgIHZhciB1cmxQYXJ0ID0gbG9jYXRpb24uYnVja2V0T25seVNlcnZlclVybCgpO1xuICAgIHZhciBtZXRhZGF0YSA9IG1ldGFkYXRhRm9yVXBsb2FkXyhsb2NhdGlvbiwgYmxvYiwgb3B0X21ldGFkYXRhKTtcbiAgICB2YXIgdXJsUGFyYW1zID0geyBuYW1lOiBtZXRhZGF0YVsnZnVsbFBhdGgnXSB9O1xuICAgIHZhciB1cmwgPSBVcmxVdGlscy5tYWtlVXBsb2FkVXJsKHVybFBhcnQpO1xuICAgIHZhciBtZXRob2QgPSAnUE9TVCc7XG4gICAgdmFyIGhlYWRlcnMgPSB7XG4gICAgICAgICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ3Jlc3VtYWJsZScsXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiAnc3RhcnQnLFxuICAgICAgICAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1MZW5ndGgnOiBibG9iLnNpemUoKSxcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtVHlwZSc6IG1ldGFkYXRhWydjb250ZW50VHlwZSddLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnXG4gICAgfTtcbiAgICB2YXIgYm9keSA9IE1ldGFkYXRhVXRpbHMudG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgbWFwcGluZ3MpO1xuICAgIHZhciB0aW1lb3V0ID0gYXV0aFdyYXBwZXIubWF4VXBsb2FkUmV0cnlUaW1lKCk7XG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIsIHRleHQpIHtcbiAgICAgICAgY2hlY2tSZXN1bWVIZWFkZXJfKHhocik7XG4gICAgICAgIHZhciB1cmw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cmwgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtR29vZy1VcGxvYWQtVVJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlckNoZWNrKHR5cGUuaXNTdHJpbmcodXJsKSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHZhciByZXF1ZXN0SW5mbyA9IG5ldyByZXF1ZXN0aW5mb18xLlJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBoYW5kbGVyLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby51cmxQYXJhbXMgPSB1cmxQYXJhbXM7XG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgcmVxdWVzdEluZm8uYm9keSA9IGJvZHk7XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG5leHBvcnRzLmNyZWF0ZVJlc3VtYWJsZVVwbG9hZCA9IGNyZWF0ZVJlc3VtYWJsZVVwbG9hZDtcbi8qKlxuICogQHBhcmFtIHVybCBGcm9tIGEgY2FsbCB0byBmYnMucmVxdWVzdHMuY3JlYXRlUmVzdW1hYmxlVXBsb2FkLlxuICovXG5mdW5jdGlvbiBnZXRSZXN1bWFibGVVcGxvYWRTdGF0dXMoYXV0aFdyYXBwZXIsIGxvY2F0aW9uLCB1cmwsIGJsb2IpIHtcbiAgICB2YXIgaGVhZGVycyA9IHsgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6ICdxdWVyeScgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkge1xuICAgICAgICB2YXIgc3RhdHVzID0gY2hlY2tSZXN1bWVIZWFkZXJfKHhociwgWydhY3RpdmUnLCAnZmluYWwnXSk7XG4gICAgICAgIHZhciBzaXplU3RyaW5nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2l6ZVN0cmluZyA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1Hb29nLVVwbG9hZC1TaXplLVJlY2VpdmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSBwYXJzZUludChzaXplU3RyaW5nLCAxMCk7XG4gICAgICAgIGhhbmRsZXJDaGVjayghaXNOYU4oc2l6ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cyhzaXplLCBibG9iLnNpemUoKSwgc3RhdHVzID09PSAnZmluYWwnKTtcbiAgICB9XG4gICAgdmFyIG1ldGhvZCA9ICdQT1NUJztcbiAgICB2YXIgdGltZW91dCA9IGF1dGhXcmFwcGVyLm1heFVwbG9hZFJldHJ5VGltZSgpO1xuICAgIHZhciByZXF1ZXN0SW5mbyA9IG5ldyByZXF1ZXN0aW5mb18xLlJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBoYW5kbGVyLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby5oZWFkZXJzID0gaGVhZGVycztcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmV4cG9ydHMuZ2V0UmVzdW1hYmxlVXBsb2FkU3RhdHVzID0gZ2V0UmVzdW1hYmxlVXBsb2FkU3RhdHVzO1xuLyoqXG4gKiBBbnkgdXBsb2FkcyB2aWEgdGhlIHJlc3VtYWJsZSB1cGxvYWQgQVBJIG11c3QgdHJhbnNmZXIgYSBudW1iZXIgb2YgYnl0ZXNcbiAqIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiB0aGlzIG51bWJlci5cbiAqL1xuZXhwb3J0cy5yZXN1bWFibGVVcGxvYWRDaHVua1NpemUgPSAyNTYgKiAxMDI0O1xuLyoqXG4gKiBAcGFyYW0gdXJsIEZyb20gYSBjYWxsIHRvIGZicy5yZXF1ZXN0cy5jcmVhdGVSZXN1bWFibGVVcGxvYWQuXG4gKiBAcGFyYW0gY2h1bmtTaXplIE51bWJlciBvZiBieXRlcyB0byB1cGxvYWQuXG4gKiBAcGFyYW0gb3B0X3N0YXR1cyBUaGUgcHJldmlvdXMgc3RhdHVzLlxuICogICAgIElmIG5vdCBwYXNzZWQgb3IgbnVsbCwgd2Ugc3RhcnQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICogQHRocm93cyBmYnMuRXJyb3IgSWYgdGhlIHVwbG9hZCBpcyBhbHJlYWR5IGNvbXBsZXRlLCB0aGUgcGFzc2VkIGluIHN0YXR1c1xuICogICAgIGhhcyBhIGZpbmFsIHNpemUgaW5jb25zaXN0ZW50IHdpdGggdGhlIGJsb2IsIG9yIHRoZSBibG9iIGNhbm5vdCBiZSBzbGljZWRcbiAqICAgICBmb3IgdXBsb2FkLlxuICovXG5mdW5jdGlvbiBjb250aW51ZVJlc3VtYWJsZVVwbG9hZChsb2NhdGlvbiwgYXV0aFdyYXBwZXIsIHVybCwgYmxvYiwgY2h1bmtTaXplLCBtYXBwaW5ncywgb3B0X3N0YXR1cywgb3B0X3Byb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAvLyBUT0RPKGFuZHlzb3RvKTogc3RhbmRhcmRpemUgb24gaW50ZXJuYWwgYXNzZXJ0c1xuICAgIC8vIGFzc2VydCghKG9wdF9zdGF0dXMgJiYgb3B0X3N0YXR1cy5maW5hbGl6ZWQpKTtcbiAgICB2YXIgc3RhdHVzID0gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cygwLCAwKTtcbiAgICBpZiAob3B0X3N0YXR1cykge1xuICAgICAgICBzdGF0dXMuY3VycmVudCA9IG9wdF9zdGF0dXMuY3VycmVudDtcbiAgICAgICAgc3RhdHVzLnRvdGFsID0gb3B0X3N0YXR1cy50b3RhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXR1cy5jdXJyZW50ID0gMDtcbiAgICAgICAgc3RhdHVzLnRvdGFsID0gYmxvYi5zaXplKCk7XG4gICAgfVxuICAgIGlmIChibG9iLnNpemUoKSAhPT0gc3RhdHVzLnRvdGFsKSB7XG4gICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuc2VydmVyRmlsZVdyb25nU2l6ZSgpO1xuICAgIH1cbiAgICB2YXIgYnl0ZXNMZWZ0ID0gc3RhdHVzLnRvdGFsIC0gc3RhdHVzLmN1cnJlbnQ7XG4gICAgdmFyIGJ5dGVzVG9VcGxvYWQgPSBieXRlc0xlZnQ7XG4gICAgaWYgKGNodW5rU2l6ZSA+IDApIHtcbiAgICAgICAgYnl0ZXNUb1VwbG9hZCA9IE1hdGgubWluKGJ5dGVzVG9VcGxvYWQsIGNodW5rU2l6ZSk7XG4gICAgfVxuICAgIHZhciBzdGFydEJ5dGUgPSBzdGF0dXMuY3VycmVudDtcbiAgICB2YXIgZW5kQnl0ZSA9IHN0YXJ0Qnl0ZSArIGJ5dGVzVG9VcGxvYWQ7XG4gICAgdmFyIHVwbG9hZENvbW1hbmQgPSBieXRlc1RvVXBsb2FkID09PSBieXRlc0xlZnQgPyAndXBsb2FkLCBmaW5hbGl6ZScgOiAndXBsb2FkJztcbiAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IHN0YXR1cy5jdXJyZW50XG4gICAgfTtcbiAgICB2YXIgYm9keSA9IGJsb2Iuc2xpY2Uoc3RhcnRCeXRlLCBlbmRCeXRlKTtcbiAgICBpZiAoYm9keSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmNhbm5vdFNsaWNlQmxvYigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkge1xuICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogVmVyaWZ5IHRoZSBNRDUgb2YgZWFjaCB1cGxvYWRlZCByYW5nZTpcbiAgICAgICAgLy8gdGhlICd4LXJhbmdlLW1kNScgaGVhZGVyIGNvbWVzIGJhY2sgd2l0aCBzdGF0dXMgY29kZSAzMDggcmVzcG9uc2VzLlxuICAgICAgICAvLyBXZSdsbCBvbmx5IGJlIGFibGUgdG8gYmFpbCBvdXQgdGhvdWdoLCBiZWNhdXNlIHlvdSBjYW4ndCByZS11cGxvYWQgYVxuICAgICAgICAvLyByYW5nZSB0aGF0IHlvdSBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAgICAgICB2YXIgdXBsb2FkU3RhdHVzID0gY2hlY2tSZXN1bWVIZWFkZXJfKHhociwgWydhY3RpdmUnLCAnZmluYWwnXSk7XG4gICAgICAgIHZhciBuZXdDdXJyZW50ID0gc3RhdHVzLmN1cnJlbnQgKyBieXRlc1RvVXBsb2FkO1xuICAgICAgICB2YXIgc2l6ZSA9IGJsb2Iuc2l6ZSgpO1xuICAgICAgICB2YXIgbWV0YWRhdGE7XG4gICAgICAgIGlmICh1cGxvYWRTdGF0dXMgPT09ICdmaW5hbCcpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGFIYW5kbGVyKGF1dGhXcmFwcGVyLCBtYXBwaW5ncykoeGhyLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cyhuZXdDdXJyZW50LCBzaXplLCB1cGxvYWRTdGF0dXMgPT09ICdmaW5hbCcsIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgdmFyIG1ldGhvZCA9ICdQT1NUJztcbiAgICB2YXIgdGltZW91dCA9IGF1dGhXcmFwcGVyLm1heFVwbG9hZFJldHJ5VGltZSgpO1xuICAgIHZhciByZXF1ZXN0SW5mbyA9IG5ldyByZXF1ZXN0aW5mb18xLlJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBoYW5kbGVyLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby5oZWFkZXJzID0gaGVhZGVycztcbiAgICByZXF1ZXN0SW5mby5ib2R5ID0gYm9keS51cGxvYWREYXRhKCk7XG4gICAgcmVxdWVzdEluZm8ucHJvZ3Jlc3NDYWxsYmFjayA9IG9wdF9wcm9ncmVzc0NhbGxiYWNrIHx8IG51bGw7XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG5leHBvcnRzLmNvbnRpbnVlUmVzdW1hYmxlVXBsb2FkID0gY29udGludWVSZXN1bWFibGVVcGxvYWQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3RzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIGVycm9yc0V4cG9ydHMgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbmV4cG9ydHMuU3RyaW5nRm9ybWF0ID0ge1xuICAgIFJBVzogJ3JhdycsXG4gICAgQkFTRTY0OiAnYmFzZTY0JyxcbiAgICBCQVNFNjRVUkw6ICdiYXNlNjR1cmwnLFxuICAgIERBVEFfVVJMOiAnZGF0YV91cmwnXG59O1xuZnVuY3Rpb24gZm9ybWF0VmFsaWRhdG9yKHN0cmluZ0Zvcm1hdCkge1xuICAgIHN3aXRjaCAoc3RyaW5nRm9ybWF0KSB7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TdHJpbmdGb3JtYXQuUkFXOlxuICAgICAgICBjYXNlIGV4cG9ydHMuU3RyaW5nRm9ybWF0LkJBU0U2NDpcbiAgICAgICAgY2FzZSBleHBvcnRzLlN0cmluZ0Zvcm1hdC5CQVNFNjRVUkw6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TdHJpbmdGb3JtYXQuREFUQV9VUkw6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgb25lIG9mIHRoZSBldmVudCB0eXBlczogWycgK1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuU3RyaW5nRm9ybWF0LlJBVyArXG4gICAgICAgICAgICAgICAgJywgJyArXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5TdHJpbmdGb3JtYXQuQkFTRTY0ICtcbiAgICAgICAgICAgICAgICAnLCAnICtcbiAgICAgICAgICAgICAgICBleHBvcnRzLlN0cmluZ0Zvcm1hdC5CQVNFNjRVUkwgK1xuICAgICAgICAgICAgICAgICcsICcgK1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuU3RyaW5nRm9ybWF0LkRBVEFfVVJMICtcbiAgICAgICAgICAgICAgICAnXS4nO1xuICAgIH1cbn1cbmV4cG9ydHMuZm9ybWF0VmFsaWRhdG9yID0gZm9ybWF0VmFsaWRhdG9yO1xuLyoqXG4gKiBAc3RydWN0XG4gKi9cbnZhciBTdHJpbmdEYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ0RhdGEoZGF0YSwgb3B0X2NvbnRlbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBvcHRfY29udGVudFR5cGUgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZ0RhdGE7XG59KCkpO1xuZXhwb3J0cy5TdHJpbmdEYXRhID0gU3RyaW5nRGF0YTtcbmZ1bmN0aW9uIGRhdGFGcm9tU3RyaW5nKGZvcm1hdCwgc3RyaW5nKSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSBleHBvcnRzLlN0cmluZ0Zvcm1hdC5SQVc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0RhdGEodXRmOEJ5dGVzXyhzdHJpbmcpKTtcbiAgICAgICAgY2FzZSBleHBvcnRzLlN0cmluZ0Zvcm1hdC5CQVNFNjQ6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TdHJpbmdGb3JtYXQuQkFTRTY0VVJMOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdEYXRhKGJhc2U2NEJ5dGVzXyhmb3JtYXQsIHN0cmluZykpO1xuICAgICAgICBjYXNlIGV4cG9ydHMuU3RyaW5nRm9ybWF0LkRBVEFfVVJMOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdEYXRhKGRhdGFVUkxCeXRlc18oc3RyaW5nKSwgZGF0YVVSTENvbnRlbnRUeXBlXyhzdHJpbmcpKTtcbiAgICB9XG4gICAgLy8gYXNzZXJ0KGZhbHNlKTtcbiAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLnVua25vd24oKTtcbn1cbmV4cG9ydHMuZGF0YUZyb21TdHJpbmcgPSBkYXRhRnJvbVN0cmluZztcbmZ1bmN0aW9uIHV0ZjhCeXRlc18oc3RyaW5nKSB7XG4gICAgdmFyIGIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAxMjcpIHtcbiAgICAgICAgICAgIGIucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjIDw9IDIwNDcpIHtcbiAgICAgICAgICAgICAgICBiLnB1c2goMTkyIHwgKGMgPj4gNiksIDEyOCB8IChjICYgNjMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgoYyAmIDY0NTEyKSA9PSA1NTI5Nikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc3RhcnQgb2YgYSBzdXJyb2dhdGUgcGFpci5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkID0gaSA8IHN0cmluZy5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgNjQ1MTIpID09IDU2MzIwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2Vjb25kIHN1cnJvZ2F0ZSB3YXNuJ3QgdGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGkgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvID0gc3RyaW5nLmNoYXJDb2RlQXQoKytpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSA2NTUzNiB8ICgoaGkgJiAxMDIzKSA8PCAxMCkgfCAobG8gJiAxMDIzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyNDAgfCAoYyA+PiAxOCksIDEyOCB8ICgoYyA+PiAxMikgJiA2MyksIDEyOCB8ICgoYyA+PiA2KSAmIDYzKSwgMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT0gNTYzMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgbG93IHN1cnJvZ2F0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyMjQgfCAoYyA+PiAxMiksIDEyOCB8ICgoYyA+PiA2KSAmIDYzKSwgMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShiKTtcbn1cbmV4cG9ydHMudXRmOEJ5dGVzXyA9IHV0ZjhCeXRlc187XG5mdW5jdGlvbiBwZXJjZW50RW5jb2RlZEJ5dGVzXyhzdHJpbmcpIHtcbiAgICB2YXIgZGVjb2RlZDtcbiAgICB0cnkge1xuICAgICAgICBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KHN0cmluZyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuaW52YWxpZEZvcm1hdChleHBvcnRzLlN0cmluZ0Zvcm1hdC5EQVRBX1VSTCwgJ01hbGZvcm1lZCBkYXRhIFVSTC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0ZjhCeXRlc18oZGVjb2RlZCk7XG59XG5leHBvcnRzLnBlcmNlbnRFbmNvZGVkQnl0ZXNfID0gcGVyY2VudEVuY29kZWRCeXRlc187XG5mdW5jdGlvbiBiYXNlNjRCeXRlc18oZm9ybWF0LCBzdHJpbmcpIHtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICBjYXNlIGV4cG9ydHMuU3RyaW5nRm9ybWF0LkJBU0U2NDoge1xuICAgICAgICAgICAgdmFyIGhhc01pbnVzID0gc3RyaW5nLmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gICAgICAgICAgICB2YXIgaGFzVW5kZXIgPSBzdHJpbmcuaW5kZXhPZignXycpICE9PSAtMTtcbiAgICAgICAgICAgIGlmIChoYXNNaW51cyB8fCBoYXNVbmRlcikge1xuICAgICAgICAgICAgICAgIHZhciBpbnZhbGlkQ2hhciA9IGhhc01pbnVzID8gJy0nIDogJ18nO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuaW52YWxpZEZvcm1hdChmb3JtYXQsIFwiSW52YWxpZCBjaGFyYWN0ZXIgJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZENoYXIgK1xuICAgICAgICAgICAgICAgICAgICBcIicgZm91bmQ6IGlzIGl0IGJhc2U2NHVybCBlbmNvZGVkP1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TdHJpbmdGb3JtYXQuQkFTRTY0VVJMOiB7XG4gICAgICAgICAgICB2YXIgaGFzUGx1cyA9IHN0cmluZy5pbmRleE9mKCcrJykgIT09IC0xO1xuICAgICAgICAgICAgdmFyIGhhc1NsYXNoID0gc3RyaW5nLmluZGV4T2YoJy8nKSAhPT0gLTE7XG4gICAgICAgICAgICBpZiAoaGFzUGx1cyB8fCBoYXNTbGFzaCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnZhbGlkQ2hhciA9IGhhc1BsdXMgPyAnKycgOiAnLyc7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzRXhwb3J0cy5pbnZhbGlkRm9ybWF0KGZvcm1hdCwgXCJJbnZhbGlkIGNoYXJhY3RlciAnXCIgKyBpbnZhbGlkQ2hhciArIFwiJyBmb3VuZDogaXMgaXQgYmFzZTY0IGVuY29kZWQ/XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYnl0ZXM7XG4gICAgdHJ5IHtcbiAgICAgICAgYnl0ZXMgPSBhdG9iKHN0cmluZyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuaW52YWxpZEZvcm1hdChmb3JtYXQsICdJbnZhbGlkIGNoYXJhY3RlciBmb3VuZCcpO1xuICAgIH1cbiAgICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmJhc2U2NEJ5dGVzXyA9IGJhc2U2NEJ5dGVzXztcbi8qKlxuICogQHN0cnVjdFxuICovXG52YXIgRGF0YVVSTFBhcnRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGFVUkxQYXJ0cyhkYXRhVVJMKSB7XG4gICAgICAgIHRoaXMuYmFzZTY0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBudWxsO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGRhdGFVUkwubWF0Y2goL15kYXRhOihbXixdKyk/LC8pO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzRXhwb3J0cy5pbnZhbGlkRm9ybWF0KGV4cG9ydHMuU3RyaW5nRm9ybWF0LkRBVEFfVVJMLCBcIk11c3QgYmUgZm9ybWF0dGVkICdkYXRhOls8bWVkaWF0eXBlPl1bO2Jhc2U2NF0sPGRhdGE+XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaWRkbGUgPSBtYXRjaGVzWzFdIHx8IG51bGw7XG4gICAgICAgIGlmIChtaWRkbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iYXNlNjQgPSBlbmRzV2l0aChtaWRkbGUsICc7YmFzZTY0Jyk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gdGhpcy5iYXNlNjRcbiAgICAgICAgICAgICAgICA/IG1pZGRsZS5zdWJzdHJpbmcoMCwgbWlkZGxlLmxlbmd0aCAtICc7YmFzZTY0Jy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgOiBtaWRkbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN0ID0gZGF0YVVSTC5zdWJzdHJpbmcoZGF0YVVSTC5pbmRleE9mKCcsJykgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIERhdGFVUkxQYXJ0cztcbn0oKSk7XG5mdW5jdGlvbiBkYXRhVVJMQnl0ZXNfKHN0cmluZykge1xuICAgIHZhciBwYXJ0cyA9IG5ldyBEYXRhVVJMUGFydHMoc3RyaW5nKTtcbiAgICBpZiAocGFydHMuYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBiYXNlNjRCeXRlc18oZXhwb3J0cy5TdHJpbmdGb3JtYXQuQkFTRTY0LCBwYXJ0cy5yZXN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwZXJjZW50RW5jb2RlZEJ5dGVzXyhwYXJ0cy5yZXN0KTtcbiAgICB9XG59XG5leHBvcnRzLmRhdGFVUkxCeXRlc18gPSBkYXRhVVJMQnl0ZXNfO1xuZnVuY3Rpb24gZGF0YVVSTENvbnRlbnRUeXBlXyhzdHJpbmcpIHtcbiAgICB2YXIgcGFydHMgPSBuZXcgRGF0YVVSTFBhcnRzKHN0cmluZyk7XG4gICAgcmV0dXJuIHBhcnRzLmNvbnRlbnRUeXBlO1xufVxuZXhwb3J0cy5kYXRhVVJMQ29udGVudFR5cGVfID0gZGF0YVVSTENvbnRlbnRUeXBlXztcbmZ1bmN0aW9uIGVuZHNXaXRoKHMsIGVuZCkge1xuICAgIHZhciBsb25nRW5vdWdoID0gcy5sZW5ndGggPj0gZW5kLmxlbmd0aDtcbiAgICBpZiAoIWxvbmdFbm91Z2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcy5zdWJzdHJpbmcocy5sZW5ndGggLSBlbmQubGVuZ3RoKSA9PT0gZW5kO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRhc2tFdmVudCA9IHtcbiAgICAvKiogVHJpZ2dlcmVkIHdoZW5ldmVyIHRoZSB0YXNrIGNoYW5nZXMgb3IgcHJvZ3Jlc3MgaXMgdXBkYXRlZC4gKi9cbiAgICBTVEFURV9DSEFOR0VEOiAnc3RhdGVfY2hhbmdlZCdcbn07XG5leHBvcnRzLkludGVybmFsVGFza1N0YXRlID0ge1xuICAgIFJVTk5JTkc6ICdydW5uaW5nJyxcbiAgICBQQVVTSU5HOiAncGF1c2luZycsXG4gICAgUEFVU0VEOiAncGF1c2VkJyxcbiAgICBTVUNDRVNTOiAnc3VjY2VzcycsXG4gICAgQ0FOQ0VMSU5HOiAnY2FuY2VsaW5nJyxcbiAgICBDQU5DRUxFRDogJ2NhbmNlbGVkJyxcbiAgICBFUlJPUjogJ2Vycm9yJ1xufTtcbmV4cG9ydHMuVGFza1N0YXRlID0ge1xuICAgIC8qKiBUaGUgdGFzayBpcyBjdXJyZW50bHkgdHJhbnNmZXJyaW5nIGRhdGEuICovXG4gICAgUlVOTklORzogJ3J1bm5pbmcnLFxuICAgIC8qKiBUaGUgdGFzayB3YXMgcGF1c2VkIGJ5IHRoZSB1c2VyLiAqL1xuICAgIFBBVVNFRDogJ3BhdXNlZCcsXG4gICAgLyoqIFRoZSB0YXNrIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuICovXG4gICAgU1VDQ0VTUzogJ3N1Y2Nlc3MnLFxuICAgIC8qKiBUaGUgdGFzayB3YXMgY2FuY2VsZWQuICovXG4gICAgQ0FOQ0VMRUQ6ICdjYW5jZWxlZCcsXG4gICAgLyoqIFRoZSB0YXNrIGZhaWxlZCB3aXRoIGFuIGVycm9yLiAqL1xuICAgIEVSUk9SOiAnZXJyb3InXG59O1xuZnVuY3Rpb24gdGFza1N0YXRlRnJvbUludGVybmFsVGFza1N0YXRlKHN0YXRlKSB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIGV4cG9ydHMuSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORzpcbiAgICAgICAgY2FzZSBleHBvcnRzLkludGVybmFsVGFza1N0YXRlLlBBVVNJTkc6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5JbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UYXNrU3RhdGUuUlVOTklORztcbiAgICAgICAgY2FzZSBleHBvcnRzLkludGVybmFsVGFza1N0YXRlLlBBVVNFRDpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlRhc2tTdGF0ZS5QQVVTRUQ7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5JbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVGFza1N0YXRlLlNVQ0NFU1M7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5JbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRDpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlRhc2tTdGF0ZS5DQU5DRUxFRDtcbiAgICAgICAgY2FzZSBleHBvcnRzLkludGVybmFsVGFza1N0YXRlLkVSUk9SOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVGFza1N0YXRlLkVSUk9SO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UYXNrU3RhdGUuRVJST1I7XG4gICAgfVxufVxuZXhwb3J0cy50YXNrU3RhdGVGcm9tSW50ZXJuYWxUYXNrU3RhdGUgPSB0YXNrU3RhdGVGcm9tSW50ZXJuYWxUYXNrU3RhdGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhc2tlbnVtcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQHJldHVybiBGYWxzZSBpZiB0aGUgb2JqZWN0IGlzIHVuZGVmaW5lZCBvciBudWxsLCB0cnVlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNEZWYocCkge1xuICAgIHJldHVybiBwICE9IG51bGw7XG59XG5leHBvcnRzLmlzRGVmID0gaXNEZWY7XG5mdW5jdGlvbiBpc0p1c3REZWYocCkge1xuICAgIHJldHVybiBwICE9PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzSnVzdERlZiA9IGlzSnVzdERlZjtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24ocCkge1xuICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5mdW5jdGlvbiBpc09iamVjdChwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdChwKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHApICYmIHAgIT09IG51bGw7XG59XG5leHBvcnRzLmlzTm9uTnVsbE9iamVjdCA9IGlzTm9uTnVsbE9iamVjdDtcbmZ1bmN0aW9uIGlzTm9uQXJyYXlPYmplY3QocCkge1xuICAgIHJldHVybiBpc09iamVjdChwKSAmJiAhQXJyYXkuaXNBcnJheShwKTtcbn1cbmV4cG9ydHMuaXNOb25BcnJheU9iamVjdCA9IGlzTm9uQXJyYXlPYmplY3Q7XG5mdW5jdGlvbiBpc1N0cmluZyhwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJyB8fCBwIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZnVuY3Rpb24gaXNOdW1iZXIocCkge1xuICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ251bWJlcicgfHwgcCBpbnN0YW5jZW9mIE51bWJlcjtcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmZ1bmN0aW9uIGlzTmF0aXZlQmxvYihwKSB7XG4gICAgcmV0dXJuIGlzTmF0aXZlQmxvYkRlZmluZWQoKSAmJiBwIGluc3RhbmNlb2YgQmxvYjtcbn1cbmV4cG9ydHMuaXNOYXRpdmVCbG9iID0gaXNOYXRpdmVCbG9iO1xuZnVuY3Rpb24gaXNOYXRpdmVCbG9iRGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc05hdGl2ZUJsb2JEZWZpbmVkID0gaXNOYXRpdmVCbG9iRGVmaW5lZDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBGdW5jdGlvbnMgdG8gY3JlYXRlIGFuZCBtYW5pcHVsYXRlIFVSTHMgZm9yIHRoZSBzZXJ2ZXIgQVBJLlxuICovXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIG9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbmZ1bmN0aW9uIG1ha2VOb3JtYWxVcmwodXJsUGFydCkge1xuICAgIHJldHVybiBjb25zdGFudHMuZG9tYWluQmFzZSArIGNvbnN0YW50cy5hcGlCYXNlVXJsICsgdXJsUGFydDtcbn1cbmV4cG9ydHMubWFrZU5vcm1hbFVybCA9IG1ha2VOb3JtYWxVcmw7XG5mdW5jdGlvbiBtYWtlRG93bmxvYWRVcmwodXJsUGFydCkge1xuICAgIHJldHVybiBjb25zdGFudHMuZG93bmxvYWRCYXNlICsgY29uc3RhbnRzLmFwaUJhc2VVcmwgKyB1cmxQYXJ0O1xufVxuZXhwb3J0cy5tYWtlRG93bmxvYWRVcmwgPSBtYWtlRG93bmxvYWRVcmw7XG5mdW5jdGlvbiBtYWtlVXBsb2FkVXJsKHVybFBhcnQpIHtcbiAgICByZXR1cm4gY29uc3RhbnRzLmRvbWFpbkJhc2UgKyBjb25zdGFudHMuYXBpVXBsb2FkQmFzZVVybCArIHVybFBhcnQ7XG59XG5leHBvcnRzLm1ha2VVcGxvYWRVcmwgPSBtYWtlVXBsb2FkVXJsO1xuZnVuY3Rpb24gbWFrZVF1ZXJ5U3RyaW5nKHBhcmFtcykge1xuICAgIHZhciBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG4gICAgdmFyIHF1ZXJ5UGFydCA9ICc/JztcbiAgICBvYmplY3QuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICB2YXIgbmV4dFBhcnQgPSBlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwpO1xuICAgICAgICBxdWVyeVBhcnQgPSBxdWVyeVBhcnQgKyBuZXh0UGFydCArICcmJztcbiAgICB9KTtcbiAgICAvLyBDaG9wIG9mZiB0aGUgZXh0cmEgJyYnIG9yICc/JyBvbiB0aGUgZW5kXG4gICAgcXVlcnlQYXJ0ID0gcXVlcnlQYXJ0LnNsaWNlKDAsIC0xKTtcbiAgICByZXR1cm4gcXVlcnlQYXJ0O1xufVxuZXhwb3J0cy5tYWtlUXVlcnlTdHJpbmcgPSBtYWtlUXVlcnlTdHJpbmc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGVudW17bnVtYmVyfVxuICovXG52YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTk9fRVJST1JcIl0gPSAwXSA9IFwiTk9fRVJST1JcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTkVUV09SS19FUlJPUlwiXSA9IDFdID0gXCJORVRXT1JLX0VSUk9SXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkFCT1JUXCJdID0gMl0gPSBcIkFCT1JUXCI7XG59KShFcnJvckNvZGUgPSBleHBvcnRzLkVycm9yQ29kZSB8fCAoZXhwb3J0cy5FcnJvckNvZGUgPSB7fSkpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD14aHJpby5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBlcnJvcnNFeHBvcnRzID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG52YXIgb2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xudmFyIHByb21pc2VpbXBsID0gcmVxdWlyZShcIi4vcHJvbWlzZV9leHRlcm5hbFwiKTtcbnZhciB0eXBlID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbnZhciBYaHJJb0V4cG9ydHMgPSByZXF1aXJlKFwiLi94aHJpb1wiKTtcbi8qKlxuICogV2UgdXNlIHRoaXMgaW5zdGVhZCBvZiBnb29nLm5ldC5YaHJJbyBiZWNhdXNlIGdvb2cubmV0LlhocklvIGlzIGh5dXV1dWdlIGFuZFxuICogZG9lc24ndCB3b3JrIGluIFJlYWN0IE5hdGl2ZSBvbiBBbmRyb2lkLlxuICovXG52YXIgTmV0d29ya1hocklvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtYaHJJbygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zZW50XyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnhocl8gPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgdGhpcy5lcnJvckNvZGVfID0gWGhySW9FeHBvcnRzLkVycm9yQ29kZS5OT19FUlJPUjtcbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZV8gPSBwcm9taXNlaW1wbC5tYWtlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLnhocl8uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lcnJvckNvZGVfID0gWGhySW9FeHBvcnRzLkVycm9yQ29kZS5BQk9SVDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMueGhyXy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVycm9yQ29kZV8gPSBYaHJJb0V4cG9ydHMuRXJyb3JDb2RlLk5FVFdPUktfRVJST1I7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLnhocl8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBOZXR3b3JrWGhySW8ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAodXJsLCBtZXRob2QsIG9wdF9ib2R5LCBvcHRfaGVhZGVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zZW50Xykge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzRXhwb3J0cy5pbnRlcm5hbEVycm9yKCdjYW5ub3QgLnNlbmQoKSBtb3JlIHRoYW4gb25jZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VudF8gPSB0cnVlO1xuICAgICAgICB0aGlzLnhocl8ub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICAgIGlmICh0eXBlLmlzRGVmKG9wdF9oZWFkZXJzKSkge1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBvcHRfaGVhZGVycztcbiAgICAgICAgICAgIG9iamVjdC5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnhocl8uc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlLmlzRGVmKG9wdF9ib2R5KSkge1xuICAgICAgICAgICAgdGhpcy54aHJfLnNlbmQob3B0X2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54aHJfLnNlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kUHJvbWlzZV87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBOZXR3b3JrWGhySW8ucHJvdG90eXBlLmdldEVycm9yQ29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbnRfKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0RXJyb3JDb2RlKCkgYmVmb3JlIHNlbmRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvZGVfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgTmV0d29ya1hocklvLnByb3RvdHlwZS5nZXRTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZW50Xykge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzRXhwb3J0cy5pbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldFN0YXR1cygpIGJlZm9yZSBzZW5kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhocl8uc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIE5ldHdvcmtYaHJJby5wcm90b3R5cGUuZ2V0UmVzcG9uc2VUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VudF8pIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuaW50ZXJuYWxFcnJvcignY2Fubm90IC5nZXRSZXNwb25zZVRleHQoKSBiZWZvcmUgc2VuZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnhocl8ucmVzcG9uc2VUZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIE5ldHdvcmtYaHJJby5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMueGhyXy5hYm9ydCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgTmV0d29ya1hocklvLnByb3RvdHlwZS5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueGhyXy5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgTmV0d29ya1hocklvLnByb3RvdHlwZS5hZGRVcGxvYWRQcm9ncmVzc0xpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlLmlzRGVmKHRoaXMueGhyXy51cGxvYWQpKSB7XG4gICAgICAgICAgICB0aGlzLnhocl8udXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBOZXR3b3JrWGhySW8ucHJvdG90eXBlLnJlbW92ZVVwbG9hZFByb2dyZXNzTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHR5cGUuaXNEZWYodGhpcy54aHJfLnVwbG9hZCkpIHtcbiAgICAgICAgICAgIHRoaXMueGhyXy51cGxvYWQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZXR3b3JrWGhySW87XG59KCkpO1xuZXhwb3J0cy5OZXR3b3JrWGhySW8gPSBOZXR3b3JrWGhySW87XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhocmlvX25ldHdvcmsuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeGhyaW9fbmV0d29ya18xID0gcmVxdWlyZShcIi4veGhyaW9fbmV0d29ya1wiKTtcbi8qKlxuICogRmFjdG9yeS1saWtlIGNsYXNzIGZvciBjcmVhdGluZyBYaHJJbyBpbnN0YW5jZXMuXG4gKi9cbnZhciBYaHJJb1Bvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWGhySW9Qb29sKCkge1xuICAgIH1cbiAgICBYaHJJb1Bvb2wucHJvdG90eXBlLmNyZWF0ZVhocklvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IHhocmlvX25ldHdvcmtfMS5OZXR3b3JrWGhySW8oKTtcbiAgICB9O1xuICAgIHJldHVybiBYaHJJb1Bvb2w7XG59KCkpO1xuZXhwb3J0cy5YaHJJb1Bvb2wgPSBYaHJJb1Bvb2w7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhocmlvcG9vbC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBEZWZpbmVzIHRoZSBGaXJlYmFzZSBTdG9yYWdlIFJlZmVyZW5jZSBjbGFzcy5cbiAqL1xudmFyIGFyZ3MgPSByZXF1aXJlKFwiLi9pbXBsZW1lbnRhdGlvbi9hcmdzXCIpO1xudmFyIGJsb2JfMSA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL2Jsb2JcIik7XG52YXIgZXJyb3JzRXhwb3J0cyA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL2Vycm9yXCIpO1xudmFyIGxvY2F0aW9uXzEgPSByZXF1aXJlKFwiLi9pbXBsZW1lbnRhdGlvbi9sb2NhdGlvblwiKTtcbnZhciBtZXRhZGF0YSA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL21ldGFkYXRhXCIpO1xudmFyIG9iamVjdCA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL29iamVjdFwiKTtcbnZhciBwYXRoID0gcmVxdWlyZShcIi4vaW1wbGVtZW50YXRpb24vcGF0aFwiKTtcbnZhciByZXF1ZXN0cyA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL3JlcXVlc3RzXCIpO1xudmFyIGZic1N0cmluZyA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL3N0cmluZ1wiKTtcbnZhciBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL3N0cmluZ1wiKTtcbnZhciB0eXBlID0gcmVxdWlyZShcIi4vaW1wbGVtZW50YXRpb24vdHlwZVwiKTtcbnZhciB0YXNrXzEgPSByZXF1aXJlKFwiLi90YXNrXCIpO1xuLyoqXG4gKiBQcm92aWRlcyBtZXRob2RzIHRvIGludGVyYWN0IHdpdGggYSBidWNrZXQgaW4gdGhlIEZpcmViYXNlIFN0b3JhZ2Ugc2VydmljZS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBBbiBmYnMubG9jYXRpb24sIG9yIHRoZSBVUkwgYXRcbiAqICAgICB3aGljaCB0byBiYXNlIHRoaXMgb2JqZWN0LCBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcbiAqICAgICAgICAgZ3M6Ly88YnVja2V0Pi88b2JqZWN0LXBhdGg+XG4gKiAgICAgICAgIGh0dHBbc106Ly9maXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vXG4gKiAgICAgICAgICAgICAgICAgICAgIDxhcGktdmVyc2lvbj4vYi88YnVja2V0Pi9vLzxvYmplY3QtcGF0aD5cbiAqICAgICBBbnkgcXVlcnkgb3IgZnJhZ21lbnQgc3RyaW5ncyB3aWxsIGJlIGlnbm9yZWQgaW4gdGhlIGh0dHBbc11cbiAqICAgICBmb3JtYXQuIElmIG5vIHZhbHVlIGlzIHBhc3NlZCwgdGhlIHN0b3JhZ2Ugb2JqZWN0IHdpbGwgdXNlIGEgVVJMIGJhc2VkIG9uXG4gKiAgICAgdGhlIHByb2plY3QgSUQgb2YgdGhlIGJhc2UgZmlyZWJhc2UuQXBwIGluc3RhbmNlLlxuICovXG52YXIgUmVmZXJlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZShhdXRoV3JhcHBlciwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5hdXRoV3JhcHBlciA9IGF1dGhXcmFwcGVyO1xuICAgICAgICBpZiAobG9jYXRpb24gaW5zdGFuY2VvZiBsb2NhdGlvbl8xLkxvY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb25fMS5Mb2NhdGlvbi5tYWtlRnJvbVVybChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgVVJMIGZvciB0aGUgYnVja2V0IGFuZCBwYXRoIHRoaXMgb2JqZWN0IHJlZmVyZW5jZXMsXG4gICAgICogICAgIGluIHRoZSBmb3JtIGdzOi8vPGJ1Y2tldD4vPG9iamVjdC1wYXRoPlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFyZ3MudmFsaWRhdGUoJ3RvU3RyaW5nJywgW10sIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiAnZ3M6Ly8nICsgdGhpcy5sb2NhdGlvbi5idWNrZXQgKyAnLycgKyB0aGlzLmxvY2F0aW9uLnBhdGg7XG4gICAgfTtcbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLm5ld1JlZiA9IGZ1bmN0aW9uIChhdXRoV3JhcHBlciwgbG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2UoYXV0aFdyYXBwZXIsIGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUubWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YS5nZXRNYXBwaW5ncygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBBIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IG9idGFpbmVkIGJ5XG4gICAgICogICAgIGFwcGVuZGluZyBjaGlsZFBhdGgsIHJlbW92aW5nIGFueSBkdXBsaWNhdGUsIGJlZ2lubmluZywgb3IgdHJhaWxpbmdcbiAgICAgKiAgICAgc2xhc2hlcy5cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gKGNoaWxkUGF0aCkge1xuICAgICAgICBhcmdzLnZhbGlkYXRlKCdjaGlsZCcsIFthcmdzLnN0cmluZ1NwZWMoKV0sIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBuZXdQYXRoID0gcGF0aC5jaGlsZCh0aGlzLmxvY2F0aW9uLnBhdGgsIGNoaWxkUGF0aCk7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IG5ldyBsb2NhdGlvbl8xLkxvY2F0aW9uKHRoaXMubG9jYXRpb24uYnVja2V0LCBuZXdQYXRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3UmVmKHRoaXMuYXV0aFdyYXBwZXIsIGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZlcmVuY2UucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIEEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgb2YgdGhlXG4gICAgICAgICAqICAgICBjdXJyZW50IG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgY3VycmVudCBvYmplY3QgaXMgdGhlIHJvb3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoID0gcGF0aC5wYXJlbnQodGhpcy5sb2NhdGlvbi5wYXRoKTtcbiAgICAgICAgICAgIGlmIChuZXdQYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBuZXcgbG9jYXRpb25fMS5Mb2NhdGlvbih0aGlzLmxvY2F0aW9uLmJ1Y2tldCwgbmV3UGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXdSZWYodGhpcy5hdXRoV3JhcHBlciwgbG9jYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJyb290XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gQW4gcmVmZXJlbmNlIHRvIHRoZSByb290IG9mIHRoaXNcbiAgICAgICAgICogICAgIG9iamVjdCdzIGJ1Y2tldC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gbmV3IGxvY2F0aW9uXzEuTG9jYXRpb24odGhpcy5sb2NhdGlvbi5idWNrZXQsICcnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld1JlZih0aGlzLmF1dGhXcmFwcGVyLCBsb2NhdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZlcmVuY2UucHJvdG90eXBlLCBcImJ1Y2tldFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24uYnVja2V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJmdWxsUGF0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24ucGF0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmVyZW5jZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGgubGFzdENvbXBvbmVudCh0aGlzLmxvY2F0aW9uLnBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJzdG9yYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoV3JhcHBlci5zZXJ2aWNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBibG9iIHRvIHRoaXMgb2JqZWN0J3MgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGJsb2IgdG8gdXBsb2FkLlxuICAgICAqIEByZXR1cm4gQW4gVXBsb2FkVGFzayB0aGF0IGxldHMgeW91IGNvbnRyb2wgYW5kXG4gICAgICogICAgIG9ic2VydmUgdGhlIHVwbG9hZC5cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChkYXRhLCBtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEgPT09IHZvaWQgMCkgeyBtZXRhZGF0YSA9IG51bGw7IH1cbiAgICAgICAgYXJncy52YWxpZGF0ZSgncHV0JywgW2FyZ3MudXBsb2FkRGF0YVNwZWMoKSwgYXJncy5tZXRhZGF0YVNwZWModHJ1ZSldLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRocm93SWZSb290XygncHV0Jyk7XG4gICAgICAgIHJldHVybiBuZXcgdGFza18xLlVwbG9hZFRhc2sodGhpcywgdGhpcy5hdXRoV3JhcHBlciwgdGhpcy5sb2NhdGlvbiwgdGhpcy5tYXBwaW5ncygpLCBuZXcgYmxvYl8xLkZic0Jsb2IoZGF0YSksIG1ldGFkYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBzdHJpbmcgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSBvcHRfZm9ybWF0IFRoZSBmb3JtYXQgb2YgdGhlIHN0cmluZyB0byB1cGxvYWQuXG4gICAgICogQHJldHVybiBBbiBVcGxvYWRUYXNrIHRoYXQgbGV0cyB5b3UgY29udHJvbCBhbmRcbiAgICAgKiAgICAgb2JzZXJ2ZSB0aGUgdXBsb2FkLlxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUucHV0U3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZywgZm9ybWF0LCBvcHRfbWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7IGZvcm1hdCA9IHN0cmluZ18xLlN0cmluZ0Zvcm1hdC5SQVc7IH1cbiAgICAgICAgYXJncy52YWxpZGF0ZSgncHV0U3RyaW5nJywgW1xuICAgICAgICAgICAgYXJncy5zdHJpbmdTcGVjKCksXG4gICAgICAgICAgICBhcmdzLnN0cmluZ1NwZWMoZmJzU3RyaW5nLmZvcm1hdFZhbGlkYXRvciwgdHJ1ZSksXG4gICAgICAgICAgICBhcmdzLm1ldGFkYXRhU3BlYyh0cnVlKVxuICAgICAgICBdLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRocm93SWZSb290XygncHV0U3RyaW5nJyk7XG4gICAgICAgIHZhciBkYXRhID0gZmJzU3RyaW5nLmRhdGFGcm9tU3RyaW5nKGZvcm1hdCwgc3RyaW5nKTtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gb2JqZWN0LmNsb25lKG9wdF9tZXRhZGF0YSk7XG4gICAgICAgIGlmICghdHlwZS5pc0RlZihtZXRhZGF0YVsnY29udGVudFR5cGUnXSkgJiYgdHlwZS5pc0RlZihkYXRhLmNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgbWV0YWRhdGFbJ2NvbnRlbnRUeXBlJ10gPSBkYXRhLmNvbnRlbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGFza18xLlVwbG9hZFRhc2sodGhpcywgdGhpcy5hdXRoV3JhcHBlciwgdGhpcy5sb2NhdGlvbiwgdGhpcy5tYXBwaW5ncygpLCBuZXcgYmxvYl8xLkZic0Jsb2IoZGF0YS5kYXRhLCB0cnVlKSwgbWV0YWRhdGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgb2JqZWN0IGF0IHRoaXMgbG9jYXRpb24uXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBpZiB0aGUgZGVsZXRpb24gc3VjY2VlZHMuXG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFyZ3MudmFsaWRhdGUoJ2RlbGV0ZScsIFtdLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRocm93SWZSb290XygnZGVsZXRlJyk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFdyYXBwZXIuZ2V0QXV0aFRva2VuKCkudGhlbihmdW5jdGlvbiAoYXV0aFRva2VuKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdEluZm8gPSByZXF1ZXN0cy5kZWxldGVPYmplY3Qoc2VsZi5hdXRoV3JhcHBlciwgc2VsZi5sb2NhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5hdXRoV3JhcHBlci5tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgYXV0aFRva2VuKS5nZXRQcm9taXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogICAgIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG1ldGFkYXRhIGZvciB0aGlzIG9iamVjdC4gSWYgdGhpc1xuICAgICAqICAgICBvYmplY3QgZG9lc24ndCBleGlzdCBvciBtZXRhZGF0YSBjYW5ub3QgYmUgcmV0cmVpdmVkLCB0aGUgcHJvbWlzZSBpc1xuICAgICAqICAgICByZWplY3RlZC5cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLmdldE1ldGFkYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhcmdzLnZhbGlkYXRlKCdnZXRNZXRhZGF0YScsIFtdLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRocm93SWZSb290XygnZ2V0TWV0YWRhdGEnKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoV3JhcHBlci5nZXRBdXRoVG9rZW4oKS50aGVuKGZ1bmN0aW9uIChhdXRoVG9rZW4pIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0SW5mbyA9IHJlcXVlc3RzLmdldE1ldGFkYXRhKHNlbGYuYXV0aFdyYXBwZXIsIHNlbGYubG9jYXRpb24sIHNlbGYubWFwcGluZ3MoKSk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5hdXRoV3JhcHBlci5tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgYXV0aFRva2VuKS5nZXRQcm9taXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YSBUaGUgbmV3IG1ldGFkYXRhIGZvciB0aGUgb2JqZWN0LlxuICAgICAqICAgICBPbmx5IHZhbHVlcyB0aGF0IGhhdmUgYmVlbiBleHBsaWNpdGx5IHNldCB3aWxsIGJlIGNoYW5nZWQuIEV4cGxpY2l0bHlcbiAgICAgKiAgICAgc2V0dGluZyBhIHZhbHVlIHRvIG51bGwgd2lsbCByZW1vdmUgdGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXNcbiAgICAgKiAgICAgd2l0aCB0aGUgbmV3IG1ldGFkYXRhIGZvciB0aGlzIG9iamVjdC5cbiAgICAgKiAgICAgQHNlZSBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlLnByb3RvdHlwZS5nZXRNZXRhZGF0YVxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUudXBkYXRlTWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICAgICAgYXJncy52YWxpZGF0ZSgndXBkYXRlTWV0YWRhdGEnLCBbYXJncy5tZXRhZGF0YVNwZWMoKV0sIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudGhyb3dJZlJvb3RfKCd1cGRhdGVNZXRhZGF0YScpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dGhXcmFwcGVyLmdldEF1dGhUb2tlbigpLnRoZW4oZnVuY3Rpb24gKGF1dGhUb2tlbikge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RJbmZvID0gcmVxdWVzdHMudXBkYXRlTWV0YWRhdGEoc2VsZi5hdXRoV3JhcHBlciwgc2VsZi5sb2NhdGlvbiwgbWV0YWRhdGEsIHNlbGYubWFwcGluZ3MoKSk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5hdXRoV3JhcHBlci5tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgYXV0aFRva2VuKS5nZXRQcm9taXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBkb3dubG9hZFxuICAgICAqICAgICBVUkwgZm9yIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUuZ2V0RG93bmxvYWRVUkwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFyZ3MudmFsaWRhdGUoJ2dldERvd25sb2FkVVJMJywgW10sIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudGhyb3dJZlJvb3RfKCdnZXREb3dubG9hZFVSTCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNZXRhZGF0YSgpLnRoZW4oZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gbWV0YWRhdGFbJ2Rvd25sb2FkVVJMcyddWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUuaXNEZWYodXJsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLm5vRG93bmxvYWRVUkwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnRocm93SWZSb290XyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2F0aW9uLnBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmludmFsaWRSb290T3BlcmF0aW9uKG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVmZXJlbmNlO1xufSgpKTtcbmV4cG9ydHMuUmVmZXJlbmNlID0gUmVmZXJlbmNlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZlcmVuY2UuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXJncyA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL2FyZ3NcIik7XG52YXIgYXV0aHdyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL2F1dGh3cmFwcGVyXCIpO1xudmFyIGxvY2F0aW9uXzEgPSByZXF1aXJlKFwiLi9pbXBsZW1lbnRhdGlvbi9sb2NhdGlvblwiKTtcbnZhciBmYnNQcm9taXNlSW1wbCA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL3Byb21pc2VfZXh0ZXJuYWxcIik7XG52YXIgUmVxdWVzdEV4cG9ydHMgPSByZXF1aXJlKFwiLi9pbXBsZW1lbnRhdGlvbi9yZXF1ZXN0XCIpO1xudmFyIHJlZmVyZW5jZV8xID0gcmVxdWlyZShcIi4vcmVmZXJlbmNlXCIpO1xuLyoqXG4gKiBBIHNlcnZpY2UgdGhhdCBwcm92aWRlcyBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIGluc3RhbmNlcy5cbiAqIEBwYXJhbSBvcHRfdXJsIGdzOi8vIHVybCB0byBhIGN1c3RvbSBTdG9yYWdlIEJ1Y2tldFxuICpcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIFNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VydmljZShhcHAsIHBvb2wsIHVybCkge1xuICAgICAgICB0aGlzLmJ1Y2tldF8gPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBtYWtlcihhdXRoV3JhcHBlciwgbG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJlZmVyZW5jZV8xLlJlZmVyZW5jZShhdXRoV3JhcHBlciwgbG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dGhXcmFwcGVyXyA9IG5ldyBhdXRod3JhcHBlcl8xLkF1dGhXcmFwcGVyKGFwcCwgbWFrZXIsIFJlcXVlc3RFeHBvcnRzLm1ha2VSZXF1ZXN0LCB0aGlzLCBwb29sKTtcbiAgICAgICAgdGhpcy5hcHBfID0gYXBwO1xuICAgICAgICBpZiAodXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVja2V0XyA9IGxvY2F0aW9uXzEuTG9jYXRpb24ubWFrZUZyb21CdWNrZXRTcGVjKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXV0aFdyYXBwZXJCdWNrZXQgPSB0aGlzLmF1dGhXcmFwcGVyXy5idWNrZXQoKTtcbiAgICAgICAgICAgIGlmIChhdXRoV3JhcHBlckJ1Y2tldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWNrZXRfID0gbmV3IGxvY2F0aW9uXzEuTG9jYXRpb24oYXV0aFdyYXBwZXJCdWNrZXQsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsc18gPSBuZXcgU2VydmljZUludGVybmFscyh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2UgZm9yIHRoZSBnaXZlbiBwYXRoIGluIHRoZSBkZWZhdWx0XG4gICAgICogYnVja2V0LlxuICAgICAqL1xuICAgIFNlcnZpY2UucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRvcihwYXRoKSB7XG4gICAgICAgICAgICBpZiAoL15bQS1aYS16XSs6XFwvXFwvLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGNoaWxkIHBhdGggYnV0IGdvdCBhIFVSTCwgdXNlIHJlZkZyb21VUkwgaW5zdGVhZC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3MudmFsaWRhdGUoJ3JlZicsIFthcmdzLnN0cmluZ1NwZWModmFsaWRhdG9yLCB0cnVlKV0sIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmJ1Y2tldF8gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTdG9yYWdlIEJ1Y2tldCBkZWZpbmVkIGluIEZpcmViYXNlIE9wdGlvbnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZiA9IG5ldyByZWZlcmVuY2VfMS5SZWZlcmVuY2UodGhpcy5hdXRoV3JhcHBlcl8sIHRoaXMuYnVja2V0Xyk7XG4gICAgICAgIGlmIChwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZWYuY2hpbGQocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZmlyZWJhc2VTdG9yYWdlLlJlZmVyZW5jZSBvYmplY3QgZm9yIHRoZSBnaXZlbiBhYnNvbHV0ZSBVUkwsXG4gICAgICogd2hpY2ggbXVzdCBiZSBhIGdzOi8vIG9yIGh0dHBbc106Ly8gVVJMLlxuICAgICAqL1xuICAgIFNlcnZpY2UucHJvdG90eXBlLnJlZkZyb21VUkwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRvcihwKSB7XG4gICAgICAgICAgICBpZiAoIS9eW0EtWmEtel0rOlxcL1xcLy8udGVzdChwKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBmdWxsIFVSTCBidXQgZ290IGEgY2hpbGQgcGF0aCwgdXNlIHJlZiBpbnN0ZWFkLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uXzEuTG9jYXRpb24ubWFrZUZyb21VcmwocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCB2YWxpZCBmdWxsIFVSTCBidXQgZ290IGFuIGludmFsaWQgb25lLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJncy52YWxpZGF0ZSgncmVmRnJvbVVSTCcsIFthcmdzLnN0cmluZ1NwZWModmFsaWRhdG9yLCBmYWxzZSldLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gbmV3IHJlZmVyZW5jZV8xLlJlZmVyZW5jZSh0aGlzLmF1dGhXcmFwcGVyXywgdXJsKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLnByb3RvdHlwZSwgXCJtYXhVcGxvYWRSZXRyeVRpbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1dGhXcmFwcGVyXy5tYXhVcGxvYWRSZXRyeVRpbWUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU2VydmljZS5wcm90b3R5cGUuc2V0TWF4VXBsb2FkUmV0cnlUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgYXJncy52YWxpZGF0ZSgnc2V0TWF4VXBsb2FkUmV0cnlUaW1lJywgW2FyZ3Mubm9uTmVnYXRpdmVOdW1iZXJTcGVjKCldLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmF1dGhXcmFwcGVyXy5zZXRNYXhVcGxvYWRSZXRyeVRpbWUodGltZSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZS5wcm90b3R5cGUsIFwibWF4T3BlcmF0aW9uUmV0cnlUaW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoV3JhcHBlcl8ubWF4T3BlcmF0aW9uUmV0cnlUaW1lKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNlcnZpY2UucHJvdG90eXBlLnNldE1heE9wZXJhdGlvblJldHJ5VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIGFyZ3MudmFsaWRhdGUoJ3NldE1heE9wZXJhdGlvblJldHJ5VGltZScsIFthcmdzLm5vbk5lZ2F0aXZlTnVtYmVyU3BlYygpXSwgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hdXRoV3JhcHBlcl8uc2V0TWF4T3BlcmF0aW9uUmV0cnlUaW1lKHRpbWUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UucHJvdG90eXBlLCBcImFwcFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwXztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UucHJvdG90eXBlLCBcIklOVEVSTkFMXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbHNfO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlNlcnZpY2UgPSBTZXJ2aWNlO1xuLyoqXG4gKiBAc3RydWN0XG4gKi9cbnZhciBTZXJ2aWNlSW50ZXJuYWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZpY2VJbnRlcm5hbHMoc2VydmljZSkge1xuICAgICAgICB0aGlzLnNlcnZpY2VfID0gc2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgYXBwIGlzIGRlbGV0ZWQuXG4gICAgICogQHNlZSB7IWZicy5BdXRoV3JhcHBlci5wcm90b3R5cGUuZGVsZXRlQXBwfVxuICAgICAqL1xuICAgIFNlcnZpY2VJbnRlcm5hbHMucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlXy5hdXRoV3JhcHBlcl8uZGVsZXRlQXBwKCk7XG4gICAgICAgIHJldHVybiBmYnNQcm9taXNlSW1wbC5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VydmljZUludGVybmFscztcbn0oKSk7XG5leHBvcnRzLlNlcnZpY2VJbnRlcm5hbHMgPSBTZXJ2aWNlSW50ZXJuYWxzO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2aWNlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERlZmluZXMgdHlwZXMgZm9yIGludGVyYWN0aW5nIHdpdGggYmxvYiB0cmFuc2ZlciB0YXNrcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRhc2tlbnVtc18xID0gcmVxdWlyZShcIi4vaW1wbGVtZW50YXRpb24vdGFza2VudW1zXCIpO1xudmFyIG9ic2VydmVyXzEgPSByZXF1aXJlKFwiLi9pbXBsZW1lbnRhdGlvbi9vYnNlcnZlclwiKTtcbnZhciB0YXNrZW51bXNfMiA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL3Rhc2tlbnVtc1wiKTtcbnZhciB0YXNrc25hcHNob3RfMSA9IHJlcXVpcmUoXCIuL3Rhc2tzbmFwc2hvdFwiKTtcbnZhciBmYnNBcmdzID0gcmVxdWlyZShcIi4vaW1wbGVtZW50YXRpb24vYXJnc1wiKTtcbnZhciBmYnNBcnJheSA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL2FycmF5XCIpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKFwiLi9pbXBsZW1lbnRhdGlvbi9hc3luY1wiKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKFwiLi9pbXBsZW1lbnRhdGlvbi9lcnJvclwiKTtcbnZhciBmYnNQcm9taXNlaW1wbCA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uL3Byb21pc2VfZXh0ZXJuYWxcIik7XG52YXIgZmJzUmVxdWVzdHMgPSByZXF1aXJlKFwiLi9pbXBsZW1lbnRhdGlvbi9yZXF1ZXN0c1wiKTtcbnZhciBmYnNUYXNrRW51bXMgPSByZXF1aXJlKFwiLi9pbXBsZW1lbnRhdGlvbi90YXNrZW51bXNcIik7XG52YXIgdHlwZVV0aWxzID0gcmVxdWlyZShcIi4vaW1wbGVtZW50YXRpb24vdHlwZVwiKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGJsb2IgYmVpbmcgdXBsb2FkZWQuIENhbiBiZSB1c2VkIHRvIHBhdXNlL3Jlc3VtZS9jYW5jZWwgdGhlXG4gKiB1cGxvYWQgYW5kIG1hbmFnZSBjYWxsYmFja3MgZm9yIHZhcmlvdXMgZXZlbnRzLlxuICovXG52YXIgVXBsb2FkVGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcmVmIFRoZSBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIG9iamVjdCB0aGlzIHRhc2sgY2FtZVxuICAgICAqICAgICBmcm9tLCB1bnR5cGVkIHRvIGF2b2lkIGN5Y2xpYyBkZXBlbmRlbmNpZXMuXG4gICAgICogQHBhcmFtIGJsb2IgVGhlIGJsb2IgdG8gdXBsb2FkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVwbG9hZFRhc2socmVmLCBhdXRoV3JhcHBlciwgbG9jYXRpb24sIG1hcHBpbmdzLCBibG9iLCBtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEgPT09IHZvaWQgMCkgeyBtZXRhZGF0YSA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50cmFuc2ZlcnJlZF8gPSAwO1xuICAgICAgICB0aGlzLm5lZWRUb0ZldGNoU3RhdHVzXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5lZWRUb0ZldGNoTWV0YWRhdGFfID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzXyA9IFtdO1xuICAgICAgICB0aGlzLmVycm9yXyA9IG51bGw7XG4gICAgICAgIHRoaXMudXBsb2FkVXJsXyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVxdWVzdF8gPSBudWxsO1xuICAgICAgICB0aGlzLmNodW5rTXVsdGlwbGllcl8gPSAxO1xuICAgICAgICB0aGlzLnJlc29sdmVfID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWplY3RfID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWZfID0gcmVmO1xuICAgICAgICB0aGlzLmF1dGhXcmFwcGVyXyA9IGF1dGhXcmFwcGVyO1xuICAgICAgICB0aGlzLmxvY2F0aW9uXyA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLmJsb2JfID0gYmxvYjtcbiAgICAgICAgdGhpcy5tZXRhZGF0YV8gPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5tYXBwaW5nc18gPSBtYXBwaW5ncztcbiAgICAgICAgdGhpcy5yZXN1bWFibGVfID0gdGhpcy5zaG91bGREb1Jlc3VtYWJsZV8odGhpcy5ibG9iXyk7XG4gICAgICAgIHRoaXMuc3RhdGVfID0gdGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORztcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXJfID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0XyA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5jaHVua011bHRpcGxpZXJfID0gMTtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlRXF1YWxzKGVycm9ycy5Db2RlLkNBTkNFTEVEKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm5lZWRUb0ZldGNoU3RhdHVzXyA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmVycm9yXyA9IGVycm9yO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zaXRpb25fKHRhc2tlbnVtc18xLkludGVybmFsVGFza1N0YXRlLkVSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YUVycm9ySGFuZGxlcl8gPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLnJlcXVlc3RfID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlRXF1YWxzKGVycm9ycy5Db2RlLkNBTkNFTEVEKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lcnJvcl8gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2l0aW9uXyh0YXNrZW51bXNfMS5JbnRlcm5hbFRhc2tTdGF0ZS5FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvbWlzZV8gPSBmYnNQcm9taXNlaW1wbC5tYWtlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLnJlc29sdmVfID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIF90aGlzLnJlamVjdF8gPSByZWplY3Q7XG4gICAgICAgICAgICBfdGhpcy5zdGFydF8oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFByZXZlbnQgdW5jYXVnaHQgcmVqZWN0aW9ucyBvbiB0aGUgaW50ZXJuYWwgcHJvbWlzZSBmcm9tIGJ1YmJsaW5nIG91dFxuICAgICAgICAvLyB0byB0aGUgdG9wIGxldmVsIHdpdGggYSBkdW1teSBoYW5kbGVyLlxuICAgICAgICB0aGlzLnByb21pc2VfLnRoZW4obnVsbCwgZnVuY3Rpb24gKCkgeyB9KTtcbiAgICB9XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUubWFrZVByb2dyZXNzQ2FsbGJhY2tfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2l6ZUJlZm9yZSA9IHRoaXMudHJhbnNmZXJyZWRfO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGxvYWRlZCwgdG90YWwpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVByb2dyZXNzXyhzaXplQmVmb3JlICsgbG9hZGVkKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLnNob3VsZERvUmVzdW1hYmxlXyA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgIHJldHVybiBibG9iLnNpemUoKSA+IDI1NiAqIDEwMjQ7XG4gICAgfTtcbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS5zdGFydF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlXyAhPT0gdGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORykge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHNvbWVvbmUgcGF1c2VzIHVzIGluIGEgcmVzdW1lIGNhbGxiYWNrLCBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0XyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlc3VtYWJsZV8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVwbG9hZFVybF8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVJlc3VtYWJsZV8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5lZWRUb0ZldGNoU3RhdHVzXykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZldGNoU3RhdHVzXygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmVlZFRvRmV0Y2hNZXRhZGF0YV8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhcHBlbnMgaWYgd2UgbWlzcyB0aGUgbWV0YWRhdGEgb24gdXBsb2FkIGNvbXBsZXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZldGNoTWV0YWRhdGFfKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlVXBsb2FkXygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbmVTaG90VXBsb2FkXygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS5yZXNvbHZlVG9rZW5fID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYXV0aFdyYXBwZXJfLmdldEF1dGhUb2tlbigpLnRoZW4oZnVuY3Rpb24gKGF1dGhUb2tlbikge1xuICAgICAgICAgICAgc3dpdGNoIChfdGhpcy5zdGF0ZV8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIHRhc2tlbnVtc18xLkludGVybmFsVGFza1N0YXRlLlJVTk5JTkc6XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGF1dGhUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2l0aW9uXyh0YXNrZW51bXNfMS5JbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJhbnNpdGlvbl8odGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0IGZhbHNlXG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUuY3JlYXRlUmVzdW1hYmxlXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNvbHZlVG9rZW5fKGZ1bmN0aW9uIChhdXRoVG9rZW4pIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0SW5mbyA9IGZic1JlcXVlc3RzLmNyZWF0ZVJlc3VtYWJsZVVwbG9hZChfdGhpcy5hdXRoV3JhcHBlcl8sIF90aGlzLmxvY2F0aW9uXywgX3RoaXMubWFwcGluZ3NfLCBfdGhpcy5ibG9iXywgX3RoaXMubWV0YWRhdGFfKTtcbiAgICAgICAgICAgIHZhciBjcmVhdGVSZXF1ZXN0ID0gX3RoaXMuYXV0aFdyYXBwZXJfLm1ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBhdXRoVG9rZW4pO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdF8gPSBjcmVhdGVSZXF1ZXN0O1xuICAgICAgICAgICAgY3JlYXRlUmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbihmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdF8gPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnVwbG9hZFVybF8gPSB1cmw7XG4gICAgICAgICAgICAgICAgX3RoaXMubmVlZFRvRmV0Y2hTdGF0dXNfID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgIH0sIF90aGlzLmVycm9ySGFuZGxlcl8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLmZldGNoU3RhdHVzXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydCh0aGlzLnVwbG9hZFVybF8gIT09IG51bGwpO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy51cGxvYWRVcmxfO1xuICAgICAgICB0aGlzLnJlc29sdmVUb2tlbl8oZnVuY3Rpb24gKGF1dGhUb2tlbikge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RJbmZvID0gZmJzUmVxdWVzdHMuZ2V0UmVzdW1hYmxlVXBsb2FkU3RhdHVzKF90aGlzLmF1dGhXcmFwcGVyXywgX3RoaXMubG9jYXRpb25fLCB1cmwsIF90aGlzLmJsb2JfKTtcbiAgICAgICAgICAgIHZhciBzdGF0dXNSZXF1ZXN0ID0gX3RoaXMuYXV0aFdyYXBwZXJfLm1ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBhdXRoVG9rZW4pO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdF8gPSBzdGF0dXNSZXF1ZXN0O1xuICAgICAgICAgICAgc3RhdHVzUmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbihmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RfID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVQcm9ncmVzc18oc3RhdHVzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLm5lZWRUb0ZldGNoU3RhdHVzXyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5lZWRUb0ZldGNoTWV0YWRhdGFfID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgIH0sIF90aGlzLmVycm9ySGFuZGxlcl8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLmNvbnRpbnVlVXBsb2FkXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNodW5rU2l6ZSA9IGZic1JlcXVlc3RzLnJlc3VtYWJsZVVwbG9hZENodW5rU2l6ZSAqIHRoaXMuY2h1bmtNdWx0aXBsaWVyXztcbiAgICAgICAgdmFyIHN0YXR1cyA9IG5ldyBmYnNSZXF1ZXN0cy5SZXN1bWFibGVVcGxvYWRTdGF0dXModGhpcy50cmFuc2ZlcnJlZF8sIHRoaXMuYmxvYl8uc2l6ZSgpKTtcbiAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydCh0aGlzLnVwbG9hZFVybF8gIT09IG51bGwpO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy51cGxvYWRVcmxfO1xuICAgICAgICB0aGlzLnJlc29sdmVUb2tlbl8oZnVuY3Rpb24gKGF1dGhUb2tlbikge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RJbmZvO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SW5mbyA9IGZic1JlcXVlc3RzLmNvbnRpbnVlUmVzdW1hYmxlVXBsb2FkKF90aGlzLmxvY2F0aW9uXywgX3RoaXMuYXV0aFdyYXBwZXJfLCB1cmwsIF90aGlzLmJsb2JfLCBjaHVua1NpemUsIF90aGlzLm1hcHBpbmdzXywgc3RhdHVzLCBfdGhpcy5tYWtlUHJvZ3Jlc3NDYWxsYmFja18oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVycm9yXyA9IGU7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhbnNpdGlvbl8odGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1cGxvYWRSZXF1ZXN0ID0gX3RoaXMuYXV0aFdyYXBwZXJfLm1ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBhdXRoVG9rZW4pO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdF8gPSB1cGxvYWRSZXF1ZXN0O1xuICAgICAgICAgICAgdXBsb2FkUmVxdWVzdFxuICAgICAgICAgICAgICAgIC5nZXRQcm9taXNlKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobmV3U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5jcmVhc2VNdWx0aXBsaWVyXygpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RfID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVQcm9ncmVzc18obmV3U3RhdHVzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0dXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1ldGFkYXRhXyA9IG5ld1N0YXR1cy5tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJhbnNpdGlvbl8odGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF90aGlzLmVycm9ySGFuZGxlcl8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLmluY3JlYXNlTXVsdGlwbGllcl8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50U2l6ZSA9IGZic1JlcXVlc3RzLnJlc3VtYWJsZVVwbG9hZENodW5rU2l6ZSAqIHRoaXMuY2h1bmtNdWx0aXBsaWVyXztcbiAgICAgICAgLy8gTWF4IGNodW5rIHNpemUgaXMgMzJNLlxuICAgICAgICBpZiAoY3VycmVudFNpemUgPCAzMiAqIDEwMjQgKiAxMDI0KSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rTXVsdGlwbGllcl8gKj0gMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUuZmV0Y2hNZXRhZGF0YV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzb2x2ZVRva2VuXyhmdW5jdGlvbiAoYXV0aFRva2VuKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdEluZm8gPSBmYnNSZXF1ZXN0cy5nZXRNZXRhZGF0YShfdGhpcy5hdXRoV3JhcHBlcl8sIF90aGlzLmxvY2F0aW9uXywgX3RoaXMubWFwcGluZ3NfKTtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YVJlcXVlc3QgPSBfdGhpcy5hdXRoV3JhcHBlcl8ubWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIGF1dGhUb2tlbik7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0XyA9IG1ldGFkYXRhUmVxdWVzdDtcbiAgICAgICAgICAgIG1ldGFkYXRhUmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbihmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0XyA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMubWV0YWRhdGFfID0gbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhbnNpdGlvbl8odGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUyk7XG4gICAgICAgICAgICB9LCBfdGhpcy5tZXRhZGF0YUVycm9ySGFuZGxlcl8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLm9uZVNob3RVcGxvYWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc29sdmVUb2tlbl8oZnVuY3Rpb24gKGF1dGhUb2tlbikge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RJbmZvID0gZmJzUmVxdWVzdHMubXVsdGlwYXJ0VXBsb2FkKF90aGlzLmF1dGhXcmFwcGVyXywgX3RoaXMubG9jYXRpb25fLCBfdGhpcy5tYXBwaW5nc18sIF90aGlzLmJsb2JfLCBfdGhpcy5tZXRhZGF0YV8pO1xuICAgICAgICAgICAgdmFyIG11bHRpcGFydFJlcXVlc3QgPSBfdGhpcy5hdXRoV3JhcHBlcl8ubWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIGF1dGhUb2tlbik7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0XyA9IG11bHRpcGFydFJlcXVlc3Q7XG4gICAgICAgICAgICBtdWx0aXBhcnRSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RfID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5tZXRhZGF0YV8gPSBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVQcm9ncmVzc18oX3RoaXMuYmxvYl8uc2l6ZSgpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2l0aW9uXyh0YXNrZW51bXNfMS5JbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTKTtcbiAgICAgICAgICAgIH0sIF90aGlzLmVycm9ySGFuZGxlcl8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLnVwZGF0ZVByb2dyZXNzXyA9IGZ1bmN0aW9uICh0cmFuc2ZlcnJlZCkge1xuICAgICAgICB2YXIgb2xkID0gdGhpcy50cmFuc2ZlcnJlZF87XG4gICAgICAgIHRoaXMudHJhbnNmZXJyZWRfID0gdHJhbnNmZXJyZWQ7XG4gICAgICAgIC8vIEEgcHJvZ3Jlc3MgdXBkYXRlIGNhbiBtYWtlIHRoZSBcInRyYW5zZmVycmVkXCIgdmFsdWUgc21hbGxlciAoZS5nLiBhXG4gICAgICAgIC8vIHBhcnRpYWwgdXBsb2FkIG5vdCBjb21wbGV0ZWQgYnkgc2VydmVyLCBhZnRlciB3aGljaCB0aGUgXCJ0cmFuc2ZlcnJlZFwiXG4gICAgICAgIC8vIHZhbHVlIG1heSByZXNldCB0byB0aGUgdmFsdWUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVxdWVzdCkuXG4gICAgICAgIGlmICh0aGlzLnRyYW5zZmVycmVkXyAhPT0gb2xkKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeU9ic2VydmVyc18oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUudHJhbnNpdGlvbl8gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgdGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HOlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyB8fFxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXF1ZXN0XyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RfLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVfID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdF8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Xy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRhc2tlbnVtc18xLkludGVybmFsVGFza1N0YXRlLlJVTk5JTkc6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgfHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcpO1xuICAgICAgICAgICAgICAgIHZhciB3YXNQYXVzZWQgPSB0aGlzLnN0YXRlXyA9PT0gdGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVfID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHdhc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9ic2VydmVyc18oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydF8oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRhc2tlbnVtc18xLkludGVybmFsVGFza1N0YXRlLlBBVVNFRDpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVfID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlPYnNlcnZlcnNfKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRhc2tlbnVtc18xLkludGVybmFsVGFza1N0YXRlLkNBTkNFTEVEOlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JfID0gZXJyb3JzLmNhbmNlbGVkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9ic2VydmVyc18oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuRVJST1I6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVfID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlPYnNlcnZlcnNfKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRhc2tlbnVtc18xLkludGVybmFsVGFza1N0YXRlLlNVQ0NFU1M6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVfID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlPYnNlcnZlcnNfKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLmNvbXBsZXRlVHJhbnNpdGlvbnNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGVfKSB7XG4gICAgICAgICAgICBjYXNlIHRhc2tlbnVtc18xLkludGVybmFsVGFza1N0YXRlLlBBVVNJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uXyh0YXNrZW51bXNfMS5JbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0YXNrZW51bXNfMS5JbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uXyh0YXNrZW51bXNfMS5JbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRhc2tlbnVtc18xLkludGVybmFsVGFza1N0YXRlLlJVTk5JTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydF8oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydChmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcGxvYWRUYXNrLnByb3RvdHlwZSwgXCJzbmFwc2hvdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV4dGVybmFsU3RhdGUgPSBmYnNUYXNrRW51bXMudGFza1N0YXRlRnJvbUludGVybmFsVGFza1N0YXRlKHRoaXMuc3RhdGVfKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGFza3NuYXBzaG90XzEuVXBsb2FkVGFza1NuYXBzaG90KHRoaXMudHJhbnNmZXJyZWRfLCB0aGlzLmJsb2JfLnNpemUoKSwgZXh0ZXJuYWxTdGF0ZSwgdGhpcy5tZXRhZGF0YV8sIHRoaXMsIHRoaXMucmVmXyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjYWxsYmFjayBmb3IgYW4gZXZlbnQuXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICAgKi9cbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgPT09IHZvaWQgMCkgeyBuZXh0T3JPYnNlcnZlciA9IHVuZGVmaW5lZDsgfVxuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IHVuZGVmaW5lZDsgfVxuICAgICAgICBpZiAoY29tcGxldGVkID09PSB2b2lkIDApIHsgY29tcGxldGVkID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIGZ1bmN0aW9uIHR5cGVWYWxpZGF0b3IoX3ApIHtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSB0YXNrZW51bXNfMi5UYXNrRXZlbnQuU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiRXhwZWN0ZWQgb25lIG9mIHRoZSBldmVudCB0eXBlczogW1wiICsgdGFza2VudW1zXzIuVGFza0V2ZW50LlNUQVRFX0NIQU5HRUQgKyBcIl0uXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRPck9ic2VydmVyTWVzc2FnZSA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uIG9yIGFuIE9iamVjdCB3aXRoIG9uZSBvZiAnICtcbiAgICAgICAgICAgICdgbmV4dGAsIGBlcnJvcmAsIGBjb21wbGV0ZWAgcHJvcGVydGllcy4nO1xuICAgICAgICB2YXIgbmV4dFZhbGlkYXRvciA9IGZic0FyZ3MubnVsbEZ1bmN0aW9uU3BlYyh0cnVlKS52YWxpZGF0b3I7XG4gICAgICAgIHZhciBvYnNlcnZlclZhbGlkYXRvciA9IGZic0FyZ3MubG9vc2VPYmplY3RTcGVjKG51bGwsIHRydWUpLnZhbGlkYXRvcjtcbiAgICAgICAgZnVuY3Rpb24gbmV4dE9yT2JzZXJ2ZXJWYWxpZGF0b3IocCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXh0VmFsaWRhdG9yKHApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJWYWxpZGF0b3IocCk7XG4gICAgICAgICAgICAgICAgdmFyIGFueURlZmluZWQgPSB0eXBlVXRpbHMuaXNKdXN0RGVmKHBbJ25leHQnXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZVV0aWxzLmlzSnVzdERlZihwWydlcnJvciddKSB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlVXRpbHMuaXNKdXN0RGVmKHBbJ2NvbXBsZXRlJ10pO1xuICAgICAgICAgICAgICAgIGlmICghYW55RGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXh0T3JPYnNlcnZlck1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNwZWNzID0gW1xuICAgICAgICAgICAgZmJzQXJncy5zdHJpbmdTcGVjKHR5cGVWYWxpZGF0b3IpLFxuICAgICAgICAgICAgZmJzQXJncy5sb29zZU9iamVjdFNwZWMobmV4dE9yT2JzZXJ2ZXJWYWxpZGF0b3IsIHRydWUpLFxuICAgICAgICAgICAgZmJzQXJncy5udWxsRnVuY3Rpb25TcGVjKHRydWUpLFxuICAgICAgICAgICAgZmJzQXJncy5udWxsRnVuY3Rpb25TcGVjKHRydWUpXG4gICAgICAgIF07XG4gICAgICAgIGZic0FyZ3MudmFsaWRhdGUoJ29uJywgc3BlY3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gbWFrZUJpbmRlcihzcGVjcykge1xuICAgICAgICAgICAgZnVuY3Rpb24gYmluZGVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgb3B0X2NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWNzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZic0FyZ3MudmFsaWRhdGUoJ29uJywgc3BlY3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBvYnNlcnZlcl8xLk9ic2VydmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFkZE9ic2VydmVyXyhvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVPYnNlcnZlcl8ob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmluZGVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRlck5leHRPck9ic2VydmVyVmFsaWRhdG9yKHApIHtcbiAgICAgICAgICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV4dE9yT2JzZXJ2ZXJNZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dE9yT2JzZXJ2ZXJWYWxpZGF0b3IocCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpbmRlclNwZWNzID0gW1xuICAgICAgICAgICAgZmJzQXJncy5sb29zZU9iamVjdFNwZWMoYmluZGVyTmV4dE9yT2JzZXJ2ZXJWYWxpZGF0b3IpLFxuICAgICAgICAgICAgZmJzQXJncy5udWxsRnVuY3Rpb25TcGVjKHRydWUpLFxuICAgICAgICAgICAgZmJzQXJncy5udWxsRnVuY3Rpb25TcGVjKHRydWUpXG4gICAgICAgIF07XG4gICAgICAgIHZhciB0eXBlT25seSA9ICEodHlwZVV0aWxzLmlzSnVzdERlZihuZXh0T3JPYnNlcnZlcikgfHxcbiAgICAgICAgICAgIHR5cGVVdGlscy5pc0p1c3REZWYoZXJyb3IpIHx8XG4gICAgICAgICAgICB0eXBlVXRpbHMuaXNKdXN0RGVmKGNvbXBsZXRlZCkpO1xuICAgICAgICBpZiAodHlwZU9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlQmluZGVyKGJpbmRlclNwZWNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlQmluZGVyKG51bGwpKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBvYmplY3QgYmVoYXZlcyBsaWtlIGEgUHJvbWlzZSwgYW5kIHJlc29sdmVzIHdpdGggaXRzIHNuYXBzaG90IGRhdGFcbiAgICAgKiB3aGVuIHRoZSB1cGxvYWQgY29tcGxldGVzLlxuICAgICAqIEBwYXJhbSBvbkZ1bGZpbGxlZCBUaGUgZnVsZmlsbG1lbnQgY2FsbGJhY2suIFByb21pc2UgY2hhaW5pbmcgd29ya3MgYXMgbm9ybWFsLlxuICAgICAqIEBwYXJhbSBvblJlamVjdGVkIFRoZSByZWplY3Rpb24gY2FsbGJhY2suXG4gICAgICovXG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAvLyBUaGVzZSBjYXN0cyBhcmUgbmVlZGVkIHNvIHRoYXQgVHlwZVNjcmlwdCBjYW4gaW5mZXIgdGhlIHR5cGVzIG9mIHRoZVxuICAgICAgICAvLyByZXN1bHRpbmcgUHJvbWlzZS5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZV8udGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIGNhbGxpbmcgYHRoZW4obnVsbCwgb25SZWplY3RlZClgLlxuICAgICAqL1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIG9ic2VydmVyLlxuICAgICAqL1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLmFkZE9ic2VydmVyXyA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHRoaXMubm90aWZ5T2JzZXJ2ZXJfKG9ic2VydmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIG9ic2VydmVyLlxuICAgICAqL1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyXyA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBmYnNBcnJheS5yZW1vdmUodGhpcy5vYnNlcnZlcnNfLCBvYnNlcnZlcik7XG4gICAgfTtcbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS5ub3RpZnlPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZpbmlzaFByb21pc2VfKCk7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSBmYnNBcnJheS5jbG9uZSh0aGlzLm9ic2VydmVyc18pO1xuICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLm5vdGlmeU9ic2VydmVyXyhvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUuZmluaXNoUHJvbWlzZV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVfICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmJzVGFza0VudW1zLnRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSh0aGlzLnN0YXRlXykpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHRhc2tlbnVtc18yLlRhc2tTdGF0ZS5TVUNDRVNTOlxuICAgICAgICAgICAgICAgICAgICBhc3luY18xLmFzeW5jKHRoaXMucmVzb2x2ZV8uYmluZChudWxsLCB0aGlzLnNuYXBzaG90KSkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0YXNrZW51bXNfMi5UYXNrU3RhdGUuQ0FOQ0VMRUQ6XG4gICAgICAgICAgICAgICAgY2FzZSB0YXNrZW51bXNfMi5UYXNrU3RhdGUuRVJST1I6XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b0NhbGwgPSB0aGlzLnJlamVjdF87XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jXzEuYXN5bmModG9DYWxsLmJpbmQobnVsbCwgdGhpcy5lcnJvcl8pKSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3RfID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUubm90aWZ5T2JzZXJ2ZXJfID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHZhciBleHRlcm5hbFN0YXRlID0gZmJzVGFza0VudW1zLnRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSh0aGlzLnN0YXRlXyk7XG4gICAgICAgIHN3aXRjaCAoZXh0ZXJuYWxTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSB0YXNrZW51bXNfMi5UYXNrU3RhdGUuUlVOTklORzpcbiAgICAgICAgICAgIGNhc2UgdGFza2VudW1zXzIuVGFza1N0YXRlLlBBVVNFRDpcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhc3luY18xLmFzeW5jKG9ic2VydmVyLm5leHQuYmluZChvYnNlcnZlciwgdGhpcy5zbmFwc2hvdCkpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0YXNrZW51bXNfMi5UYXNrU3RhdGUuU1VDQ0VTUzpcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIuY29tcGxldGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNfMS5hc3luYyhvYnNlcnZlci5jb21wbGV0ZS5iaW5kKG9ic2VydmVyKSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRhc2tlbnVtc18yLlRhc2tTdGF0ZS5DQU5DRUxFRDpcbiAgICAgICAgICAgIGNhc2UgdGFza2VudW1zXzIuVGFza1N0YXRlLkVSUk9SOlxuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5lcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhc3luY18xLmFzeW5jKG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIsIHRoaXMuZXJyb3JfKSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOiBhc3NlcnQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5lcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhc3luY18xLmFzeW5jKG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIsIHRoaXMuZXJyb3JfKSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgYSBwYXVzZWQgdGFzay4gSGFzIG5vIGVmZmVjdCBvbiBhIGN1cnJlbnRseSBydW5uaW5nIG9yIGZhaWxlZCB0YXNrLlxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIHRvb2sgZWZmZWN0LCBmYWxzZSBpZiBpZ25vcmVkLlxuICAgICAqL1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmJzQXJncy52YWxpZGF0ZSgncmVzdW1lJywgW10sIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciB2YWxpZCA9IHRoaXMuc3RhdGVfID09PSB0YXNrZW51bXNfMS5JbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGVfID09PSB0YXNrZW51bXNfMS5JbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HO1xuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbl8odGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGF1c2VzIGEgY3VycmVudGx5IHJ1bm5pbmcgdGFzay4gSGFzIG5vIGVmZmVjdCBvbiBhIHBhdXNlZCBvciBmYWlsZWQgdGFzay5cbiAgICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIG9wZXJhdGlvbiB0b29rIGVmZmVjdCwgZmFsc2UgaWYgaWdub3JlZC5cbiAgICAgKi9cbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmJzQXJncy52YWxpZGF0ZSgncGF1c2UnLCBbXSwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHZhbGlkID0gdGhpcy5zdGF0ZV8gPT09IHRhc2tlbnVtc18xLkludGVybmFsVGFza1N0YXRlLlJVTk5JTkc7XG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uXyh0YXNrZW51bXNfMS5JbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgY3VycmVudGx5IHJ1bm5pbmcgb3IgcGF1c2VkIHRhc2suIEhhcyBubyBlZmZlY3Qgb24gYSBjb21wbGV0ZSBvclxuICAgICAqIGZhaWxlZCB0YXNrLlxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIHRvb2sgZWZmZWN0LCBmYWxzZSBpZiBpZ25vcmVkLlxuICAgICAqL1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmJzQXJncy52YWxpZGF0ZSgnY2FuY2VsJywgW10sIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciB2YWxpZCA9IHRoaXMuc3RhdGVfID09PSB0YXNrZW51bXNfMS5JbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlXyA9PT0gdGFza2VudW1zXzEuSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORztcbiAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25fKHRhc2tlbnVtc18xLkludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH07XG4gICAgcmV0dXJuIFVwbG9hZFRhc2s7XG59KCkpO1xuZXhwb3J0cy5VcGxvYWRUYXNrID0gVXBsb2FkVGFzaztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFzay5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFVwbG9hZFRhc2tTbmFwc2hvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcGxvYWRUYXNrU25hcHNob3QoYnl0ZXNUcmFuc2ZlcnJlZCwgdG90YWxCeXRlcywgc3RhdGUsIG1ldGFkYXRhLCB0YXNrLCByZWYpIHtcbiAgICAgICAgdGhpcy5ieXRlc1RyYW5zZmVycmVkID0gYnl0ZXNUcmFuc2ZlcnJlZDtcbiAgICAgICAgdGhpcy50b3RhbEJ5dGVzID0gdG90YWxCeXRlcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMudGFzayA9IHRhc2s7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXBsb2FkVGFza1NuYXBzaG90LnByb3RvdHlwZSwgXCJkb3dubG9hZFVSTFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJscyA9IHRoaXMubWV0YWRhdGFbJ2Rvd25sb2FkVVJMcyddO1xuICAgICAgICAgICAgICAgIGlmICh1cmxzICE9IG51bGwgJiYgdXJsc1swXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmxzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBVcGxvYWRUYXNrU25hcHNob3Q7XG59KCkpO1xuZXhwb3J0cy5VcGxvYWRUYXNrU25hcHNob3QgPSBVcGxvYWRUYXNrU25hcHNob3Q7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhc2tzbmFwc2hvdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvYXNzZXJ0XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9jcnlwdFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvY29uc3RhbnRzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9kZWVwQ29weVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvZGVmZXJyZWRcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2Vudmlyb25tZW50XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9lcnJvcnNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2pzb25cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2p3dFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvb2JqXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9xdWVyeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvc2hhMVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvc3Vic2NyaWJlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy92YWxpZGF0aW9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy91dGY4XCIpKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgYXNzZXJ0aW9uIGlzIGZhbHN5XG4gKiBAcGFyYW0geyp9IGFzc2VydGlvbiBUaGUgYXNzZXJ0aW9uIHRvIGJlIHRlc3RlZCBmb3IgZmFsc2luZXNzXG4gKiBAcGFyYW0geyFzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBpZiB0aGUgY2hlY2sgZmFpbHNcbiAqL1xuZXhwb3J0cy5hc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgdGhyb3cgZXhwb3J0cy5hc3NlcnRpb25FcnJvcihtZXNzYWdlKTtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIGFuIEVycm9yIG9iamVjdCBzdWl0YWJsZSBmb3IgdGhyb3dpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybiB7IUVycm9yfVxuICovXG5leHBvcnRzLmFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdGaXJlYmFzZSBEYXRhYmFzZSAoJyArXG4gICAgICAgIGNvbnN0YW50c18xLkNPTlNUQU5UUy5TREtfVkVSU0lPTiArXG4gICAgICAgICcpIElOVEVSTkFMIEFTU0VSVCBGQUlMRUQ6ICcgK1xuICAgICAgICBtZXNzYWdlKTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBGaXJlYmFzZSBjb25zdGFudHMuICBTb21lIG9mIHRoZXNlIChAZGVmaW5lcykgY2FuIGJlIG92ZXJyaWRkZW4gYXQgY29tcGlsZS10aW1lLlxuICovXG5leHBvcnRzLkNPTlNUQU5UUyA9IHtcbiAgICAvKipcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0NMSUVOVDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBBZG1pbiBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0FETUlOOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxuICAgICAqL1xuICAgIFNES19WRVJTSU9OOiAnJHtKU0NPUkVfVkVSU0lPTn0nXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3RyaW5nVG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIG91dHB1dCA9IFtdLCBwID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB3aGlsZSAoYyA+IDI1NSkge1xuICAgICAgICAgICAgb3V0cHV0W3ArK10gPSBjICYgMjU1O1xuICAgICAgICAgICAgYyA+Pj0gODtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRbcCsrXSA9IGM7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBudW1iZXJzIGludG8gdGhlIHN0cmluZyBnaXZlbiBieSB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcbiAqIGNoYXJhY3RlcnMgdG8gd2hpY2ggdGhlIG51bWJlcnMgY29ycmVzcG9uZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYnl0ZXMgQXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgY2hhcmFjdGVycy5cbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5naWZpY2F0aW9uIG9mIHRoZSBhcnJheS5cbiAqL1xudmFyIGJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgdmFyIENIVU5LX1NJWkUgPSA4MTkyO1xuICAgIC8vIFNwZWNpYWwtY2FzZSB0aGUgc2ltcGxlIGNhc2UgZm9yIHNwZWVkJ3Mgc2FrZS5cbiAgICBpZiAoYnl0ZXMubGVuZ3RoIDwgQ0hVTktfU0laRSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG4gICAgfVxuICAgIC8vIFRoZSByZW1haW5pbmcgbG9naWMgc3BsaXRzIGNvbnZlcnNpb24gYnkgY2h1bmtzIHNpbmNlXG4gICAgLy8gRnVuY3Rpb24jYXBwbHkoKSBoYXMgYSBtYXhpbXVtIHBhcmFtZXRlciBjb3VudC5cbiAgICAvLyBTZWUgZGlzY3Vzc2lvbjogaHR0cDovL2dvby5nbC9McldtWjlcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gQ0hVTktfU0laRSkge1xuICAgICAgICB2YXIgY2h1bmsgPSBieXRlcy5zbGljZShpLCBpICsgQ0hVTktfU0laRSk7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG4vLyBTdGF0aWMgbG9va3VwIG1hcHMsIGxhemlseSBwb3B1bGF0ZWQgYnkgaW5pdF8oKVxuZXhwb3J0cy5iYXNlNjQgPSB7XG4gICAgLyoqXG4gICAgICogTWFwcyBieXRlcyB0byBjaGFyYWN0ZXJzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBieXRlVG9DaGFyTWFwXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNoYXJUb0J5dGVNYXBfOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE1hcHMgYnl0ZXMgdG8gd2Vic2FmZSBjaGFyYWN0ZXJzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBieXRlVG9DaGFyTWFwV2ViU2FmZV86IG51bGwsXG4gICAgLyoqXG4gICAgICogTWFwcyB3ZWJzYWZlIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldCwgc2hhcmVkIGJldHdlZW5cbiAgICAgKiBFTkNPREVEX1ZBTFMgYW5kIEVOQ09ERURfVkFMU19XRUJTQUZFXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBFTkNPREVEX1ZBTFNfQkFTRTogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJyArICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicgKyAnMDEyMzQ1Njc4OScsXG4gICAgLyoqXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQuIFZhbHVlIDY0ICg9KSBpcyBzcGVjaWFsOyBpdCBtZWFucyBcIm5vdGhpbmcuXCJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBFTkNPREVEX1ZBTFMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkVOQ09ERURfVkFMU19CQVNFICsgJysvPSc7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBPdXIgd2Vic2FmZSBhbHBoYWJldC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBhdG9iIGFuZCBidG9hIGZ1bmN0aW9ucy4gVGhpcyBleHRlbnNpb25cbiAgICAgKiBzdGFydGVkIGF0IE1vemlsbGEgYnV0IGlzIG5vdyBpbXBsZW1lbnRlZCBieSBtYW55IGJyb3dzZXJzLiBXZSB1c2UgdGhlXG4gICAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XG4gICAgICogYnV0IHN0aWxsIGFsbG93aW5nIHRoZSBzdGFuZGFyZCBwZXItYnJvd3NlciBjb21waWxhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBIQVNfTkFUSVZFX1NVUFBPUlQ6IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nLFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj58VWludDhBcnJheX0gaW5wdXQgQW4gYXJyYXkgb2YgYnl0ZXMgKG51bWJlcnMgd2l0aFxuICAgICAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF93ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlQnl0ZUFycmF5OiBmdW5jdGlvbiAoaW5wdXQsIG9wdF93ZWJTYWZlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRfKCk7XG4gICAgICAgIHZhciBieXRlVG9DaGFyTWFwID0gb3B0X3dlYlNhZmVcbiAgICAgICAgICAgID8gdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9cbiAgICAgICAgICAgIDogdGhpcy5ieXRlVG9DaGFyTWFwXztcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZTEgPSBpbnB1dFtpXTtcbiAgICAgICAgICAgIHZhciBoYXZlQnl0ZTIgPSBpICsgMSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBieXRlMiA9IGhhdmVCeXRlMiA/IGlucHV0W2kgKyAxXSA6IDA7XG4gICAgICAgICAgICB2YXIgaGF2ZUJ5dGUzID0gaSArIDIgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBpbnB1dFtpICsgMl0gOiAwO1xuICAgICAgICAgICAgdmFyIG91dEJ5dGUxID0gYnl0ZTEgPj4gMjtcbiAgICAgICAgICAgIHZhciBvdXRCeXRlMiA9ICgoYnl0ZTEgJiAweDAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcbiAgICAgICAgICAgIHZhciBvdXRCeXRlMyA9ICgoYnl0ZTIgJiAweDBmKSA8PCAyKSB8IChieXRlMyA+PiA2KTtcbiAgICAgICAgICAgIHZhciBvdXRCeXRlNCA9IGJ5dGUzICYgMHgzZjtcbiAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUzKSB7XG4gICAgICAgICAgICAgICAgb3V0Qnl0ZTQgPSA2NDtcbiAgICAgICAgICAgICAgICBpZiAoIWhhdmVCeXRlMikge1xuICAgICAgICAgICAgICAgICAgICBvdXRCeXRlMyA9IDY0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTFdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUyXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlM10sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQmFzZTY0LWVuY29kZSBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBBIHN0cmluZyB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dlYlNhZmUgSWYgdHJ1ZSwgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGVuY29kZVN0cmluZzogZnVuY3Rpb24gKGlucHV0LCBvcHRfd2ViU2FmZSkge1xuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhb3B0X3dlYlNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiBidG9hKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVCeXRlQXJyYXkoc3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQpLCBvcHRfd2ViU2FmZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBkZWNvZGVTdHJpbmc6IGZ1bmN0aW9uIChpbnB1dCwgb3B0X3dlYlNhZmUpIHtcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxuICAgICAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIW9wdF93ZWJTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXRvYihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheVRvU3RyaW5nKHRoaXMuZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQsIG9wdF93ZWJTYWZlKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcbiAgICAgKiBieXRlcy4gIElmIHRoZSBlbmNvZGVyIGRpZCBub3QgYXBwbHkgcGFkZGluZywgdGhlIGlucHV0IGxlbmd0aCBtYXkgbm90XG4gICAgICogYmUgYSBtdWx0aXBsZSBvZiA0LlxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgbGFzdCBncm91cCB3aWxsIGhhdmUgZmV3ZXIgdGhhbiA0IGNoYXJhY3RlcnMsIGFuZFxuICAgICAqIHBhZGRpbmcgd2lsbCBiZSBpbmZlcnJlZC4gIElmIHRoZSBncm91cCBoYXMgb25lIG9yIHR3byBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzXG4gICAgICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IElucHV0IHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxuICAgICAqIEByZXR1cm4geyFBcnJheTxudW1iZXI+fSBieXRlcyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXG4gICAgICovXG4gICAgZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXk6IGZ1bmN0aW9uIChpbnB1dCwgb3B0X3dlYlNhZmUpIHtcbiAgICAgICAgdGhpcy5pbml0XygpO1xuICAgICAgICB2YXIgY2hhclRvQnl0ZU1hcCA9IG9wdF93ZWJTYWZlXG4gICAgICAgICAgICA/IHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfXG4gICAgICAgICAgICA6IHRoaXMuY2hhclRvQnl0ZU1hcF87XG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgIHZhciBoYXZlQnl0ZTIgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGJ5dGUyID0gaGF2ZUJ5dGUyID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogMDtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIHZhciBoYXZlQnl0ZTMgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGJ5dGUzID0gaGF2ZUJ5dGUzID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB2YXIgaGF2ZUJ5dGU0ID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgaWYgKGJ5dGUxID09IG51bGwgfHwgYnl0ZTIgPT0gbnVsbCB8fCBieXRlMyA9PSBudWxsIHx8IGJ5dGU0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG91dEJ5dGUxID0gKGJ5dGUxIDw8IDIpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTEpO1xuICAgICAgICAgICAgaWYgKGJ5dGUzICE9IDY0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dEJ5dGUyID0gKChieXRlMiA8PCA0KSAmIDB4ZjApIHwgKGJ5dGUzID4+IDIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUyKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZTQgIT0gNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dEJ5dGUzID0gKChieXRlMyA8PCA2KSAmIDB4YzApIHwgYnl0ZTQ7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIExhenkgc3RhdGljIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBDYWxsZWQgYmVmb3JlXG4gICAgICogYWNjZXNzaW5nIGFueSBvZiB0aGUgc3RhdGljIG1hcCB2YXJpYWJsZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0XzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnl0ZVRvQ2hhck1hcF8pIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF8gPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF8gPSB7fTtcbiAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfID0ge307XG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlXyA9IHt9O1xuICAgICAgICAgICAgLy8gV2Ugd2FudCBxdWljayBtYXBwaW5ncyBiYWNrIGFuZCBmb3J0aCwgc28gd2UgcHJlY29tcHV0ZSB0d28gbWFwcy5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5FTkNPREVEX1ZBTFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5ieXRlVG9DaGFyTWFwX1tpXV0gPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV1dID0gaTtcbiAgICAgICAgICAgICAgICAvLyBCZSBmb3JnaXZpbmcgd2hlbiBkZWNvZGluZyBhbmQgY29ycmVjdGx5IGRlY29kZSBib3RoIGVuY29kaW5ncy5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSB0aGlzLkVOQ09ERURfVkFMU19CQVNFLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZ1xuICogQHBhcmFtIHshc3RyaW5nfSBzdHJcbiAqIEByZXR1cm4geyFzdHJpbmd9XG4gKi9cbmV4cG9ydHMuYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciB1dGY4Qnl0ZXMgPSBzdHJpbmdUb0J5dGVBcnJheShzdHIpO1xuICAgIHJldHVybiBleHBvcnRzLmJhc2U2NC5lbmNvZGVCeXRlQXJyYXkodXRmOEJ5dGVzLCB0cnVlKTtcbn07XG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBkZWNvZGluZ1xuICpcbiAqIE5PVEU6IERPIE5PVCB1c2UgdGhlIGdsb2JhbCBhdG9iKCkgZnVuY3Rpb24gLSBpdCBkb2VzIE5PVCBzdXBwb3J0IHRoZVxuICogYmFzZTY0VXJsIHZhcmlhbnQgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUbyBiZSBkZWNvZGVkXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBEZWNvZGVkIHJlc3VsdCwgaWYgcG9zc2libGVcbiAqL1xuZXhwb3J0cy5iYXNlNjREZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYmFzZTY0LmRlY29kZVN0cmluZyhzdHIsIHRydWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdiYXNlNjREZWNvZGUgZmFpbGVkOiAnLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogRG8gYSBkZWVwLWNvcHkgb2YgYmFzaWMgSmF2YVNjcmlwdCBPYmplY3RzIG9yIEFycmF5cy5cbiAqL1xuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcbiAgICByZXR1cm4gZGVlcEV4dGVuZCh1bmRlZmluZWQsIHZhbHVlKTtcbn1cbmV4cG9ydHMuZGVlcENvcHkgPSBkZWVwQ29weTtcbi8qKlxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRhcmdldCAocmVjdXJzaXZlbHkgYWxsb3dzIGV4dGVuc2lvblxuICogb2YgT2JqZWN0cyBhbmQgQXJyYXlzKS4gIFNjYWxhciB2YWx1ZXMgaW4gdGhlIHRhcmdldCBhcmUgb3Zlci13cml0dGVuLlxuICogSWYgdGFyZ2V0IGlzIHVuZGVmaW5lZCwgYW4gb2JqZWN0IG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlIHdpbGwgYmUgY3JlYXRlZFxuICogKGFuZCByZXR1cm5lZCkuXG4gKlxuICogV2UgcmVjdXJzaXZlbHkgY29weSBhbGwgY2hpbGQgcHJvcGVydGllcyBvZiBwbGFpbiBPYmplY3RzIGluIHRoZSBzb3VyY2UtIHNvXG4gKiB0aGF0IG5hbWVzcGFjZS0gbGlrZSBkaWN0aW9uYXJpZXMgYXJlIG1lcmdlZC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHRhcmdldCBjYW4gYmUgYSBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSB0aGUgcHJvcGVydGllcyBpblxuICogdGhlIHNvdXJjZSBPYmplY3QgYXJlIGNvcGllZCBvbnRvIGl0IGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgc3dpdGNoIChzb3VyY2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgICAgLy8gVHJlYXQgRGF0ZXMgbGlrZSBzY2FsYXJzOyBpZiB0aGUgdGFyZ2V0IGRhdGUgb2JqZWN0IGhhZCBhbnkgY2hpbGRcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgLSB0aGV5IHdpbGwgYmUgbG9zdCFcbiAgICAgICAgICAgIHZhciBkYXRlVmFsdWUgPSBzb3VyY2U7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZVZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjb3B5IHRoZSBhcnJheSBzb3VyY2UgYW5kIG92ZXJ3cml0ZSB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgdGFyZ2V0ID0gW107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIE5vdCBhIHBsYWluIE9iamVjdCAtIHRyZWF0IGl0IGFzIGEgc2NhbGFyLlxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IGRlZXBFeHRlbmQodGFyZ2V0W3Byb3BdLCBzb3VyY2VbcHJvcF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0cy5kZWVwRXh0ZW5kID0gZGVlcEV4dGVuZDtcbi8vIFRPRE86IFJlYWxseSBuZWVkZWQgKGZvciBKU0NvbXBpbGVyIHR5cGUgY2hlY2tpbmcpP1xuZnVuY3Rpb24gcGF0Y2hQcm9wZXJ0eShvYmosIHByb3AsIHZhbHVlKSB7XG4gICAgb2JqW3Byb3BdID0gdmFsdWU7XG59XG5leHBvcnRzLnBhdGNoUHJvcGVydHkgPSBwYXRjaFByb3BlcnR5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWVwQ29weS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEZWZlcnJlZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZlcnJlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBfdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIE91ciBBUEkgaW50ZXJuYWxzIGFyZSBub3QgcHJvbWlzZWlmaWVkIGFuZCBjYW5ub3QgYmVjYXVzZSBvdXIgY2FsbGJhY2sgQVBJcyBoYXZlIHN1YnRsZSBleHBlY3RhdGlvbnMgYXJvdW5kXG4gICAgKiBpbnZva2luZyBwcm9taXNlcyBpbmxpbmUsIHdoaWNoIFByb21pc2VzIGFyZSBmb3JiaWRkZW4gdG8gZG8uIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgbm9kZS1zdHlsZSBjYWxsYmFja1xuICAgICogYW5kIHJldHVybnMgYSBub2RlLXN0eWxlIGNhbGxiYWNrIHdoaWNoIHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIERlZmVycmVkJ3MgcHJvbWlzZS5cbiAgICAqIEBwYXJhbSB7KCg/ZnVuY3Rpb24oPyhFcnJvcikpOiAoP3x1bmRlZmluZWQpKXwgKD9mdW5jdGlvbig/KEVycm9yKSw/PSk6ICg/fHVuZGVmaW5lZCkpKT19IGNhbGxiYWNrXG4gICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oPyhFcnJvciksID89KX1cbiAgICAqL1xuICAgIERlZmVycmVkLnByb3RvdHlwZS53cmFwQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBBdHRhY2hpbmcgbm9vcCBoYW5kbGVyIGp1c3QgaW4gY2FzZSBkZXZlbG9wZXIgd2Fzbid0IGV4cGVjdGluZ1xuICAgICAgICAgICAgICAgIC8vIHByb21pc2VzXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgb2Ygb3VyIGNhbGxiYWNrcyBkb24ndCBleHBlY3QgYSB2YWx1ZSBhbmQgb3VyIG93biB0ZXN0c1xuICAgICAgICAgICAgICAgIC8vIGFzc2VydCB0aGF0IHRoZSBwYXJhbWV0ZXIgbGVuZ3RoIGlzIDFcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIERlZmVycmVkO1xufSgpKTtcbmV4cG9ydHMuRGVmZXJyZWQgPSBEZWZlcnJlZDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmZXJyZWQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIFJldHVybnMgbmF2aWdhdG9yLnVzZXJBZ2VudCBzdHJpbmcgb3IgJycgaWYgaXQncyBub3QgZGVmaW5lZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdXNlciBhZ2VudCBzdHJpbmdcbiAqL1xuZXhwb3J0cy5nZXRVQSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvclsndXNlckFnZW50J10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn07XG4vKipcbiAqIERldGVjdCBDb3Jkb3ZhIC8gUGhvbmVHYXAgLyBJb25pYyBmcmFtZXdvcmtzIG9uIGEgbW9iaWxlIGRldmljZS5cbiAqXG4gKiBEZWxpYmVyYXRlbHkgZG9lcyBub3QgcmVseSBvbiBjaGVja2luZyBgZmlsZTovL2AgVVJMcyAoYXMgdGhpcyBmYWlscyBQaG9uZUdhcCBpbiB0aGUgUmlwcGxlIGVtdWxhdG9yKSBub3JcbiAqIENvcmRvdmEgYG9uRGV2aWNlUmVhZHlgLCB3aGljaCB3b3VsZCBub3JtYWxseSB3YWl0IGZvciBhIGNhbGxiYWNrLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlzTW9iaWxlQ29yZG92YVxuICovXG5leHBvcnRzLmlzTW9iaWxlQ29yZG92YSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICEhKHdpbmRvd1snY29yZG92YSddIHx8IHdpbmRvd1sncGhvbmVnYXAnXSB8fCB3aW5kb3dbJ1Bob25lR2FwJ10pICYmXG4gICAgICAgIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGUvaS50ZXN0KGV4cG9ydHMuZ2V0VUEoKSkpO1xufTtcbi8qKlxuICogRGV0ZWN0IFJlYWN0IE5hdGl2ZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxuICovXG5leHBvcnRzLmlzUmVhY3ROYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3JbJ3Byb2R1Y3QnXSA9PT0gJ1JlYWN0TmF0aXZlJyk7XG59O1xuLyoqXG4gKiBEZXRlY3QgTm9kZS5qcy5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQuXG4gKi9cbmV4cG9ydHMuaXNOb2RlU2RrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb25zdGFudHNfMS5DT05TVEFOVFMuTk9ERV9DTElFTlQgPT09IHRydWUgfHwgY29uc3RhbnRzXzEuQ09OU1RBTlRTLk5PREVfQURNSU4gPT09IHRydWU7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnZpcm9ubWVudC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVSUk9SX05BTUUgPSAnRmlyZWJhc2VFcnJvcic7XG52YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvclxuICAgIC5jYXB0dXJlU3RhY2tUcmFjZTtcbi8vIEV4cG9ydCBmb3IgZmFraW5nIGluIHRlc3RzXG5mdW5jdGlvbiBwYXRjaENhcHR1cmUoY2FwdHVyZUZha2UpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgY2FwdHVyZVN0YWNrVHJhY2UgPSBjYXB0dXJlRmFrZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXRjaENhcHR1cmUgPSBwYXRjaENhcHR1cmU7XG52YXIgRmlyZWJhc2VFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaXJlYmFzZUVycm9yKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdmFyIHN0YWNrO1xuICAgICAgICAvLyBXZSB3YW50IHRoZSBzdGFjayB2YWx1ZSwgaWYgaW1wbGVtZW50ZWQgYnkgRXJyb3JcbiAgICAgICAgaWYgKGNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICAvLyBQYXRjaGVzIHRoaXMuc3RhY2ssIG9taXR0ZWQgY2FsbHMgYWJvdmUgRXJyb3JGYWN0b3J5I2NyZWF0ZVxuICAgICAgICAgICAgY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXJyb3JGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVycl8xID0gRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IEVSUk9SX05BTUU7XG4gICAgICAgICAgICAvLyBNYWtlIG5vbi1lbnVtZXJhYmxlIGdldHRlciBmb3IgdGhlIHByb3BlcnR5LlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGFjaycsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycl8xLnN0YWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBGaXJlYmFzZUVycm9yO1xufSgpKTtcbmV4cG9ydHMuRmlyZWJhc2VFcnJvciA9IEZpcmViYXNlRXJyb3I7XG4vLyBCYWNrLWRvb3IgaW5oZXJpdGFuY2VcbkZpcmViYXNlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuRmlyZWJhc2VFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGaXJlYmFzZUVycm9yO1xuRmlyZWJhc2VFcnJvci5wcm90b3R5cGUubmFtZSA9IEVSUk9SX05BTUU7XG52YXIgRXJyb3JGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVycm9yRmFjdG9yeShzZXJ2aWNlLCBzZXJ2aWNlTmFtZSwgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIC8vIE1hdGNoZXMgeyRuYW1lfSwgYnkgZGVmYXVsdC5cbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gL1xce1xcJChbXn1dKyl9L2c7XG4gICAgICAgIC8vIGVtcHR5XG4gICAgfVxuICAgIEVycm9yRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNvZGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMuZXJyb3JzW2NvZGVdO1xuICAgICAgICB2YXIgZnVsbENvZGUgPSB0aGlzLnNlcnZpY2UgKyAnLycgKyBjb2RlO1xuICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnRXJyb3InO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRlbXBsYXRlLnJlcGxhY2UodGhpcy5wYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlLnRvU3RyaW5nKCkgOiAnPCcgKyBrZXkgKyAnPz4nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VydmljZTogRXJyb3IgbWVzc2FnZSAoc2VydmljZS9jb2RlKS5cbiAgICAgICAgbWVzc2FnZSA9IHRoaXMuc2VydmljZU5hbWUgKyAnOiAnICsgbWVzc2FnZSArICcgKCcgKyBmdWxsQ29kZSArICcpLic7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRmlyZWJhc2VFcnJvcihmdWxsQ29kZSwgbWVzc2FnZSk7XG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBFcnJvciBvYmplY3Qgd2l0aCBtZXNzYWdlIHBhcnRzIGZvciBwcm9ncmFtbWF0aWNcbiAgICAgICAgLy8gYWNjZXNzZXMgKGUuZy4sIGUuZmlsZSkuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KHByb3ApIHx8IHByb3Auc2xpY2UoLTEpID09PSAnXycpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycltwcm9wXSA9IGRhdGFbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9O1xuICAgIHJldHVybiBFcnJvckZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5FcnJvckZhY3RvcnkgPSBFcnJvckZhY3Rvcnk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFic3RyYWN0IGNyeXB0b2dyYXBoaWMgaGFzaCBpbnRlcmZhY2UuXG4gKlxuICogU2VlIFNoYTEgYW5kIE1kNSBmb3Igc2FtcGxlIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKi9cbi8qKlxuICogQ3JlYXRlIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGluc3RhbmNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICovXG52YXIgSGFzaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIYXNoKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJsb2NrIHNpemUgZm9yIHRoZSBoYXNoZXIuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrU2l6ZSA9IC0xO1xuICAgIH1cbiAgICByZXR1cm4gSGFzaDtcbn0oKSk7XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBFdmFsdWF0ZXMgYSBKU09OIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBjb250YWluaW5nIEpTT04uXG4gKiBAcmV0dXJuIHsqfSBUaGUgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgSlNPTi5cbiAqL1xuZnVuY3Rpb24ganNvbkV2YWwoc3RyKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbn1cbmV4cG9ydHMuanNvbkV2YWwgPSBqc29uRXZhbDtcbi8qKlxuICogUmV0dXJucyBKU09OIHJlcHJlc2VudGluZyBhIGphdmFzY3JpcHQgb2JqZWN0LlxuICogQHBhcmFtIHsqfSBkYXRhIEphdmFzY3JpcHQgb2JqZWN0IHRvIGJlIHN0cmluZ2lmaWVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSlNPTiBjb250ZW50cyBvZiB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNyeXB0XzEgPSByZXF1aXJlKFwiLi9jcnlwdFwiKTtcbnZhciBqc29uXzEgPSByZXF1aXJlKFwiLi9qc29uXCIpO1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gaW50byBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiB3aXRoIGludmFsaWQgLyBpbmNvbXBsZXRlIGNsYWltcyBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSB0b2tlblxuICogQHJldHVybiB7e2hlYWRlcjogKiwgY2xhaW1zOiAqLCBkYXRhOiAqLCBzaWduYXR1cmU6IHN0cmluZ319XG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgdmFyIGhlYWRlciA9IHt9LCBjbGFpbXMgPSB7fSwgZGF0YSA9IHt9LCBzaWduYXR1cmUgPSAnJztcbiAgICB0cnkge1xuICAgICAgICB2YXIgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xuICAgICAgICBoZWFkZXIgPSBqc29uXzEuanNvbkV2YWwoY3J5cHRfMS5iYXNlNjREZWNvZGUocGFydHNbMF0pIHx8ICcnKTtcbiAgICAgICAgY2xhaW1zID0ganNvbl8xLmpzb25FdmFsKGNyeXB0XzEuYmFzZTY0RGVjb2RlKHBhcnRzWzFdKSB8fCAnJyk7XG4gICAgICAgIHNpZ25hdHVyZSA9IHBhcnRzWzJdO1xuICAgICAgICBkYXRhID0gY2xhaW1zWydkJ10gfHwge307XG4gICAgICAgIGRlbGV0ZSBjbGFpbXNbJ2QnXTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcjogaGVhZGVyLFxuICAgICAgICBjbGFpbXM6IGNsYWltcyxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVcbiAgICB9O1xufTtcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyB0aW1lLWJhc2VkIGNsYWltcy4gV2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGVcbiAqIHRva2VuIGlzIHdpdGhpbiB0aGUgdGltZSB3aW5kb3cgYXV0aG9yaXplZCBieSB0aGUgJ25iZicgKG5vdC1iZWZvcmUpIGFuZCAnaWF0JyAoaXNzdWVkLWF0KSBjbGFpbXMuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSB0b2tlblxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkVGltZXN0YW1wID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgdmFyIGNsYWltcyA9IGV4cG9ydHMuZGVjb2RlKHRva2VuKS5jbGFpbXMsIG5vdyA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKSwgdmFsaWRTaW5jZSwgdmFsaWRVbnRpbDtcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnbmJmJykpIHtcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ25iZiddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ2lhdCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2V4cCcpKSB7XG4gICAgICAgICAgICB2YWxpZFVudGlsID0gY2xhaW1zWydleHAnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRva2VuIHdpbGwgZXhwaXJlIGFmdGVyIDI0aCBieSBkZWZhdWx0XG4gICAgICAgICAgICB2YWxpZFVudGlsID0gdmFsaWRTaW5jZSArIDg2NDAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAobm93ICYmIHZhbGlkU2luY2UgJiYgdmFsaWRVbnRpbCAmJiBub3cgPj0gdmFsaWRTaW5jZSAmJiBub3cgPD0gdmFsaWRVbnRpbCk7XG59O1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIHJldHVybnMgaXRzIGlzc3VlZCBhdCB0aW1lIGlmIHZhbGlkLCBudWxsIG90aGVyd2lzZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBudWxsIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHRva2VuXG4gKiBAcmV0dXJuIHs/bnVtYmVyfVxuICovXG5leHBvcnRzLmlzc3VlZEF0VGltZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHZhciBjbGFpbXMgPSBleHBvcnRzLmRlY29kZSh0b2tlbikuY2xhaW1zO1xuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XG4gICAgICAgIHJldHVybiBjbGFpbXNbJ2lhdCddO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgZm9ybWF0LiBFeHBlY3RzIGEgdmFsaWQgaXNzdWVkLWF0IHRpbWUgYW5kIG5vbi1lbXB0eVxuICogc2lnbmF0dXJlLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHZhciBkZWNvZGVkID0gZXhwb3J0cy5kZWNvZGUodG9rZW4pLCBjbGFpbXMgPSBkZWNvZGVkLmNsYWltcztcbiAgICByZXR1cm4gKCEhZGVjb2RlZC5zaWduYXR1cmUgJiZcbiAgICAgICAgISFjbGFpbXMgJiZcbiAgICAgICAgdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSk7XG59O1xuLyoqXG4gKiBBdHRlbXB0cyB0byBwZWVyIGludG8gYW4gYXV0aCB0b2tlbiBhbmQgZGV0ZXJtaW5lIGlmIGl0J3MgYW4gYWRtaW4gYXV0aCB0b2tlbiBieSBsb29raW5nIGF0IHRoZSBjbGFpbXMgcG9ydGlvbi5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHRva2VuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzQWRtaW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICB2YXIgY2xhaW1zID0gZXhwb3J0cy5kZWNvZGUodG9rZW4pLmNsYWltcztcbiAgICByZXR1cm4gdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zWydhZG1pbiddID09PSB0cnVlO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9and0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gU2VlIGh0dHA6Ly93d3cuZGV2dGhvdWdodC5jb20vMjAxMi8wMS8xOC9hbi1vYmplY3QtaXMtbm90LWEtaGFzaC9cbmV4cG9ydHMuY29udGFpbnMgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn07XG5leHBvcnRzLnNhZmVHZXQgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSlcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIC8vIGVsc2UgcmV0dXJuIHVuZGVmaW5lZC5cbn07XG4vKipcbiAqIEVudW1lcmF0ZXMgdGhlIGtleXMvdmFsdWVzIGluIGFuIG9iamVjdCwgZXhjbHVkaW5nIGtleXMgZGVmaW5lZCBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7P09iamVjdC48SyxWPn0gb2JqIE9iamVjdCB0byBlbnVtZXJhdGUuXG4gKiBAcGFyYW0geyFmdW5jdGlvbihLLCBWKX0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBrZXkgYW5kIHZhbHVlLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5leHBvcnRzLmZvckVhY2ggPSBmdW5jdGlvbiAob2JqLCBmbikge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGZuKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQ29waWVzIGFsbCB0aGUgKG93bikgcHJvcGVydGllcyBmcm9tIG9uZSBvYmplY3QgdG8gYW5vdGhlci5cbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqVG9cbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqRnJvbVxuICogQHJldHVybiB7IU9iamVjdH0gb2JqVG9cbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAob2JqVG8sIG9iakZyb20pIHtcbiAgICBleHBvcnRzLmZvckVhY2gob2JqRnJvbSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgb2JqVG9ba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmpUbztcbn07XG4vKipcbiAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgc3BlY2lmaWVkIG9iamVjdC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBjbG9uZWQgb2JqLlxuICovXG5leHBvcnRzLmNsb25lID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBleHBvcnRzLmV4dGVuZCh7fSwgb2JqKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaGFzIHR5cGVvZiBcIm9iamVjdFwiIGFuZCBpcyBub3QgbnVsbC4gIFVubGlrZSBnb29nLmlzT2JqZWN0KCksIGRvZXMgbm90IHJldHVybiB0cnVlXG4gKiBmb3IgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSBvYmogeyp9IEEgcG90ZW50aWFsIG9iamVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGl0J3MgYW4gb2JqZWN0LlxuICovXG5leHBvcnRzLmlzTm9uTnVsbE9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsO1xufTtcbmV4cG9ydHMuaXNFbXB0eSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZXhwb3J0cy5nZXRDb3VudCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcnYgPSAwO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgcnYrKztcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufTtcbmV4cG9ydHMubWFwID0gZnVuY3Rpb24gKG9iaiwgZiwgb3B0X29iaikge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJlc1trZXldID0gZi5jYWxsKG9wdF9vYmosIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuZXhwb3J0cy5maW5kS2V5ID0gZnVuY3Rpb24gKG9iaiwgZm4sIG9wdF90aGlzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoZm4uY2FsbChvcHRfdGhpcywgb2JqW2tleV0sIGtleSwgb2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydHMuZmluZFZhbHVlID0gZnVuY3Rpb24gKG9iaiwgZm4sIG9wdF90aGlzKSB7XG4gICAgdmFyIGtleSA9IGV4cG9ydHMuZmluZEtleShvYmosIGZuLCBvcHRfdGhpcyk7XG4gICAgcmV0dXJuIGtleSAmJiBvYmpba2V5XTtcbn07XG5leHBvcnRzLmdldEFueUtleSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICByZXNbaSsrXSA9IG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcbi8qKlxuICogVGVzdHMgd2hldGhlciBldmVyeSBrZXkvdmFsdWUgcGFpciBpbiBhbiBvYmplY3QgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZFxuICogYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHs/T2JqZWN0LjxLLFY+fSBvYmogT2JqZWN0IHRvIHRlc3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbihLLCBWKX0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBrZXkgYW5kIHZhbHVlLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5leHBvcnRzLmV2ZXJ5ID0gZnVuY3Rpb24gKG9iaiwgZm4pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIWZuKGtleSwgb2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG9ial8xID0gcmVxdWlyZShcIi4vb2JqXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgcXVlcnlzdHJpbmctZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAmYXJnPXZhbCZhcmcyPXZhbDIpIGZyb20gYSBwYXJhbXNcbiAqIG9iamVjdCAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gcXVlcnlzdHJpbmdQYXJhbXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5xdWVyeXN0cmluZyA9IGZ1bmN0aW9uIChxdWVyeXN0cmluZ1BhcmFtcykge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBvYmpfMS5mb3JFYWNoKHF1ZXJ5c3RyaW5nUGFyYW1zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGFycmF5VmFsKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJyYXlWYWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXJhbXMubGVuZ3RoID8gJyYnICsgcGFyYW1zLmpvaW4oJyYnKSA6ICcnO1xufTtcbi8qKlxuICogRGVjb2RlcyBhIHF1ZXJ5c3RyaW5nIChlLmcuID9hcmc9dmFsJmFyZzI9dmFsMikgaW50byBhIHBhcmFtcyBvYmplY3QgKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5c3RyaW5nXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICovXG5leHBvcnRzLnF1ZXJ5c3RyaW5nRGVjb2RlID0gZnVuY3Rpb24gKHF1ZXJ5c3RyaW5nKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciB0b2tlbnMgPSBxdWVyeXN0cmluZy5yZXBsYWNlKC9eXFw/LywgJycpLnNwbGl0KCcmJyk7XG4gICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgdmFyIGtleSA9IHRva2VuLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBvYmpba2V5WzBdXSA9IGtleVsxXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoLlxuICogVmFyaWFibGUgbmFtZXMgZm9sbG93IHRoZSBub3RhdGlvbiBpbiBGSVBTIFBVQiAxODAtMzpcbiAqIGh0dHA6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9maXBzL2ZpcHMxODAtMy9maXBzMTgwLTNfZmluYWwucGRmLlxuICpcbiAqIFVzYWdlOlxuICogICB2YXIgc2hhMSA9IG5ldyBzaGExKCk7XG4gKiAgIHNoYTEudXBkYXRlKGJ5dGVzKTtcbiAqICAgdmFyIGhhc2ggPSBzaGExLmRpZ2VzdCgpO1xuICpcbiAqIFBlcmZvcm1hbmNlOlxuICogICBDaHJvbWUgMjM6ICAgfjQwMCBNYml0L3NcbiAqICAgRmlyZWZveCAxNjogIH4yNTAgTWJpdC9zXG4gKlxuICovXG4vKipcbiAqIFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBUaGUgcHJvcGVydGllcyBkZWNsYXJlZCBoZXJlIGFyZSBkaXNjdXNzZWQgaW4gdGhlIGFib3ZlIGFsZ29yaXRobSBkb2N1bWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0hhc2h9XG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIFNoYTEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNoYTEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2hhMSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvbGRzIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGEtZSBpbiB0aGUgY29tcHJlc3NfXG4gICAgICAgICAqIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5PG51bWJlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jaGFpbl8gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYnVmZmVyIGhvbGRpbmcgdGhlIHBhcnRpYWxseSBjb21wdXRlZCBoYXNoIHJlc3VsdC5cbiAgICAgICAgICogQHR5cGUgeyFBcnJheTxudW1iZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYnVmXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgODAgYnl0ZXMsIGVhY2ggYSBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIGhhc2hlZC4gIFJlZmVycmVkIHRvXG4gICAgICAgICAqIGFzIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGluIHRoZSBkb2NzLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5PG51bWJlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5XXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGFpbnMgZGF0YSBuZWVkZWQgdG8gcGFkIG1lc3NhZ2VzIGxlc3MgdGhhbiA2NCBieXRlcy5cbiAgICAgICAgICogQHR5cGUgeyFBcnJheTxudW1iZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucGFkXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmluYnVmXyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudG90YWxfID0gMDtcbiAgICAgICAgX3RoaXMuYmxvY2tTaXplID0gNTEyIC8gODtcbiAgICAgICAgX3RoaXMucGFkX1swXSA9IDEyODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfdGhpcy5ibG9ja1NpemU7ICsraSkge1xuICAgICAgICAgICAgX3RoaXMucGFkX1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTaGExLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xuICAgICAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XG4gICAgICAgIHRoaXMuY2hhaW5fWzJdID0gMHg5OGJhZGNmZTtcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xuICAgICAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY29tcHJlc3MgaGVscGVyIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7IUFycmF5PG51bWJlcj58IVVpbnQ4QXJyYXl8c3RyaW5nfSBidWYgQmxvY2sgdG8gY29tcHJlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfb2Zmc2V0IE9mZnNldCBvZiB0aGUgYmxvY2sgaW4gdGhlIGJ1ZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFNoYTEucHJvdG90eXBlLmNvbXByZXNzXyA9IGZ1bmN0aW9uIChidWYsIG9wdF9vZmZzZXQpIHtcbiAgICAgICAgaWYgKCFvcHRfb2Zmc2V0KSB7XG4gICAgICAgICAgICBvcHRfb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVyA9IHRoaXMuV187XG4gICAgICAgIC8vIGdldCAxNiBiaWcgZW5kaWFuIHdvcmRzXG4gICAgICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyh1c2VyKTogW2J1ZyA4MTQwMTIyXSBSZWNlbnQgdmVyc2lvbnMgb2YgU2FmYXJpIGZvciBNYWMgT1MgYW5kIGlPU1xuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBidWcgdGhhdCB0dXJucyB0aGUgcG9zdC1pbmNyZW1lbnQgKysgb3BlcmF0b3IgaW50byBwcmUtaW5jcmVtZW50XG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIEpJVCBjb21waWxhdGlvbi4gIFdlIGhhdmUgY29kZSB0aGF0IGRlcGVuZHMgaGVhdmlseSBvbiBTSEEtMSBmb3JcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0bmVzcyBhbmQgd2hpY2ggaXMgYWZmZWN0ZWQgYnkgdGhpcyBidWcsIHNvIEkndmUgcmVtb3ZlZCBhbGwgdXNlc1xuICAgICAgICAgICAgICAgIC8vIG9mIHBvc3QtaW5jcmVtZW50ICsrIGluIHdoaWNoIHRoZSByZXN1bHQgdmFsdWUgaXMgdXNlZC4gIFdlIGNhbiByZXZlcnRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoYW5nZSBvbmNlIHRoZSBTYWZhcmkgYnVnXG4gICAgICAgICAgICAgICAgLy8gKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDkwMzYpIGhhcyBiZWVuIGZpeGVkIGFuZFxuICAgICAgICAgICAgICAgIC8vIG1vc3QgY2xpZW50cyBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAgICAgICAgICAgICBXW2ldID1cbiAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9wdF9vZmZzZXQpIDw8IDI0KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob3B0X29mZnNldCArIDEpIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob3B0X29mZnNldCArIDIpIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5jaGFyQ29kZUF0KG9wdF9vZmZzZXQgKyAzKTtcbiAgICAgICAgICAgICAgICBvcHRfb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBXW2ldID1cbiAgICAgICAgICAgICAgICAgICAgKGJ1ZltvcHRfb2Zmc2V0XSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZltvcHRfb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWZbb3B0X29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvcHRfb2Zmc2V0ICsgM107XG4gICAgICAgICAgICAgICAgb3B0X29mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGV4cGFuZCB0byA4MCB3b3Jkc1xuICAgICAgICBmb3IgKHZhciBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdCA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG4gICAgICAgICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFpbl9bMF07XG4gICAgICAgIHZhciBiID0gdGhpcy5jaGFpbl9bMV07XG4gICAgICAgIHZhciBjID0gdGhpcy5jaGFpbl9bMl07XG4gICAgICAgIHZhciBkID0gdGhpcy5jaGFpbl9bM107XG4gICAgICAgIHZhciBlID0gdGhpcy5jaGFpbl9bNF07XG4gICAgICAgIHZhciBmLCBrO1xuICAgICAgICAvLyBUT0RPKHVzZXIpOiBUcnkgdG8gdW5yb2xsIHRoaXMgbG9vcCB0byBzcGVlZCB1cCB0aGUgY29tcHV0YXRpb24uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCA0MCkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg1YTgyNzk5OTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgNjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gKCgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyBrICsgV1tpXSkgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgZSA9IGQ7XG4gICAgICAgICAgICBkID0gYztcbiAgICAgICAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBiID0gYTtcbiAgICAgICAgICAgIGEgPSB0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhaW5fWzBdID0gKHRoaXMuY2hhaW5fWzBdICsgYSkgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1sxXSA9ICh0aGlzLmNoYWluX1sxXSArIGIpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAodGhpcy5jaGFpbl9bMl0gKyBjKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzNdID0gKHRoaXMuY2hhaW5fWzNdICsgZCkgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1s0XSA9ICh0aGlzLmNoYWluX1s0XSArIGUpICYgMHhmZmZmZmZmZjtcbiAgICB9O1xuICAgIFNoYTEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChieXRlcywgb3B0X2xlbmd0aCkge1xuICAgICAgICAvLyBUT0RPKGpvaG5sZW56KTogdGlnaHRlbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIGFuZCByZW1vdmUgdGhpcyBjaGVja1xuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRfbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdF9sZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aE1pbnVzQmxvY2sgPSBvcHRfbGVuZ3RoIC0gdGhpcy5ibG9ja1NpemU7XG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgLy8gVXNpbmcgbG9jYWwgaW5zdGVhZCBvZiBtZW1iZXIgdmFyaWFibGVzIGdpdmVzIH41JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYuXG4gICAgICAgIHZhciBidWYgPSB0aGlzLmJ1Zl87XG4gICAgICAgIHZhciBpbmJ1ZiA9IHRoaXMuaW5idWZfO1xuICAgICAgICAvLyBUaGUgb3V0ZXIgd2hpbGUgbG9vcCBzaG91bGQgZXhlY3V0ZSBhdCBtb3N0IHR3aWNlLlxuICAgICAgICB3aGlsZSAobiA8IG9wdF9sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxuICAgICAgICAgICAgLy8gaW5wdXQgYnVmZmVyIChhc3N1bWluZyBpdCBjb250YWlucyBzdWZmaWNpZW50IGRhdGEpLiBUaGlzIGdpdmVzIH4yNSVcbiAgICAgICAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cbiAgICAgICAgICAgIGlmIChpbmJ1ZiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPD0gbGVuZ3RoTWludXNCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhieXRlcywgbik7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5ibG9ja1NpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IG9wdF9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzLmNoYXJDb2RlQXQobik7XG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XG4gICAgICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5idWYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IG9wdF9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzW25dO1xuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xuICAgICAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJ1ZiA9PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5idWZfID0gaW5idWY7XG4gICAgICAgIHRoaXMudG90YWxfICs9IG9wdF9sZW5ndGg7XG4gICAgfTtcbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgU2hhMS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGlnZXN0ID0gW107XG4gICAgICAgIHZhciB0b3RhbEJpdHMgPSB0aGlzLnRvdGFsXyAqIDg7XG4gICAgICAgIC8vIEFkZCBwYWQgMHg4MCAweDAwKi5cbiAgICAgICAgaWYgKHRoaXMuaW5idWZfIDwgNTYpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgNTYgLSB0aGlzLmluYnVmXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIHRoaXMuYmxvY2tTaXplIC0gKHRoaXMuaW5idWZfIC0gNTYpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgIyBiaXRzLlxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5ibG9ja1NpemUgLSAxOyBpID49IDU2OyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuYnVmX1tpXSA9IHRvdGFsQml0cyAmIDI1NTtcbiAgICAgICAgICAgIHRvdGFsQml0cyAvPSAyNTY7IC8vIERvbid0IHVzZSBiaXQtc2hpZnRpbmcgaGVyZSFcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXByZXNzXyh0aGlzLmJ1Zl8pO1xuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XG4gICAgICAgICAgICAgICAgZGlnZXN0W25dID0gKHRoaXMuY2hhaW5fW2ldID4+IGopICYgMjU1O1xuICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlnZXN0O1xuICAgIH07XG4gICAgcmV0dXJuIFNoYTE7XG59KGhhc2hfMS5IYXNoKSk7XG5leHBvcnRzLlNoYTEgPSBTaGExO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGExLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEhlbHBlciB0byBtYWtlIGEgU3Vic2NyaWJlIGZ1bmN0aW9uIChqdXN0IGxpa2UgUHJvbWlzZSBoZWxwcyBtYWtlIGFcbiAqIFRoZW5hYmxlKS5cbiAqXG4gKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcbiAqICAgICBhcyBhIHByb3h5LlxuICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmUoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcbiAgICB2YXIgcHJveHkgPSBuZXcgT2JzZXJ2ZXJQcm94eShleGVjdXRvciwgb25Ob09ic2VydmVycyk7XG4gICAgcmV0dXJuIHByb3h5LnN1YnNjcmliZS5iaW5kKHByb3h5KTtcbn1cbmV4cG9ydHMuY3JlYXRlU3Vic2NyaWJlID0gY3JlYXRlU3Vic2NyaWJlO1xuLyoqXG4gKiBJbXBsZW1lbnQgZmFuLW91dCBmb3IgYW55IG51bWJlciBvZiBPYnNlcnZlcnMgYXR0YWNoZWQgdmlhIGEgc3Vic2NyaWJlXG4gKiBmdW5jdGlvbi5cbiAqL1xudmFyIE9ic2VydmVyUHJveHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXG4gICAgICogICAgIGFzIGEgcHJveHkuXG4gICAgICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmVyUHJveHkoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXMgPSBbXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50ID0gMDtcbiAgICAgICAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXG4gICAgICAgIHRoaXMudGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xuICAgICAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcbiAgICAgICAgLy8gc3luY2hyb25vdXNseSBhZnRlciB0aGUgY3JlYXRpb24gb2YgdGhlIHN1YnNjcmliZSBmdW5jdGlvblxuICAgICAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxuICAgICAgICB0aGlzLnRhc2tcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV4ZWN1dG9yKF90aGlzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMuZXJyb3IoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYnNlcnZlclByb3h5LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2ZXJQcm94eS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsb3NlKGVycm9yKTtcbiAgICB9O1xuICAgIE9ic2VydmVyUHJveHkucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgYW4gT2JzZXJ2ZXIgdG8gdGhlIGZhbi1vdXQgbGlzdC5cbiAgICAgKlxuICAgICAqIC0gV2UgcmVxdWlyZSB0aGF0IG5vIGV2ZW50IGlzIHNlbnQgdG8gYSBzdWJzY3JpYmVyIHN5Y2hyb25vdXNseSB0byB0aGVpclxuICAgICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cbiAgICAgKi9cbiAgICBPYnNlcnZlclByb3h5LnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgT2JzZXJ2ZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzZW1ibGUgYW4gT2JzZXJ2ZXIgb2JqZWN0IHdoZW4gcGFzc2VkIGFzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgICAgaWYgKGltcGxlbWVudHNBbnlNZXRob2RzKG5leHRPck9ic2VydmVyLCBbJ25leHQnLCAnZXJyb3InLCAnY29tcGxldGUnXSkpIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXh0T3JPYnNlcnZlcixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5uZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvciA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdW5zdWIgPSB0aGlzLnVuc3Vic2NyaWJlT25lLmJpbmQodGhpcywgdGhpcy5vYnNlcnZlcnMubGVuZ3RoKTtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzdWJzY3JpYmUgdG8gYSB0ZXJtaW5hdGVkIE9ic2VydmFibGUgLSB3ZVxuICAgICAgICAvLyBqdXN0IHJlc3BvbmQgdG8gdGhlIE9ic2VydmVyIHdpdGggdGhlIGZpbmFsIGVycm9yIG9yIGNvbXBsZXRlXG4gICAgICAgIC8vIGV2ZW50LlxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGFzay50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmluYWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoX3RoaXMuZmluYWxFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB1bnN1YjtcbiAgICB9O1xuICAgIC8vIFVuc3Vic2NyaWJlIGlzIHN5bmNocm9ub3VzIC0gd2UgZ3VhcmFudGVlIHRoYXQgbm8gZXZlbnRzIGFyZSBzZW50IHRvXG4gICAgLy8gYW55IHVuc3Vic2NyaWJlZCBPYnNlcnZlci5cbiAgICBPYnNlcnZlclByb3h5LnByb3RvdHlwZS51bnN1YnNjcmliZU9uZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVycyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub2JzZXJ2ZXJzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcnNbaV07XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlckNvdW50ID09PSAwICYmIHRoaXMub25Ob09ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnModGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9ic2VydmVyUHJveHkucHJvdG90eXBlLmZvckVhY2hPYnNlcnZlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIC8vIEFscmVhZHkgY2xvc2VkIGJ5IHByZXZpb3VzIGV2ZW50Li4uLmp1c3QgZWF0IHRoZSBhZGRpdGlvbmFsIHZhbHVlcy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSBzZW5kT25lIGNhbGxzIGFzeW5jaHJvbm91c2x5IC0gdGhlcmUgaXMgbm8gY2hhbmNlIHRoYXRcbiAgICAgICAgLy8gdGhpcy5vYnNlcnZlcnMgd2lsbCBiZWNvbWUgdW5kZWZpbmVkLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRPbmUoaSwgZm4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXG4gICAgLy8gY29uZmlybSB0aGF0IHRoZSBvYnNlcnZlIGhhcyBub3QgYmVlbiB1bnN1YnNjcmliZWQgc2luY2UgdGhpcyBhc3luY2hyb25vdXNcbiAgICAvLyBmdW5jdGlvbiBoYWQgYmVlbiBxdWV1ZWQuXG4gICAgT2JzZXJ2ZXJQcm94eS5wcm90b3R5cGUuc2VuZE9uZSA9IGZ1bmN0aW9uIChpLCBmbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhc3luY2hyb25vdXNseVxuICAgICAgICB0aGlzLnRhc2sudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQgJiYgX3RoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbihfdGhpcy5vYnNlcnZlcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXhjZXB0aW9ucyByYWlzZWQgaW4gT2JzZXJ2ZXJzIG9yIG1pc3NpbmcgbWV0aG9kcyBvZiBhblxuICAgICAgICAgICAgICAgICAgICAvLyBPYnNlcnZlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIHRvIGNvbnNvbGUuIGIvMzE0MDQ4MDZcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmVyUHJveHkucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb3h5IGlzIG5vIGxvbmdlciBuZWVkZWQgLSBnYXJiYWdlIGNvbGxlY3QgcmVmZXJlbmNlc1xuICAgICAgICB0aGlzLnRhc2sudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5vYnNlcnZlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfdGhpcy5vbk5vT2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZlclByb3h5O1xufSgpKTtcbi8qKiBUdXJuIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gb25lIGNhbGxlZCBhc3luY2hyb25vdXNseS4gKi9cbmZ1bmN0aW9uIGFzeW5jKGZuLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlLnJlc29sdmUodHJ1ZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5hc3luYyA9IGFzeW5jO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpbXBsZW1lbnRzIGFueSBvZiB0aGUgbmFtZWQgbWV0aG9kcy5cbiAqL1xuZnVuY3Rpb24gaW1wbGVtZW50c0FueU1ldGhvZHMob2JqLCBtZXRob2RzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgbWV0aG9kc18xID0gbWV0aG9kczsgX2kgPCBtZXRob2RzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzXzFbX2ldO1xuICAgICAgICBpZiAobWV0aG9kIGluIG9iaiAmJiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgLy8gZG8gbm90aGluZ1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcbi8vIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgJ1xcclxcbicgd2l0aCAnXFxuJywgYW5kIHRoZXkgZGlkbid0IGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMsXG4vLyBzbyBpdCdzIGJlZW4gbW9kaWZpZWQuXG4vLyBOb3RlIHRoYXQgbm90IGFsbCBVbmljb2RlIGNoYXJhY3RlcnMgYXBwZWFyIGFzIHNpbmdsZSBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cbi8vIGZyb21DaGFyQ29kZSByZXR1cm5zIHRoZSBVVEYtMTYgZW5jb2Rpbmcgb2YgYSBjaGFyYWN0ZXIgLSBzbyBzb21lIFVuaWNvZGUgY2hhcmFjdGVyc1xuLy8gdXNlIDIgY2hhcmFjdGVycyBpbiBKYXZhc2NyaXB0LiAgQWxsIDQtYnl0ZSBVVEYtOCBjaGFyYWN0ZXJzIGJlZ2luIHdpdGggYSBmaXJzdFxuLy8gY2hhcmFjdGVyIGluIHRoZSByYW5nZSAweEQ4MDAgLSAweERCRkYgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzby1jYWxsZWQgc3Vycm9nYXRlXG4vLyBwYWlyKS5cbi8vIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuMS4zXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnRzLnN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBvdXQgPSBbXSwgcCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gSXMgdGhpcyB0aGUgbGVhZCBzdXJyb2dhdGUgaW4gYSBzdXJyb2dhdGUgcGFpcj9cbiAgICAgICAgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICB2YXIgaGlnaCA9IGMgLSAweGQ4MDA7IC8vIHRoZSBoaWdoIDEwIGJpdHMuXG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBhc3NlcnRfMS5hc3NlcnQoaSA8IHN0ci5sZW5ndGgsICdTdXJyb2dhdGUgcGFpciBtaXNzaW5nIHRyYWlsIHN1cnJvZ2F0ZS4nKTtcbiAgICAgICAgICAgIHZhciBsb3cgPSBzdHIuY2hhckNvZGVBdChpKSAtIDB4ZGMwMDsgLy8gdGhlIGxvdyAxMCBiaXRzLlxuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoaGlnaCA8PCAxMCkgKyBsb3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDY1NTM2KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbGVuZ3RoIHdpdGhvdXQgYWN0dWFsbHkgY29udmVydGluZzsgdXNlZnVsIGZvciBkb2luZyBjaGVhcGVyIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuc3RyaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBwID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgcCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgICBwICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcbiAgICAgICAgICAgIC8vIExlYWQgc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuICBUaGUgcGFpciB0b2dldGhlciB3aWxsIHRha2UgNCBieXRlcyB0byByZXByZXNlbnQuXG4gICAgICAgICAgICBwICs9IDQ7XG4gICAgICAgICAgICBpKys7IC8vIHNraXAgdHJhaWwgc3Vycm9nYXRlLlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcCArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXJndW1lbnRzIGFyZSBwcm92aWRlZCBmb3IgYSBwdWJsaWMgZnVuY3Rpb24uXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcbiAqIEBwYXJhbSB7IW51bWJlcn0gbWluQ291bnQgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcbiAqIEBwYXJhbSB7IW51bWJlcn0gbWF4Q291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50IHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxuICogQHBhcmFtIHshbnVtYmVyfSBhcmdDb3VudCBUaGUgYWN0dWFsIG51bWJlciBvZiBhcmd1bWVudHMgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydHMudmFsaWRhdGVBcmdDb3VudCA9IGZ1bmN0aW9uIChmbk5hbWUsIG1pbkNvdW50LCBtYXhDb3VudCwgYXJnQ291bnQpIHtcbiAgICB2YXIgYXJnRXJyb3I7XG4gICAgaWYgKGFyZ0NvdW50IDwgbWluQ291bnQpIHtcbiAgICAgICAgYXJnRXJyb3IgPSAnYXQgbGVhc3QgJyArIG1pbkNvdW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XG4gICAgICAgIGFyZ0Vycm9yID0gbWF4Q291bnQgPT09IDAgPyAnbm9uZScgOiAnbm8gbW9yZSB0aGFuICcgKyBtYXhDb3VudDtcbiAgICB9XG4gICAgaWYgKGFyZ0Vycm9yKSB7XG4gICAgICAgIHZhciBlcnJvciA9IGZuTmFtZSArXG4gICAgICAgICAgICAnIGZhaWxlZDogV2FzIGNhbGxlZCB3aXRoICcgK1xuICAgICAgICAgICAgYXJnQ291bnQgK1xuICAgICAgICAgICAgKGFyZ0NvdW50ID09PSAxID8gJyBhcmd1bWVudC4nIDogJyBhcmd1bWVudHMuJykgK1xuICAgICAgICAgICAgJyBFeHBlY3RzICcgK1xuICAgICAgICAgICAgYXJnRXJyb3IgK1xuICAgICAgICAgICAgJy4nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIH1cbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyB0byBwcmVmaXggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCBmYWlsZWQgYXJndW1lbnQgdmFsaWRhdGlvblxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXG4gKiBAcGFyYW0geyFudW1iZXJ9IGFyZ3VtZW50TnVtYmVyIFRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uYWwgV2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4gKiBAcmV0dXJuIHshc3RyaW5nfSBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgZXJyb3IgdGhyb3duIGZvciB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkge1xuICAgIHZhciBhcmdOYW1lID0gJyc7XG4gICAgc3dpdGNoIChhcmd1bWVudE51bWJlcikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBhcmdOYW1lID0gb3B0aW9uYWwgPyAnZmlyc3QnIDogJ0ZpcnN0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBhcmdOYW1lID0gb3B0aW9uYWwgPyAnc2Vjb25kJyA6ICdTZWNvbmQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGFyZ05hbWUgPSBvcHRpb25hbCA/ICd0aGlyZCcgOiAnVGhpcmQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGFyZ05hbWUgPSBvcHRpb25hbCA/ICdmb3VydGgnIDogJ0ZvdXJ0aCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3JQcmVmaXggY2FsbGVkIHdpdGggYXJndW1lbnROdW1iZXIgPiA0LiAgTmVlZCB0byB1cGRhdGUgaXQ/Jyk7XG4gICAgfVxuICAgIHZhciBlcnJvciA9IGZuTmFtZSArICcgZmFpbGVkOiAnO1xuICAgIGVycm9yICs9IGFyZ05hbWUgKyAnIGFyZ3VtZW50ICc7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0cy5lcnJvclByZWZpeCA9IGVycm9yUHJlZml4O1xuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IGZuTmFtZVxuICogQHBhcmFtIHshbnVtYmVyfSBhcmd1bWVudE51bWJlclxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uYWxcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVOYW1lc3BhY2UoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgbmFtZXNwYWNlLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiAhbmFtZXNwYWNlKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vVE9ETzogSSBzaG91bGQgZG8gbW9yZSB2YWxpZGF0aW9uIGhlcmUuIFdlIG9ubHkgYWxsb3cgY2VydGFpbiBjaGFycyBpbiBuYW1lc3BhY2VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgbmFtZXNwYWNlLicpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVOYW1lc3BhY2UgPSB2YWxpZGF0ZU5hbWVzcGFjZTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ2FsbGJhY2soZm5OYW1lLCBhcmd1bWVudE51bWJlciwgY2FsbGJhY2ssIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmICFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAgICAgJ211c3QgYmUgYSB2YWxpZCBmdW5jdGlvbi4nKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVDYWxsYmFjayA9IHZhbGlkYXRlQ2FsbGJhY2s7XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHRPYmplY3QoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgY29udGV4dCwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgIWNvbnRleHQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnIHx8IGNvbnRleHQgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAgICAgJ211c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC4nKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVDb250ZXh0T2JqZWN0ID0gdmFsaWRhdGVDb250ZXh0T2JqZWN0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uLmpzLm1hcFxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxucmVxdWlyZSgnQGZpcmViYXNlL3BvbHlmaWxsJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ0BmaXJlYmFzZS9hcHAnKS5kZWZhdWx0O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxucmVxdWlyZSgnQGZpcmViYXNlL2F1dGgnKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnQGZpcmViYXNlL2RhdGFiYXNlJyk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgZmlyZWJhc2UgPSByZXF1aXJlKCcuL2FwcCcpO1xucmVxdWlyZSgnLi9hdXRoJyk7XG5yZXF1aXJlKCcuL2RhdGFiYXNlJyk7XG5yZXF1aXJlKCcuL21lc3NhZ2luZycpO1xucmVxdWlyZSgnLi9zdG9yYWdlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmlyZWJhc2U7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5yZXF1aXJlKCdAZmlyZWJhc2UvbWVzc2FnaW5nJyk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5yZXF1aXJlKCdAZmlyZWJhc2Uvc3RvcmFnZScpO1xuIiwiKGZ1bmN0aW9uIChyb290KSB7XG5cbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gcHJvbWlzZS1wb2x5ZmlsbCB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBzZXRUaW1lb3V0RnVuYyA9IHNldFRpbWVvdXQ7XG5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gIFxuICAvLyBQb2x5ZmlsbCBmb3IgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBQcm9taXNlKGZuKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKTtcbiAgICB0aGlzLl9zdGF0ZSA9IDA7XG4gICAgdGhpcy5faGFuZGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlZmVycmVkcyA9IFtdO1xuXG4gICAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZShzZWxmLCBkZWZlcnJlZCkge1xuICAgIHdoaWxlIChzZWxmLl9zdGF0ZSA9PT0gMykge1xuICAgICAgc2VsZiA9IHNlbGYuX3ZhbHVlO1xuICAgIH1cbiAgICBpZiAoc2VsZi5fc3RhdGUgPT09IDApIHtcbiAgICAgIHNlbGYuX2RlZmVycmVkcy5wdXNoKGRlZmVycmVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5faGFuZGxlZCA9IHRydWU7XG4gICAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNiID0gc2VsZi5fc3RhdGUgPT09IDEgPyBkZWZlcnJlZC5vbkZ1bGZpbGxlZCA6IGRlZmVycmVkLm9uUmVqZWN0ZWQ7XG4gICAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgICAgKHNlbGYuX3N0YXRlID09PSAxID8gcmVzb2x2ZSA6IHJlamVjdCkoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmV0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gY2Ioc2VsZi5fdmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgcmV0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmUoc2VsZiwgbmV3VmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgIGlmIChuZXdWYWx1ZSAmJiAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHZhciB0aGVuID0gbmV3VmFsdWUudGhlbjtcbiAgICAgICAgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHNlbGYuX3N0YXRlID0gMztcbiAgICAgICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkb1Jlc29sdmUoYmluZCh0aGVuLCBuZXdWYWx1ZSksIHNlbGYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2VsZi5fc3RhdGUgPSAxO1xuICAgICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIGZpbmFsZShzZWxmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3Qoc2VsZiwgZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVqZWN0KHNlbGYsIG5ld1ZhbHVlKSB7XG4gICAgc2VsZi5fc3RhdGUgPSAyO1xuICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgZmluYWxlKHNlbGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluYWxlKHNlbGYpIHtcbiAgICBpZiAoc2VsZi5fc3RhdGUgPT09IDIgJiYgc2VsZi5fZGVmZXJyZWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghc2VsZi5faGFuZGxlZCkge1xuICAgICAgICAgIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuKHNlbGYuX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuX2RlZmVycmVkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaGFuZGxlKHNlbGYsIHNlbGYuX2RlZmVycmVkc1tpXSk7XG4gICAgfVxuICAgIHNlbGYuX2RlZmVycmVkcyA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9taXNlKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiAgICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gICAqXG4gICAqIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiAgICovXG4gIGZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgc2VsZikge1xuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGZuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZShzZWxmLCB2YWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZWplY3Qoc2VsZiwgcmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICByZWplY3Qoc2VsZiwgZXgpO1xuICAgIH1cbiAgfVxuXG4gIFByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICB9O1xuXG4gIFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgcHJvbSA9IG5ldyAodGhpcy5jb25zdHJ1Y3Rvcikobm9vcCk7XG5cbiAgICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb20pKTtcbiAgICByZXR1cm4gcHJvbTtcbiAgfTtcblxuICBQcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0aGVuLmNhbGwodmFsLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXJnc1tpXSA9IHZhbDtcbiAgICAgICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHJlamVjdChleCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVqZWN0KHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFsdWVzW2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBVc2UgcG9seWZpbGwgZm9yIHNldEltbWVkaWF0ZSBmb3IgcGVyZm9ybWFuY2UgZ2FpbnNcbiAgUHJvbWlzZS5faW1tZWRpYXRlRm4gPSAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBmdW5jdGlvbiAoZm4pIHsgc2V0SW1tZWRpYXRlKGZuKTsgfSkgfHxcbiAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHNldFRpbWVvdXRGdW5jKGZuLCAwKTtcbiAgICB9O1xuXG4gIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3VuaGFuZGxlZFJlamVjdGlvbkZuKGVycikge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSkge1xuICAgICAgY29uc29sZS53YXJuKCdQb3NzaWJsZSBVbmhhbmRsZWQgUHJvbWlzZSBSZWplY3Rpb246JywgZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGltbWVkaWF0ZSBmdW5jdGlvbiB0byBleGVjdXRlIGNhbGxiYWNrc1xuICAgKiBAcGFyYW0gZm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0byBleGVjdXRlXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBQcm9taXNlLl9zZXRJbW1lZGlhdGVGbiA9IGZ1bmN0aW9uIF9zZXRJbW1lZGlhdGVGbihmbikge1xuICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuID0gZm47XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiB1bmhhbmRsZWQgcmVqZWN0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gdW5oYW5kbGVkIHJlamVjdGlvblxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgUHJvbWlzZS5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmdW5jdGlvbiBfc2V0VW5oYW5kbGVkUmVqZWN0aW9uRm4oZm4pIHtcbiAgICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZuO1xuICB9O1xuICBcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuICB9IGVsc2UgaWYgKCFyb290LlByb21pc2UpIHtcbiAgICByb290LlByb21pc2UgPSBQcm9taXNlO1xuICB9XG5cbn0pKHRoaXMpO1xuIiwiY29uc3QgZmlyZWJhc2UgPSByZXF1aXJlKCdmaXJlYmFzZScpO1xuXG5jbGFzcyBSb29tY2hhdGEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBmaXJlYmFzZS5pbml0aWFsaXplQXBwKHtcbiAgICAgICAgICAgIGFwaUtleTogXCJBSXphU3lEaE1kMmNaS01iaDNWNnB3bUNYN2haM0dQeG5KYUxKN1FcIixcbiAgICAgICAgICAgIGF1dGhEb21haW46IFwicm9vbWNoYXRhLTk4MzZlLmZpcmViYXNlYXBwLmNvbVwiLFxuICAgICAgICAgICAgZGF0YWJhc2VVUkw6IFwiaHR0cHM6Ly9yb29tY2hhdGEtOTgzNmUuZmlyZWJhc2Vpby5jb21cIixcbiAgICAgICAgICAgIHByb2plY3RJZDogXCJyb29tY2hhdGEtOTgzNmVcIixcbiAgICAgICAgICAgIHN0b3JhZ2VCdWNrZXQ6IFwicm9vbWNoYXRhLTk4MzZlLmFwcHNwb3QuY29tXCIsXG4gICAgICAgICAgICBtZXNzYWdpbmdTZW5kZXJJZDogXCI1OTI4ODI5MjgwMTFcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRoID0gZmlyZWJhc2UuYXV0aCgpO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBmaXJlYmFzZS5zdG9yYWdlKCk7XG4gICAgICAgIHRoaXMuZGF0YWJhc2UgPSBmaXJlYmFzZS5kYXRhYmFzZSgpO1xuICAgICAgICB0aGlzLmF1dGgub25BdXRoU3RhdGVDaGFuZ2VkKHRoaXMub25BdXRoU3RhdGVDaGFuZ2VkKCkuYmluZCh0aGlzKSk7XG4gICAgfVxufVxuXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LnJvb21jaGF0YSA9IG5ldyBSb29tY2hhdGEoKTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIChiNjQubGVuZ3RoICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKChsZW4gKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KG9iaikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChpc0FycmF5QnVmZmVyVmlldyhzdHJpbmcpIHx8IGlzQXJyYXlCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlcnMgZnJvbSBhbm90aGVyIGNvbnRleHQgKGkuZS4gYW4gaWZyYW1lKSBkbyBub3QgcGFzcyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrXG4vLyBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gICAgICB0eXBlb2Ygb2JqLmJ5dGVMZW5ndGggPT09ICdudW1iZXInKVxufVxuXG4vLyBOb2RlIDAuMTAgc3VwcG9ydHMgYEFycmF5QnVmZmVyYCBidXQgbGFja3MgYEFycmF5QnVmZmVyLmlzVmlld2BcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3IChvYmopIHtcbiAgcmV0dXJuICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxufVxuXG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl19
